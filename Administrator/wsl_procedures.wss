_PROCEDWSL_ Ws_Procedure_Compile 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Procedure_Compile
(
  @p_name        varchar(64)
, @p_stmt        ntext
, @p_ret_msg     varchar(256) OUTPUT
, @p_result      integer       OUTPUT
)
AS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name               :	SQL Server
  -- Script Name             :	ws_procedure_copile
  -- Description             :	Compile a procedure/function or package
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  EXEC @p_result = sp_executesql @p_stmt

  IF @p_result <> 0
  BEGIN
    SELECT @p_ret_msg = ERROR_MESSAGE()
  END
  ELSE
  BEGIN
    SET @p_ret_msg = 'Compile worked'
  END
_PROCEDWSL_ Ws_Procedure_Save 
-- Notes / History
--
-- WMR 22/01/2002  Version 1.0.0
-- WMR 07/11/2002  Version 1.2.1   Sql Server port
-- AP  29/10/2009  Version 6.0.5.2 Corrected error message
-- HM  15/10/2018  Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019  Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Procedure_Save
  @p_obj_key     integer
, @p_lines0      varchar(8000)
, @p_lines1      text
, @p_lines2      text
, @p_lines3      text
, @p_lines4      text
, @p_lines5      text
, @p_lines6      text
, @p_lines7      text
, @p_lines8      text
, @p_lines9      text
, @p_ret_msg     varchar(1024) OUTPUT
, @p_result      integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name       :    SQL Server
  -- Script Name     :    ws_procedure_save
  -- Description     :    Save a procedure to ws_pro_line
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_line_no         integer          -- line counter
  , @v_stmt            nvarchar(4000)
  , @v_lined           varchar(4000)
  , @v_step            integer
  , @v_pos             integer
  , @v_loop            integer
  , @v_start           integer
  , @v_end             integer
  , @v_size            integer

  SET @v_line_no = 0

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- IF a key of 0 and a string of CHECK is passed
  -- return -98 to indicate this procedure is incompatible
  -- with the version of RED in use
  --=====================================================
  IF @p_obj_key = 0 And @p_lines0 = 'CHECK'
  BEGIN
    SET @v_step = 20
    SET @p_result = -98
    SET @p_ret_msg = 'Please upgrade meta data'
    RETURN 0
  END

  --=====================================================
  -- IF a key of 0 and a string of CHECK is passed
  -- return -99 to indicate this procedure is active
  --=====================================================
  IF @p_obj_key = 0 And @p_lines0 = 'CHECKIT'
  BEGIN
    SET @v_step = 21
    SET @p_result = -99
    SET @p_result = -98
    SET @p_ret_msg = 'Ready'
    SET @p_ret_msg = 'Not supported under SQL Server'
    RETURN 0
  END
_PROCEDWSL_ WsWrkAudit 
-- Notes / History:
-- Inserts messages into the ws_wrk_audit_log table
-- Called by the scheduler or ws_job_execute when ever a task completes.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
--
-- ============================================================================
-- Calling:
-- v_result :=WsWrkAudit(v_status_code, v_job_name, v_task_name, v_sequence,
--                       v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key);
-- ============================================================================
-- WMR 22/01/2002 Version 1.0.0
-- WMR 06/11/2003 Version 4.1.0.5 Made three separate transactions for insert/updates
-- WMR 07/07/2006 Version 5.0.1.6 Changed lock check to > 0 from = 0
-- AP  16/08/2006 Version 5.5.0.5 Implemented a lock timeout on the lock call
--                                    this should help address locking issues
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- RS  21/07/2015 Version 6.8.4.2 Removed explicit call of sp_releaseapplock
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE WsWrkAudit
    @p_status_code  varchar(1)
  , @p_job_name     varchar(64)
  , @p_task_name    varchar(64)
  , @p_sequence     integer
  , @p_message      varchar(1024)
  , @p_db_code      varchar(10)
  , @p_db_msg       varchar(1024)
  , @p_task_key     integer
  , @p_job_key      integer
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   SQL Server
  -- Script Name   :   WsWrkAudit.sql
  -- Description   :   Writes row to audit log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  DECLARE
      @v_ws_pro_version varchar(50)
    , @v_okay_count     integer
    , @v_info_count     integer
    , @v_warn_count     integer
    , @v_error_count    integer
    , @v_return         integer
    , @v_step           integer
    , @v_msgtext        varchar(2046)
    , @v_lock_result    integer
    , @v_wait           char(12)
    , @v_db_code        varchar(10)
    , @v_db_msg         varchar(1024)


  SET @v_ws_pro_version           = 'WsWrkAudit(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY


  SELECT
      @v_okay_count    = 0
    , @v_info_count    = 0
    , @v_warn_count    = 0
    , @v_error_count   = 0

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =========================================================================
  -- Insert the message into the audit log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================


  SET @v_return = 1

  BEGIN TRANSACTION WA001

  INSERT INTO ws_wrk_audit_log
  ( wa_time_stamp
  , wa_sequence
  , wa_job
  , wa_task
  , wa_status
  , wa_message
  , wa_db_msg_code
  , wa_db_msg_desc
  , wa_task_key
  , wa_job_key
  )
  VALUES
  ( GETDATE()
  , @p_sequence
  , @p_job_name
  , @p_task_name
  , @p_status_code
  , @p_message
  , @p_db_code
  , @p_db_msg
  , @p_task_key
  , @p_job_key
  )

  COMMIT TRANSACTION WA001

  -- =========================================================================
  -- If the task or job key is not zero we need to know which counter to increment
  -- =========================================================================

  IF @p_task_key <> 0
  OR @p_job_key  <> 0
  BEGIN
    IF @p_status_code = 'S'
    BEGIN
     SET @v_okay_count = 1
    END
    IF @p_status_code = 'I'
    BEGIN
      SET @v_info_count = 1
    END
    IF @p_status_code = 'W'
    BEGIN
      SET @v_warn_count = 1
    END
    IF @p_status_code = 'E'
    BEGIN
      SET @v_error_count = 1
    END
    IF @p_status_code = 'F'
    BEGIN
      SET @v_error_count = 1
    END
  END

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF @p_task_key <> 0
  BEGIN

    SET @v_step = 200
    BEGIN TRANSACTION WA002

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0
      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 300
    BEGIN TRY

    UPDATE ws_wrk_task_run
    SET
      wtr_info_count = ISNULL(wtr_info_count,0) + @v_info_count
    , wtr_warning_count = ISNULL(wtr_warning_count,0) + @v_warn_count
    WHERE wtr_task_key = @p_task_key
    AND   wtr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH

    COMMIT TRANSACTION WA002

  END

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF @p_job_key <> 0
  BEGIN

    SET @v_step = 400
    BEGIN TRANSACTION WA003

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0
      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 500
    BEGIN TRY

    UPDATE ws_wrk_job_run
    SET
      wjr_okay_count = ISNULL(wjr_okay_count,0) + @v_okay_count
    , wjr_info_count = ISNULL(wjr_info_count,0) + @v_info_count
    , wjr_warning_count = ISNULL(wjr_warning_count,0) + @v_warn_count
    , wjr_error_count = ISNULL(wjr_error_count,0) + @v_error_count
    WHERE wjr_job_key = @p_job_key
    AND   wjr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH

    COMMIT TRANSACTION WA003

  END

  -- =========================================================================
  --Commit the message. This may be undesirable !!
  -- =========================================================================
  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sql
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN @v_return  -- insert OK, or a warning on the update
END
_PROCEDWSL_ WsWrkError 
-- Notes / History:
-- Inserts messages into the ws_wrk_error_log table
-- Called on demand.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
-- msg_type           - Code to indicate the type of error message
--
-- ============================================================================
-- Calling:
-- v_result :=WsWrkError(v_status_code, v_job_name, v_task_name, v_sequence,
--                       v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key, v_msg_type);
-- ============================================================================
-- WMR 22/01/2002 Version 1.0.0
-- WMR 06/11/2003 Version 4.1.0.5 Made three separate transactions for insert/updates
-- WMR 07/07/2006 Version 5.0.1.6 Changed lock check to > 0 from = 0
-- AP  16/08/2006 Version 5.5.0.5 Implemented a lock timeout on the lock call
--                                    this should help address locking issues
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE WsWrkError
    @p_status_code  varchar(1)
  , @p_job_name     varchar(64)
  , @p_task_name    varchar(64)
  , @p_sequence     integer
  , @p_message      varchar(1024)
  , @p_db_code      varchar(10)
  , @p_db_msg       varchar(1024)
  , @p_task_key     integer
  , @p_job_key      integer
  , @p_msg_type     varchar(10)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   SQL Server
  -- Script Name   :   WsWrkError.sql
  -- Description   :   Writes row to error log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  DECLARE
    @v_ws_pro_version   varchar(50)
  , @v_okay_count       integer
  , @v_info_count       integer
  , @v_warn_count       integer
  , @v_error_count      integer
  , @v_return           integer
  , @v_step             integer
  , @v_lock_result      integer
  , @v_wait             char(12)
  , @v_db_code          varchar(10)
  , @v_db_msg           varchar(1024)
  , @v_msgtext          varchar(2046)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =========================================================================
  -- Insert the message into the error log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  SET @v_step = 100
  SET @v_ws_pro_version           = 'WsWrkError(8.4.1.0)'
  BEGIN TRY

  SET @v_return = 1

  BEGIN TRANSACTION WE001

  SET @v_step = 200
  INSERT INTO ws_wrk_error_log
  ( wd_time_stamp
  , wd_sequence
  , wd_job
  , wd_task
  , wd_status
  , wd_message
  , wd_db_msg_code
  , wd_db_msg_desc
  , wd_task_key
  , wd_job_key
  , wd_msg_type_code
  )
  VALUES
  ( GETDATE()
  , @p_sequence
  , @p_job_name
  , @p_task_name
  , @p_status_code
  , @p_message
  , @p_db_code
  , @p_db_msg
  , @p_task_key
  , @p_job_key
  , @p_msg_type
  )

  COMMIT TRANSACTION WE001

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF @p_task_key <> 0
  BEGIN
    BEGIN TRANSACTION WE002

    SET @v_step = 300
    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 400
    -- if lock result is zero then we got the lock

    BEGIN TRY
    UPDATE ws_wrk_task_run
    SET
      wtr_detail_count = ISNULL(wtr_detail_count,0) + 1
    WHERE wtr_task_key = @p_task_key
    AND   wtr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH

    COMMIT TRANSACTION WE002

  END

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF @p_job_key <> 0
  BEGIN
    BEGIN TRANSACTION WE003

    SET @v_step = 500
    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 600
    BEGIN TRY

    UPDATE ws_wrk_job_run
    SET
      wjr_detail_count = ISNULL(wjr_detail_count,0) + 1
    WHERE wjr_job_key = @p_job_key
    AND   wjr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH

    COMMIT TRANSACTION WE003

  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sqlS
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN @v_return  -- insert OK, or a warning on the update
END
_PROCEDWSL_ WsWrkTask 
-- Notes / History:
-- ============================================================================
-- WMR 07/07/2006 Version 5.0.1.6 Changed lock check to > 0 from = 0
-- AP  16/08/2006 Version 5.5.0.5 Implemented a lock timeout on the lock call
--                                    this should help address locking issues
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE WsWrkTask
    @p_job_key        integer
  , @p_task_key       integer
  , @p_sequence       integer
  , @p_inserted       integer
  , @p_updated        integer
  , @p_replaced       integer
  , @p_deleted        integer
  , @p_discarded      integer
  , @p_rejected       integer
  , @p_errored        integer
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   SQL Server
  -- Script Name   :   WsWrkTask.sql
  -- Description   :   Updates info in the task run record
  -- Author        :   Wayne Richmond
  -- Date          :   26 November 2003
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'WsWrkTask(8.3.1.0)'

  DECLARE
    @v_MsgText                 varchar(255)  -- Text for audit_trail
  , @v_step                    integer       -- return code
  , @v_update_count            integer       -- no of records updated
  , @v_db_code                 varchar(10)   -- Database error code
  , @v_db_msg                  varchar(100)  -- Database error message
  , @v_return                  integer
  , @v_lock_result             integer
  , @v_wait                    char(12)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018

  SET @v_step = 100

  BEGIN TRY

  SET @v_return = 0;
  -- =========================================================================
  -- If the job, task or sequence are zero then probably run interactively
  -- and not as part of a job so return a warning
  -- =========================================================================
  IF ISNULL(@p_task_key,0) = 0
  OR ISNULL(@p_job_key,0) = 0
  OR ISNULL(@p_sequence,0) = 0
  BEGIN
    return -1;
  END

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF @p_task_key <> 0
  BEGIN
    BEGIN TRANSACTION WT002
    SET @v_step = 200

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0
      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END
    END

    SET @v_step = 300

    UPDATE ws_wrk_task_run
    SET
      wtr_rec_inserted =  ISNULL(@p_inserted,0)
    , wtr_rec_updated =   ISNULL(@p_updated,0)
    , wtr_rec_replaced =  ISNULL(@p_replaced,0)
    , wtr_rec_deleted =   ISNULL(@p_deleted,0)
    , wtr_rec_discarded = ISNULL(@p_discarded,0)
    , wtr_rec_rejected =  ISNULL(@p_rejected,0)
    , wtr_rec_errored =   ISNULL(@p_errored,0)
    WHERE wtr_task_key = @p_task_key
    AND   wtr_sequence = @p_sequence

    COMMIT TRANSACTION WT002
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -2

    SET @v_MsgText = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @v_ws_pro_version, @v_ws_pro_version ,@p_sequence,
        @v_MsgText,@v_db_code, @v_db_msg, @p_task_key, @p_job_key
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @v_MsgText = @v_MsgText
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_MsgText,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_MsgText = @v_MsgText + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------


  RETURN @v_return  -- insert OK, or a warning on the update
END
_PROCEDWSL_ WsWrkAuditBulk 
-- Notes / History:
-- Inserts messages into the ws_wrk_audit_log table
-- Called by the scheduler or ws_job_execute when ever a task completes.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
--
-- ============================================================================
-- Calling:
-- @v_result =WsWrkAuditBulk(v_status_code, @v_job_name, @v_task_name, @v_sequence,
--                       @v_message, @v_rdbms_code, @v_rdbms_msg, @v_task_key, @v_job_key)
-- ============================================================================
-- WMR 22/01/2002 Version 1.0.0
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE WsWrkAuditBulk
    @p_status_code  varchar(1)
  , @p_job_name     varchar(64)
  , @p_task_name    varchar(64)
  , @p_sequence     integer
  , @p_message      varchar(4000)
  , @p_db_code      varchar(10)
  , @p_db_msg       varchar(1024)
  , @p_task_key     integer
  , @p_job_key      integer
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   SQL Server
  -- Script Name   :   WsWrkAuditBulk.sql
  -- Description   :   Writes row to audit log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  DECLARE
      @v_okay_count    integer
    , @v_info_count    integer
    , @v_warn_count    integer
    , @v_error_count   integer
    , @v_return        integer
    , @v_row_count     integer

    , @v_stmt          varchar(1024)
    , @v_cr            varchar(10)
    , @v_step          integer
    , @v_pos           integer
    , @v_loop          integer
    , @v_start         integer
    , @v_end           integer
    , @v_size          integer
    , @v_tilde         integer
    , @v_rows          integer

  SELECT
      @v_okay_count    = 0
    , @v_info_count    = 0
    , @v_warn_count    = 0
    , @v_error_count   = 0
    , @v_row_count     = 0
    , @v_tilde         = 0
    , @v_rows          = 0

  DECLARE
      @v_ws_pro_version  varchar(50)
    , @v_msgtext         varchar(2046)
    , @v_db_code         varchar(10)
    , @v_db_msg          varchar(1024)

  SET @v_ws_pro_version           = 'WsWrkAuditBulk(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =========================================================================
  -- Insert the message into the audit log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  SET @v_return = 1
  BEGIN TRANSACTION

  --=====================================================
  -- Loop through the text passed
  -- saving a line after each newline character
  -- a line is a max of 1024 bytes long
  --=====================================================
  SET @v_step = 30
  SET @v_loop = 1
  SET @v_start = 1
  SET @v_end = LEN(@p_message)
  SET @v_step = 40

  WHILE @v_loop = 1
  BEGIN
    SET @v_step = 50
    SET @v_cr = '%'+CHAR(10)+'%'
    SET @v_pos = PATINDEX(@v_cr,SUBSTRING(@p_message,@v_start,LEN(@p_message)-@v_start))
    IF ISNULL(@v_pos,0) < 1
    BEGIN
      SET @v_pos = PATINDEX('%~%',SUBSTRING(@p_message,@v_start,LEN(@p_message)-@v_start))
      IF ISNULL(@v_pos,0) >= 1
      BEGIN
        SET @v_pos = @v_pos + @v_start
        SET @v_tilde = 1
      END
      ELSE
      BEGIN
        SET @v_tilde = 0
      END
    END
    ELSE
    BEGIN
      SET @v_tilde = 0
    END
    SET @v_step = 60
    IF ISNULL(@v_pos,0) < 1
    BEGIN
      SET @v_size = ISNULL(LEN(@p_message),-1)
      SET @v_loop = 0
      SET @v_size = (@v_size - @v_start)
      IF @v_tilde = 0
      BEGIN
        SET @v_size = @v_size + 1
      END
      IF @v_size > 0
      BEGIN
        -- Maximum of 1024 characters in a line
        IF @v_size > 1024
        BEGIN
          SET @v_size = 1024
        END
        SET @v_stmt = SUBSTRING(@p_message,@v_start,@v_size)
        SET @v_step = 81
        SET @v_row_count = @v_row_count +1
        SET @v_step = 91

        INSERT INTO ws_wrk_audit_log
        ( wa_time_stamp
        , wa_sequence
        , wa_job
        , wa_task
        , wa_status
        , wa_message
        , wa_db_msg_code
        , wa_db_msg_desc
        , wa_task_key
        , wa_job_key
        )
        VALUES
        ( GETDATE()
        , @p_sequence
        , @p_job_name
        , @p_task_name
        , @p_status_code
        , @v_stmt
        , @p_db_code
        , @p_db_msg
        , @p_task_key
        , @p_job_key
        )

      END
    END
    ELSE
    BEGIN
      SET @v_step = 70
      SET @v_size = (@v_pos - @v_start)
      IF @v_tilde = 0
      BEGIN
        SET @v_size = @v_size + 1
      END
      -- Maximum of 1024 characters in a line
      IF @v_size > 1024
      BEGIN
        SET @v_size = 1024
      END
      SET @v_stmt = SUBSTRING(@p_message,@v_start,@v_size)
      SET @v_step = 80
      SET @v_row_count = @v_row_count +1
      SET @v_step = 90

      INSERT INTO ws_wrk_audit_log
      ( wa_time_stamp
      , wa_sequence
      , wa_job
      , wa_task
      , wa_status
      , wa_message
      , wa_db_msg_code
      , wa_db_msg_desc
      , wa_task_key
      , wa_job_key
      )
      VALUES
      ( GETDATE()
      , @p_sequence
      , @p_job_name
      , @p_task_name
      , @p_status_code
      , @v_stmt
      , @p_db_code
      , @p_db_msg
      , @p_task_key
      , @p_job_key
      )

      SET @v_start = @v_pos + 1
      SET @v_step = 100
      IF @v_start >= @v_end
      BEGIN
        SET @v_loop = 0
      END

    END

    -- only allow a maximum of 1000 rows from one task to
    -- prevent a blow-out of the audit trail.
    SET @v_rows = @v_rows + 1
    IF @v_rows >999
    BEGIN
      SET @v_loop = 0
      SET @v_stmt = 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkAuditBulk'
      INSERT INTO ws_wrk_audit_log
      ( wa_time_stamp
      , wa_sequence
      , wa_job
      , wa_task
      , wa_status
      , wa_message
      , wa_db_msg_code
      , wa_db_msg_desc
      , wa_task_key
      , wa_job_key
      )
      VALUES
      ( GETDATE()
      , @p_sequence
      , @p_job_name
      , @p_task_name
      , @p_status_code
      , @v_stmt
      , @p_db_code
      , @p_db_msg
      , @p_task_key
      , @p_job_key
      )

    END
  END

  -- =========================================================================
  -- If the task or job key is not zero we need to know which counter to increment
  -- =========================================================================

  IF @p_task_key <> 0  OR  @p_job_key <> 0
  BEGIN
    IF @p_status_code = 'S'
    BEGIN
     SET @v_okay_count = 1
    END
    IF @p_status_code = 'I'
    BEGIN
      SET @v_info_count = 1
    END
    IF @p_status_code = 'W'
    BEGIN
      SET @v_warn_count = 1
    END
    IF @p_status_code = 'E'
    BEGIN
      SET @v_error_count = 1
    END
    IF @p_status_code = 'F'
    BEGIN
      SET @v_error_count = 1
    END
  END

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF @p_task_key <> 0
  BEGIN
    BEGIN TRY
    UPDATE ws_wrk_task_run
    SET
      wtr_info_count = ISNULL(wtr_info_count,0) + @v_info_count
    , wtr_warning_count = ISNULL(wtr_warning_count,0) + @v_warn_count
    WHERE wtr_task_key = @p_task_key
    AND   wtr_sequence = @p_sequence
    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH
  END

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF @p_job_key <> 0
  BEGIN
    BEGIN TRY

    UPDATE ws_wrk_job_run
    SET
      wjr_okay_count = ISNULL(wjr_okay_count,0) + @v_okay_count
    , wjr_info_count = ISNULL(wjr_info_count,0) + @v_info_count
    , wjr_warning_count = ISNULL(wjr_warning_count,0) + @v_warn_count
    , wjr_error_count = ISNULL(wjr_error_count,0) + @v_error_count
    WHERE wjr_job_key = @p_job_key
    AND   wjr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH
  END

  -- =========================================================================
  --Commit the message. This may be undesirable !!
  -- =========================================================================
  COMMIT

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sqlS
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------



  RETURN @v_return  -- insert OK, or a warning on the update
END
_PROCEDWSL_ WsWrkErrorBulk 
-- Notes / History:
-- Inserts messages into the ws_wrk_error_log table
-- Called on demand.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
-- msg_type           - Code to indicate the type of error message
--
-- ============================================================================
-- Calling:
-- v_result :=WsWrkErrorBulk(v_status_code, v_job_name, v_task_name, v_sequence,
--                       v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key, v_msg_type);
-- ============================================================================
-- WMR 22/01/2002 Version 1.0.0
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE WsWrkErrorBulk
    @p_status_code   varchar(1)
  , @p_job_name      varchar(64)
  , @p_task_name     varchar(64)
  , @p_sequence      integer
  , @p_message       varchar(4000)
  , @p_db_code       varchar(10)
  , @p_db_msg        varchar(1024)
  , @p_task_key      integer
  , @p_job_key       integer
  , @p_msg_type      varchar(10)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   SQL Server
  -- Script Name   :   WsWrkErrorBulk.sql
  -- Description   :   Writes row to error log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  DECLARE
      @v_okay_count    integer
    , @v_info_count    integer
    , @v_warn_count    integer
    , @v_error_count   integer
    , @v_return        integer
    , @v_row_count     integer
    , @v_stmt          varchar(1024)
    , @v_cr            varchar(10)
    , @v_step          integer
    , @v_pos           integer
    , @v_loop          integer
    , @v_start         integer
    , @v_end           integer
    , @v_size          integer
    , @v_tilde         integer
    , @v_rows          integer

  SELECT
      @v_okay_count    = 0
    , @v_info_count    = 0
    , @v_warn_count    = 0
    , @v_error_count   = 0
    , @v_row_count     = 0
    , @v_tilde         = 0
    , @v_rows          = 0

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =========================================================================
  -- Insert the message into the error log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================
  DECLARE
      @v_ws_pro_version  varchar(50)
    , @v_msgtext         varchar(2046)
    , @v_db_code         varchar(10)
    , @v_db_msg          varchar(1024)

  SET @v_ws_pro_version           = 'WsWrkErrorBulk(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_return = 1
  BEGIN TRANSACTION

  INSERT INTO ws_wrk_error_log
  ( wd_time_stamp
  , wd_sequence
  , wd_job
  , wd_task
  , wd_status
  , wd_message
  , wd_db_msg_code
  , wd_db_msg_desc
  , wd_task_key
  , wd_job_key
  , wd_msg_type_code
  )
  VALUES
  ( GETDATE()
  , @p_sequence
  , @p_job_name
  , @p_task_name
  , @p_status_code
  , @p_message
  , @p_db_code
  , @p_db_msg
  , @p_task_key
  , @p_job_key
  , @p_msg_type
  )
  --=====================================================
  -- Loop through the text passed
  -- saving a line after each newline character
  -- a line is a max of 1024 bytes long
  --=====================================================
  SET @v_step = 30
  SET @v_loop = 1
  SET @v_start = 1
  SET @v_end = LEN(@p_message)
  SET @v_step = 40

  WHILE @v_loop = 1
  BEGIN
    SET @v_step = 50
    SET @v_cr = '%'+CHAR(10)+'%'
    SET @v_pos = PATINDEX(@v_cr,SUBSTRING(@p_message,@v_start,LEN(@p_message)-@v_start))
    IF ISNULL(@v_pos,0) < 1
    BEGIN
      SET @v_pos = PATINDEX('%~%',SUBSTRING(@p_message,@v_start,LEN(@p_message)-@v_start))
      IF ISNULL(@v_pos,0) >= 1
      BEGIN
        SET @v_pos = @v_pos + @v_start
        SET @v_tilde = 1
      END
      ELSE
      BEGIN
        SET @v_tilde = 0
      END
    END
    ELSE
    BEGIN
      SET @v_tilde = 0
    END
    SET @v_step = 60
    IF ISNULL(@v_pos,0) < 1
    BEGIN
      SET @v_size = ISNULL(LEN(@p_message),-1)
      SET @v_loop = 0
      SET @v_size = (@v_size - @v_start)
      IF @v_tilde = 0
      BEGIN
        SET @v_size = @v_size + 1
      END
      IF @v_size > 0
      BEGIN
        -- Maximum of 1024 characters in a line
        IF @v_size > 1024
        BEGIN
          SET @v_size = 1024
        END
        SET @v_stmt = SUBSTRING(@p_message,@v_start,@v_size)
        SET @v_step = 81
        SET @v_row_count = @v_row_count +1
        SET @v_step = 91

        INSERT INTO ws_wrk_error_log
        ( wd_time_stamp
        , wd_sequence
        , wd_job
        , wd_task
        , wd_status
        , wd_message
        , wd_db_msg_code
        , wd_db_msg_desc
        , wd_task_key
        , wd_job_key
        , wd_msg_type_code
        )
        VALUES
        ( GETDATE()
        , @p_sequence
        , @p_job_name
        , @p_task_name
        , @p_status_code
        , @v_stmt
        , @p_db_code
        , @p_db_msg
        , @p_task_key
        , @p_job_key
        , @p_msg_type
        )

      END
    END
    ELSE
    BEGIN
      SET @v_step = 70
      SET @v_size = (@v_pos - @v_start)
      IF @v_tilde = 0
      BEGIN
        SET @v_size = @v_size + 1
      END
      -- Maximum of 1024 characters in a line
      IF @v_size > 1024
      BEGIN
        SET @v_size = 1024
      END
      SET @v_stmt = SUBSTRING(@p_message,@v_start,@v_size)
      SET @v_step = 80
      SET @v_row_count = @v_row_count +1
      SET @v_step = 90

      INSERT INTO ws_wrk_error_log
      ( wd_time_stamp
      , wd_sequence
      , wd_job
      , wd_task
      , wd_status
      , wd_message
      , wd_db_msg_code
      , wd_db_msg_desc
      , wd_task_key
      , wd_job_key
      , wd_msg_type_code
      )
      VALUES
      ( GETDATE()
      , @p_sequence
      , @p_job_name
      , @p_task_name
      , @p_status_code
      , @v_stmt
      , @p_db_code
      , @p_db_msg
      , @p_task_key
      , @p_job_key
      , @p_msg_type
      )

      SET @v_start = @v_pos + 1
      SET @v_step = 100
      IF @v_start >= @v_end
      BEGIN
        SET @v_loop = 0
      END

    END

    -- only allow a maximum of 2000 rows from one task to
    -- prevent a blowout of the audit trail.
    SET @v_rows = @v_rows + 1
    IF @v_rows >1999
    BEGIN
      SET @v_loop = 0
      SET @v_stmt = 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkAuditBulk'
      INSERT INTO ws_wrk_error_log
      ( wd_time_stamp
      , wd_sequence
      , wd_job
      , wd_task
      , wd_status
      , wd_message
      , wd_db_msg_code
      , wd_db_msg_desc
      , wd_task_key
      , wd_job_key
      , wd_msg_type_code
      )
      VALUES
      ( GETDATE()
      , @p_sequence
      , @p_job_name
      , @p_task_name
      , @p_status_code
      , @v_stmt
      , @p_db_code
      , @p_db_msg
      , @p_task_key
      , @p_job_key
      , @p_msg_type
      )

    END
  END

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF @p_task_key <> 0
  BEGIN

    BEGIN TRY
    UPDATE ws_wrk_task_run
    SET
      wtr_detail_count = ISNULL(wtr_detail_count,0) + @v_row_count
    WHERE wtr_task_key = @p_task_key
    AND   wtr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH
  END

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF @p_job_key <> 0
  BEGIN
    BEGIN TRY

    UPDATE ws_wrk_job_run
    SET
      wjr_detail_count = ISNULL(wjr_detail_count,0) + @v_row_count
    WHERE wjr_job_key = @p_job_key
    AND   wjr_sequence = @p_sequence

    END TRY
    BEGIN CATCH
    -- Purposely allowing fail of this call as non critical
    END CATCH

  END

  -- =========================================================================
  --Commit the message. This may be undesirable !!
  -- =========================================================================
  COMMIT

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sqlS
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN @v_return  -- insert OK, or a warning on the update
END
_PROCEDWSL_ WsParameterRead 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterRead(v_parameter_name);
-- ============================================================================
-- WMR 22/01/2002 Version 1.0.0
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE WsParameterRead
  @p_parameter    varchar(64)
, @p_value        varchar(2000) OUTPUT
, @p_comment      varchar(256)  OUTPUT
AS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterRead.sql
  -- Description    :   Reads an entry from the parameter table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  DECLARE
    @v_row_count       integer       -- General row count

  DECLARE
      @v_ws_pro_version  varchar(50)
    , @v_return          integer
    , @v_step            integer
    , @v_msgtext         varchar(256)
    , @v_db_code         varchar(10)
    , @v_db_msg          varchar(256)

  SET @v_ws_pro_version           = 'WsParameterRead(8.3.1.0)'
  SET @v_step = 100

  BEGIN TRY
  SET @p_value = NULL
  SET @p_comment = 'parameter not found'

  -- =========================================================================
  -- Select the parameter from the table and return the value
  -- =========================================================================
  BEGIN TRANSACTION
  SELECT
    @p_value = dss_parameter_value
  , @p_comment = dss_parameter_comments
  FROM
    dss_parameter
  WHERE
    UPPER(LTRIM(RTRIM(dss_parameter_name))) = UPPER(LTRIM(RTRIM(@p_parameter)))

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_row_count = 0
  BEGIN
    SET @p_value = NULL
    SET @p_comment = 'parameter not found'
  END
  COMMIT
  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------


  RETURN 0
_PROCEDWSL_ WsParameterReadF 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterRead(v_parameter_name);
-- ============================================================================
-- WMR  22/01/2002   Version 1.0.0
-- HM   15/10/2018   Version 8.3.1.0 RED-9774 Remove encryption.

CREATE FUNCTION WsParameterReadF (
  @p_parameter    varchar(64)
) RETURNS varchar(4000)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterRead.sql
  -- Description    :   Reads an entry from the parameter table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  DECLARE
    @v_return_status   integer       -- Update result status
  , @v_row_count       integer       -- General row count
  , @v_value           varchar(4000) -- returned value

  -- =========================================================================
  -- Select the parameter from the table and return the value
  -- =========================================================================
  SELECT
    @v_value = dss_parameter_value
  FROM
    dss_parameter
  WHERE
    UPPER(LTRIM(RTRIM(dss_parameter_name))) = UPPER(LTRIM(RTRIM(@p_parameter)))

  SELECT
    @v_return_status = @@ERROR
  , @v_row_count     = @@ROWCOUNT

  IF @v_row_count = 0
  BEGIN
    SET @v_value = NULL
  END

  RETURN (@v_value)
END


_PROCEDWSL_ WsParameterReadG 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterReadG(v_parameter_name);
-- ============================================================================
-- WMR  14/01/2003   Version 41.0
-- BC   27/06/2016   Version 6.8.6.1  RED-6790: Don't match on the job key, because a child job gets given the job key of its parent job (if any) so that auditing is all accurate.
-- HM   15/10/2018   Version 8.3.1.0  RED-9774 Remove encryption.

CREATE FUNCTION WsParameterReadG (
    @p_parameter  varchar(64)
  , @p_job_id     integer
  , @p_task_id    integer
) RETURNS varchar(4000)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterReadG.sql
  -- Description    :   Reads a Global parameter
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_document          integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_user1             integer
  , @v_ws_obj_user2             integer
  , @v_ws_obj_user3             integer
  , @v_ws_obj_user4             integer
  , @v_ws_obj_user5             integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_document          = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_report            = 16
  , @v_ws_obj_user1             = 17
  , @v_ws_obj_user2             = 18
  , @v_ws_obj_user3             = 19
  , @v_ws_obj_user4             = 20
  , @v_ws_obj_user5             = 21

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_return_status   integer       -- Update result status
  , @v_row_count       integer       -- General row count
  , @v_value           varchar(4000) -- returned value
  , @v_obj_key         integer       -- the object key
  , @v_obj_type        integer        -- The object type

  -- =========================================================================
  -- If the job number is zero then the task number is the object id
  -- otherwise we need to find the object from the task.
  -- =========================================================================
  SET @v_obj_key = 0
  IF @p_job_id IS NULL or @p_job_id = 0
  BEGIN
    SET @v_obj_key = @p_task_id
  END
  ELSE
  BEGIN
    SELECT @v_obj_key = wtr_obj_key
    FROM   ws_wrk_task_run
    WHERE  wtr_task_key = @p_task_id
-- RED-6790: Don't match on the job key, because a child job gets given the job key of its parent job (if any) so that auditing is all accurate.
--    AND    wtr_job_key = @p_job_id
  END

  -- =========================================================================
  -- make sure we have a valid object key else quit
  -- =========================================================================
  IF @v_obj_key IS NULL OR @v_obj_key  = 0
  BEGIN
    RETURN ('')
  END

  -- =========================================================================
  -- get the object type
  -- =========================================================================
  SET @v_obj_type = 0
  SELECT @v_obj_type = oo_type_key
  FROM   ws_obj_object
  WHERE  oo_obj_key = @v_obj_key

  -- =========================================================================
  -- make sure we have a valid object type else quit
  -- =========================================================================
  IF @v_obj_type IS NULL OR @v_obj_type  = 0
  BEGIN
    RETURN ('')
  END

  -- =========================================================================
  -- If the parameter is $$TABLE_NAME then return the table name
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(@p_parameter))) = '$$TABLE_NAME'
  BEGIN
    IF @v_obj_type = @v_ws_obj_load
    BEGIN
      SET @v_value = ''
      SELECT @v_value = lt_table_name
      FROM ws_load_tab
      WHERE lt_obj_key = @v_obj_key
      RETURN (@v_value)
    END
  END

  -- =========================================================================
  -- If the parameter is $$SOURCE_TABLE then return the source table
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(@p_parameter))) = '$$SOURCE_TABLE'
  BEGIN

    IF @v_obj_type = @v_ws_obj_load
    BEGIN
      SET @v_value = ''
      SELECT @v_value = max(lc_src_table)
      FROM ws_load_col
      WHERE lc_obj_key = @v_obj_key
      RETURN (@v_value)
    END
  END


  RETURN ('')
END




_PROCEDWSL_ WsParameterReadJ 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterReadJ(v_parameter, v_job_id);
-- ============================================================================
-- WMR  23/04/2004   Version 4.1.0.8
-- HM   15/10/2018   Version 8.3.1.0 RED-9774 Remove encryption.

CREATE FUNCTION WsParameterReadJ (
    @p_parameter  varchar(64)
  , @p_job_id     integer
) RETURNS varchar(4000)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterReadJ.sql
  -- Description    :   Reads a Job related parameter
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_return_status   integer       -- Update result status
  , @v_row_count       integer       -- General row count
  , @v_value           varchar(4000) -- returned value


  -- =========================================================================
  -- make sure we have a valid job key else quit
  -- =========================================================================
  IF @p_job_id IS NULL OR @p_job_id  = 0
  BEGIN
    RETURN ('');  -- return null
  END

  -- =========================================================================
  -- If the parameter is NAME then return the job name
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(@p_parameter))) = 'NAME'
  BEGIN
    SET @v_value = '';
    SELECT @v_value = wjr_name
    FROM ws_wrk_job_run
    WHERE wjr_job_key = @p_job_id;
    RETURN (@v_value)
  END


  RETURN ('')
END





_PROCEDWSL_ WsParameterWrite 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_result := WsParameterWrite(v_parameter_name, v_value, v_comments);
-- ============================================================================
-- WMR 22/01/2002  Version 1.0.0
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE WsParameterWrite
  @p_parameter    varchar(64)
, @p_value        varchar(2000)
, @p_comment      varchar(256)
AS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterWrite.sql
  -- Description    :   Write or update an entry in the parameter table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  DECLARE
    @v_row_count       integer       -- General row count
  , @v_result          integer       -- result of the procedure
  DECLARE
      @v_ws_pro_version  varchar(50)
    , @v_return          integer
    , @v_step            integer
    , @v_msgtext         varchar(256)
    , @v_db_code         varchar(10)
    , @v_db_msg          varchar(256)

  SET @v_ws_pro_version           = 'WsParameterWrite(8.3.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_result = -3
  -- =========================================================================
  -- Update or Insert the parameter
  -- =========================================================================
  BEGIN TRANSACTION
  UPDATE dss_parameter
  SET
    dss_parameter_value = @p_value
  , dss_parameter_comments = ISNULL(@p_comment,dss_parameter_comments)
  WHERE
    UPPER(LTRIM(RTRIM(dss_parameter_name))) = UPPER(LTRIM(RTRIM(@p_parameter)))

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_row_count > 0
  BEGIN
    SET @v_result = 1
  END

  IF @v_row_count = 0
  BEGIN
    IF @p_comment IS NULL
    BEGIN
      SET @p_comment = 'Inserted via WsParameterWrite'
    END

    INSERT INTO dss_parameter
    ( dss_parameter_name
    , dss_parameter_value
    , dss_parameter_comments
    )
    VALUES
    ( @p_parameter
    , @p_value
    , @p_comment
    )
    SET @v_result = 2
  END
  COMMIT

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_return = -3

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    --BEGIN TRY
    --  EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
    --    @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    --END TRY

    -----------
    --BEGIN CATCH
    -----------
    --  IF XACT_STATE() <> 0
    --    ROLLBACK TRANSACTION

      SET @v_msgtext = @v_msgtext
                        + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                        + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)
                        + ' DBCode '          + CAST(COALESCE(ERROR_NUMBER()   ,0) AS varchar)
                        + ' "'                +      COALESCE(ERROR_MESSAGE()  ,'Null')
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    --END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_msgtext = @v_msgtext + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------


  RETURN @v_result
_PROCEDWSL_ WsParameterReplace 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterReplace(v_incoming_string, max_length);
-- ============================================================================
-- AP  19/09/2006   Version 5.5.0.5
-- AP  07/11/2006   Version 5.5.0.9 Ensure no replace of values in params
--                                  Don't process as $P if has "'s around it
--                                  Leave parameter there if no value exits
--                                  Decided to not use the "'s logic so force to not work
-- AP  19/02/2008   Version 5.6.3.1 Increased size of variables
-- AP  20/07/2011   Version 6.5.4.1 When no param found continue search from after the found $P
--                                  previously it searched from after terminating $ and hence risked
--                                  missing the next $P
-- HM  10/07/2014   Version 6.8.1.1 Changed all varchar(8000) to varchar(max); supported since SQL
--                                  Server 2005: http://www.teratrax.com/varchar-max-sql-server/
-- HM  15/10/2018   Version 8.3.1.0 RED-9774 Remove encryption.

CREATE FUNCTION WsParameterReplace (
  @p_incoming    varchar(max)
 ,@p_max         integer
) RETURNS varchar(max)
AS
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   SQLServer
  -- Script Name    :   WsParameterReplace.sql
  -- Description    :   Replaces occurrences of Parameters in a string
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  DECLARE
    @v_return_status   integer       -- Update result status
  , @v_row_count       integer       -- General row count
  , @v_value           varchar(max) -- returned value
  , @v_work            varchar(max)
  , @v_work2           varchar(max)
  , @v_parameter       varchar(max)
  , @v_spos            integer
  , @v_epos            integer
  , @v_qspos           integer
  , @v_qepos           integer
  , @v_search_value    varchar(max)
  , @v_return_value    varchar(max)


  SET @v_return_value = ''
  SET @v_search_value = @p_incoming
  -- look for first $P
  SET @v_spos = ISNULL(PATINDEX('%$P%',@v_search_value),0)

  WHILE  @v_spos > 0
  BEGIN
    -- look for first dbl quote
    SET @v_qspos =  0 -- (forced removal of this check) ISNULL(PATINDEX('%"%',@v_search_value),9999)

    -- Check if Quotes before or after the parameter
    IF @v_qspos < @v_spos
    AND @v_qspos > 0
    BEGIN -- have double quotes somewhere before the first parameter
      -- append upto the "
      SET @v_return_value = @v_return_value + SUBSTRING(@v_search_value,1,@v_qspos)
      -- remove upto and including the quote from the search string
      SET @v_search_value = SUBSTRING(@v_search_value,@v_qspos+1,LEN(@v_search_value)-@v_qspos )

      -- find terminating quote
      SET @v_qepos = ISNULL(PATINDEX('%"%',@v_search_value),9999)

      IF @v_qepos > 0
      BEGIN
        -- append upto the "
        SET @v_return_value = @v_return_value + SUBSTRING(@v_search_value,1,@v_qepos)

        -- remove upto and including the quote from the search string
        SET @v_search_value = SUBSTRING(@v_search_value,@v_qepos+1,LEN(@v_search_value)-@v_qepos )

      END

      -- look for anymore $P
      SET @v_spos = ISNULL(PATINDEX('%$P%',@v_search_value),0)

    END
    ELSE
    BEGIN

      -- append upto the $P
      SET @v_return_value = @v_return_value + SUBSTRING(@v_search_value,1,@v_spos-1)

      --remove upto and including the $P from the search string
      SET @v_search_value = SUBSTRING(@v_search_value,@v_spos+2,LEN(@v_search_value)-@v_spos-1)

      --find terminating $
      SET @v_epos = ISNULL(PATINDEX('%$%',@v_search_value),0)

      IF @v_epos = 0
      BEGIN
        SET @v_spos = 0
        -- leave the search string alone and just append teh $P to the return value
        SET @v_return_value = @v_return_value + '$P'
      END
      ELSE
      BEGIN
        -- determine the parameter name
        SET @v_work = SUBSTRING(@v_search_value,1,@v_epos-1)

        -- extract the parameter value
        SELECT @v_parameter = dbo.WsParameterReadF(@v_work)

        IF @v_parameter IS NULL
        BEGIN
          -- leave the search string alone and just append the $P to the return value
          SET @v_return_value = @v_return_value +'$P'
        END
        ELSE
        BEGIN
          -- append the parameter value
          SET @v_return_value = @v_return_value + @v_parameter
          -- remove upto (and including) terminating $ from the search string for next search
          SET @v_search_value = SUBSTRING(@v_search_value,@v_epos+1,LEN(@v_search_value)-@v_epos)
        END

        -- look for anymore $P
        SET @v_spos = ISNULL(PATINDEX('%$P%',@v_search_value),0)

      END
    END
  END

  -- Append rest of string
  SET @v_return_value = @v_return_value + @v_search_value

  -- If going to be too big then NULL it out to be handled on return
  IF LEN(@v_return_value) > @p_max
  BEGIN
    SET @v_return_value = NULL
  END

  RETURN (@v_return_value)
END
_PROCEDWSL_ Ws_Object_Info 
-- Notes / History
--
-- AP  20/02/2008 Version 5.6.3.1 SQLServer copy of TeraData Procedure
-- AP  09/04/2008 Version 6.0.0.0 Added support for ODS/Normal
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  20/02/2012 Version 6.5.6.1 Include option for partition table key
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.
--
-- ============================================================================
-- Calling Examples:
--
-- SQLADMIN
-- {call dbo.Ws_Object_Info(1,'Job','Task',0,0,NULL,'dim_date','Type' ,? ,?,?,?)}
--
-- PROCEDURE
-- EXEC @v_result = Ws_Object_Info @p_sequence, @p_job_name, @p_task_name, @p_job_id, @p_task_id,
--                                 1,NULL,'Type',
--                                 @v_return_code OUTPUT, @p_return_msg OUTPUT,
--                                 @v_result OUTPUT , @v_value OUTPUT
-- ==========================================================================

CREATE PROCEDURE Ws_Object_Info
  @p_sequence     integer
, @p_job_name     varchar(64)
, @p_task_name    varchar(64)
, @p_job_id       integer
, @p_task_id      integer
, @p_obj_key      integer
, @p_obj_name     varchar(64)
, @p_info_type    varchar(64)
, @p_return_code  varchar(1)     OUTPUT
, @p_return_msg   varchar(1024)  OUTPUT
, @p_result       integer        OUTPUT
, @p_value        varchar(4000)  OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name    :  SQLServer
  -- Script Name  :  Ws_Object_Info.sql
  -- Description  :  Returns request information regarding an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(15)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Object_Info(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_procedure_key   integer
  , @v_procedure       varchar(64)

  , @v_obj_count       INTEGER
  , @v_obj_key         INTEGER
  , @v_obj_name        VARCHAR(64)
  , @v_obj_type        INTEGER
  , @v_info_type       VARCHAR(64)
  , @v_value           VARCHAR(4000)

  , @v_tablespace      VARCHAR(64)
  , @v_short_name      VARCHAR(64)
  , @v_genspec         VARCHAR(4000)
  , @v_work            VARCHAR(4000)
  , @v_start           integer
  , @v_end             integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_step = 100

  BEGIN TRY

  SET @p_return_code = 'F'
  SET @p_result = -3

  IF ( @p_obj_key IS NOT NULL AND @p_obj_name IS NOT NULL )
  BEGIN
    SELECT @p_return_code = 'E'
         , @p_return_msg = 'Unable to get info as a maximum of one of p_obj_key and p_obj_name can be specified.'
         , @p_result = -2
         , @p_value = ''

    RETURN @p_result
  END

  SET @v_step = 200

  IF ( @p_obj_key IS NOT NULL )
  BEGIN
    SET @v_step = 300
    SELECT @v_obj_count = COUNT(*)
         , @v_obj_type = MAX(oo_type_key)
         , @v_obj_key = MAX(oo_obj_key)
         , @v_obj_name = MAX(oo_name)
    FROM   ws_obj_object
    WHERE  oo_obj_key = @p_obj_key
  END
  ELSE
  BEGIN
    IF ( @p_obj_name IS NOT NULL )
    BEGIN
      SET @v_step = 400
      SELECT @v_obj_count = COUNT(*)
           , @v_obj_type = MAX(oo_type_key)
           , @v_obj_key = MAX(oo_obj_key)
           , @v_obj_name = MAX(oo_name)
      FROM   ws_obj_object
      WHERE  LOWER(oo_name) = LOWER(@p_obj_name)
    END
    ELSE
    BEGIN
      SET @v_step = 500
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Unable to check for object existance, either @p_obj_key or @p_obj_name must be specified.'
      SET @p_result = -2
      SET @p_value = ''
      RETURN @p_result
    END
  END

  SET @v_step = 600

  IF ( @v_obj_count <> 1 )
  BEGIN
    SET @v_step = 700
    SET @p_return_code = 'E'
    IF ( @p_obj_name IS NOT NULL AND @p_obj_name <> '' )
    BEGIN
      SET @p_return_msg = 'The object ' + @p_obj_name + ' does not exists.'
    END
    ELSE
    BEGIN
      SET @p_return_msg = 'The object with key ' + CAST(@p_obj_key AS VARCHAR(18)) + ' does not exists.'
    END

    SET @p_result = -2
    SET @p_value = ''
    RETURN @p_result

  END


  IF ( UPPER(@p_info_type) IN ( 'NAME','KEY','TYPE','DATABASE','TABLESPACE','FILEGROUP','SHORTNAME','PARTKEY') )
  BEGIN
    SET @v_info_type = @p_info_type
  END
  ELSE
  BEGIN
    SET @v_step = 800
    SET @v_info_type = @p_info_type
    SET @p_return_code = 'E'
    SET @p_return_msg = 'Invalid information type requested ('+ @v_info_type + ').'
    SET @p_result = -2
    SET @p_value = ''
    RETURN @p_result
  END

  SET @v_step = 900
  IF ( UPPER(@p_info_type)IN ( 'DATABASE','TABLESPACE','FILEGROUP','SHORTNAME','PARTKEY') )
  BEGIN
  --=====================================================
  -- Check that we have a valid table type
  --=====================================================
    IF  @v_obj_type <> @v_ws_obj_load
    AND @v_obj_type <> @v_ws_obj_dim
    AND @v_obj_type <> @v_ws_obj_dim_view
    AND @v_obj_type <> @v_ws_obj_view
    AND @v_obj_type <> @v_ws_obj_fact
    AND @v_obj_type <> @v_ws_obj_fact_kpi
    AND @v_obj_type <> @v_ws_obj_stage
    AND @v_obj_type <> @v_ws_obj_agg
    AND @v_obj_type <> @v_ws_obj_retro_copy
    AND @v_obj_type <> @v_ws_obj_retro
    AND @v_obj_type <> @v_ws_obj_index
    AND @v_obj_type <> @v_ws_obj_join
    AND @v_obj_type <> @v_ws_obj_export
    AND @v_obj_type <> @v_ws_obj_ods
    AND @v_obj_type <> @v_ws_obj_normal
    AND @v_obj_type <> @v_ws_obj_hub
    AND @v_obj_type <> @v_ws_obj_satellite
    AND @v_obj_type <> @v_ws_obj_link
    AND @v_obj_type <> @v_ws_obj_custom1
    AND @v_obj_type <> @v_ws_obj_custom2
    BEGIN
      SET @v_step = 1000
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Unable to find object''s ' + @v_info_type +': unsupported object type.'
      SET @p_result = -2
      SET @p_value = ''

      RETURN @p_result
    END

    IF ( @v_obj_type = @v_ws_obj_load )
    BEGIN
      SET @v_step = 1100

      SELECT @v_tablespace = lt_tablespace
           , @v_short_name = lt_short_name
           , @v_genspec    = NULL
      FROM   ws_load_tab
      WHERE  lt_obj_key = @v_obj_key
    END

    IF (( @v_obj_type = @v_ws_obj_dim )
    OR  ( @v_obj_type = @v_ws_obj_dim_view ))
    BEGIN
      SET @v_step = 1200

      SELECT @v_tablespace = dt_tablespace
           , @v_short_name = dt_short_name
           , @v_genspec    = NULL
      FROM   ws_dim_tab
      WHERE  dt_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_view )
    BEGIN
      SET @v_step = 1300

      SELECT @v_tablespace = vt_tablespace
           , @v_short_name = vt_short_name
           , @v_genspec    = NULL
      FROM   ws_view_tab
      WHERE  vt_obj_key = @v_obj_key
    END

    IF (( @v_obj_type = @v_ws_obj_fact )
    OR  ( @v_obj_type = @v_ws_obj_fact_kpi ))
    BEGIN
      SET @v_step = 1400

      SELECT @v_tablespace = ft_tablespace
           , @v_short_name = ft_short_name
           , @v_genspec    = ft_gen_spec
      FROM   ws_fact_tab
      WHERE  ft_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_stage )
    BEGIN
      SET @v_step = 1500

      SELECT @v_tablespace = st_tablespace
           , @v_short_name = st_short_name
           , @v_genspec    = NULL
      FROM   ws_stage_tab
      WHERE  st_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_agg )
    BEGIN
      SET @v_step = 1600

      SELECT @v_tablespace = at_tablespace
           , @v_short_name = at_short_name
           , @v_genspec    = NULL
      FROM   ws_agg_tab
      WHERE  at_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_index )
    BEGIN
      SET @v_step = 1700

      SELECT @v_tablespace = ih_tablespace
           , @v_short_name = ih_index_name
           , @v_genspec    = NULL
      FROM   ws_index_header
      WHERE  ih_index_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_join )
    BEGIN
      SET @v_step = 1800

      SELECT @v_tablespace = jt_tablespace
           , @v_short_name = jt_short_name
           , @v_genspec    = NULL
      FROM   ws_join_tab
      WHERE  jt_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_export )
    BEGIN

      SET @v_step = 1900
      SELECT @v_tablespace = et_tablespace
           , @v_short_name = et_short_name
           , @v_genspec    = NULL
      FROM   ws_export_tab
      WHERE  et_obj_key = @v_obj_key
    END

    IF (( @v_obj_type = @v_ws_obj_retro )
    OR  ( @v_obj_type = @v_ws_obj_retro_copy ))
    BEGIN
      SET @v_step = 2000

      SELECT @v_tablespace = rt_tablespace
           , @v_short_name = rt_short_name
           , @v_genspec    = NULL
      FROM   ws_retro_tab
      WHERE  rt_obj_key = @v_obj_key
    END

    IF ( @v_obj_type = @v_ws_obj_ods )
    BEGIN

      SET @v_step = 2100
      SELECT @v_tablespace = ot_tablespace
           , @v_short_name = ot_short_name
           , @v_genspec    = ot_gen_spec
      FROM   ws_ods_tab
      WHERE  ot_obj_key = @v_obj_key
    END

    IF @v_obj_type = @v_ws_obj_normal
    OR @v_obj_type = @v_ws_obj_hub
    OR @v_obj_type = @v_ws_obj_satellite
    OR @v_obj_type = @v_ws_obj_link
    OR @v_obj_type = @v_ws_obj_custom1
    OR @v_obj_type = @v_ws_obj_custom2
    BEGIN

      SET @v_step = 2200
      SELECT @v_tablespace = nt_tablespace
           , @v_short_name = nt_short_name
           , @v_genspec    = nt_gen_spec
      FROM   ws_normal_tab
      WHERE  nt_obj_key = @v_obj_key
    END

  END

  --===========================================================================
  -- format the result
  --===========================================================================

  SET @v_step = 2300

  IF ( UPPER(@p_info_type) = 'NAME' )
  BEGIN
    SET @v_value = @v_obj_name
    SET @p_return_msg = 'Object with key ' + CAST(@v_obj_key AS VARCHAR(18)) + ' is called: ' + @v_value;
  END

  SET @v_step = 2400

  IF ( UPPER(@p_info_type) = 'KEY' )
  BEGIN
    SET @v_value = CAST (@v_obj_key AS VARCHAR(18))
    SET @p_return_msg = 'Object ' + @v_obj_name + ' has a key of: ' + @v_value
  END

  SET @v_step = 2500

  IF ( UPPER(@p_info_type) = 'TYPE' )
  BEGIN
    SET @v_value = 'Unknown Type for key ' + CAST (@v_obj_type AS VARCHAR(18))
    SELECT @v_value = ot_description
    FROM   ws_obj_type
    WHERE  ot_type_key = @v_obj_type

    SET @p_return_msg = 'Object ' +  @v_obj_name + ' (object key ' + CAST(@v_obj_key AS VARCHAR(18)) + ') is an object type ' + @v_value;

  END

  SET @v_step = 2600
  IF ( UPPER(@p_info_type) = 'SHORTNAME' )
  BEGIN
    SET @v_value = @v_short_name
    SET @p_return_msg = 'Object ' + @v_obj_name + ' (object key ' + CAST(@v_obj_key AS VARCHAR(18)) + ') is an object type ' + CAST(@v_obj_type AS VARCHAR(18)) + ' with a short name of ' + @v_value;
  END

  SET @v_step = 2700

  IF ( UPPER(@p_info_type)IN ( 'DATABASE','TABLESPACE','FILEGROUP' ))
  BEGIN
    SET @v_value = @v_tablespace
    SET @p_return_msg = 'Object ' + @v_obj_name + ' (object key ' + CAST(@v_obj_key AS VARCHAR(18)) + ') is an object type ' + CAST(@v_obj_type AS VARCHAR(18)) + ' with a ' + @v_info_type + ' of ' + @v_value;
  END

  SET @v_step = 2800
  IF ( UPPER(@p_info_type) = 'PARTKEY' )
  BEGIN
    SET @v_work = NULL
    IF NULLIF(@v_genspec,'') IS NULL
    BEGIN
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Unable to find partitioning exchange table name.'
      SET @p_result = -2
      SET @p_value = ''

      RETURN @p_result
    END

    SET @v_step = 2900

    SELECT @v_work = SUBSTRING(@v_genspec
           ,PATINDEX('%pname=%',@v_genspec)+6
           ,CHARINDEX(';',@v_genspec,PATINDEX('%pname=%',@v_genspec))-6
             -PATINDEX('%pname=%',@v_genspec))

    IF NULLIF(@v_work,'') IS NULL
    BEGIN
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Unable to find partitioning exchange table name in spec.'
      SET @p_result = -2
      SET @p_value = ''

      RETURN @p_result
    END

    SET @v_step = 3000
    EXEC @p_result = Ws_Object_Info @p_sequence, @p_job_name, @p_task_name, @p_job_id, @p_task_id,
                                    NULL,@v_work, 'KEY',
                                    @p_return_code OUTPUT, @p_return_msg OUTPUT,
                                    @p_result OUTPUT , @v_value OUTPUT

    IF @p_result < 1
    BEGIN
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Unable to find object key for partition exchange table ' + @v_work +'.'
      SET @p_result = -2
      SET @p_value = ''

      RETURN @p_result
    END

  END

  SET @p_return_code = 'S'
  SET @p_result = 1
  SET @p_value = @v_value

  SET @v_step = 3100

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

RETURN @p_result
_PROCEDWSL_ Ws_Job_Get_Start 
CREATE PROCEDURE Ws_Job_Get_Start
  (
  @pi_job_key       integer
, @po_start_after   datetime     OUT
, @po_job_status    char(1)      OUT
, @po_result_code   integer      OUT
, @po_return_msg    varchar(255) OUT
  )
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      :    SQL Server
  -- Script Name    :    Ws_Job_Starttime
  -- Description    :    Return next valid starttime for a job
  -- Author         :    Chris Lerew
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================
  -- Notes / History
  -- CJL 2008-06-01 Version 6.0.4.0  New procedure to replace multiple repeated code
  --     Does NOT do any updates
  --     For Custom schedules, allows for StartAfter to be later than StartBefore.  ie exclusion period in the middle of the day.
  -- AP  2009-09-28 Version 6.0.5.1  Fixed lack of handling of non us date formats .. using convert( ...,102)
  -- AP  2009-11-18 Version 6.0.5.2  Corrected further issue for non US date format RED-1364 .. additional convert to datetime for truncate (char(10))
  -- AP  20100702  Version 6.1.1.1   RED_1670 - Change start before to 2400 if 0000 irrespective of start before
  -- BC  2015-04-23 Version 6.8.3.3  RED-4549 Change the daily, weekly, monthly, and annually calculations of the new 'start after' datetime
  --                                 to calculate from the old 'start after' datetime rather than from the current datetime.
  -- AP  23/07/2015 Version 6.8.4.3  RED-5279 Azure Support
  -- BC  2015-08-14 Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
  -- HM  15/10/2018 Version 8.3.1.0  RED-9774 Remove encryption.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE @v_ws_pro_version       VARCHAR(50)
  SET     @v_ws_pro_version     = 'Ws_Job_Get_Start(8.3.1.0)'

  --=====================================================
  -- Control variables
  --=====================================================
  DECLARE
    @v_msgtext                  varchar(255)  -- Text for audit_trail
  , @v_step                     integer       -- return code
  , @v_db_code                  varchar(10)   -- Database error code
  , @v_db_msg                   varchar(100)  -- Database error message

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_row_count                integer       -- General row count
  , @v_job_type                 varchar(1)
  , @v_start_after              datetime
  , @v_start_hh                 integer
  , @v_start_mi                 integer
  , @v_start_day                integer
  , @v_cust_sa_hh               integer
  , @v_cust_sa_mm               integer
  , @v_cust_sb_hh               integer
  , @v_cust_sb_mm               integer
  , @v_cust_min                 integer
  , @v_cust_days                integer
  -- Variables for Custom schedule calculations
  , @v_Cust_SDate               datetime -- Proposed Start, Date part only
  , @v_Cust_SATime              datetime -- Start After  time on proposed date
  , @v_Cust_SBTime              datetime -- Start Before time on proposed date
  --, @v_Cust_SADay               char(3)  -- Day of week of proposed date
  , @v_Cust_SDayOK              integer  -- 0 = Not scheduled on this day
  , @v_more                     integer

  --=====================================================
  -- MAIN
  --=====================================================

  SET @v_step = 100

  BEGIN TRY

  -- Set assumption for failure
  SET @po_result_code = -3
--  SET @po_start_after = '9999-12-31'
  SET @po_start_after = CONVERT(DATETIME,'9999-12-31',102)
  SET @po_job_status  = 'H'
  SET @po_return_msg  = @v_ws_pro_version + ' Failed to determine next start for job key '
                      + CAST (COALESCE(@pi_job_key,0) as varchar(10))

  SET @v_step = 200

  -- Get the current job settings
  SELECT  @v_job_type        = wjc_type
         ,@v_start_hh        = wjc_start_hour
         ,@v_start_mi        = wjc_start_minute
         ,@v_start_day       = wjc_start_day
         ,@v_cust_sa_hh      = COALESCE(wjc_cust_sa_hh,0)
         ,@v_cust_sa_mm      = COALESCE(wjc_cust_sa_mm,0)
         ,@v_cust_sb_hh      = COALESCE(wjc_cust_sb_hh,0)
         ,@v_cust_sb_mm      = COALESCE(wjc_cust_sb_mm,0)
         ,@v_cust_min        = COALESCE(wjc_cust_min,0)
         ,@v_cust_days       = COALESCE(wjc_cust_days,0)
         ,@v_start_after = wjc_start_after
  FROM   ws_wrk_job_ctrl
  WHERE  wjc_job_key = @pi_job_key

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_row_count <> 1
  BEGIN
    SET @po_result_code = -2
    SET @po_return_msg  = @v_ws_pro_version + ' Failed to find job for job key '
                        + CAST (COALESCE(@pi_job_key,0) as varchar(10))

    RETURN
  END

  SET @v_step = 300
  
  -- Assume custom range 0000 to 0000 is really 0000 to 2400 (all day)
  -- RED_1670
  -- IF  @v_cust_sa_hh + @v_cust_sa_mm = 0
  IF @v_cust_sb_hh + @v_cust_sb_mm = 0
    SET @v_cust_sb_hh = 24
  
  SET @v_step = 400
  SET @po_job_status = 'W' -- Default for most job types

  IF @v_job_type IN ( 'H', 'S' )  -- Hold or Once and Hold Schedule.
     BEGIN
     SET @v_start_after = GETDATE()
     SET @po_job_status = 'H'
     END
  ELSE IF @v_job_type = 'D' -- Daily
--RED-1364      SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(char(10),GETDATE() + 1,111))
      WHILE @v_start_after < GETDATE()  -- play catch up in case we got behind
		SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(DATETIME,CONVERT(CHAR(10),@v_start_after + 1,102),102))

  ELSE IF @v_job_type = 'W' -- Weekly
--RED-1364      SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(char(10),GETDATE() + 7,111))
      WHILE @v_start_after < GETDATE()  -- play catch up in case we got behind
		SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(DATETIME,CONVERT(CHAR(10),@v_start_after + 7,102),102))

  ELSE IF @v_job_type = 'M' -- Monthly
--RED-1364      SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(char(10),DATEADD(month,1,GETDATE()),111))
      WHILE @v_start_after < GETDATE()  -- play catch up in case we got behind
		SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(DATETIME,CONVERT(CHAR(10),DATEADD(month,1,@v_start_after),102),102))

  ELSE IF @v_job_type = 'A' -- Annually
--RED-1364      SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(char(10),DATEADD(year ,1,GETDATE()),111))
      WHILE @v_start_after < GETDATE()  -- play catch up in case we got behind
		SET @v_start_after = DATEADD(minute, @v_start_hh * 60 + @v_start_mi, CONVERT(DATETIME,CONVERT(CHAR(10),DATEADD(year ,1,@v_start_after),102),102))

  ELSE IF @v_job_type = 'C' -- Custom
  BEGIN
      SET @v_step = 500
      WHILE @v_start_after < GETDATE()  -- play catch up in case we got behind
        SET @v_start_after  = DATEADD(minute, @v_cust_min, @v_start_after) -- Add first 'Interval' minutes for next proposed start date and time

      SET @v_more = 1

      SET @v_step = 600
      WHILE @v_more = 1 AND @v_start_after < GETDATE() + 8 -- Must be a mistake if we get over a week out with no match.
      BEGIN
--RED-1364        SET @v_Cust_SDate  = CONVERT(char(10),@v_start_after,111)
        SET @v_Cust_SDate  = CONVERT(DATETIME,CONVERT(CHAR(10),@v_start_after,102),102)
        -- SET @v_Cust_SADay  = SUBSTRING(DATENAME(WEEKDAY,@v_start_after),1,3)
        SET @v_Cust_SATime = DATEADD(minute, @v_cust_sa_hh * 60 + @v_cust_sa_mm, @v_Cust_SDate)
        SET @v_Cust_SBTime = DATEADD(minute, @v_cust_sb_hh * 60 + @v_cust_sb_mm, @v_Cust_SDate)

        -- Check that the proposed Day is scheduled
        SET @v_step = 700
        SET @v_Cust_SDayOK  = @v_cust_days
                            & CASE DATENAME(WEEKDAY,@v_start_after)         -- SQL Server bitwise AND. Equal to Zero if not scheduled
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-01',102)) THEN 1    --Monday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-02',102)) THEN 2    --Tuesday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-03',102)) THEN 4    --Wednesday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-04',102)) THEN 8    --Thurday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-05',102)) THEN 16   --Friday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-06',102)) THEN 32   --Saturday
                              WHEN DATENAME(WEEKDAY,CONVERT(DATETIME,'1900-01-07',102)) THEN 64   --Sunday
                              ELSE 0
                              END

        -- Day not scheduled, skip to next day
        IF @v_Cust_SDayOK = 0

          SET @v_start_after = @v_Cust_SDate + 1

        -- Exclusion period spans midnight. eg allow start After 2am and start Before 10pm
        ELSE IF @v_Cust_SATime <= @v_Cust_SBTime
        BEGIN
          SET @v_step = 800
          IF @v_start_after < @v_Cust_SATime        -- Prior to the Start After time
          BEGIN                                     -- so jump directly to the Start After time and exit loop
            SET @v_start_after = @v_Cust_SATime
            SET @v_more = 0
          END

          ELSE IF @v_start_after > @v_Cust_SBTime   -- Past the Start Before time
            SET @v_start_after = @v_Cust_SDate + 1 -- so skip to the next day
          ELSE
            SET @v_more = 0                      -- Between valid start times so exit the loop

        END
        -- Exclusion period does not span midnight. eg allow start Before 2am and start again After 3am
        ELSE  --@v_Cust_SATime > @v_Cust_SBTime
        BEGIN
          SET @v_step = 900
          IF  @v_start_after >  @v_Cust_SBTime -- In exclusion period, jump to end of it, OK, exit loop
          AND @v_start_after <  @v_Cust_SATime
          BEGIN
            SET @v_start_after = @v_Cust_SATime
            SET @v_more = 0
          END
          ELSE                                -- Not in exclusion period, OK, so exit loop
            SET @v_more = 0
        END

      END -- of While loop

      IF @v_start_after >= GETDATE() + 8
        SET @v_start_after = CONVERT(DATETIME,'9999-12-31',102)
  END -- of Type = 'C'ustom

  ELSE -- Unknown schedule type.
  BEGIN
      SET @v_step = 1000
      SET @po_return_msg = @v_ws_pro_version + ' Unknown schedule type ' + COALESCE(@v_job_type,'Null') + ', or unknown job key ' + CAST (COALESCE(@pi_job_key,0) as varchar(10))
      SET @v_start_after = CONVERT(DATETIME,'9999-12-31',102)
      SET @po_result_code = -2
      SET @po_job_status  = 'H'
      RETURN
  END -- of CASE job_type

  SET @po_start_after = @v_start_after
  SET @po_result_code = 1
  SET @po_return_msg  = 'New job Start time assigned'

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @po_result_code = -3


    SET @po_return_msg= @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', '', '' , 0,
        @po_return_msg,@v_db_code, @v_db_msg, 0, pi_job_key
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @po_return_msg= @po_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@po_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

  -----------
  END CATCH
  -----------

 RETURN 0
_PROCEDWSL_ Ws_Act_Analyze 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- WMR 05/04/2002 Version 1.0.7   Added for all indexed columns to analyze
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2014 Version 6.8.0.2 Schema support
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- KH  28/10/2015 Version 6.8.4.4 Statement increased to 4000
-- TA  01/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Analyze
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_percent         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : SQl Server
  -- Script Name  : ws_act_analyze
  -- Description  : Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Analyze(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_table_database   varchar(64)
  , @v_table_schema     varchar(64)
  , @v_table_name       varchar(64)
  , @v_table_with_owner varchar(256)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  SET @v_step = 100

  BEGIN TRY

  SET @p_result = 1

  --=====================================================
  -- Handle either an Index or a Table
  --=====================================================
  IF @p_obj_type = @v_ws_obj_index
  BEGIN

    SET @v_step = 110
    -- needs to look up the schema from ws_dbc_target for the indexed tables schema
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
             , @v_table_name = oo_name
    FROM       ws_index_header
    LEFT JOIN  ws_obj_object
    ON         ws_obj_object.oo_obj_key = ws_index_header.ih_obj_key
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      UPPER(ih_index_name) = UPPER(@p_task_name)

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_with_owner = @v_table_with_owner + @v_table_name

    IF @p_percent = 100
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS '+ @v_table_with_owner + N' ' + @p_task_name + N' WITH FULLSCAN'
    END
    ELSE
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS '+ @v_table_with_owner + N' ' + @p_task_name + N' WITH SAMPLE ' +
                      convert(varchar,@p_percent) + ' PERCENT'
    END

    SET @p_return_msg = 'Index '+ @p_task_name+' analyzed'

    -- Execute the analyze
    SET @v_step = 200
    EXECUTE sp_executesql @v_stmt

    SET @v_step = 300

    SET @p_status_code = 1
    SET @p_result = 1

    RETURN 0
  END
  ELSE
  BEGIN
    --=====================================================
    -- Table
    --=====================================================
   -- needs to look up the schema from ws_dbc_target for the indexed tables schema
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
             , @v_table_name = oo_name
    FROM       ws_obj_object
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      UPPER(oo_name) = UPPER(@p_task_name)

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_with_owner = @v_table_with_owner + @v_table_name

    IF @p_percent = 100
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS ' + @v_table_with_owner  + N' WITH FULLSCAN'
    END
    ELSE
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS ' + @v_table_with_owner  + N' WITH SAMPLE ' +
                      convert(varchar,@p_percent) + ' PERCENT'
    END
    SET @p_return_msg = 'Table '+ @v_table_with_owner  +' analyzed '

    -- Execute the analyze
    SET @v_step = 400
    EXECUTE sp_executesql @v_stmt

    SET @v_step = 500

    SET @p_status_code = 1
    SET @p_result = 1

    RETURN 0

  END

  SET @p_status_code = -1
  SET @p_result = -1
  SET @p_return_msg = 'No action chosen'

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Build 
-- Notes / History
--
-- WMR 30/08/2001 Version 0.3.0.6 Added support for Primary Keys
-- WMR 21/01/2002 Version 1.0.0.0 Added support for Partitioned indexes
-- WMR 20/03/2002 Version 1.0.6.0 Added support for Parallel Index builds
-- WMR 29/10/2002 Version 1.2.1.0 Sql Server port
-- WMR 24/12/2003 Version 4.1.0.0 Added support for clustered indexes
-- WMR 20/09/2004 Version 4.1.0.9 Use NonClustered if Clustered flag not set
-- WMR 21/09/2004 Version 4.1.0.9 Previously failed to put index in correct filegroup
-- WMR 08/11/2005 Version 5.0.0.0 Added support for parallel and fill factors.
-- AP  01/08/2006 Version 5.5.0.5 Add Version Number as constant to out messages
--                                Add call to wswrkerror for each index as drop/built
--                                Separated out check of existence for drop
--                                Corrected setting of job task for calls to wswrkaudit
-- AP  26/05/2009 Version 6.0.4.1 Add Include columns
-- AP  10/06/2009 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/09/2009 Version 6.0.5.1 Tightened checking for existing index.
-- AP  30/10/2009 Version 6.0.5.2 RED-1329 New options on index create.
-- AP  31/03/2010 Version 6.1.0.1 RED-1493 Order added to index to do clustered FIRST
-- AP  23/11/2010 Version 6.3.0.1 RED-1954 Include Filter/Where
-- AP  09/03/2011 Version 6.5.4.1 RED_2000:Include DATA_COMPRESSION setting
-- AP  20/02/2012 Version 6.5.6.1 RED_2575:Handle Columnstore indexes
-- AP  28/03/2015 Version 6.7.4.1 RED_3570:Handle CLUSTERED Columnstore Indexes
-- MXU 31/10/2013 Version 6.7.4.1 RED_3264:Index create failure in scheduler causes failure in subsequent task index drop
-- HM  19/08/2014 Version 6.8.1.2 RED_3906:Added Schema support
-- DLC 24/10/2014 Version 6.8.1.2 Increased the buffer size for the column buffer
-- HM  05/03/2015 Version 6.8.3.0 RED-4616:Fix broken index rebuild due to uninitialized v_ih_table
-- HM  06/03/2015 Version 6.8.3.0 RED-4635:Fix issue with missing ',' between index columns.
-- BC  19/03/2015 Version 6.8.3.1 RED-4634:Fix problem with a primary key index always being created as clustered
--                                regardless of the configured index type.
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  07/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  21/02/2017 Version 6.8.7.1 RED-7796 Search for index to drop in correct database
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Build
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name               :  SQLServer
  -- Script Name             :  Ws_Act_Build
  -- Description             :  Build any indexes due for rebuild
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Build(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_count           integer
  , @v_columns         varchar(4000) -- RED-4053 increase buffer size
  , @v_col_number      integer
  , @v_index_key       integer
  , @v_day             integer
  , @v_day_name        varchar(3)
  , @v_month_end       integer
  , @v_month           integer
  , @v_tommorrow_month integer
  , @v_part_count      integer
  , @v_row             integer
  , @v_index_name      varchar(63)
  , @v_stats_include   varchar(1)
  , @v_index_exist     integer       -- counter for index existence
  , @v_pos             integer
  , @v_sortintemp      integer
  , @v_build_options   nvarchar(4000)
  , @v_size            integer
  , @v_spos            integer
  , @v_columnstore     integer
  , @v_with            integer

  --=====================================================
  -- Cursor Variables
  --=====================================================
  DECLARE
    @v_ih_unique          varchar(1)
  , @v_ih_key_type        varchar(1)
  , @v_ih_index_key       integer
  , @v_ih_tablespace      varchar(64)
  , @v_ih_table           varchar(64)
  , @v_ih_index_name      varchar(64)
  , @v_ih_pre_drop_flag   varchar(1)
  , @v_ih_rebuild_freq    varchar(12)
  , @v_ih_clustered_ind   varchar(1)
  , @v_ih_parallel        integer
  , @v_ih_pct_free        integer
  , @v_ic_column          varchar(64)
  , @v_ic_foreign_table   varchar(64)
  , @v_ic_foreign_column  varchar(64)
  , @v_ih_index_options   varchar(4000)
  , @v_ih_where           varchar(4000)
  , @v_table_database     varchar(64)
  , @v_table_schema       varchar(64)
  , @v_table_owner        varchar(150)
  , @v_table_with_owner   varchar(256)

  SET @v_step = 100

  BEGIN TRY

  SET @v_index_name = ''
  SET @p_return_msg = ''
  SET @p_result = 1
  SET @v_count = 0
  SET @v_columns = ''

  -- needs to look up the database and schema from ws_dbc_target for the indexed tables schema
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_owner = @v_table_database
  IF NULLIF(@v_table_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_owner = @v_table_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_owner = @v_table_owner + @v_table_schema
  IF NULLIF(@v_table_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_owner = @v_table_owner + '.'
  END

  --=====================================================
  -- If this is an index task just build that index
  -- Otherwise we have a table so build all required indexes
  --=====================================================
  IF @p_obj_type = @v_ws_obj_index
  BEGIN
    SET @v_step = 200

    --=====================================================
    -- Build for specified index
    -- First get the information about the index
    --=====================================================
    SELECT
      @v_ih_unique = ih_unique
    , @v_ih_key_type = ih_key_type
    , @v_ih_table = ih_table
    , @v_ih_index_key = ih_index_key
    , @v_ih_tablespace = ih_tablespace
    , @v_ih_index_name = ih_index_name
    , @v_ih_pre_drop_flag = ih_pre_drop_flag
    , @v_ih_rebuild_freq = ih_rebuild_freq
    , @v_ih_clustered_ind = ih_clustered_ind
    , @v_ih_parallel = ih_parallel
    , @v_ih_pct_free = ih_pct_free
    , @v_ih_index_options = ih_index_options
    , @v_ih_where = ih_where
    FROM
      ws_index_header
    WHERE ih_index_key = @p_obj_key

    SELECT @v_row_count = @@ROWCOUNT

    IF @v_row_count = 0
    BEGIN
      SET @p_return_msg = 'Index ' + @v_ih_index_name + ' Build failed'

      BEGIN
        SET @v_db_code = NULL
        SET @v_db_msg = NULL
      END
      EXEC WsWrkAudit
        @p_status_code = 'W'
      , @p_job_name    = @p_job_name
      , @p_task_name   = @p_task_name
      , @p_sequence    = @p_sequence
      , @p_message     = @p_return_msg
      , @p_db_code     = @v_db_code
      , @p_db_msg      = @v_db_msg
      , @p_task_key    = @p_task_id
      , @p_job_key     = @p_job_id
      SET @p_status_code = -1
      SET @p_result = -1
      RETURN 0
    END

    SET @v_step = 300

    SET @v_index_name = @v_ih_index_name

    SET @v_step = 400
    -- RED-2575 - determine if columnstore
    SET @v_columnstore = 0
    SELECT @v_columnstore = ISNULL(PATINDEX('%columnstore=TR%',@v_ih_index_options),0)

    -- RED-1329 - determine if sort in temp requested
    SET @v_sortintemp = 0
    SELECT @v_sortintemp = ISNULL(PATINDEX('%sortintemp=TR%',@v_ih_index_options),0)

    SET @v_step = 500
    SET @v_build_options = ''
    -- RED-1329 - determine additional build options
    IF NULLIF(@v_ih_index_options,'') is NOT NULL
    BEGIN
      SELECT @v_pos = PATINDEX('%buildopts=%',@v_ih_index_options)
      IF ISNULL(@v_pos,0) >= 1
      BEGIN
        SET @v_step = 600
        SELECT @v_size = CONVERT(integer,SUBSTRING(@v_ih_index_options,@v_pos+10,4))
        IF @v_size > 0
        BEGIN
          SET @v_step = 700
          SELECT @v_build_options = LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_pos+15,@v_size)))
        END
      END
    END

    -- RED_2000 - include option for DATA_COMPRESSION
    SET @v_step = 800

    IF NULLIF(@v_ih_index_options,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_ih_index_options)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 900
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_ih_index_options,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           SET @v_step = 1000

           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 1100
             IF NULLIF(@v_build_options,'') IS NOT NULL
             BEGIN
                SET @v_build_options = @v_build_options + ', '
             END

             SET @v_step = 1200

             SET @v_build_options = @v_build_options
                                  + 'DATA_COMPRESSION='
                                  + LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1)))
           END
        END
      END
    END

    SET @v_table_with_owner = @v_table_owner + COALESCE(@v_ih_table, '')

    --=====================================================
    -- Next drop the index in case that step was not run
    -- Execute the drop
    --=====================================================
    SET @v_index_exist = 0

    -- Azure SQL Database does not support 'DROP INDEX IF EXITS' so we have to do this
    SET @v_stmt = @v_table_database
    IF NULLIF(@v_stmt,'') IS NOT NULL
    BEGIN
        SET @v_stmt = @v_stmt + '.'
    END
    SET @v_stmt =
        'SELECT @v_index_exist = COUNT(*) FROM ' + @v_stmt + 'sys.indexes' +
        ' WHERE name = ''' + @v_ih_index_name + '''' +
        ' AND object_id = OBJECT_ID(''' + @v_table_with_owner + ''')'
        ;

    -- While it looks like output param isn't needed here (just checking ROWCOUNT should be fine) this is not the case.
    -- Accessing ROWCOUNT after EXECing the above statement when database IS SET fails catastrophically.  You CAN do it
    -- interactively in Management Studio, it works fine there, but in a stored procedure it causes a silent crash.
    -- Sometimes it returns correct value and then crashes on the next step, other times it crashes on ROWCOUNT access.
    -- Tested on 2016 and 2012.
    EXECUTE sp_executesql @v_stmt, N'@v_index_exist integer OUTPUT', @v_index_exist = @v_index_exist OUTPUT

    IF @v_index_exist > 0
    BEGIN
      SET @v_step = 1300

      IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
      BEGIN
        SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
      END
      ELSE
      BEGIN
        SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
      END

      SET @v_step = 1400
      EXEC ( @v_stmt )
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        --=====================================================
        -- Put detail message
        --=====================================================
        SET @v_step = 1500

        SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name  + ' dropped'

        EXEC WsWrkError
          @p_status_code = 'I'
        , @p_job_name    = @p_job_name
        , @p_task_name   = @p_task_name
        , @p_sequence    = @p_sequence
        , @p_message     = @v_msgtext
        , @p_db_code     = NULL
        , @p_db_msg      = NULL
        , @p_task_key    = @p_task_id
        , @p_job_key     = @p_job_id
        , @p_msg_type    = NULL
      END
    END -- index existed

    --=====================================================
    -- Create the rebuild command
    --=====================================================
    SET @v_step = 1600

    IF  @v_ih_unique = 'Y'
    AND @v_ih_key_type = 'A'
    BEGIN
      SET @v_stmt = 'Alter Table '
      SET @v_stmt = @v_stmt + @v_table_with_owner

      SET @v_stmt = @v_stmt + ' Add Constraint '
      SET @v_stmt = @v_stmt + @v_ih_index_name + ' Primary Key '

      IF @v_ih_clustered_ind = 'Y'
      BEGIN
         SET @v_stmt = @v_stmt + 'Clustered '
      END
      ELSE
      BEGIN
         SET @v_stmt = @v_stmt + 'NonClustered '
      END

--RED_3570      SET @v_stmt = @v_stmt + '('
    END
    ELSE
    BEGIN
      SET @v_stmt = 'Create '
      IF @v_ih_unique = 'Y'
      BEGIN
         SET @v_stmt = @v_stmt + 'Unique '
      END

      IF @v_columnstore > 0
      BEGIN
        IF @v_ih_clustered_ind = 'Y'--RED_3570
        BEGIN
           SET @v_stmt = @v_stmt + 'Clustered '
        END
        SET @v_stmt = @v_stmt + 'Columnstore '
      END
      ELSE
      BEGIN
        IF @v_ih_clustered_ind = 'Y'
        BEGIN
           SET @v_stmt = @v_stmt + 'Clustered '
        END
        ELSE
        BEGIN
           SET @v_stmt = @v_stmt + 'NonClustered '
        END
      END

      SET @v_stmt = @v_stmt + 'Index ' + @v_ih_index_name + ' ON '

      SET @v_stmt = @v_stmt + @v_table_with_owner

    END

    -- Now add in all the columns
    SET @v_index_key = @v_ih_index_key
    SET @v_columns = ''
    SET @v_col_number = 0

    SET @v_step = 1700

    --=====================================================
    -- Cursor for index columns
    --=====================================================
    DECLARE c_IndCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR -- RED_3264
      SELECT
        ic_column
      , ic_foreign_table
      , ic_foreign_column
      FROM
        ws_index_col
      WHERE ic_index_key = @v_index_key
      AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'N'
      ORDER BY ic_column_no

    OPEN c_IndCol
    FETCH NEXT FROM c_IndCol INTO
      @v_ic_column
    , @v_ic_foreign_table
    , @v_ic_foreign_column

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 1800

      SET @v_col_number = @v_col_number + 1
      IF @v_col_number > 1
      BEGIN
        SET @v_columns = @v_columns + ','
      END
      SET @v_columns = @v_columns + @v_ic_column

      FETCH NEXT FROM c_IndCol INTO
        @v_ic_column
      , @v_ic_foreign_table
      , @v_ic_foreign_column

    END

    CLOSE c_IndCol
    DEALLOCATE c_IndCol

    --RED_3570
    --SET @v_stmt = @v_stmt + @v_columns + ')'
    IF @v_col_number > 0
    BEGIN
      SET @v_stmt = @v_stmt + '(' + @v_columns + ')'
    END
    -- Now for the include Columns

    --=====================================================
    -- Cursor for index columns
    --=====================================================
    SET @v_step = 1900

    DECLARE c_IndInclCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR -- RED_3264
      SELECT
        ic_column
      FROM
        ws_index_col
      WHERE ic_index_key = @v_index_key
      AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'Y'
      ORDER BY ic_column_no

    SET @v_columns = ''
    SET @v_col_number = 0

    OPEN c_IndInclCol
    FETCH NEXT FROM c_IndInclCol INTO
      @v_ic_column

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_step = 2000

      SET @v_col_number = @v_col_number + 1

      IF @v_col_number > 1
      BEGIN
        SET @v_columns = @v_columns + ','
      END

      SET @v_columns = @v_columns + @v_ic_column

      FETCH NEXT FROM c_IndInclCol INTO
        @v_ic_column

    END

    CLOSE c_IndInclCol
    DEALLOCATE c_IndInclCol

    IF @v_col_number > 0
    BEGIN
      SET @v_stmt = @v_stmt + ' INCLUDE (' + @v_columns + ') '
    END

    -- RED_1954 include Filter/Where
    SET @v_step = 2100

    IF @v_ih_clustered_ind = 'Y'
       SET @v_ih_where = ''

    IF NULLIF(@v_ih_where,'') IS NOT NULL
    BEGIN
      SELECT @v_pos = PATINDEX('where%',lower(@v_ih_where))
      IF ISNULL(@v_pos,0) <> 1
      BEGIN
        SET @v_ih_where = 'WHERE (' + @v_ih_where + ')'
      END

      SET @v_stmt = @v_stmt + ' ' + @v_ih_where + ' '
    END

    IF @v_columnstore > 0
    BEGIN
    SET  @v_with =0
    IF NULLIF(@v_build_options,'') IS NOT NULL
    BEGIN
      SET  @v_stmt = @v_stmt + ' WITH ( ' + @v_build_options
      SET  @v_with =1
    END

    IF @v_ih_parallel > 0
    BEGIN
      IF @v_with > 0
        SET  @v_stmt = @v_stmt + ' ,'
      ELSE
        SET  @v_stmt = @v_stmt + ' WITH ( '

      SET  @v_stmt = @v_stmt + ' MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
      SET  @v_with =1
    END

    IF @v_with > 0
      SET  @v_stmt = @v_stmt + ') '
    END
    ELSE
    BEGIN

    SET @v_stmt = @v_stmt + ' WITH ('

    IF @v_sortintemp = 0
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = OFF '
    ELSE
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = ON '

    IF NULLIF(@v_build_options,'') IS NOT NULL
      SET  @v_stmt = @v_stmt + ', ' + @v_build_options

    IF @v_ih_parallel > 0
    BEGIN
      SET  @v_stmt = @v_stmt + ', MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
    END

    IF @v_ih_pct_free >0
    BEGIN
      SET  @v_stmt = @v_stmt + ', FILLFACTOR = ' + CONVERT(varchar,ISNULL(@v_ih_pct_free,0))
    END
    SET @v_stmt = @v_stmt + ' ) '

    END

    IF @v_ih_tablespace <> ''
    BEGIN
      SET @v_stmt = @v_stmt + ' ON '
      SET @v_stmt = @v_stmt + @v_ih_tablespace
    END

    --=====================================================
    -- Rebuild the index
    --=====================================================
    SET @v_step = 2200

    EXEC ( @v_stmt )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      --=====================================================
      -- Put detail message
      --=====================================================
      SET @v_step = 2300

      SET @v_msgtext = 'Index ' + @v_table_with_owner  + '.' + @v_ih_index_name  + ' rebuilt'
      IF @v_stats_include = 'Y'
      BEGIN
        SET @v_msgtext = @v_msgtext + ' including stats'
      END

      EXEC WsWrkError
          @p_status_code = 'I'
        , @p_job_name    = @p_job_name
        , @p_task_name   = @p_task_name
        , @p_sequence    = @p_sequence
        , @p_message     = @v_msgtext
        , @p_db_code     = NULL
        , @p_db_msg      = NULL
        , @p_task_key    = @p_task_id
        , @p_job_key     = @p_job_id
        , @p_msg_type    = NULL

      SET @v_count = @v_count + 1

    END

  END
  ELSE -- Non specific index so build what is required
  BEGIN

    --=====================================================
    -- Get the day of the week, and if at start or end of month
    --=====================================================
    SELECT
      @v_day_name = SUBSTRING(DATENAME(dw,GETDATE()),1,3)
    , @v_day = DATEPART(dd,GETDATE())
    , @v_month = DATEPART(mm,GETDATE())
    , @v_tommorrow_month = DATEPART(mm,GETDATE()+1)

    IF @v_month <> @v_tommorrow_month
    BEGIN
       SET @v_month_end = 1
    END
    ELSE
    BEGIN
      SET @v_month_end = 0
    END

    --=====================================================
    -- Loop through all the indexes looking for what to build
    --=====================================================
    --=====================================================
    -- Cursor for all indexes
    --=====================================================
    SET @v_step = 2400

    DECLARE c_Index CURSOR LOCAL FAST_FORWARD READ_ONLY FOR -- RED_3264
    SELECT
      ih_unique
    , ih_key_type
    , ih_table
    , ih_index_key
    , ih_tablespace
    , ih_index_name
    , ih_pre_drop_flag
    , ih_rebuild_freq
    , ih_clustered_ind
    , ih_parallel
    , ih_pct_free
    , ih_index_options
    , ih_where
    FROM
      ws_index_header
    WHERE ih_obj_key = @p_obj_key
    AND   ih_active = 'Y'
    ORDER BY ISNULL( ih_clustered_ind,'N') DESC  -- RED_1493

    OPEN c_Index
    FETCH NEXT FROM c_Index INTO
      @v_ih_unique
    , @v_ih_key_type
    , @v_ih_table
    , @v_ih_index_key
    , @v_ih_tablespace
    , @v_ih_index_name
    , @v_ih_pre_drop_flag
    , @v_ih_rebuild_freq
    , @v_ih_clustered_ind
    , @v_ih_parallel
    , @v_ih_pct_free
    , @v_ih_index_options
    , @v_ih_where

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 2500

      SET @v_table_with_owner = @v_table_owner + COALESCE(@v_ih_table, '')

      IF upper(@v_ih_pre_drop_flag) = 'Y'
      OR upper(@v_ih_rebuild_freq) = 'DAILY'
      OR upper(substring(@v_ih_rebuild_freq,1,3)) = upper(@v_day_name)
      OR (upper(@v_ih_rebuild_freq) = 'END MONTH' And @v_month_end = 1)
      OR (upper(@v_ih_rebuild_freq) = 'START MONTH' And @v_day = 1)
      BEGIN

        SET @v_step = 2600

        SET @v_index_name = @v_ih_index_name

        SET @v_step = 2700
        -- RED-2575 - determine if columnstore
        SET @v_columnstore = 0
        SELECT @v_columnstore = ISNULL(PATINDEX('%columnstore=TR%',@v_ih_index_options),0)

        -- RED-1329 - determine if sort in temp requested
        SET @v_sortintemp = 0
        SELECT @v_sortintemp = ISNULL(PATINDEX('%sortintemp=TR%',@v_ih_index_options),0)

        SET @v_step = 2800
        SET @v_build_options = ''
        -- RED-1329 - determine additional build options
        IF NULLIF(@v_ih_index_options,'') is NOT NULL
        BEGIN
          SELECT @v_pos = PATINDEX('%buildopts=%',@v_ih_index_options)
          IF ISNULL(@v_pos,0) >= 1
          BEGIN
            SET @v_step = 2900
            SELECT @v_size = CONVERT(integer,SUBSTRING(@v_ih_index_options,@v_pos+10,4))
            IF @v_size > 0
            BEGIN
              SET @v_step = 3000
              SELECT @v_build_options = LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_pos+15,@v_size)))
            END
          END
        END

        -- RED_2000 - include option for DATA_COMPRESSION
        SET @v_step = 3100

        IF NULLIF(@v_ih_index_options,'') IS NOT NULL
        BEGIN

          SELECT @v_spos = PATINDEX('%datacompression=%',@v_ih_index_options)

          IF ISNULL(@v_spos,0) >= 1
          BEGIN
            SET @v_step = 3200
            SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_ih_index_options,@v_spos+16,1000))

            IF ISNULL(@v_size,0) >= 1
            BEGIN
               SET @v_step = 3300

               IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1))),'') IS NOT NULL
               BEGIN
                 SET @v_step = 3400
                 IF NULLIF(@v_build_options,'') IS NOT NULL
                 BEGIN
                  SET @v_build_options = @v_build_options + ', '
                 END

                 SET @v_step = 3500

                 SET @v_build_options = @v_build_options
                                     + 'DATA_COMPRESSION='
                                     + LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1)))
               END
            END
          END
        END

        --=====================================================
        -- First drop the index in case that step was not run
        -- Execute the drop
        --=====================================================
        SET @v_step = 3600
        SET @v_index_exist = 0

        -- Azure SQL Database does not support 'DROP INDEX IF EXITS' so we have to do this
        SET @v_stmt = @v_table_database
        IF NULLIF(@v_stmt,'') IS NOT NULL
        BEGIN
            SET @v_stmt = @v_stmt + '.'
        END
        SET @v_stmt =
            'SELECT @v_index_exist = COUNT(*) FROM ' + @v_stmt + 'sys.indexes' +
            ' WHERE name = ''' + @v_ih_index_name + '''' +
            ' AND object_id = OBJECT_ID(''' + @v_table_with_owner + ''')'
            ;

        -- While it looks like output param isn't needed here (just checking ROWCOUNT should be fine) this is not the case.
        -- Accessing ROWCOUNT after EXECing the above statement when database IS SET fails catastrophically.  You CAN do it
        -- interactively in Management Studio, it works fine there, but in a stored procedure it causes a silent crash.
        -- Sometimes it returns correct value and then crashes on the next step, other times it crashes on ROWCOUNT access.
        -- Tested on 2016 and 2012.
        EXECUTE sp_executesql @v_stmt, N'@v_index_exist integer OUTPUT', @v_index_exist = @v_index_exist OUTPUT

        IF @v_index_exist > 0
        BEGIN
          IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
          BEGIN
            SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
          END
          ELSE
          BEGIN
            SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
          END

          SET @v_step = 3700
          EXEC ( @v_stmt )
          SELECT @v_row_count = @@ROWCOUNT

          BEGIN
            --=====================================================
            -- Put detail message
            --=====================================================
            SET @v_step = 3800

            SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name  + ' dropped'

            EXEC WsWrkError
               @p_status_code = 'I'
             , @p_job_name    = @p_job_name
             , @p_task_name   = @p_task_name
             , @p_sequence    = @p_sequence
             , @p_message     = @v_msgtext
             , @p_db_code     = NULL
             , @p_db_msg      = NULL
             , @p_task_key    = @p_task_id
             , @p_job_key     = @p_job_id
             , @p_msg_type    = NULL
           END
        END  -- index existed

        --=====================================================
        -- Create the rebuild command
        --=====================================================
        SET @v_step = 3900

        IF  @v_ih_unique = 'Y'
        AND @v_ih_key_type = 'A'
        BEGIN
          SET @v_stmt = 'Alter Table '

          SET @v_stmt = @v_stmt + @v_table_with_owner + ' Add Constraint '
          SET @v_stmt = @v_stmt + @v_ih_index_name + ' Primary Key '
          IF @v_ih_clustered_ind = 'Y'
          BEGIN
             SET @v_stmt = @v_stmt + 'Clustered '
          END
          ELSE
          BEGIN
             SET @v_stmt = @v_stmt + 'NonClustered '
          END
--RED_3570          SET @v_stmt = @v_stmt + '('
        END
        ELSE
        BEGIN
          SET @v_stmt = 'Create '
          IF @v_ih_unique = 'Y'
          BEGIN
             SET @v_stmt = @v_stmt + 'Unique '
          END

          IF @v_columnstore > 0
          BEGIN
            IF @v_ih_clustered_ind = 'Y'--RED_3570
            BEGIN
               SET @v_stmt = @v_stmt + 'Clustered '
            END
            SET @v_stmt = @v_stmt + 'Columnstore '
          END
          ELSE
          BEGIN
            IF @v_ih_clustered_ind = 'Y'
            BEGIN
               SET @v_stmt = @v_stmt + 'Clustered '
            END
          END
          SET @v_stmt = @v_stmt + 'Index ' + @v_ih_index_name + ' ON '
--RED_3570          SET @v_stmt = @v_stmt + + @v_ih_table + ']('
          SET @v_stmt = @v_stmt + @v_table_with_owner
        END

        -- Now add in all the columns
        SET @v_index_key = @v_ih_index_key
        SET @v_columns = ''
        SET @v_col_number = 0

        --=====================================================
        -- Cursor for index columns
        --=====================================================
        SET @v_step = 4000

        DECLARE c_IndCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR -- RED_3264
          SELECT
            ic_column
          , ic_foreign_table
          , ic_foreign_column
          FROM
            ws_index_col
          WHERE ic_index_key = @v_index_key
          AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'N'
          ORDER BY ic_column_no

        OPEN c_IndCol
        FETCH NEXT FROM c_IndCol INTO
          @v_ic_column
        , @v_ic_foreign_table
        , @v_ic_foreign_column

        WHILE @@FETCH_STATUS = 0
        BEGIN

          SET @v_step = 4100

          SET @v_col_number = @v_col_number + 1
          IF @v_col_number > 1
          BEGIN
            SET @v_columns = @v_columns + ','
          END
          SET @v_columns = @v_columns + @v_ic_column

          FETCH NEXT FROM c_IndCol INTO
            @v_ic_column
          , @v_ic_foreign_table
          , @v_ic_foreign_column

        END

        CLOSE c_IndCol
        DEALLOCATE c_IndCol

        --RED_3570
        --SET @v_stmt = @v_stmt + @v_columns + ')'
        IF @v_col_number > 0
        BEGIN
          SET @v_stmt = @v_stmt + '(' + @v_columns + ')'
        END

        -- Now for the include Columns

        --=====================================================
        -- Cursor for index columns
        --=====================================================
        SET @v_step = 4200

        DECLARE c_IndInclCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR -- RED_3264
          SELECT
            ic_column
          FROM
            ws_index_col
          WHERE ic_index_key = @v_index_key
          AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'Y'
          ORDER BY ic_column_no

        SET @v_columns = ''
        SET @v_col_number = 0

        OPEN c_IndInclCol
        FETCH NEXT FROM c_IndInclCol INTO
          @v_ic_column

        WHILE @@FETCH_STATUS = 0
        BEGIN

          SET @v_step = 4300

          SET @v_col_number = @v_col_number + 1

          IF @v_col_number > 1
          BEGIN
            SET @v_columns = @v_columns + ','
          END

          SET @v_columns = @v_columns + @v_ic_column

          FETCH NEXT FROM c_IndInclCol INTO
            @v_ic_column

        END

        CLOSE c_IndInclCol
        DEALLOCATE c_IndInclCol

        IF @v_col_number > 0
        BEGIN
          SET @v_stmt = @v_stmt + ' INCLUDE (' + @v_columns + ') '
        END

        -- RED_1954 include Filter/Where
        IF @v_ih_clustered_ind = 'Y'
           SET @v_ih_where = ''

        IF NULLIF(@v_ih_where,'') is NOT NULL
        BEGIN
          SELECT @v_pos = PATINDEX('where%',lower(@v_ih_where))
          IF ISNULL(@v_pos,0) <> 1
          BEGIN
            SET @v_ih_where = 'WHERE (' + @v_ih_where + ')'
          END

          SET @v_stmt = @v_stmt + ' ' + @v_ih_where + ' '
        END

        IF @v_columnstore > 0
        BEGIN
    SET  @v_with =0
    IF NULLIF(@v_build_options,'') IS NOT NULL
    BEGIN
      SET  @v_stmt = @v_stmt + ' WITH ( ' + @v_build_options
      SET  @v_with =1
    END

    IF @v_ih_parallel > 0
    BEGIN
      IF @v_with > 0
      BEGIN
        SET  @v_stmt = @v_stmt + ' ,'
      END
      ELSE
      BEGIN
        SET  @v_stmt = @v_stmt + ' WITH ('
      END

      SET  @v_stmt = @v_stmt + ' MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
      SET  @v_with =1
    END

    IF @v_with > 0
    BEGIN
      SET  @v_stmt = @v_stmt + ' ) '
    END
        END
        ELSE
        BEGIN
    SET @v_stmt = @v_stmt + ' WITH ('

    IF @v_sortintemp = 0
    BEGIN
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = OFF '
    END
    ELSE
    BEGIN
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = ON '
    END

    IF NULLIF(@v_build_options,'') IS NOT NULL
    BEGIN
      SET  @v_stmt = @v_stmt + ', ' + @v_build_options
    END
    IF @v_ih_parallel > 0
    BEGIN
      SET  @v_stmt = @v_stmt + ', MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
    END

    IF @v_ih_pct_free >0
    BEGIN
      SET  @v_stmt = @v_stmt + ', FILLFACTOR = ' + CONVERT(varchar,ISNULL(@v_ih_pct_free,0))
    END
    SET @v_stmt = @v_stmt + ' ) '
        END

        IF @v_ih_tablespace <> ''
        BEGIN
          SET @v_stmt = @v_stmt + ' ON '
          SET @v_stmt = @v_stmt + @v_ih_tablespace
        END
        --=====================================================
        -- Rebuild the index
        --=====================================================

        SET @v_step = 4400

        EXEC ( @v_stmt )
        SELECT @v_row_count = @@ROWCOUNT

        BEGIN
          --=====================================================
          -- Put detail message
          --=====================================================
          SET @v_step = 4500

          SET @v_msgtext = 'Index [' + @v_ih_table  + '].' + @v_ih_index_name  + ' rebuilt'
          IF @v_stats_include = 'Y'
          BEGIN
            SET @v_msgtext = @v_msgtext + ' including stats'
          END

          EXEC WsWrkError
            @p_status_code = 'I'
          , @p_job_name    = @p_job_name
          , @p_task_name   = @p_task_name
          , @p_sequence    = @p_sequence
          , @p_message     = @v_msgtext
          , @p_db_code     = NULL
          , @p_db_msg      = NULL
          , @p_task_key    = @p_task_id
          , @p_job_key     = @p_job_id
          , @p_msg_type    = NULL

          SET @v_count = @v_count + 1

        END

      END -- End of index needs a build

      FETCH NEXT FROM c_Index INTO
        @v_ih_unique
      , @v_ih_key_type
      , @v_ih_table
      , @v_ih_index_key
      , @v_ih_tablespace
      , @v_ih_index_name
      , @v_ih_pre_drop_flag
      , @v_ih_rebuild_freq
      , @v_ih_clustered_ind
      , @v_ih_parallel
      , @v_ih_pct_free
      , @v_ih_index_options
      , @v_ih_where

    END -- End of Index cursor

    CLOSE c_Index
    DEALLOCATE c_Index

  End -- End of all index build

  SET @v_step = 4600

  -- tell them how many indexes we rebuilt
  IF @v_count <= 0
  BEGIN
    SET @p_return_msg = 'No indexes rebuilt'
  END
  IF @v_count = 1
  BEGIN
    SET @p_return_msg = '1 index rebuilt'
  END
  IF @v_count > 1
  BEGIN
    SET @p_return_msg = CONVERT(varchar,ISNULL(@v_count,0)) + ' indexes rebuilt'
  END
  SET @p_status_code = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_IndInclCol') >= -1 -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_IndInclCol                      -- RED_3264
    END                                            -- RED_3264
    IF CURSOR_STATUS('local','c_IndCol') >= -1     -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_IndCol                          -- RED_3264
    END                                            -- RED_3264
    IF CURSOR_STATUS('local','c_Index') >= -1      -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_Index                           -- RED_3264
    END                                            -- RED_3264
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Build_All 
-- Notes / History
--
-- WMR 30/08/2001 Version 0.3.0.6 Added support for Primary Keys
-- WMR 21/01/2002 Version 1.0.0.0 Added support for Partitioned indexes
-- WMR 20/03/2002 Version 1.0.6.0 Added support for Parallel index builds
-- WMR 29/10/2002 Version 1.2.1.0 Sql Server port
-- WMR 24/12/2003 Version 4.1.0.0 Added support for Clustered Indexes
-- WMR 20/09/2004 Version 4.1.0.9 Use NonClustered if Clustered flag not set
-- WMR 21/09/2004 Version 4.1.0.9 Previously failed to put index in correct filegroup
-- WMR 08/11/2005 Version 5.0.0.0 Added support for parallel and fill factors.
-- AP  01/08/2006 Version 5.5.0.5 Add Version Number as constant to out messages
--                                Add call to wswrkerror for each index as drop/built
--                                Separated out check of existence for drop
--                                Corrected setting of task and job in call to wrkaudit
-- AP  26/05/2009 Version 6.0.4.1 Add Include columns
-- AP  10/06/2009 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/09/2009 Version 6.0.5.1 Tightened checking for existing index.
-- AP  30/10/2009 Version 6.0.5.2 RED-1329 New options on index create.
-- AP  31/03/2010 Version 6.1.0.1 RED-1493 Order added to index to do clustered FIRST
-- AP  23/11/2010 Version 6.3.0.1 RED-1954 Include Filter/Where
-- AP  09/03/2011 Version 6.5.4.1 RED_2000:Include DATA_COMPRESSION setting
-- AP  18/07/2011 Version 6.5.4.1 RED_1990:Include Include column handling
-- AP  20/02/2012 Version 6.5.6.1 RED_2575:Handle Columnstore indexes
-- AP  28/03/2014 Version 6.7.4.1 RED_3570:Handle CLUSTERED Columnstore Indexes
-- MXU 31/10/2013 Version 6.7.4.1 RED_3264:Index create failure in scheduler causes failure in subsequent task index drop
-- HM  19/08/2014 Version 6.8.1.2 RED_3906:Added Schema support
-- DLC 24/10/2014 Version 6.8.1.2 Increased the buffer size for the column buffer
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  07/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  20/02/2017 Version 6.8.7.1 RED-7796 Search for index to drop in correct database
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Build_All
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name               :  SQL Server
  -- Script Name             :  Ws_Act_Build_All
  -- Description             :  Build all indexes associated with an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Build_All(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_count           integer
  , @v_columns         varchar(4000) -- RED-4053 increase buffer size
  , @v_col_number      integer
  , @v_index_key       integer
  , @v_day             integer
  , @v_day_name        varchar(3)
  , @v_month_end       integer
  , @v_month           integer
  , @v_tommorrow_month integer
  , @v_part_count      integer
  , @v_table_name      varchar(64)
  , @v_row             integer
  , @v_index_name      varchar(64)
  , @v_index_exist     integer       -- counter for index existence
  , @v_pos             integer
  , @v_sortintemp      integer
  , @v_build_options   nvarchar(4000)
  , @v_size            integer
  , @v_spos            integer
  , @v_columnstore     integer
  , @v_with            integer

  --=====================================================
  -- Cursor Variables
  --=====================================================
  DECLARE
    @v_ih_unique          varchar(1)
  , @v_ih_key_type        varchar(1)
  , @v_ih_index_key       integer
  , @v_ih_tablespace      varchar(64)
  , @v_ih_table           varchar(64)
  , @v_ih_index_name      varchar(64)
  , @v_ih_pre_drop_flag   varchar(1)
  , @v_ih_rebuild_freq    varchar(12)
  , @v_ih_clustered_ind   varchar(1)
  , @v_ih_parallel        integer
  , @v_ih_pct_free        integer
  , @v_ic_column          varchar(64)
  , @v_ic_foreign_table   varchar(64)
  , @v_ic_foreign_column  varchar(64)
  , @v_ih_index_options   varchar(4000)
  , @v_ih_where           varchar(4000)
  , @v_table_database     varchar(64)
  , @v_table_schema       varchar(64)
  , @v_table_with_owner   varchar(256)

  SET @v_step = 100

  BEGIN TRY

  SET @v_index_name = ''
  SET @p_return_msg = ''
  SET @p_result = 1
  SET @v_count = 0
  SET @v_columns = ''

  -- needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
           , @v_table_name = oo_name
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_name

  --=====================================================
  -- Loop through all the indexes
  --=====================================================
  --=====================================================
  -- Cursor for all indexes
  --=====================================================
  DECLARE c_Index CURSOR LOCAL FAST_FORWARD READ_ONLY FOR --RED_3264
    SELECT
    ih_unique
  , ih_key_type
  , ih_table
  , ih_index_key
  , ih_tablespace
  , ih_index_name
  , ih_pre_drop_flag
  , ih_rebuild_freq
  , ih_clustered_ind
  , ih_parallel
  , ih_pct_free
  , ih_index_options
  , ih_where
  FROM
    ws_index_header
  WHERE ih_obj_key = @p_obj_key
  AND   ih_active = 'Y'
  ORDER BY ISNULL( ih_clustered_ind,'N') DESC  -- RED_1493

  OPEN c_Index
  FETCH NEXT FROM c_Index INTO
    @v_ih_unique
  , @v_ih_key_type
  , @v_ih_table
  , @v_ih_index_key
  , @v_ih_tablespace
  , @v_ih_index_name
  , @v_ih_pre_drop_flag
  , @v_ih_rebuild_freq
  , @v_ih_clustered_ind
  , @v_ih_parallel
  , @v_ih_pct_free
  , @v_ih_index_options
  , @v_ih_where

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 200

    SET @v_index_name = @v_ih_index_name

    SET @v_step = 300
    -- RED-2575 - determine if columnstore
    SET @v_columnstore = 0
    SELECT @v_columnstore = ISNULL(PATINDEX('%columnstore=TR%',@v_ih_index_options),0)

    SET @v_step = 400
    -- RED-1329 - determine if sort in temp requested
    SET @v_sortintemp = 0
    SELECT @v_sortintemp = ISNULL(PATINDEX('%sortintemp=TR%',@v_ih_index_options),0)

    SET @v_step = 500
    SET @v_build_options = ''
    -- RED-1329 - determine additional build options
    IF NULLIF(@v_ih_index_options,'') is NOT NULL
    BEGIN
      SELECT @v_pos = PATINDEX('%buildopts=%',@v_ih_index_options)
      IF ISNULL(@v_pos,0) >= 1
      BEGIN
        SET @v_step = 600
        SELECT @v_size = CONVERT(integer,SUBSTRING(@v_ih_index_options,@v_pos+10,4))
        IF @v_size > 0
        BEGIN
          SET @v_step = 700
          SELECT @v_build_options = LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_pos+15,@v_size)))
        END
      END
    END

    -- RED_2000 - include option for DATA_COMPRESSION
    SET @v_step = 800

    IF NULLIF(@v_ih_index_options,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_ih_index_options)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 900
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_ih_index_options,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           SET @v_step = 1000

           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 1100
             IF NULLIF(@v_build_options,'') IS NOT NULL
             BEGIN
                SET @v_build_options = @v_build_options + ', '
             END

             SET @v_step = 1200

             SET @v_build_options = @v_build_options
                                  + 'DATA_COMPRESSION='
                                  + LTRIM(RTRIM(SUBSTRING(@v_ih_index_options,@v_spos+16,@v_size-1)))
           END
        END
      END
    END

    --=====================================================
    -- First drop the index in case that step was not run
    -- Execute the drop
    --=====================================================
    SET @v_step = 1300
    SET @v_index_exist = 0

    -- Azure SQL Database does not support 'DROP INDEX IF EXITS' so we have to do this
    SET @v_stmt = @v_table_database
    IF NULLIF(@v_stmt,'') IS NOT NULL
    BEGIN
        SET @v_stmt = @v_stmt + '.'
    END
    SET @v_stmt =
        'SELECT @v_index_exist = COUNT(*) FROM ' + @v_stmt + 'sys.indexes' +
        ' WHERE name = ''' + @v_ih_index_name + '''' +
        ' AND object_id = OBJECT_ID(''' + @v_table_with_owner + ''')'
        ;

    -- While it looks like output param isn't needed here (just checking ROWCOUNT should be fine) this is not the case.
    -- Accessing ROWCOUNT after EXECing the above statement when database IS SET fails catastrophically.  You CAN do it
    -- interactively in Management Studio, it works fine there, but in a stored procedure it causes a silent crash.
    -- Sometimes it returns correct value and then crashes on the next step, other times it crashes on ROWCOUNT access.
    -- Tested on 2016 and 2012.
    EXECUTE sp_executesql @v_stmt, N'@v_index_exist integer OUTPUT', @v_index_exist = @v_index_exist OUTPUT

    IF @v_index_exist > 0
    BEGIN
      IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
      BEGIN
        SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
      END
      ELSE
      BEGIN
        SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
      END

      SET @v_step = 1400
      EXEC ( @v_stmt )
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        --=====================================================
        -- Put detail message
        --=====================================================
        SET @v_step = 1500

        SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name  + ' dropped'

        EXEC WsWrkError
          @p_status_code = 'I'
        , @p_job_name    = @p_job_name
        , @p_task_name   = @p_task_name
        , @p_sequence    = @p_sequence
        , @p_message     = @v_msgtext
        , @p_db_code     = NULL
        , @p_db_msg      = NULL
        , @p_task_key    = @p_task_id
        , @p_job_key     = @p_job_id
        , @p_msg_type    = NULL
      END --@v_return_status <> 0
    END --index existed

    --=====================================================
    -- Create the rebuild command
    --=====================================================
    SET @v_step = 1600
    IF  @v_ih_unique = 'Y'
    AND @v_ih_key_type = 'A'
    BEGIN
      SET @v_stmt = 'Alter Table '
      SET @v_stmt = @v_stmt + @v_table_with_owner + ' Add Constraint '
      SET @v_stmt = @v_stmt + @v_ih_index_name + ' Primary Key '
      IF @v_ih_clustered_ind = 'Y'
      BEGIN
         SET @v_stmt = @v_stmt + 'Clustered '
      END
      ELSE
      BEGIN
         SET @v_stmt = @v_stmt + 'NonClustered '
      END
      --RED_3570 SET @v_stmt = @v_stmt + '('
    END
    ELSE
    BEGIN
      SET @v_stmt = 'Create '
      IF @v_ih_unique = 'Y'
      BEGIN
         SET @v_stmt = @v_stmt + 'Unique '
      END

      IF @v_columnstore > 0
      BEGIN
        IF @v_ih_clustered_ind = 'Y'--RED_3570
        BEGIN
           SET @v_stmt = @v_stmt + 'Clustered '
        END
        SET @v_stmt = @v_stmt + 'Columnstore '
      END
      ELSE
      BEGIN
        IF @v_ih_clustered_ind = 'Y'
        BEGIN
           SET @v_stmt = @v_stmt + 'Clustered '
        END
        ELSE
        BEGIN
           SET @v_stmt = @v_stmt + 'NonClustered '
        END
      END
      SET @v_stmt = @v_stmt + 'Index ' + @v_ih_index_name + ' ON '

      SET @v_stmt = @v_stmt + @v_table_with_owner
    END

    -- Now add in all the columns
    SET @v_index_key = @v_ih_index_key
    SET @v_columns = ''
    SET @v_col_number = 0

    SET @v_step = 1700

    --=====================================================
    -- Cursor for index columns
    --=====================================================
    DECLARE c_IndCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR --RED_3264
      SELECT
        ic_column
      , ic_foreign_table
      , ic_foreign_column
      FROM
        ws_index_col
      WHERE ic_index_key = @v_index_key
      AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'N'
      ORDER BY ic_column_no

    OPEN c_IndCol
    FETCH NEXT FROM c_IndCol INTO
      @v_ic_column
    , @v_ic_foreign_table
    , @v_ic_foreign_column

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_step = 1800

      SET @v_col_number = @v_col_number + 1
      IF @v_col_number > 1
      BEGIN
        SET @v_columns = @v_columns + ','
      END
      SET @v_columns = @v_columns + @v_ic_column

      FETCH NEXT FROM c_IndCol INTO
        @v_ic_column
      , @v_ic_foreign_table
      , @v_ic_foreign_column

    END

    CLOSE c_IndCol
    DEALLOCATE c_IndCol

--RED_3570  SET @v_stmt = @v_stmt + @v_columns + ')'
    IF @v_col_number > 0
    BEGIN
      SET @v_stmt = @v_stmt + '(' + @v_columns + ')'
    END

    --=====================================================
    -- Cursor for index include columns
    --=====================================================
    SET @v_step = 1900

    DECLARE c_IndInclCol CURSOR LOCAL FAST_FORWARD READ_ONLY FOR --RED_3264
      SELECT
        ic_column
      FROM
        ws_index_col
      WHERE ic_index_key = @v_index_key
      AND COALESCE(NULLIF(RTRIM(LTRIM(ic_include_flag)),''),'N') = 'Y'
      ORDER BY ic_column_no

    SET @v_col_number = 0
    SET @v_columns = ' INCLUDE ('

    OPEN c_IndInclCol
    FETCH NEXT FROM c_IndInclCol INTO
      @v_ic_column

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_step = 2000

      SET @v_col_number = @v_col_number + 1

      IF @v_col_number > 1
      BEGIN
        SET @v_columns = @v_columns + ','
      END

      SET @v_columns = @v_columns + @v_ic_column

      FETCH NEXT FROM c_IndInclCol INTO
        @v_ic_column

    END

    CLOSE c_IndInclCol
    DEALLOCATE c_IndInclCol

    IF @v_col_number > 0
    BEGIN
      SET @v_stmt = @v_stmt + @v_columns + ') '
    END

    -- RED_1954 include Filter/Where
    SET @v_step = 2100
    IF @v_ih_clustered_ind = 'Y'
       SET @v_ih_where = ''

    IF NULLIF(@v_ih_where,'') IS NOT NULL
    BEGIN
      SELECT @v_pos = PATINDEX('where%',lower(@v_ih_where))
      IF ISNULL(@v_pos,0) <> 1
      BEGIN
        SET @v_ih_where = 'WHERE (' + @v_ih_where + ')'
      END

      SET @v_stmt = @v_stmt + ' ' + @v_ih_where + ' '
    END

      IF @v_columnstore > 0
      BEGIN
    SET  @v_with =0
    IF NULLIF(@v_build_options,'') IS NOT NULL
    BEGIN
      SET  @v_stmt = @v_stmt + ' WITH ( ' + @v_build_options
      SET  @v_with =1
    END


    IF @v_ih_parallel > 0
    BEGIN
      IF @v_with > 0
        SET  @v_stmt = @v_stmt + ' ,'
      ELSE
        SET  @v_stmt = @v_stmt + ' WITH ( '

      SET  @v_stmt = @v_stmt + ' MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
      SET  @v_with =1
    END

    IF @v_with > 0
      SET  @v_stmt = @v_stmt + ') '
      END
      ELSE
      BEGIN

    SET @v_stmt = @v_stmt + ' WITH ('

    IF @v_sortintemp = 0
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = OFF '
    ELSE
      SET  @v_stmt = @v_stmt + ' SORT_IN_TEMPDB = ON '

    IF NULLIF(@v_build_options,'') IS NOT NULL
      SET  @v_stmt = @v_stmt + ', ' + @v_build_options

    IF @v_ih_parallel > 0
    BEGIN
      SET  @v_stmt = @v_stmt + ', MAXDOP = ' + CONVERT(varchar,ISNULL(@v_ih_parallel,0))
    END

    IF @v_ih_pct_free >0
    BEGIN
      SET  @v_stmt = @v_stmt + ', FILLFACTOR = ' + CONVERT(varchar,ISNULL(@v_ih_pct_free,0))
    END
    SET @v_stmt = @v_stmt + ' ) '

    END

    IF @v_ih_tablespace <> ''
    BEGIN
      SET @v_stmt = @v_stmt + ' ON '
      SET @v_stmt = @v_stmt + @v_ih_tablespace
    END
    --=====================================================
    -- Rebuild the index
    --=====================================================
    SET @v_step = 2200

    EXEC ( @v_stmt )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      --=====================================================
      -- Put detail message
      --=====================================================
      SET @v_step = 2300

      SET @v_count = @v_count + 1

      SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name  + ' rebuilt'

      EXEC WsWrkError
        @p_status_code = 'I'
      , @p_job_name    = @p_job_name
      , @p_task_name   = @p_task_name
      , @p_sequence    = @p_sequence
      , @p_message     = @v_msgtext
      , @p_db_code     = NULL
      , @p_db_msg      = NULL
      , @p_task_key    = @p_task_id
      , @p_job_key     = @p_job_id
      , @p_msg_type    = NULL
    END

    FETCH NEXT FROM c_Index INTO
      @v_ih_unique
    , @v_ih_key_type
    , @v_ih_table
    , @v_ih_index_key
    , @v_ih_tablespace
    , @v_ih_index_name
    , @v_ih_pre_drop_flag
    , @v_ih_rebuild_freq
    , @v_ih_clustered_ind
    , @v_ih_parallel
    , @v_ih_pct_free
    , @v_ih_index_options
    , @v_ih_where

  END -- End of Index cursor

  CLOSE c_Index
  DEALLOCATE c_Index

  SET @v_step = 2400
  -- tell them how many indexes we rebuilt
  IF @v_count <= 0
  BEGIN
    SET @p_return_msg = 'No indexes rebuilt'
  END
  IF @v_count = 1
  BEGIN
    SET @p_return_msg = '1 index rebuilt'
  END
  IF @v_count > 1
  BEGIN
    SET @p_return_msg = CONVERT(varchar,ISNULL(@v_count,0)) + ' indexes rebuilt'
  END
  SET @p_status_code = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_IndInclCol') >= -1 -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_IndInclCol                      -- RED_3264
    END                                            -- RED_3264
    IF CURSOR_STATUS('local','c_IndCol') >= -1     -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_IndCol                          -- RED_3264
    END                                            -- RED_3264
    IF CURSOR_STATUS('local','c_Index') >= -1      -- RED_3264
    BEGIN                                          -- RED_3264
      DEALLOCATE c_Index                           -- RED_3264
    END                                            -- RED_3264
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Create 
-- Notes / History
--
-- WMR 22/01/2002     Version 1.0.0.0
-- WMR 10/02/2005     Version 4.1.1.3  Add support for User Views
-- WMR 26/03/2006     Version 5.6.0.0  Add support for Retrofit copies
-- AP  31/01/2008     Version 5.6.3.1  Added parameter substitution for view creates
--                                     Added version to messages
-- AP  04/03/2008     Version 5.6.3.1  Alter tables to vardecimal if required in attributes
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
-- AP  24/09/2008     Version 6.0.1.1  Added default column values
-- AP  31/12/2008     Version 6.0.2.3  Added support for View
-- AP  15/04/2009     Version 6.0.4.1  No longer default to add quotes to default
-- AP  10/06/2009     Version 6.0.4.1  Changes to workflow locking.and 2005+ TRY
-- AP  09/03/2011     Version 6.5.4.1  RED_2000:Include DATA_COMPRESSION setting
-- HM  07/07/2014     Version 6.8.1.1  Added Override DDL
-- HM  19/08/2014     Version 6.8.1.2  Added Schema support
-- AP  16/10/2014     Version 6.8.1.2  Support DISTINCT on views.
-- RS  11/08/2015     Version 6.8.4.2  Added support for transformations in dimension views and views, removed deprecated sql server 2000 support
-- RS  17/08/2015     Version 6.8.4.2  Fixed issue when user specifies a FROM-clause in views
-- AP  23/07/2015     Version 6.8.4.3  RED-5279 Azure Support
-- BC  14/08/2015     Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- DLC 21/01/2016     Version 6.8.5.2  \r characters added to \n characters to make \r\n pairs
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- RS  03/10/2016     Version 6.8.6.2  Added support for multiple statements in DDL override
-- RS  02/11/2016     Version 6.8.6.3  RED-7375: Fixed issue with user defined views
-- HM  07/02/2017     Version 6.8.7.1  RED-7757 Added multi-database support (3-part naming)
-- HM  13/02/2017     Version 6.8.7.1  RED-7776 Added missing $DATABASE$ replace.
-- HM  13/02/2017     Version 6.8.7.1  RED-5782 Fixed issue with string concatenation where one of the variables was set to null
-- DLC 17/02/2017     Version 6.8.7.1  RED-7790 Using 3 part naming where applicable
-- TA  14/03/2017     Version 6.8.7.1  RED-7799 Fixed creation of views with source tables in targets
-- BC  18/04/2017     Version 6.8.8.0  RED-8093 Fixed creation of views in targets with local source tables
-- HM  15/10/2018     Version 8.3.1.0  RED-9774 Remove encryption.
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Create
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    :  SQLServer
  -- Script Name  :  ws_act_create
  -- Description  :  Create a Table or View
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Create(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_max               = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext              varchar(1024) -- Text in audit_trail
  , @v_step                 integer       -- step
  , @v_stmt                 nvarchar(4000)
  , @v_row_count            integer
  , @v_db_code              varchar(10)   -- Database error code
  , @v_db_msg               varchar(1024) -- Database error message
  , @v_create               varchar(8000)
  , @v_as                   varchar(4000)
  , @v_row                  integer
  , @v_user_view            integer
  , @v_spos                 integer
  , @v_table_created        integer      -- flag for table created OK
  , @v_size                 integer
  , @v_filegroup            varchar(64)
  , @v_text1                varchar(4000)
  , @v_text2                varchar(4000)
  , @v_text3                varchar(4000)
  , @v_text4                varchar(4000)
  , @v_text5                varchar(4000)
  , @v_ddl_override         varchar(max)
  , @v_table_database       varchar(64)
  , @v_table_schema         varchar(64)
  , @v_table_with_owner     varchar(256)
  , @v_src_table_database   varchar(64)
  , @v_src_table_schema     varchar(64)
  , @v_src_table_with_owner varchar(256)
  , @v_start_location       integer
  , @v_end_location         integer
  , @v_statement            varchar(max)
  , @v_delimiter            varchar(4000)

  --=====================================================
  -- Variables for Tables and cursors
  --=====================================================
  DECLARE
    @v_load_lt_table_name   varchar(64)
  , @v_load_lt_tablespace   varchar(64)
  , @v_dim_dt_table_name    varchar(64)
  , @v_dim_dt_tablespace    varchar(64)
  , @v_dim_dt_view_where    varchar(2048)
  , @v_dim_dt_gen_spec      varchar(4000)
  , @v_dim_dt_attributes    varchar(4000)
  , @v_dim_dt_where         varchar(4000)
  , @v_dim_dt_post_fix      varchar(4000)
  , @v_dim_dt_type          varchar(1)
  , @v_fact_ft_table_name   varchar(64)
  , @v_fact_ft_tablespace   varchar(64)
  , @v_retro_rt_table_name  varchar(64)
  , @v_retro_rt_tablespace  varchar(64)
  , @v_stage_st_table_name  varchar(64)
  , @v_stage_st_tablespace  varchar(64)
  , @v_agg_at_table_name    varchar(64)
  , @v_agg_at_tablespace    varchar(64)
  , @v_ods_ot_table_name    varchar(64)
  , @v_ods_ot_tablespace    varchar(64)
  , @v_normal_nt_table_name varchar(64)
  , @v_normal_nt_tablespace varchar(64)
  , @v_lc_col_name          varchar(64)
  , @v_lc_data_type         varchar(64)
  , @v_lc_nulls_flag        varchar(1)
  , @v_dc_col_name          varchar(64)
  , @v_dc_data_type         varchar(64)
  , @v_dc_nulls_flag        varchar(1)
  , @v_dc_src_table         varchar(64)
  , @v_dc_src_column        varchar(64)
  , @v_fc_col_name          varchar(64)
  , @v_fc_data_type         varchar(64)
  , @v_fc_nulls_flag        varchar(1)
  , @v_sc_col_name          varchar(64)
  , @v_sc_data_type         varchar(64)
  , @v_sc_nulls_flag        varchar(1)
  , @v_rc_col_name          varchar(64)
  , @v_rc_data_type         varchar(64)
  , @v_rc_nulls_flag        varchar(1)
  , @v_ac_col_name          varchar(64)
  , @v_ac_data_type         varchar(64)
  , @v_ac_nulls_flag        varchar(1)
  , @v_oc_col_name          varchar(64)
  , @v_oc_data_type         varchar(64)
  , @v_oc_nulls_flag        varchar(1)
  , @v_nc_col_name          varchar(64)
  , @v_nc_data_type         varchar(64)
  , @v_nc_nulls_flag        varchar(1)
  , @v_table_name           varchar(64)
  , @v_attributes           varchar(4000)
  , @v_default_value        varchar(64)
  , @v_transform_code       varchar(4000)
  , @v_numeric_flag         varchar(1)

  --=====================================================
  -- MAIN
  --=====================================================
  SET @v_step = 100

  BEGIN TRY

  SELECT @v_spos = 0
       , @v_table_name = ''
       , @v_attributes = ''
       , @v_table_created = 0
       , @v_start_location = 1

  -- needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))

  --=====================================================
  -- DDL Override
  --=====================================================
  SELECT @v_text1 = COALESCE(ta_text_1, '')
       , @v_text2 = COALESCE(ta_text_2, '')
       , @v_text3 = COALESCE(ta_text_3, '')
       , @v_text4 = COALESCE(ta_text_4, '')
       , @v_text5 = COALESCE(ta_text_5, '')
  FROM ws_table_attributes
  WHERE ta_obj_key = @p_obj_key
    AND ta_type = 'D'

  IF LTRIM(@v_text1) <> ''
  BEGIN
    SET @v_step = 200

    IF @p_obj_type = @v_ws_obj_load
      SELECT @v_table_name = lt_table_name, @v_filegroup = lt_tablespace FROM ws_load_tab WHERE lt_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_stage
      SELECT @v_table_name = st_table_name, @v_filegroup = st_tablespace FROM ws_stage_tab WHERE st_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_ods
      SELECT @v_table_name = ot_table_name, @v_filegroup = ot_tablespace FROM ws_ods_tab WHERE ot_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_normal
    OR @p_obj_type = @v_ws_obj_hub
    OR @p_obj_type = @v_ws_obj_satellite
    OR @p_obj_type = @v_ws_obj_link
    OR @p_obj_type = @v_ws_obj_custom1
    OR @p_obj_type = @v_ws_obj_custom2
      SELECT @v_table_name = nt_table_name, @v_filegroup = nt_tablespace FROM ws_normal_tab WHERE nt_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_dim
      SELECT @v_table_name = dt_table_name, @v_filegroup = dt_tablespace FROM ws_dim_tab WHERE dt_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_fact
      SELECT @v_table_name = ft_table_name, @v_filegroup = ft_tablespace FROM ws_fact_tab WHERE ft_obj_key = @p_obj_key
    ELSE
    IF @p_obj_type = @v_ws_obj_agg
      SELECT @v_table_name = at_table_name, @v_filegroup = at_tablespace FROM ws_agg_tab WHERE at_obj_key = @p_obj_key
    ELSE
      SET @v_table_name = ''

    SET @v_table_name = LTRIM(RTRIM(@v_table_name))

    SET @v_step = 300

    SET @v_ddl_override = @v_text1 + @v_text2 + @v_text3 + @v_text4 + @v_text5
    SET @v_ddl_override = REPLACE(@v_ddl_override, '$TABLE$', @v_table_name)
    SET @v_ddl_override = REPLACE(@v_ddl_override, '$INDEX$', @v_table_name)

    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_name

    SET @v_ddl_override = REPLACE(@v_ddl_override, '$FILEGROUP$', @v_filegroup)
    SET @v_ddl_override = REPLACE(@v_ddl_override, '$DATABASE$', @v_table_database)
    SET @v_ddl_override = REPLACE(@v_ddl_override, '$SCHEMA$', @v_table_schema)
    SET @v_ddl_override = REPLACE(@v_ddl_override, '$OBJECT$', @v_table_with_owner)
    SELECT @v_ddl_override = dbo.WsParameterReplace(@v_ddl_override, 32000)

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET @v_end_location = COALESCE(LEN(@v_ddl_override),0)

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT @v_delimiter = CASE WHEN COALESCE(CAST(ta_text_3 AS VARCHAR(MAX)), '<EOS>') <> ''
                               THEN ta_text_3 ELSE '<EOS>'
                          END FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

    -- Loop through the override statement and execute each statement individually
    WHILE @v_end_location > 0
    BEGIN
       SET @v_end_location = CHARINDEX(@v_delimiter, @v_ddl_override, @v_start_location)

       SELECT @v_statement = CASE
              WHEN @v_end_location > 0
              THEN SUBSTRING(@v_ddl_override,@v_start_location,@v_end_location - @v_start_location)
              WHEN @v_start_location <= LEN(@v_ddl_override)
              THEN SUBSTRING(@v_ddl_override,@v_start_location, LEN(@v_ddl_override))
             END

        IF @v_statement IS NOT NULL
        BEGIN
            EXEC (@v_statement)
            SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_start_location = @v_end_location + LEN(@v_delimiter)
    END

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created (using DDL Override) ' + @v_table_name
      SET @v_table_created = 1
    END

    RETURN 0
  END

  --=====================================================
  -- Handle all the table types
  --=====================================================
  --=====================================================
  -- L O A D
  --=====================================================
  IF @p_obj_type = @v_ws_obj_load
  BEGIN
    SELECT
      @v_load_lt_table_name = lt_table_name
    , @v_load_lt_tablespace = lt_tablespace
    , @v_attributes = lt_attributes
    FROM ws_load_tab
    WHERE lt_obj_key = @p_obj_key

    --=====================================================
    -- Build the create string
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_load_lt_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    SET @v_step = 400
    SET @v_row = 0

    DECLARE c_Load CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        lc_col_name
      , lc_data_type
      , lc_nulls_flag
      , lc_numeric_flag
      , COALESCE(lc_default_value,'')
      FROM
        ws_load_col
      WHERE lc_obj_key = @p_obj_key
      ORDER BY lc_order

    OPEN c_Load
    FETCH NEXT FROM c_Load INTO
      @v_lc_col_name
    , @v_lc_data_type
    , @v_lc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 500

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_lc_col_name + ' ' + @v_lc_data_type
      IF @v_lc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL'
      END

      IF @v_default_value <> ''
      BEGIN
 --       IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
 --       ELSE
 --         SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

    FETCH NEXT FROM c_Load INTO
        @v_lc_col_name
      , @v_lc_data_type
      , @v_lc_nulls_flag
      , @v_numeric_flag
      , @v_default_value
    END
    CLOSE c_Load
    DEALLOCATE c_Load

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_load_lt_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_load_lt_tablespace
    END

    SET @v_step = 600

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SET @v_step = 700
      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 800
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           SET @v_step = 900

           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 1000
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 1100

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_load_lt_table_name
      SET @v_table_name = @v_load_lt_table_name
      SET @v_table_created = 1
    END

  END

  --=====================================================
  -- D I M E N S I O N
  --=====================================================
  IF @p_obj_type = @v_ws_obj_dim
  BEGIN
    SET @v_step = 1200

    SELECT
      @v_dim_dt_table_name = dt_table_name
    , @v_dim_dt_tablespace = dt_tablespace
    , @v_attributes = dt_attributes
    FROM ws_dim_tab
    WHERE dt_obj_key = @p_obj_key

    --=====================================================
    -- D I M E N S I O N    T A B L E  create
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_dim_dt_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    set @v_row = 0
    SET @v_step = 1300

    DECLARE c_Dim CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        dc_col_name
      , dc_data_type
      , dc_nulls_flag
      , dc_numeric_flag
      , COALESCE(dc_default_value,'')
      FROM
        ws_dim_col
      WHERE dc_obj_key = @p_obj_key
      ORDER BY dc_order

    OPEN c_Dim
    FETCH NEXT FROM c_Dim INTO
      @v_dc_col_name
    , @v_dc_data_type
    , @v_dc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 1400

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_dc_col_name + ' ' + @v_dc_data_type
      IF @v_dc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL '
      END

      IF @v_default_value <> ''
      BEGIN
 --       IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
 --       ELSE
 --         SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Dim INTO
        @v_dc_col_name
      , @v_dc_data_type
      , @v_dc_nulls_flag
      , @v_numeric_flag
      , @v_default_value
    END
    CLOSE c_Dim
    DEALLOCATE c_Dim

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_dim_dt_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_dim_dt_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SET @v_step = 1500

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 1600
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           SET @v_step = 1700

           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 1800
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 1900

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_dim_dt_table_name
      SET @v_table_name = @v_dim_dt_table_name
      SET @v_table_created = 1
    END
  END
  --=====================================================
  -- D I M E N S I O N     V I E W
  --=====================================================
  IF @p_obj_type = @v_ws_obj_dim_view
  BEGIN
    SET @v_step = 2000

    SELECT
      @v_dim_dt_table_name = COALESCE(dt_table_name,'')
    , @v_dim_dt_tablespace = COALESCE(dt_tablespace,'')
    , @v_dim_dt_view_where = COALESCE(dt_view_where,'')
    , @v_dim_dt_gen_spec = COALESCE(dt_gen_spec,'')
    , @v_dim_dt_where = COALESCE(dt_where,'')
    , @v_dim_dt_attributes = COALESCE(dt_attributes,'')
    , @v_dim_dt_post_fix = COALESCE(dt_post_fix,'')
    , @v_dim_dt_type = COALESCE(dt_type_ind,'')
    FROM ws_dim_tab
    WHERE dt_obj_key = @p_obj_key

    --=====================================================
    -- D I M E N S I O N    V I E W
    --=====================================================
    SELECT @v_user_view = 0

    IF @v_dim_dt_type = 'U'
    BEGIN
      IF UPPER(SUBSTRING(@v_dim_dt_gen_spec,1,6)) = 'CREATE'
      BEGIN
        SELECT @v_user_view = 1
      END
    END

    -- CREATE VIEW doesn't accept 3-part naming, so we have to use only the schema and execute the statement on the correct database.
    IF @v_table_schema <> ''
    BEGIN
        SET @v_table_with_owner = @v_table_schema + '.'
    END
    ELSE
    BEGIN
        SET @v_table_with_owner = ''
    END

    SET @v_table_with_owner = @v_table_with_owner + '[' + @v_dim_dt_table_name + ']'

    IF @v_user_view = 1
    BEGIN
      SELECT @v_create = @v_dim_dt_gen_spec + @v_dim_dt_where + @v_dim_dt_attributes +
                         @v_dim_dt_post_fix + @v_dim_dt_view_where
    END -- End of user view create
    ELSE
    BEGIN -- normal view create
      SET @v_as = ''
      SET @v_create = 'Create view '
      SET @v_create = @v_create + @v_table_with_owner
      SET @v_create = @v_create + CHAR(13) + CHAR(10) + '('
      -- Loop through all the columns adding them to the create
      --
      set @v_row = 0
      SET @v_step = 2100

      DECLARE c_Dim CURSOR FAST_FORWARD READ_ONLY FOR
        SELECT
          dc_col_name
        , dc_src_table
        , dc_src_column
        , dc_numeric_flag
        , COALESCE(dc_default_value,'')
        , COALESCE(RTRIM(LTRIM(CAST(dc_transform_code AS varchar(MAX)))),'')
        FROM
          ws_dim_col
        WHERE dc_obj_key = @p_obj_key
        ORDER BY dc_order

      OPEN c_Dim
      FETCH NEXT FROM c_Dim INTO
        @v_dc_col_name
      , @v_dc_src_table
      , @v_dc_src_column
      , @v_numeric_flag
      , @v_default_value
      , @v_transform_code

      WHILE @@FETCH_STATUS = 0
      BEGIN
        SET @v_step = 2200

        SET @v_row = @v_row + 1
        IF @v_row > 1
        BEGIN
          SET @v_create = @v_create + ',' + CHAR(13) + CHAR(10)
          SET @v_as = @v_as + ',' + CHAR(13) + CHAR(10)
        END
        SET @v_create = @v_create + @v_dc_col_name
        IF @v_transform_code <> ''
        BEGIN
           SET @v_as = @v_as + @v_transform_code
        END
        ELSE IF @v_dc_src_table <> ''
        BEGIN
          SET @v_as = @v_as + @v_dc_src_table + '.' + @v_dc_src_column
        END
        ELSE
        BEGIN
          SET @v_as = @v_as + @v_dc_src_column
        END


        FETCH NEXT FROM c_Dim INTO
          @v_dc_col_name
        , @v_dc_src_table
        , @v_dc_src_column
        , @v_numeric_flag
        , @v_default_value
        , @v_transform_code
      END
      CLOSE c_Dim
      DEALLOCATE c_Dim

      IF @v_dim_dt_type = 'U'
      BEGIN -- User view select
         SET @v_create = @v_create + ') As' + CHAR(13) + CHAR(10)
         SET @v_create = @v_create + @v_dim_dt_gen_spec + @v_dim_dt_where + @v_dim_dt_attributes +
                         @v_dim_dt_post_fix + @v_dim_dt_view_where
         SET @v_row = 0
      END
      ELSE
      BEGIN -- normal view select

        SET @v_spos = 0
        IF NULLIF(@v_dim_dt_attributes,'') IS NOT NULL
        BEGIN
          SET @v_step = 2250
          SELECT @v_spos = PATINDEX('%DISTINCT~;%',UPPER(@v_dim_dt_attributes))
        END

        IF ISNULL(@v_spos,0) >= 1
        BEGIN
          SET @v_create = @v_create + ') As' + CHAR(13) + CHAR(10) + 'Select DISTINCT ' + @v_as + ' '
        END
        ELSE
        BEGIN
          SET @v_create = @v_create + ') As' + CHAR(13) + CHAR(10) + 'Select ' + @v_as + ' '
        END

        SET @v_row = 0
        SET @v_step = 2300


        -- Loop through all the tables adding them to the create
        --

        -- Check the user specified a from clause
        IF LEFT(UPPER(LTRIM(@v_dim_dt_view_where)),4) <> 'FROM'
        BEGIN
            SET @v_create = @v_create + CHAR(13) + CHAR(10) + 'From '

            DECLARE c_Tables CURSOR FAST_FORWARD READ_ONLY FOR
              SELECT
                distinct dc_src_table
              FROM
                ws_dim_col
              WHERE dc_obj_key = @p_obj_key
              AND   dc_src_table <> ''

            OPEN c_Tables
            FETCH NEXT FROM c_Tables INTO
              @v_dc_src_table

            WHILE @@FETCH_STATUS = 0
            BEGIN
              SET @v_step = 2400

              SET @v_row = @v_row + 1
              IF @v_row > 1
              BEGIN
                SET @v_create = @v_create + ',' + CHAR(13) + CHAR(10)
              END

              -- needs to look up the database and schema from ws_dbc_target
              SET @v_src_table_database = ''
              SET @v_src_table_schema = ''
              SELECT     @v_src_table_database = CASE WHEN dt_target_key IS NOT NULL THEN COALESCE(dt_database, '') ELSE db_name() END
                       , @v_src_table_schema = COALESCE(dt_schema, '')
              FROM       ws_obj_object
              LEFT JOIN  ws_dbc_target
              ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
              WHERE      UPPER(ws_obj_object.oo_name) = UPPER(@v_dc_src_table)

              SET @v_src_table_database = LTRIM(RTRIM(@v_src_table_database))
              SET @v_src_table_schema = LTRIM(RTRIM(@v_src_table_schema))

              -- Create the fully qualified table name
              SET @v_src_table_with_owner = @v_src_table_database
              IF NULLIF(@v_src_table_with_owner,'') IS NOT NULL
              BEGIN
                SET @v_src_table_with_owner = @v_src_table_with_owner + '.'
              END
              SET @v_src_table_with_owner = @v_src_table_with_owner + @v_src_table_schema
              IF NULLIF(@v_src_table_with_owner,'') IS NOT NULL
              BEGIN
                SET @v_src_table_with_owner = @v_src_table_with_owner + '.'
              END
              SET @v_src_table_with_owner = @v_src_table_with_owner + @v_dc_src_table

              SET @v_create = @v_create + @v_src_table_with_owner + CHAR(13) + CHAR(10)

              FETCH NEXT FROM c_Tables INTO
              @v_dc_src_table
            END
            CLOSE c_Tables
            DEALLOCATE c_Tables
        END

        IF @v_dim_dt_view_where <> ''
        BEGIN
          SET @v_create = @v_create +' ' + @v_dim_dt_view_where
        END
      END -- End of normal view select
    END -- End of normal view create

    --=====================================================
    -- Replace any $P parameters
    --=====================================================

    SET @v_step = 2500

    SELECT @v_create = dbo.WsParameterReplace(@v_create, 4000)

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 2700

    -- Create the fully qualified table name
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_name
    -- RED-7375: Note views use the variable v_dim_dt_table_name (should be changed in a refactoring Jira)
    SET @v_table_with_owner = @v_table_with_owner + '[' + @v_dim_dt_table_name + ']'

    -- Replace special place holders
    SET @v_create = REPLACE(@v_create, '$DATABASE$', @v_table_database)
    SET @v_create = REPLACE(@v_create, '$SCHEMA$', @v_table_schema)
    SET @v_create = REPLACE(@v_create, '$OBJECT$', @v_table_with_owner)

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET @v_end_location = COALESCE(LEN(@v_create),0)

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT @v_delimiter = CASE WHEN COALESCE(CAST(ta_text_3 AS VARCHAR(MAX)), '<EOS>') <> ''
                               THEN ta_text_3 ELSE '<EOS>'
                          END FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

    -- Loop through the override statement and execute each statement individually
    WHILE @v_end_location > 0
    BEGIN
       SET @v_end_location = CHARINDEX(@v_delimiter, @v_create, @v_start_location)

       SELECT @v_statement = CASE
              WHEN @v_end_location > 0
              THEN SUBSTRING(@v_create,@v_start_location,@v_end_location - @v_start_location)
              WHEN @v_start_location <= LEN(@v_create)
              THEN SUBSTRING(@v_create,@v_start_location, LEN(@v_create))
             END

        IF @v_statement IS NOT NULL
        BEGIN
            -- CREATE VIEW can't include the database name in the view name and must be the first statement in the batch,
            -- so using sp_executesql on the correct database is the only option.
            IF @v_table_database <> ''
            BEGIN
                SET @v_statement = REPLACE(@v_statement, '''', '''''')
                EXEC ('EXEC [' + @v_table_database + ']..sp_executesql N''' + @v_statement + '''')
            END
            ELSE
                EXEC (@v_statement)
            SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_start_location = @v_end_location + LEN(@v_delimiter)
    END

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'View created ' + @v_dim_dt_table_name
      RETURN 0
    END

  END

  --=====================================================
  -- V I E W
  --=====================================================
  IF @p_obj_type = @v_ws_obj_view
  BEGIN
    SET @v_step = 2800

    SELECT
      @v_dim_dt_table_name = COALESCE(vt_table_name,'')
    , @v_dim_dt_tablespace = COALESCE(vt_tablespace,'')
    , @v_dim_dt_view_where = COALESCE(vt_view_where,'')
    , @v_dim_dt_gen_spec = COALESCE(vt_gen_spec,'')
    , @v_dim_dt_where = COALESCE(vt_where,'')
    , @v_dim_dt_attributes = COALESCE(vt_attributes,'')
    , @v_dim_dt_post_fix = COALESCE(vt_post_fix,'')
    , @v_dim_dt_type = COALESCE(vt_type_ind,'')
    FROM ws_view_tab
    WHERE vt_obj_key = @p_obj_key

    --=====================================================
    -- D I M E N S I O N    V I E W
    --=====================================================
    SELECT @v_user_view = 0

    IF @v_dim_dt_type = 'U'
    BEGIN

      SET @v_spos = PATINDEX('%~ENDGEN~;%',COALESCE(@v_dim_dt_gen_spec,''))
      IF @v_spos <> 0
      BEGIN
        IF LEN(@v_dim_dt_gen_spec) > @v_spos+10
        BEGIN
          SET @v_dim_dt_gen_spec = SUBSTRING(@v_dim_dt_gen_spec,@v_spos+9,LEN(@v_dim_dt_gen_spec)-(@v_spos+8))
        END
        ELSE
        BEGIN
          SET @v_dim_dt_gen_spec = ''
        END
      END

      SET @v_spos = PATINDEX('%~ENDWHERE~;%',COALESCE(@v_dim_dt_where,''))
      IF @v_spos <> 0
      BEGIN
        IF LEN(COALESCE(@v_dim_dt_where,'')) > @v_spos+12
        BEGIN
          SET @v_dim_dt_where = SUBSTRING(COALESCE(@v_dim_dt_where,''),@v_spos+11,LEN(@v_dim_dt_where)-(@v_spos+10))
        END
        ELSE
        BEGIN
          SET @v_dim_dt_where = ''
        END
      END

      IF UPPER(SUBSTRING(@v_dim_dt_gen_spec,1,6)) = 'CREATE'
      BEGIN
        SELECT @v_user_view = 1
      END
    END

    -- CREATE VIEW doesn't accept 3-part naming, so we have to use only the schema and execute the statement on the correct database.
    IF @v_table_schema <> ''
    BEGIN
        SET @v_table_with_owner = @v_table_schema + '.'
    END
    ELSE
    BEGIN
        SET @v_table_with_owner = ''
    END

    SET @v_table_with_owner = @v_table_with_owner + '[' + @v_dim_dt_table_name + ']'

    IF @v_user_view = 1
    BEGIN
      SELECT @v_create = @v_dim_dt_gen_spec + @v_dim_dt_where + @v_dim_dt_attributes +
                         @v_dim_dt_post_fix + @v_dim_dt_view_where
    END -- End of user view create
    ELSE
    BEGIN -- normal view create
      SET @v_as = ''
      SET @v_create = 'Create view '
      SET @v_create = @v_create + @v_table_with_owner
      SET @v_create = @v_create + CHAR(13) + CHAR(10) + '('
      -- Loop through all the columns adding them to the create
      --
      set @v_row = 0
      SET @v_step = 2900

      DECLARE c_Dim CURSOR FAST_FORWARD READ_ONLY FOR
        SELECT
          vc_col_name
        , vc_src_table
        , vc_src_column
        , vc_numeric_flag
        , COALESCE(vc_default_value,'')
        , COALESCE(RTRIM(LTRIM(CAST(vc_transform_code AS varchar(MAX)))),'')
        FROM
          ws_view_col
        WHERE vc_obj_key = @p_obj_key
        ORDER BY vc_order

      OPEN c_Dim
      FETCH NEXT FROM c_Dim INTO
        @v_dc_col_name
      , @v_dc_src_table
      , @v_dc_src_column
      , @v_numeric_flag
      , @v_default_value
      , @v_transform_code

      WHILE @@FETCH_STATUS = 0
      BEGIN
        SET @v_step = 3000

        SET @v_row = @v_row + 1
        IF @v_row > 1
        BEGIN
          SET @v_create = @v_create + ',' + CHAR(13) + CHAR(10)
          SET @v_as = @v_as + ',' + CHAR(13) + CHAR(10)
        END
        SET @v_create = @v_create + @v_dc_col_name
        IF @v_transform_code <> ''
        BEGIN
           SET @v_as = @v_as + @v_transform_code
        END
        ELSE IF @v_dc_src_table <> ''
        BEGIN
          SET @v_as = @v_as + @v_dc_src_table + '.' + @v_dc_src_column
        END
        ELSE
        BEGIN
          SET @v_as = @v_as + @v_dc_src_column
        END

        FETCH NEXT FROM c_Dim INTO
          @v_dc_col_name
        , @v_dc_src_table
        , @v_dc_src_column
        , @v_numeric_flag
        , @v_default_value
        , @v_transform_code
      END
      CLOSE c_Dim
      DEALLOCATE c_Dim

      IF @v_dim_dt_type = 'U'
      BEGIN -- User view select
         SET @v_create = @v_create + ')' + CHAR(13) + CHAR(10) + 'As '
         SET @v_create = @v_create + @v_dim_dt_gen_spec + @v_dim_dt_where + @v_dim_dt_attributes +
                         @v_dim_dt_post_fix + @v_dim_dt_view_where
         SET @v_row = 0
      END
      ELSE
      BEGIN -- normal view select

        SET @v_spos = 0
        IF NULLIF(@v_dim_dt_attributes,'') IS NOT NULL
        BEGIN
          SET @v_step = 2250
          SELECT @v_spos = PATINDEX('%DISTINCT~;%',UPPER(@v_dim_dt_attributes))
        END

        IF ISNULL(@v_spos,0) >= 1
        BEGIN
          SET @v_create = @v_create + ')' + CHAR(13) + CHAR(10) + 'As Select DISTINCT ' + @v_as + ' '
        END
        ELSE
        BEGIN
          SET @v_create = @v_create + ')' + CHAR(13) + CHAR(10) + 'As Select ' + @v_as + ' '
        END

        SET @v_row = 0

        -- Loop through all the tables adding them to the create
        --

        SET @v_step = 3100

        -- Check the user specified a from clause
        IF LEFT(UPPER(LTRIM(@v_dim_dt_view_where)),4) <> 'FROM'
        BEGIN
            SET @v_create = @v_create + CHAR(13) + CHAR(10) + 'From '

            DECLARE c_Tables CURSOR FAST_FORWARD READ_ONLY FOR
              SELECT
                distinct vc_src_table
              FROM
                ws_view_col
              WHERE vc_obj_key = @p_obj_key
              AND   vc_src_table <> ''

            OPEN c_Tables
            FETCH NEXT FROM c_Tables INTO
              @v_dc_src_table

            WHILE @@FETCH_STATUS = 0
            BEGIN
              SET @v_step = 3200

              SET @v_row = @v_row + 1
              IF @v_row > 1
              BEGIN
                SET @v_create = @v_create + ',' + CHAR(13) + CHAR(10)
              END

              -- needs to look up the database and schema from ws_dbc_target
              SET @v_src_table_database = ''
              SET @v_src_table_schema = ''
              SELECT     @v_src_table_database = CASE WHEN dt_target_key IS NOT NULL THEN COALESCE(dt_database, '') ELSE db_name() END
                       , @v_src_table_schema = COALESCE(dt_schema, '')
              FROM       ws_obj_object
              LEFT JOIN  ws_dbc_target
              ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
              WHERE      UPPER(ws_obj_object.oo_name) = UPPER(@v_dc_src_table)

              SET @v_src_table_database = LTRIM(RTRIM(@v_src_table_database))
              SET @v_src_table_schema = LTRIM(RTRIM(@v_src_table_schema))

              -- Create the fully qualified table name
              SET @v_src_table_with_owner = @v_src_table_database
              IF NULLIF(@v_src_table_with_owner,'') IS NOT NULL
              BEGIN
                SET @v_src_table_with_owner = @v_src_table_with_owner + '.'
              END
              SET @v_src_table_with_owner = @v_src_table_with_owner + @v_src_table_schema
              IF NULLIF(@v_src_table_with_owner,'') IS NOT NULL
              BEGIN
                SET @v_src_table_with_owner = @v_src_table_with_owner + '.'
              END
              SET @v_src_table_with_owner = @v_src_table_with_owner + @v_dc_src_table

              SET @v_create = @v_create + @v_src_table_with_owner + CHAR(13) + CHAR(10)

              FETCH NEXT FROM c_Tables INTO
              @v_dc_src_table
            END
            CLOSE c_Tables
            DEALLOCATE c_Tables
        END

        IF @v_dim_dt_view_where <> ''
        BEGIN
          SET @v_create = @v_create +' ' + @v_dim_dt_view_where
        END
      END -- End of normal view select
    END -- End of normal view create

    --=====================================================
    -- Replace any $P parameters
    --=====================================================

    SET @v_step = 3300

    SELECT @v_create = dbo.WsParameterReplace(@v_create, 4000)

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 3400

    -- Create the fully qualified table name
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END
    SET @v_table_with_owner = @v_table_with_owner + @v_table_name
    -- RED-7375: Note views use the variable v_dim_dt_table_name (should be changed in a refactoring Jira)
    SET @v_table_with_owner = @v_table_with_owner + '[' + @v_dim_dt_table_name + ']'

    -- Replace special place holders
    SET @v_create = REPLACE(@v_create, '$DATABASE$', @v_table_database)
    SET @v_create = REPLACE(@v_create, '$SCHEMA$', @v_table_schema)
    SET @v_create = REPLACE(@v_create, '$OBJECT$', @v_table_with_owner)

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET @v_end_location = COALESCE(LEN(@v_create),0)

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT @v_delimiter = CASE WHEN COALESCE(CAST(ta_text_3 AS VARCHAR(MAX)), '<EOS>') <> ''
                               THEN ta_text_3 ELSE '<EOS>'
                          END FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

    -- Loop through the override statement and execute each statement individually
    WHILE @v_end_location > 0
    BEGIN
       SET @v_end_location = CHARINDEX(@v_delimiter, @v_create, @v_start_location)

       SELECT @v_statement = CASE
              WHEN @v_end_location > 0
              THEN SUBSTRING(@v_create,@v_start_location,@v_end_location - @v_start_location)
              WHEN @v_start_location <= LEN(@v_create)
              THEN SUBSTRING(@v_create,@v_start_location, LEN(@v_create))
             END

        IF @v_statement IS NOT NULL
        BEGIN
            -- CREATE VIEW can't include the database name in the view name and must be the first statement in the batch,
            -- so using sp_executesql on the correct database is the only option.
            IF @v_table_database <> ''
            BEGIN
                SET @v_statement = REPLACE(@v_statement, '''', '''''')
                EXEC ('EXEC [' + @v_table_database + ']..sp_executesql N''' + @v_statement + '''')
            END
            ELSE
                EXEC (@v_statement)
            SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_start_location = @v_end_location + LEN(@v_delimiter)
    END

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'View created ' + @v_dim_dt_table_name
      RETURN 0
    END
  END

  --=====================================================
  -- F A C T
  --=====================================================
  IF @p_obj_type = @v_ws_obj_fact
  OR @p_obj_type = @v_ws_obj_fact_kpi
  BEGIN
    SET @v_step = 3500

    SELECT
      @v_fact_ft_table_name = ft_table_name
    , @v_fact_ft_tablespace = ft_tablespace
    , @v_attributes = ft_attributes
    FROM ws_fact_tab
    WHERE ft_obj_key = @p_obj_key

    --=====================================================
    -- Build the create string
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_fact_ft_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    SET @v_step = 3600
    SET @v_row = 0

    DECLARE c_Fact CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        fc_col_name
      , fc_data_type
      , fc_nulls_flag
      , fc_numeric_flag
      , COALESCE(fc_default_value,'')
      FROM
        ws_fact_col
      WHERE fc_obj_key = @p_obj_key
      ORDER BY fc_order

    OPEN c_Fact
    FETCH NEXT FROM c_Fact INTO
      @v_fc_col_name
    , @v_fc_data_type
    , @v_fc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 3700

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_fc_col_name + ' ' + @v_fc_data_type
      IF @v_fc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL'
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
           SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--       ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Fact INTO
        @v_fc_col_name
      , @v_fc_data_type
      , @v_fc_nulls_flag
      , @v_numeric_flag
      , @v_default_value
    END
    CLOSE c_Fact
    DEALLOCATE c_Fact

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_fact_ft_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_fact_ft_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 3800
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 3900
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 4000

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_fact_ft_table_name
      SET @v_table_name = @v_fact_ft_table_name
      SET @v_table_created = 1
    END

  END


  --=====================================================
  -- R E T R O      C O P Y
  --=====================================================
  IF @p_obj_type = @v_ws_obj_retro_copy
  BEGIN
    SET @v_step = 4100

    SELECT
      @v_retro_rt_table_name = rt_table_name
    , @v_retro_rt_tablespace = rt_tablespace
    , @v_attributes = rt_attributes
    FROM ws_retro_tab
    WHERE rt_obj_key = @p_obj_key

    --=====================================================
    -- Build the create string
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_retro_rt_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    SET @v_row = 0

    DECLARE c_Retro CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        rc_col_name
      , rc_data_type
      , rc_nulls_flag
      , rc_numeric_flag
      , COALESCE(rc_default_value,'')
      FROM
        ws_retro_col
      WHERE rc_obj_key = @p_obj_key
      ORDER BY rc_order

    OPEN c_Retro
    FETCH NEXT FROM c_Retro INTO
      @v_rc_col_name
    , @v_rc_data_type
    , @v_rc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 4200

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_rc_col_name + ' ' + @v_rc_data_type
      IF @v_rc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL'
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--        ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Retro INTO
        @v_rc_col_name
      , @v_rc_data_type
      , @v_rc_nulls_flag
      , @v_numeric_flag
      , @v_default_value

    END
    CLOSE c_Retro
    DEALLOCATE c_Retro

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_retro_rt_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_retro_rt_tablespace
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 4300

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_retro_rt_table_name
      SET @v_table_name = @v_retro_rt_table_name
      SET @v_table_created = 1
    END

  END

  --=====================================================
  -- S T A G E
  --=====================================================
  IF @p_obj_type = @v_ws_obj_stage
  BEGIN
    SET @v_step = 4400

    SELECT
      @v_stage_st_table_name = st_table_name
    , @v_stage_st_tablespace = st_tablespace
    , @v_attributes = st_attributes
    FROM ws_stage_tab
    WHERE st_obj_key = @p_obj_key

    --=====================================================
    -- Build the create string
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_stage_st_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    SET @v_step = 4500
    SET @v_row = 0

    DECLARE c_Stage CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        sc_col_name
      , sc_data_type
      , sc_nulls_flag
      , sc_numeric_flag
      , COALESCE(sc_default_value,'')
      FROM
        ws_stage_col
      WHERE sc_obj_key = @p_obj_key
      ORDER BY sc_order

    OPEN c_Stage
    FETCH NEXT FROM c_Stage INTO
      @v_sc_col_name
    , @v_sc_data_type
    , @v_sc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 4600

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_sc_col_name + ' ' + @v_sc_data_type
      IF @v_sc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL'
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--        ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Stage INTO
        @v_sc_col_name
      , @v_sc_data_type
      , @v_sc_nulls_flag
      , @v_numeric_flag
      , @v_default_value

    END
    CLOSE c_Stage
    DEALLOCATE c_Stage

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_stage_st_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_stage_st_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 4700
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 4800
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 4900

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_stage_st_table_name
      SET @v_table_name = @v_stage_st_table_name
      SET @v_table_created = 1
    END

  END

  --=====================================================
  -- A G G R E G A T E
  --=====================================================
  IF @p_obj_type = @v_ws_obj_agg
  BEGIN
    SET @v_step = 5000

    SELECT
      @v_agg_at_table_name = at_table_name
    , @v_agg_at_tablespace = at_tablespace
    , @v_attributes = at_attributes
    FROM ws_agg_tab
    WHERE at_obj_key = @p_obj_key

    --=====================================================
    -- Build the create string
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_agg_at_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --

    SET @v_step = 5100
    SET @v_row = 0

    DECLARE c_Agg CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        ac_col_name
      , ac_data_type
      , ac_nulls_flag
      , ac_numeric_flag
      , COALESCE(ac_default_value,'')
      FROM
        ws_agg_col
      WHERE ac_obj_key = @p_obj_key
      ORDER BY ac_order

    OPEN c_Agg
    FETCH NEXT FROM c_Agg INTO
      @v_ac_col_name
    , @v_ac_data_type
    , @v_ac_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 5200

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_ac_col_name + ' ' + @v_ac_data_type
      IF @v_sc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL'
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--        ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Agg INTO
        @v_ac_col_name
      , @v_ac_data_type
      , @v_ac_nulls_flag
      , @v_numeric_flag
      , @v_default_value

    END
    CLOSE c_Agg
    DEALLOCATE c_Agg

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_agg_at_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_agg_at_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 5300
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 5400
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 5500

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_agg_at_table_name
      SET @v_table_name = @v_agg_at_table_name
      SET @v_table_created = 1
    END

  END

  --=====================================================
  -- O D S
  --=====================================================
  IF @p_obj_type = @v_ws_obj_ods
  BEGIN
    SET @v_step = 5600

    SELECT
      @v_ods_ot_table_name = ot_table_name
    , @v_ods_ot_tablespace = ot_tablespace
    , @v_attributes = ot_attributes
    FROM ws_ods_tab
    WHERE ot_obj_key = @p_obj_key

    --=====================================================
    -- O D S    T A B L E  create
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_ods_ot_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    set @v_row = 0
    SET @v_step = 5700

    DECLARE c_Ods CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        oc_col_name
      , oc_data_type
      , oc_nulls_flag
      , oc_numeric_flag
      , COALESCE(oc_default_value,'')
      FROM
        ws_ods_col
      WHERE oc_obj_key = @p_obj_key
      ORDER BY oc_order

    OPEN c_Ods
    FETCH NEXT FROM c_Ods INTO
      @v_oc_col_name
    , @v_oc_data_type
    , @v_oc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 5800

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_oc_col_name + ' ' + @v_oc_data_type
      IF @v_oc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL '
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--        ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Ods INTO
        @v_oc_col_name
      , @v_oc_data_type
      , @v_oc_nulls_flag
      , @v_numeric_flag
      , @v_default_value

    END
    CLOSE c_Ods
    DEALLOCATE c_Ods

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_ods_ot_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_ods_ot_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 5900
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 6000
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 6100

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_ods_ot_table_name
      SET @v_table_name = @v_ods_ot_table_name
      SET @v_table_created = 1
    END
  END

  --=====================================================
  -- N O R M A L AND Hub/Satellite/Link and Custom1/Custom2
  --=====================================================
  IF @p_obj_type = @v_ws_obj_normal
    OR @p_obj_type = @v_ws_obj_hub
    OR @p_obj_type = @v_ws_obj_satellite
    OR @p_obj_type = @v_ws_obj_link
    OR @p_obj_type = @v_ws_obj_custom1
    OR @p_obj_type = @v_ws_obj_custom2
  BEGIN
    SET @v_step = 6200

    SELECT
      @v_normal_nt_table_name = nt_table_name
    , @v_normal_nt_tablespace = nt_tablespace
    , @v_attributes = nt_attributes
    FROM ws_normal_tab
    WHERE nt_obj_key = @p_obj_key

    --=====================================================
    -- N O R M A L AND Hub/Satellite/Link and Custom1/Custom2  T A B L E  create
    --=====================================================
    SET @v_create = 'CREATE TABLE '

    IF @v_table_database <> ''
    BEGIN
        -- it's ok if this ends up being "database..table"
        SET @v_create = @v_create + @v_table_database + '.' + @v_table_schema + '.'
    END
    ELSE IF @v_table_schema <> ''
    BEGIN
        SET @v_create = @v_create + @v_table_schema + '.'
    END

    SET @v_create = @v_create + '[' + @v_normal_nt_table_name + '] ('

    -- Loop through all the columns adding them to the create
    --
    set @v_row = 0
    SET @v_step = 6300

    DECLARE c_Normal CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        nc_col_name
      , nc_data_type
      , nc_nulls_flag
      , nc_numeric_flag
      , COALESCE(nc_default_value,'')
      FROM
        ws_normal_col
      WHERE nc_obj_key = @p_obj_key
      ORDER BY nc_order

    OPEN c_Normal
    FETCH NEXT FROM c_Normal INTO
      @v_nc_col_name
    , @v_nc_data_type
    , @v_nc_nulls_flag
    , @v_numeric_flag
    , @v_default_value

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 6400

      SET @v_row = @v_row + 1
      IF @v_row > 1
      BEGIN
        SET @v_create = @v_create + ','
      END
      SET @v_create = @v_create + @v_nc_col_name + ' ' + @v_nc_data_type
      IF @v_nc_nulls_flag = 'N'
      BEGIN
        SET @v_create = @v_create + ' NOT NULL '
      END

      IF @v_default_value <> ''
      BEGIN
--        IF @v_numeric_flag = 'Y'
          SET @v_create = @v_create + ' DEFAULT ' + @v_default_value
--        ELSE
--          SET @v_create = @v_create + ' DEFAULT ''' + @v_default_value + ''''
      END

      FETCH NEXT FROM c_Normal INTO
        @v_nc_col_name
      , @v_nc_data_type
      , @v_nc_nulls_flag
      , @v_numeric_flag
      , @v_default_value

    END
    CLOSE c_Normal
    DEALLOCATE c_Normal

    -- Add the rest of the create statement
    --
    SET @v_create = @v_create + ')'
    IF @v_normal_nt_tablespace <> ''
    BEGIN
      SET @v_create = @v_create + ' ON ' + @v_normal_nt_tablespace
    END

    -- RED_2000 - include option for DATA_COMPRESSION

    IF NULLIF(@v_attributes,'') IS NOT NULL
    BEGIN

      SELECT @v_spos = PATINDEX('%datacompression=%',@v_attributes)

      IF ISNULL(@v_spos,0) >= 1
      BEGIN
        SET @v_step = 6500
        SELECT @v_size = CHARINDEX(';',SUBSTRING(@v_attributes,@v_spos+16,1000))

        IF ISNULL(@v_size,0) >= 1
        BEGIN
           IF NULLIF(LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1))),'') IS NOT NULL
           BEGIN
             SET @v_step = 6600
             SET @v_create = @v_create
                           + ' WITH (DATA_COMPRESSION='
                           + LTRIM(RTRIM(SUBSTRING(@v_attributes,@v_spos+16,@v_size-1)))
                           + ') '
           END
        END
      END
    END

    --=====================================================
    -- Execute the create statement
    --=====================================================
    SET @v_step = 6700

    EXEC ( @v_create )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_result = 1
      SET @p_return_msg = 'Table created ' + @v_normal_nt_table_name
      SET @v_table_name = @v_normal_nt_table_name
      SET @v_table_created = 1
    END

  END

  --**********************************
  -- C U B E
  --**********************************
  IF @p_obj_type = @v_ws_obj_cube
  BEGIN
    -- run an Cube create by returning a result of 4
    SET @p_result = 4
    SET @p_status_code = 4
    RETURN 0
  END

  --**********************************
  -- C U B E   V I R T U A L
  --**********************************
  IF @p_obj_type = @v_ws_obj_cube_virtual
  BEGIN
    -- run an Cube create by returning a result of 4
    SET @p_result = 4
    SET @p_status_code = 4
    RETURN 0
  END

  --***************************************************
  -- If table created OK see if want to make vardecimal
  --***************************************************

  IF @v_table_created = 1
  BEGIN

    SET @v_spos = ISNULL(PATINDEX('%VARDECIMAL=TRUE%',UPPER(@v_attributes)),0)

    IF  @v_spos > 0
    BEGIN
      SET @v_create = 'exec sys.sp_tableoption '''
      SET @v_create = @v_create + @v_table_name
      SET @v_create = @v_create + ''', ''vardecimal storage format'', ''on'''
      --=====================================================
      -- Execute the create statement
      --=====================================================
      SET @v_step = 6800

      EXEC ( @v_create )
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        SET @p_return_msg = @p_return_msg + ' and altered vardecimal'
        RETURN 0
      END

    END

    RETURN 0
  END

  --=====================================================
  -- Unsupported object type
  --=====================================================
  SET @p_return_msg = 'Unsupported object type ' + CONVERT(varchar,ISNULL(@p_obj_type,-1)) +
    ' in create'
  SET @p_status_code = -2
  SET @p_result = -2

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------

      IF CURSOR_STATUS('local','c_Load') >= -1
      BEGIN
        DEALLOCATE c_Load
      END
      IF CURSOR_STATUS('local','c_Dim') >= -1
      BEGIN
        DEALLOCATE c_Dim
      END
      IF CURSOR_STATUS('local','c_Tables') >= -1
      BEGIN
        DEALLOCATE c_Tables
      END
      IF CURSOR_STATUS('local','c_Fact') >= -1
      BEGIN
        DEALLOCATE c_Fact
      END
      IF CURSOR_STATUS('local','c_Retro') >= -1
      BEGIN
        DEALLOCATE c_Retro
      END
      IF CURSOR_STATUS('local','c_Stage') >= -1
      BEGIN
        DEALLOCATE c_Stage
      END
      IF CURSOR_STATUS('local','c_Agg') >= -1
      BEGIN
        DEALLOCATE c_Agg
      END
      IF CURSOR_STATUS('local','c_Ods') >= -1
      BEGIN
        DEALLOCATE c_Ods
      END
      IF CURSOR_STATUS('local','c_Normal') >= -1
      BEGIN
        DEALLOCATE c_Normal
      END

      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs

      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

    -- Provide full message in return parameter

    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Dbms_Stats 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- WMR 05/04/2002 Version 1.0.7   Added for all indexed columns to analyze
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2014 Version 6.8.0.2 Schema support
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- KH  28/10/2015 Version 6.8.4.4 Statement increased to 4000
-- TA  01/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Dbms_Stats
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_percent         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQLServer
  -- Script Name 	:	ws_act_dbms_stats
  -- Description 	:	Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Dbms_Stats(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_table_database  varchar(64)
  , @v_table_schema    varchar(64)
  , @v_table_name      varchar(64)
  , @v_table_with_owner varchar(256)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_step = 100

  BEGIN TRY
  SET @p_result = 1

  --=====================================================
  -- Handle either an Index or a Table
  --=====================================================
  IF @p_obj_type = @v_ws_obj_index
  BEGIN
    -- needs to look up the schema from ws_dbc_target for the indexed tables schema
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
             , @v_table_name = oo_name
    FROM       ws_index_header
    LEFT JOIN  ws_obj_object
    ON         ws_obj_object.oo_obj_key = ws_index_header.ih_obj_key
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      UPPER(ih_index_name) = UPPER(@p_task_name)

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_with_owner = @v_table_with_owner + @v_table_name

    IF @p_percent = 100
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS '+ @v_table_with_owner + N' ' + @p_task_name + N' WITH FULLSCAN'
    END
    ELSE
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS '+ @v_table_with_owner + N' ' + @p_task_name + N' WITH SAMPLE ' +
                      convert(varchar,@p_percent) + ' PERCENT'
    END

    SET @p_return_msg = 'Index '+ @p_task_name+' analyzed'

    -- Execute the analyze
    SET @v_step = 200

    EXECUTE sp_executesql @v_stmt

    SET @v_step = 300

    SET @p_status_code = 1
    SET @p_result = 1

    RETURN 0
  END
  ELSE
  BEGIN
    --=====================================================
    -- Table
    --=====================================================

  -- needs to look up the schema from ws_dbc_target for the indexed tables schema
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
             , @v_table_name = oo_name
    FROM       ws_obj_object
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      UPPER(oo_name) = UPPER(@p_task_name)

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
      SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_with_owner = @v_table_with_owner + @v_table_name

    IF @p_percent = 100
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS ' + @v_table_with_owner  + N' WITH FULLSCAN'
    END
    ELSE
    BEGIN
      SET @v_stmt = N'UPDATE STATISTICS ' + @v_table_with_owner  + N' WITH SAMPLE ' +
                      convert(varchar,@p_percent) + ' PERCENT'
    END

    SET @p_return_msg = 'Table '+ @v_table_with_owner  +' analyzed '

    -- Execute the analyze
    SET @v_step = 400
    EXECUTE sp_executesql @v_stmt

    SET @v_step = 500

    SET @p_status_code = 1
    SET @p_result = 1

    RETURN 0

  END

  SET @p_status_code = -1
  SET @p_result = -1
  SET @p_return_msg = 'No action chosen'


  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Drop 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0.0
-- WMR 29/10/2002 Version 1.2.1.0 Sql Server port
-- AP  01/08/2006 Version 5.5.0.5 Add Version Number as constant to out messages
--                                Add call to wswrkerror for each index as drop/built
--                                Corrected setting of task job in call to wswrkaudit
-- AP  11/09/2007 Version 5.6.1.2 Change duplicate ws_obj_dim to ws_obj_agg
-- AP  09/04/2008 Version 6.0.0.0 Added support for ODS/Normal
-- AP  31/12/2008 Version 6.0.2.3 Added support for View
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/09/2000 Version 6.0.5.1 Version of script was not updated in prior update :-(
--                                so also fixed messages in line with other rprocs while at it
-- HM  19/08/2014 Version 6.8.1.2 Add Schema support
-- HM  05/03/2015 Version 6.8.2.2 Add missing '.' between table name and index
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  07/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  22/02/2017 Version 6.8.7.1 RED-7796 3 part naming cannot be used when dropping Views, Functions or Procedures
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Drop
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : SQL Server
  -- Script Name  : ws_act_drop
  -- Description  : Drop a table or Index
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Drop(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext            varchar(1024) -- Text in audit_trail
  , @v_step               integer       -- step
  , @v_stmt               nvarchar(4000)
  , @v_nodrop             integer
  , @v_row_count          integer
  , @v_db_code            varchar(10)   -- Database error code
  , @v_db_msg             varchar(1024) -- Database error message

  DECLARE
    @v_ih_unique          varchar(1)
  , @v_ih_key_type        varchar(1)
  , @v_ih_table           varchar(64)
  , @v_ih_index_name      varchar(64)
  , @v_table_name         varchar(64)
  , @v_table_database     varchar(64)
  , @v_table_schema       varchar(64)
  , @v_table_with_schema  varchar(256)
  , @v_table_with_owner   varchar(256)

  SET @v_step = 100
  BEGIN TRY
  SET @p_result = 1

  --=====================================================
  -- Handle either an Index, Table or View
  --=====================================================
  IF @p_obj_type = @v_ws_obj_index
  BEGIN
    SET @v_step = 200
    SELECT
      @v_ih_unique = ih_unique
    , @v_ih_key_type = ih_key_type
    , @v_ih_table = ih_table
    , @v_ih_index_name = ih_index_name
    FROM ws_index_header
    WHERE ih_index_key = @p_obj_key
    SELECT @v_row_count = @@ROWCOUNT
    SET @v_step = 300

    -- needs to look up the schema from ws_dbc_target for the indexed tables schema
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
    FROM       ws_obj_object
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      UPPER(ws_obj_object.oo_name) = UPPER(@v_ih_table)

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_with_owner = @v_table_database
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
        SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
    IF NULLIF(@v_table_with_owner,'') IS NOT NULL
    BEGIN
        SET @v_table_with_owner = @v_table_with_owner + '.'
    END

    SET @v_table_with_owner = @v_table_with_owner + COALESCE(@v_ih_table, '')

    SET @v_step = 400

    SET @v_nodrop = 0
    IF @v_row_count <> 0
    BEGIN
      SET @v_step = 500

      IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
      BEGIN
        SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
      END
      ELSE
      BEGIN
        SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
      END

      EXEC ( @v_stmt )
      SELECT @v_row_count = @@ROWCOUNT
    END
    ELSE
    BEGIN
      SET @v_nodrop = 1
    END

    IF @v_nodrop = 0
    BEGIN
      SET @p_status_code = 1
      SET @p_return_msg = 'Index '+ @v_table_with_owner + '.' + @v_ih_index_name + ' dropped'
      SET @v_msgtext = @p_return_msg

      --=====================================================
      -- Put detail message
      --=====================================================
      SET @v_step = 600

      EXEC WsWrkError
        @p_status_code = 'I'
      , @p_job_name    = @p_job_name
      , @p_task_name   = @p_task_name
      , @p_sequence    = @p_sequence
      , @p_message     = @v_msgtext
      , @p_db_code     = NULL
      , @p_db_msg      = NULL
      , @p_task_key    = @p_task_id
      , @p_job_key     = @p_job_id
      , @p_msg_type    = NULL
    END
    ELSE
    BEGIN
      SET @p_return_msg = 'Index ' + ISNULL(@v_ih_index_name,'none') + ' drop Failed'
      SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
           , @v_db_msg  = ERROR_MESSAGE()
      SET @v_step = 700

      EXEC WsWrkAudit
        @p_status_code = 'E'
      , @p_job_name    = @p_job_name
      , @p_task_name   = @p_task_name
      , @p_sequence    = @p_sequence
      , @p_message     = @p_return_msg
      , @p_db_code     = @v_db_code
      , @p_db_msg      = @v_db_msg
      , @p_task_key    = @p_task_id
      , @p_job_key     = @p_job_id
      SET @p_status_code = -1
      SET @p_result = -1
      RETURN 0
    END
  END
  ELSE
  BEGIN
      -- needs to look up the database and schema from ws_dbc_target
      SELECT     @v_table_database = COALESCE(dt_database, '')
               , @v_table_schema = COALESCE(dt_schema, '')
               , @v_table_name = COALESCE(oo_name, '')
      FROM       ws_obj_object
      LEFT JOIN  ws_dbc_target
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = @p_obj_key

      SET @v_table_database = LTRIM(RTRIM(@v_table_database))
      SET @v_table_with_owner = @v_table_database
      IF NULLIF(@v_table_with_owner,'') IS NOT NULL
      BEGIN
        SET @v_table_with_owner = @v_table_with_owner + '.'
      END

      SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
      SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
      IF NULLIF(@v_table_with_owner,'') IS NOT NULL
      BEGIN
        SET @v_table_with_owner = @v_table_with_owner + '.'
      END

      SET @v_table_with_owner = @v_table_with_owner + @v_table_name

      SET @v_table_with_schema = @v_table_schema
      IF NULLIF(@v_table_with_schema,'') IS NOT NULL
      BEGIN
        SET @v_table_with_schema = @v_table_with_schema + '.'
      END

      SET @v_table_with_schema = @v_table_with_schema + @v_table_name
  END

  --=====================================================
  -- View
  --=====================================================

  IF @p_obj_type = @v_ws_obj_dim_view
  OR @p_obj_type = @v_ws_obj_view
  BEGIN

    SET @v_stmt = 'DROP VIEW ' + @v_table_with_schema

    SET @v_step = 800
    IF NULLIF(@v_table_database,'') IS NOT NULL
    BEGIN
      -- 3 part naming cannot be used when dropping Views, Functions or Procedures
      EXEC ( 'USE ' + @v_table_database + '; ' + @v_stmt )
    END
    ELSE
    BEGIN
      EXEC ( @v_stmt )
    END
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_return_msg = 'View ' + @v_table_with_owner + ' dropped'
    END

  END

  --=====================================================
  -- Table
  --=====================================================
  IF @p_obj_type = @v_ws_obj_load
  OR @p_obj_type = @v_ws_obj_dim
  OR @p_obj_type = @v_ws_obj_stage
  OR @p_obj_type = @v_ws_obj_fact
  OR @p_obj_type = @v_ws_obj_fact_kpi
  OR @p_obj_type = @v_ws_obj_agg
  OR @p_obj_type = @v_ws_obj_retro_copy
  OR @p_obj_type = @v_ws_obj_ods
  OR @p_obj_type = @v_ws_obj_normal
  OR @p_obj_type = @v_ws_obj_hub
  OR @p_obj_type = @v_ws_obj_satellite
  OR @p_obj_type = @v_ws_obj_link
  OR @p_obj_type = @v_ws_obj_custom1
  OR @p_obj_type = @v_ws_obj_custom2

  BEGIN
    SET @v_stmt = 'drop table '
    SET @v_stmt = @v_stmt + @v_table_with_owner

    SET @v_step = 1000
    EXEC ( @v_stmt )
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @p_status_code = 1
      SET @p_return_msg = 'Table ' + @v_table_with_owner + ' dropped'
    END

  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Drop_All 
-- Notes / History
--
-- WMR 30/08/2001 Version 0.3.0.6 Added support for Primary Keys
-- WMR 21/01/2002 Version 1.0.0.0 Added support for Partitioned indexes
-- WMR 29/10/2002 Version 1.2.1.4 Converted to SQL Server
-- AP  01/08/2006 Version 5.5.0.5 Add Version Number as constant to out messages
--                                Add call to wswrkerror for each index as drop/built
--                                Corrected counts for when actually indexes dropped
--                                Separated out check of existence for drop
--                                Corrected setting of job task in call to wswrkaudit
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/09/2000 Version 6.0.5.1 Tightened checking for existing index.
-- AP  31/03/2010 Version 6.1.0.1 RED-1493 Order added to index to do clustered LAST
-- HM  19/08/2014 Version 6.8.1.2 RED-3906 Add Schema support
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  07/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  21/02/2017 Version 6.8.7.1 RED-7796 Search for index to drop in correct database
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Drop_All
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      : SQL Server
  -- Script Name    : ws_act_drop_all
  -- Description    : Drop all indexes associated with an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Drop_All(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext           varchar(1024) -- Text in audit_trail
  , @v_step              integer       -- step
  , @v_stmt              nvarchar(4000)
  , @v_row_count         integer
  , @v_db_code           varchar(10)   -- Database error code
  , @v_db_msg            varchar(1024) -- Database error message
  , @v_count             integer       -- counter
  , @v_index_exist       integer       -- counter for index existence
  , @v_table_name        varchar(64)
  , @v_table_database    varchar(64)
  , @v_table_schema      varchar(64)
  , @v_table_with_owner  varchar(256)

  DECLARE
    @v_ih_unique         varchar(1)
  , @v_ih_key_type       varchar(1)
  , @v_ih_table          varchar(64)
  , @v_ih_index_name     varchar(64)

  --=====================================================
  -- Cursor for all indexes
  --=====================================================
  DECLARE c_Index CURSOR FAST_FORWARD READ_ONLY FOR
    SELECT
      ih_unique
    , ih_key_type
    , ih_table
    , ih_index_name
    FROM
      ws_index_header
    WHERE ih_obj_key = @p_obj_key
    ORDER BY ISNULL( ih_clustered_ind,'N') ASC  -- RED_1493


  SET @v_count = 0
  SET @v_step = 100
  BEGIN TRY

  -- needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
           , @v_table_name = oo_name
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_name

  --=====================================================
  -- Loop through all the indexes to drop
  -- May not be any
  --=====================================================
  SET @p_status_code = 1
  SET @p_return_msg = ''
  SET @p_result = 1

  OPEN c_Index
  FETCH NEXT FROM c_Index INTO
    @v_ih_unique
  , @v_ih_key_type
  , @v_ih_table
  , @v_ih_index_name

  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @v_index_exist = 0

    -- Azure SQL Database does not support 'DROP INDEX IF EXITS' so we have to do this
    SET @v_stmt = @v_table_database
    IF NULLIF(@v_stmt,'') IS NOT NULL
    BEGIN
        SET @v_stmt = @v_stmt + '.'
    END
    SET @v_stmt =
        'SELECT @v_index_exist = COUNT(*) FROM ' + @v_stmt + 'sys.indexes' +
        ' WHERE name = ''' + @v_ih_index_name + '''' +
        ' AND object_id = OBJECT_ID(''' + @v_table_with_owner + ''')'
        ;

    -- While it looks like output param isn't needed here (just checking ROWCOUNT should be fine) this is not the case.
    -- Accessing ROWCOUNT after EXECing the above statement when database IS SET fails catastrophically.  You CAN do it
    -- interactively in Management Studio, it works fine there, but in a stored procedure it causes a silent crash.
    -- Sometimes it returns correct value and then crashes on the next step, other times it crashes on ROWCOUNT access.
    -- Tested on 2016 and 2012.
    EXECUTE sp_executesql @v_stmt, N'@v_index_exist integer OUTPUT', @v_index_exist = @v_index_exist OUTPUT

    IF @v_index_exist > 0
    BEGIN

      IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
      BEGIN
        SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
      END
      ELSE
      BEGIN
        SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
      END

      SET @v_step = 200
      EXEC ( @v_stmt )
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        SET @p_status_code = 1
        SET @v_count = @v_count + 1
        SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name + ' dropped.'

        --=====================================================
        -- Put detail message
        --=====================================================
        SET @v_step = 300

        EXEC WsWrkError
          @p_status_code = 'I'
        , @p_job_name    = @p_job_name
        , @p_task_name   = @p_task_name
        , @p_sequence    = @p_sequence
        , @p_message     = @v_msgtext
        , @p_db_code     = NULL
        , @p_db_msg      = NULL
        , @p_task_key    = @p_task_id
        , @p_job_key     = @p_job_id
        , @p_msg_type    = NULL
      END

    END -- Index exists

    FETCH NEXT FROM c_Index INTO
      @v_ih_unique
    , @v_ih_key_type
    , @v_ih_table
    , @v_ih_index_name
  END

  CLOSE c_Index
  DEALLOCATE c_Index


  SET @v_step = 400
  -- tell them how many indexes we dropped
  IF @v_count = 0
  BEGIN
    SET @p_return_msg = 'No indexes to drop' + @p_return_msg
  END
  IF @v_count = 1
  BEGIN
    SET @p_return_msg = '1 index dropped' + @p_return_msg
  END
  IF @v_count > 1
  BEGIN
    SET @p_return_msg = CONVERT(varchar,@v_count) + ' indexes dropped' + @p_return_msg
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Index') >= -1
    BEGIN
      DEALLOCATE c_Index
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Execute 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- AP  19/03/2009 Version 6.0.3.1 New trapping of sql dependency error (@@trancount)
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- BC  12/11/2018 Version 8.3.1.0 RED-9978 Execute procedure using fully-qualified name.
-- BC  30/11/2018 Version 8.3.1.0 RED-10077 Fix to work with Child jobs.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Execute
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : SQl Server
  -- Script Name  : ws_act_execute
  -- Description  : Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Execute(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 14
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_return_status   integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_row_count       integer
  , @v_procedure       varchar(256)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET @v_step = 90

  SELECT @v_procedure = CASE WHEN COALESCE(dt_database,'') <> '' THEN dt_database + '.' + COALESCE(dt_schema,'') + '.'
                             WHEN COALESCE(dt_schema,'') <> '' THEN dt_schema + '.' ELSE '' END + ph_name
  FROM   ws_pro_header
  JOIN   ws_obj_object ON ph_obj_key = oo_obj_key
  LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
  WHERE  UPPER(ph_name) = UPPER(@p_task_name)
  SELECT @v_row_count = @@ROWCOUNT

  IF @v_row_count = 0
  OR @v_procedure IS NULL
  BEGIN
    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to determine qualified procedure name for '  + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0
  END

  --=====================================================
  -- Execute the procedure
  --=====================================================
  SET @v_step = 100

  BEGIN TRY

  SET @p_result = 1

  -- Execute the procedure
--  BEGIN TRANSACTION
  EXEC @v_return_status = @v_procedure
        @p_sequence = @p_sequence
      , @p_job_name = @p_job_name
      , @p_task_name = @p_task_name
      , @p_job_id = @p_job_id
      , @p_task_id = @p_task_id
      , @p_return_msg = @p_return_msg OUTPUT
      , @p_status = @p_status_code OUTPUT
--  COMMIT

  -- Need to check for open transactions that can occur in SQLServer if procedure references
  -- and object that no longer exists
  -- Sql just bombs out, and cant gracefully trap in procedure!
  IF @@trancount <> 0
  BEGIN
    ROLLBACK
    SET @p_status_code = -3
    SET @p_return_msg = 'Failure in ' + @v_ws_pro_version + ' when calling procedure. View full audit trail for job'

    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Transactions left in open state by procedure'
    , @p_db_code     = NULL
    , @p_db_msg      = NULL
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id
  END

  SET @v_step = 200
  IF @v_return_status <> 0
  BEGIN
    SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
         , @v_db_msg  = ERROR_MESSAGE()
    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Failure when executing procedure'
    , @p_db_code     = @v_db_code
    , @p_db_msg      = @v_db_msg
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id

    SET @p_return_msg = 'Unhandled Exception in ' + @v_ws_pro_version + ' step ' +convert(varchar,@v_step)
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END

  SET @v_step = 300

  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sqlS
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Host_Script 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0.0
-- WMR 08/04/2002 Version 1.0.7.0 Added trailing nullcols to windows load
-- WMR 25/10/2002 Version 1.2.1.0 SQL Server version
-- WMR 13/02/2004 Version 4.1.0.1 added support for XML based file loads
-- WMR 22/05/2004 Version 4.1.0.8 Add support for wildcard file loads, fixed length
-- WMR 22/02/2005 Version 4.1.1.3 Fixed problem with fixed length loads returning -1
-- WMR 19/04/2005 Version 4.1.2.2 Changed dc_database_id length to 1024
-- WMR 13/03/2006 Version 5.0.1.4 Clean out script line and header file before insert in case a restart.
-- WMR 13/03/2006 Version 5.0.1.6 Moved the clean of the script files to the start of the procedure.
-- AP  16/08/2006 Version 5.5.0.5 Added DSS parameter substitution for load file path and name
--                                Added call to WsParameterReplace for param substitution of
--                                  script lines
-- JML 17/04/2007 Version 5.6.0.0 support for Export Objects Added.
-- AP  16/05/2007 Version 5.6.0.1 Added support for load options (lt_load_options)
-- JML 11/07/2007 Version 5.6.1.1 Added support for ASCII delimiters in exports
--                                 Now does ISNULL(x,'') to non-transformed fields in exports.
--                                 BCP Exports now use queryout to allow column selection.
--                                 Added support for where clause in exports.
--                                 Added support for isql/sqlcmd options in exports.
--                                 Error message including "Fast Export" removed.
-- AP  26/01/2009 Version 6.0.2.3 Changed export head lines to ensure don't exceed 256 char on task_scr_line
--                                Change to ensure header line always has 'AS export_data'
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  13/05/2010 Version 6.1.0.2 RED_1533 - Include task in fmt file definition so no clash at runtime
-- AP  10/06/2010 Version 6.1.1.1 RED_970 - Allow override of record delimiter for fixed width file loads.
-- AP  24/01/2012 Version 6.5.6.1 RED_2566 protect the files for if spaces in directory
-- RS  26/05/2014 Version 6.8.0.1 Changed to reflect new WS_DB_Connect column sizes
-- HM  19/08/2014 Version 6.8.1.2 Added Schema support
-- MX  16/10/2014 Version 6.8.1.2 RED_3574 remove RTRIM in the export code generation
-- MX  16/10/2014 Version 6.8.1.2 RED_4102 fix the issue with 2 double quotation marks for trigger control file
-- MX  16/10/2014 Version 6.8.1.2 RED_3574 remove RTRIM in the export code generation
-- AP  01/12/2015 Version 6.8.2.0 RED-4342 Correct append of \ to work directory when not required
-- RS  23/12/2014 Version 6.8.2.1 RED-4373 Removed plain user/password for file exports
-- RS  16/01/2015 Version 6.8.2.1 RED-4484 Added usage of variable SQLCMDPASSWORD for file exports
-- RS  23/02/2015 Version 6.8.2.1 RED-1508 Added usage of variables XXX_FILE do fix issue with too many characters in sqlcmd line
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  04/03/2016 Version 6.8.5.3 RED-6416 Add export object source schema look up
-- HM  18/03/2016 Version 6.8.5.4 RED-6199 Fix export when using single quotes to enclose record values.
-- HM  04/04/2016 Version 6.8.5.4 RED-6199 Add enclose-by character around 'nvarchar' and 'nchar' cols as well.
-- BC  29/08/2016 Version 6.8.6.2 RED-7032 Script based loads from Database/ODBC connections return host information for script connection
-- BC  18/01/2017 Version 6.8.7.1 RED-3545 Change the value for wtsh_load_type to indicate a Powershell script.
-- HM  07/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- DLC 13/02/2017 Version 6.8.7.1 RED-6454 Stopped BCP export overflowing the 256 character limit.
-- BC  27/03/2017 Version 6.8.7.1 RED-7778 Fix to set WSL_LOAD_SCHEMA only if not already set in execution environment.
-- TA  04/04/2017 Version 6.9.1.0 RED-8033 Stop using xp_cmdshell to create BULK INSERT format files
-- BC  07/04/2017 Version 6.8.8.0 RED-8076 Fix to set WSL_LOAD_SCHEMA in PowerShell syntax if executing a PowerShell script.
-- KH  05/05/2017 Version 6.9.1.0 RED-8168 Length of BULK INSERT statement, including FORMATFILE wouldn't fit in ws_wrk_task_scr_line, so now two lines.
-- KH  11/05/2017 Version 6.9.1.0 RED-8197 Length of sqlcmd statement, with large paths, wouldn't fit in ws_wrk_task_scr_line, so now two lines.
-- BC  24/08/2017 Version 8.0.1.0 RED-8611 Fix generation of BULK INSERT statement when load table not parsed.
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Host_Script
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ===============================================================================
  -- DBMS Name      : SQL Server
  -- Script Name    : ws_act_host_script
  -- Description    : Handles a host script, file or script based load
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- ===============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Host_Script(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext                  varchar(1024) -- Text in audit_trail
  , @v_step                     integer       -- step
  , @v_stmt                     nvarchar(4000)
  , @v_db_code                  varchar(10)   -- Database error code
  , @v_db_msg                   varchar(1024) -- Database error message
  , @v_create                   varchar(4000)
  , @v_count                    integer
  , @v_view                     integer
  , @v_row_count                integer
  , @v_source_con_type          varchar(1)
  , @v_connect_key              integer
  , @v_script_key               integer
  , @v_load_key                 integer
  , @v_script_type              varchar(1)
  , @v_load_type                varchar(1)
  , @v_host_type                varchar(1)
  , @v_line                     varchar(4000)
  , @v_line_no                  integer
  , @v_col_count                integer
  , @v_row                      integer
  , @v_col                      integer
  , @v_fix                      varchar(256)
  , @v_script                   varchar(512)
  , @v_audfile                  varchar(512)
  , @v_errfile                  varchar(512)
  , @v_logfile                  varchar(512)
  , @v_ctlfile                  varchar(512)
  , @v_trgfile                  varchar(512)
  , @v_lookfor                  varchar(512)
  , @v_work_dir                 varchar(256)
  , @v_file_path                varchar(1024)
  , @v_trig_path                varchar(1024)
  , @v_file_rename              varchar(256)
  , @v_trig_rename              varchar(256)
  , @v_file_repath              varchar(256)
  , @v_trig_repath              varchar(256)
  , @v_compress_path            varchar(1024)
  , @v_skip                     varchar(12)
  , @v_pos                      integer
  , @v_epos                     integer
  , @v_spos                     integer
  , @v_action                   varchar(10)
  , @v_rename                   varchar(512)
  , @v_command                  varchar(256)
  , @v_new_command              varchar(256)
  , @v_current_date             datetime
  , @v_work                     varchar(512)
  , @v_work2                    varchar(512)
  , @v_work3                    varchar(512)
  , @v_shell                    varchar(24)
  , @v_file_seq                 integer
  , @v_handled1                 integer
  , @v_handled2                 integer
  , @v_ws_script_execute        varchar(1)
  , @v_ws_load_script           varchar(1)
  , @v_ws_load_file             varchar(1)
  , @v_ws_load_xml              varchar(1)
  , @v_output                   varchar(4000)
  , @v_col_name                 varchar(64)
  , @v_width                    integer
  , @v_rec_delimiter            varchar(256)
  , @v_size                     integer
  , @v_parameter                nvarchar(4000)
  , @v_load_options             varchar(4000)
  , @v_table_database           varchar(64)
  , @v_table_schema             varchar(64)
  , @v_table_with_owner         varchar(256)
  , @v_script_row               integer
  , @v_min_script_row           integer

  --=====================================================
  -- Cursor and table Variables
  --=====================================================
  DECLARE
    @v_load_lt_type             varchar(1)
  , @v_load_lt_script_key       integer
  , @v_load_lt_connect_key      integer
  , @v_load_lt_file_header_line varchar(1)
  , @v_load_lt_file_parsed      varchar(1)
  , @v_load_lt_file_path        varchar(1024)
  , @v_load_lt_file_name        varchar(256)
  , @v_load_lt_file_delimiter   varchar(10)
  , @v_load_lt_table_name       varchar(64)
  , @v_load_lt_load_options     varchar(4000)
  , @v_script_sh_connect_key    integer
  , @v_script_sh_type           varchar(1)
  , @v_connect_dc_work_dir      varchar(256)
  , @v_connect_dc_type          varchar(1)
  , @v_connect_dc_admin_userid  varchar(1024)
  , @v_connect_dc_admin_pwd     varchar(1024)
  , @v_connect_dc_database_id   varchar(1024)
  , @v_lc_transform_code        varchar(4000)
  , @v_lc_src_column            varchar(64)
  , @v_lc_col_name              varchar(64)
  , @v_ec_source_table          varchar(64)
  , @v_et_type                  varchar(1)
  , @v_et_script_key            integer
  , @v_et_file_name             varchar(256)
  , @v_et_file_path             varchar(1024)
  , @v_et_trig_name             varchar(256)
  , @v_et_trig_path             varchar(1024)
  , @v_et_connect_key           integer
  , @v_et_header_row_ind        varchar(1)
  , @v_et_export_format         varchar(64)
  , @v_et_export_options        varchar(4000)
  , @v_et_export_routine        varchar(64)
  , @v_et_file_delimiter        varchar(10)
  , @v_et_compress_ind          varchar(1)
  , @v_et_compress_name         varchar(256)
  , @v_et_compress_path         varchar(1024)
  , @v_et_compress_param        varchar(1024)
  , @v_et_trig_param_1          varchar(1024)
  , @v_et_trig_param_2          varchar(1024)
  , @v_et_trig_param_3          varchar(1024)
  , @v_et_trig_delimiter        varchar(10)
  , @v_et_enclosed_by           varchar(10)
  , @v_et_where_clause          varchar(4000)
  , @v_ec_col_name              varchar(64)
  , @v_ec_data_type             varchar(256)
  , @v_ec_transform_code        varchar(4000)
  , @v_ec_src_column            varchar(64)
  , @v_ec_transform_type        varchar(1)
  , @v_ec_src_table             varchar(64)
  , @v_ec_display_name          varchar(256)
  , @v_database_name            varchar(256)
  , @v_server_name              varchar(256)
  , @v_length                   integer
  , @v_db_version               varchar(10)

  SELECT
    @v_ws_script_execute = 'S'
  , @v_ws_load_script = 'L'
  , @v_ws_load_file = 'F'
  , @v_ws_load_xml = 'X'

  SET @v_step = 100

  BEGIN TRY

  --=====================================================
  -- Handle:
  -- (1) a straight script execution where we are just
  -- passed the script object
  -- (2) a script based load where we are passed the
  -- the load object and can lookup the script obj
  -- (3) a file based load where we have to build up
  -- the script to be used.
  --=====================================================
  SET @v_script_key = 0
  SET @v_handled1 = 0
  SET @v_handled2 = 0

  -- Clear any old script that may be present
  DELETE from ws_wrk_task_scr_line
  WHERE wtsl_task_key = @p_task_id
  AND   wtsl_job_key = @p_job_id
  AND   wtsl_sequence = @p_sequence

  SET @v_step = 200

  DELETE from ws_wrk_task_scr_hdr
  WHERE wtsh_task_key = @p_task_id
  AND   wtsh_job_key = @p_job_id
  AND   wtsh_sequence = @p_sequence


  IF  @p_obj_type = @v_ws_obj_script
  BEGIN
    SET @v_handled1 = 1
    SET @v_script_key = @p_obj_key
    SET @v_script_type = @v_ws_script_execute
  END

  IF @p_obj_type = @v_ws_obj_load
  BEGIN
    SET @v_handled1 = 1
    SET @v_step = 300

    SELECT
      @v_load_lt_type = lt_type
    , @v_load_lt_script_key = lt_script_key
    , @v_load_lt_connect_key = lt_connect_key
    , @v_load_lt_file_header_line = lt_file_header_line
    , @v_load_lt_file_parsed = lt_file_parsed
    , @v_load_lt_file_path = lt_file_path
    , @v_load_lt_file_name = lt_file_name
    , @v_load_lt_file_delimiter = lt_file_delimiter
    , @v_load_lt_table_name = lt_table_name
    , @v_load_lt_load_options = lt_load_options
    , @v_source_con_type = dc_type
    FROM ws_load_tab
    LEFT JOIN ws_dbc_connect ON dc_obj_key = lt_connect_key
    WHERE lt_obj_key = @p_obj_key

    SELECT @v_row_count = @@ROWCOUNT

    -- ===============================================================================
    -- replace any parameters with their current values for columns of load_tab_cursor
    -- ===============================================================================
    -- 1. @v_load_lt_file_path
    SET @v_step = 400
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_load_lt_file_path),0)

    WHILE  @v_spos > 0
    BEGIN
      SET @v_step = 500
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_load_lt_file_path),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 600
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_load_lt_file_path,@v_spos+2,LEN(@v_load_lt_file_path)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 700
          SELECT @v_work = SUBSTRING(@v_load_lt_file_path,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_load_lt_file_path,@v_spos,@v_epos+2)
          SELECT @v_load_lt_file_path = REPLACE(@v_load_lt_file_path,@v_work,@v_parameter)
        END
      END
    END
    -- 2. @v_load_lt_file_name
    SET @v_step = 800
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_load_lt_file_name),0)
    WHILE  @v_spos > 0
    BEGIN
      SET @v_step = 900
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_load_lt_file_name),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 1000
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_load_lt_file_name,@v_spos+2,LEN(@v_load_lt_file_name)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 1100
          SELECT @v_work = SUBSTRING(@v_load_lt_file_name,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_load_lt_file_name,@v_spos,@v_epos+2)
          SELECT @v_load_lt_file_name = REPLACE(@v_load_lt_file_name,@v_work,@v_parameter)
        END
      END
    END
    --

    SET @v_step = 1200
    SET @v_load_type = @v_load_lt_type
    IF  @v_load_lt_type = 'S'
    BEGIN
      SET @v_handled2 = 1
      SET @v_script_key = @v_load_lt_script_key
      SET @v_script_type = @v_ws_load_script
      SET @v_load_type = ''
    END
    IF @v_load_lt_type = 'F'
    BEGIN
      SET @v_handled2 = 1
      SET @v_script_key = 0
      SET @v_script_type = @v_ws_load_file
    END
    IF @v_load_lt_type = 'X'
    BEGIN
      SET @v_handled2 = 1
      SET @v_script_key = 0
      SET @v_script_type = @v_ws_load_xml
    END

    IF @v_handled2 = 0
    BEGIN
      SET @p_return_msg = 'Unsupported host script method. Not a File, XML or Script Load. Load Type is ' +
                        @v_load_lt_type
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END
  END

  IF @p_obj_type = @v_ws_obj_export
  BEGIN
    SET @v_handled1 = 1
    SET @v_step = 1300
    SELECT
      @v_et_type = et_type
    , @v_et_script_key = et_script_key
    , @v_et_file_name = et_file_name
    , @v_et_file_path = et_file_path
    , @v_et_trig_name = et_trig_name
    , @v_et_trig_path = et_trig_path
    , @v_et_connect_key = et_connect_key
    , @v_et_header_row_ind = et_header_row_ind
    , @v_et_export_format = et_export_format
    , @v_et_export_routine = et_export_routine
    , @v_et_export_options = et_export_options
    , @v_et_file_delimiter = et_file_delimiter
    , @v_et_compress_ind = et_compress_ind
    , @v_et_compress_name = et_compress_name
    , @v_et_compress_path = et_compress_path
    , @v_et_compress_param = et_compress_param
    , @v_et_trig_param_1 = et_trig_param_1
    , @v_et_trig_param_2 = et_trig_param_2
    , @v_et_trig_param_3 = et_trig_param_3
    , @v_et_trig_delimiter = et_trig_delimiter
    , @v_et_enclosed_by = et_enclosed_by
    , @v_et_where_clause = et_where_clause
    FROM ws_export_tab
    WHERE et_obj_key = @p_obj_key
    SELECT @v_row_count = @@ROWCOUNT

    -- Convert et_file_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
    SET @v_work = UPPER(@v_et_file_delimiter)
    IF ( CHARINDEX('CHAR(',@v_work) > 0 )
    BEGIN
      SET @v_work = REPLACE(@v_work,'CHAR(','')
      IF ( CHARINDEX(')',@v_work) > 0 )
      BEGIN
        SET @v_work = REPLACE(@v_work,')','')
        SET @v_work = CHAR(@v_work)
        SET @v_et_file_delimiter = @v_work
      END
    END

    -- Convert et_trig_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
    SET @v_work = UPPER(@v_et_trig_delimiter)
    IF ( CHARINDEX('CHAR(',@v_work) > 0 )
    BEGIN
      SET @v_work = REPLACE(@v_work,'CHAR(','')
      IF ( CHARINDEX(')',@v_work) > 0 )
      BEGIN
        SET @v_work = REPLACE(@v_work,')','')
        SET @v_work = CHAR(@v_work)
        SET @v_et_trig_delimiter = @v_work
      END
    END

    -- ===============================================================================
    -- replace any parameters with their current values for columns of export_tab_cursor
    -- ===============================================================================
    -- 1. @v_et_file_path
    SET @v_step = 1400
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_file_path),0)

    WHILE  @v_spos > 0
    BEGIN
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_file_path),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 1500
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_et_file_path,@v_spos+2,LEN(@v_et_file_path)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 1600
          SELECT @v_work = SUBSTRING(@v_et_file_path,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_et_file_path,@v_spos,@v_epos+2)
          SELECT @v_et_file_path = REPLACE(@v_et_file_path,@v_work,@v_parameter)
        END
      END
    END
    -- 2. @v_et_file_name
    SET @v_step = 1700
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_file_name),0)
    WHILE  @v_spos > 0
    BEGIN
      SET @v_step = 1800
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_file_name),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 1900
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_et_file_name,@v_spos+2,LEN(@v_et_file_name)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 2000
          SELECT @v_work = SUBSTRING(@v_et_file_name,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_et_file_name,@v_spos,@v_epos+2)
          SELECT @v_et_file_name = REPLACE(@v_et_file_name,@v_work,@v_parameter)
        END
      END
    END
    -- 3. @v_et_trig_path
    SET @v_step = 2100
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_trig_path),0)
    WHILE  @v_spos > 0
    BEGIN
      SET @v_step = 2200
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_trig_path),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 2300
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_et_trig_path,@v_spos+2,LEN(@v_et_trig_path)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 2400
          SELECT @v_work = SUBSTRING(@v_et_trig_path,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_et_trig_path,@v_spos,@v_epos+2)
          SELECT @v_et_trig_path = REPLACE(@v_et_trig_path,@v_work,@v_parameter)
        END
      END
    END
    -- 4. @v_et_trig_name
    SET @v_step = 2500
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_trig_name),0)
    WHILE  @v_spos > 0
    BEGIN
      SET @v_step = 2600
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_et_trig_name),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 2700
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_et_trig_name,@v_spos+2,LEN(@v_et_trig_name)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 2800
          SELECT @v_work = SUBSTRING(@v_et_trig_name,@v_spos+2,@v_epos-1)
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_et_trig_name,@v_spos,@v_epos+2)
          SELECT @v_et_trig_name = REPLACE(@v_et_trig_name,@v_work,@v_parameter)
        END
      END
    END

    SET @v_step = 2900
    SET @v_load_type = @v_et_type
    IF @v_et_type = 'S'
    BEGIN
      SET @v_handled2 = 1
      SET @v_script_key = @v_et_script_key
      SET @v_script_type = @v_ws_load_script
      SET @v_load_type = ''
    END
    IF @v_et_type = 'F'
    BEGIN
      SET @v_handled2 = 1
      SET @v_script_key = 0
      SET @v_script_type = @v_ws_load_file
    END

    IF @v_handled2 = 0
    BEGIN
      SET @p_return_msg = 'Unsupported host script method. Not a File or Script Export. Export Type is ' +
                        @v_et_type
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    SET @v_step = 2950
    -- look up export source object database and schema from ws_dbc_target
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
    FROM       ws_obj_object
    LEFT JOIN  ws_dbc_target ON ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    LEFT JOIN  ws_dbc_connect ON ws_dbc_connect.dc_obj_key = ws_dbc_target.dt_connect_key
    WHERE UPPER(ws_obj_object.oo_name) IN (
        SELECT DISTINCT UPPER(ec_src_table)
        FROM ws_export_col
        WHERE ec_obj_key = @p_obj_key
      )

    IF @@ROWCOUNT <> 1
    BEGIN
      SET @v_table_database = ''
      SET @v_table_schema = ''

      IF @@ROWCOUNT > 1
      BEGIN
        SET @p_return_msg = 'Multiple sources found for export source, job: ' + @p_job_name + '.'
        SET @p_status_code = -2
        SET @p_result = -2
        RETURN 0
      END
    END
    ELSE
    BEGIN
      SET @v_table_database = LTRIM(RTRIM(@v_table_database))
      SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
    END
  END -- Export
  ELSE
  BEGIN
    -- needs to look up the database and schema from ws_dbc_target
    SELECT     @v_table_database = COALESCE(dt_database, '')
             , @v_table_schema = COALESCE(dt_schema, '')
    FROM       ws_obj_object
    LEFT JOIN  ws_dbc_target
    ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
    WHERE      ws_obj_object.oo_obj_key = @p_obj_key

    SET @v_table_database = LTRIM(RTRIM(@v_table_database))
    SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  END

  IF @v_handled1 = 0
  BEGIN
    SET @p_return_msg = 'Unsupported host script method. Not a script or a load. Type is ' +
                      @p_obj_type
    SET @p_status_code = -2
    SET @p_result = -2
    RETURN 0
  END

  SET @v_step = 3000
  --=====================================================
  -- See if we have a record delimiter set
  --=====================================================
  SELECT @v_rec_delimiter = NULL
  SELECT @v_load_options = NULL
  IF @v_load_lt_load_options is NOT NULL AND @v_load_lt_load_options <> ''
  BEGIN
    SET @v_step = 3100
    SELECT @v_pos = PATINDEX('%REC_DELIM=%',@v_load_lt_load_options)
    IF ISNULL(@v_pos,0) >= 1
    BEGIN
      SET @v_step = 3200
      SELECT @v_size = CONVERT(integer,SUBSTRING(@v_load_lt_load_options,@v_pos+10,4))
      IF @v_size > 0
      BEGIN
        SET @v_step = 3300
        SELECT @v_rec_delimiter = SUBSTRING(@v_load_lt_load_options,@v_pos+15,@v_size)
      END
    END
    -- Check for load options
    SELECT @v_pos = patindex('%OPTIONS=%',@v_load_lt_load_options )
    IF ISNULL(@v_pos,0) >= 1
    BEGIN
      SET @v_step = 3400
      SELECT @v_size = CONVERT(integer,substring(@v_load_lt_load_options,@v_pos+8,4))
      IF @v_size > 0
      BEGIN
        SET @v_step = 3500
        SELECT @v_load_options = SUBSTRING(@v_load_lt_load_options,@v_pos+13,@v_size)
      END
    END
  END

  --=====================================================
  -- IF  a script key copy over the script
  --=====================================================
  IF @v_script_type = @v_ws_script_execute
  OR @v_script_type = @v_ws_load_script
  BEGIN

    -- Get the Connection key
    SET @v_step = 3600
    SELECT
      @v_script_sh_connect_key = sh_connect_key
    , @v_script_sh_type = sh_type
    FROM ws_scr_header
    WHERE sh_obj_key = @v_script_key

    SELECT @v_row_count = @@ROWCOUNT

    IF  @v_script_type = @v_ws_script_execute
    BEGIN
      SET @v_connect_key = @v_script_sh_connect_key
      SET @v_load_key = 0
    END
    ELSE
    BEGIN
      IF @p_obj_type = @v_ws_obj_load
      BEGIN
        IF @v_source_con_type = 'D' OR @v_source_con_type = 'O' OR @v_source_con_type = 'Z'
        BEGIN
            SET @v_connect_key = @v_script_sh_connect_key
        END
        ELSE
        BEGIN
            SET @v_connect_key = @v_load_lt_connect_key
        END
        SET @v_load_key = @p_obj_key
      END
      ELSE
      BEGIN
        SET @v_connect_key = @v_et_connect_key
        SET @v_load_key = @p_obj_key
      END
    END

    -- Change the value for wtsh_load_type to indicate a Powershell script
    IF  @v_script_sh_type = 'P'
    BEGIN
      SET @v_load_type = 'P'
    END

    --=====================================================
    -- Get the work directory from the connection
    -- IF  no Connection we have a problem
    --=====================================================
    IF  @v_connect_key > 0
    BEGIN
      SET @v_step = 3700
      SELECT
        @v_connect_dc_work_dir = dc_work_dir
      , @v_connect_dc_type = dc_type
      , @v_connect_dc_admin_userid = dc_admin_userid
      , @v_connect_dc_admin_pwd = dc_admin_pwd
      , @v_connect_dc_database_id = dc_database_id
      FROM ws_dbc_connect
      WHERE dc_obj_key = @v_connect_key

      SELECT @v_row_count = @@ROWCOUNT

    END
    ELSE
    BEGIN
      IF  @v_script_type = @v_ws_script_execute
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to execute script'
      END
      ELSE
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to perform load'
      END
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- Build up the work directory for Unix and Windows
    --=====================================================
    IF  @v_connect_dc_type = 'U'
    BEGIN

      SET @v_step = 3800
      SET @v_work_dir = @v_connect_dc_work_dir
      IF  SUBSTRING(@v_work_dir,LEN(@v_work_dir),1) <> '/'
      BEGIN
        SET @v_work_dir = @v_work_dir + '/'
      END
    END
    ELSE
    BEGIN
      SET @v_work_dir = @v_connect_dc_work_dir
      IF  SUBSTRING(@v_work_dir,LEN(@v_work_dir),1) <> '\' -- '
      BEGIN
        SET @v_work_dir = @v_work_dir + '\' -- '
      END
    END

    BEGIN TRANSACTION

    -- Copy over the script
    IF @v_table_schema <> '' OR @v_table_database <> ''
    BEGIN
      -- Find index of the first script line
      SELECT @v_min_script_row = MIN(sl_line_no)
      FROM ws_scr_line
      WHERE sl_obj_key = @v_script_key

      -- Retrieve the first line
      SELECT @v_line = sl_line
      FROM ws_scr_line
      WHERE sl_obj_key = @v_script_key
      AND sl_line_no = @v_min_script_row

      -- Our new script will have row indexes starting at 1
      SET @v_script_row = 1

      SET @v_step = 3910
      -- While copying the script create a "hole" after '#!/bin/sh' or '@echo'
      -- to insert lines redefining target database and schema (they may have
      -- changed after the script was generated, e.g. generated for test now
      -- moving into production)
      IF ((@v_connect_dc_type = 'U' OR @v_connect_dc_type = 'H') AND SUBSTRING(LTRIM(@v_line), 1, 2) = '#!')
      OR (@v_connect_dc_type = 'W' AND LOWER(SUBSTRING(LTRIM(@v_line), 1, 5)) = '@echo')
      BEGIN
          INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id,
                 @p_job_id,
                 @p_sequence,
                 @v_script_row,
                 ISNULL(dbo.WsParameterReplace(sl_line,4000),sl_line)
          FROM ws_scr_line
          WHERE sl_obj_key = @v_script_key
          AND sl_line_no = @v_min_script_row

          -- Since we already inserted this line we will start script copy from the next line
          SET @v_min_script_row = @v_min_script_row + 1
          -- Advance new script row counter
          SET @v_script_row = @v_script_row + 1
      END

      IF @v_table_database <> ''
      BEGIN
        -- Insert target database line
        SET @v_stmt = 'SET WSL_LOAD_DB=' + @v_table_database
        -- Copy over the script
        INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id,
               @p_job_id,
               @p_sequence,
               @v_script_row,
               @v_stmt + CHAR(10)
        -- Advance new script row counter
        SET @v_script_row = @v_script_row + 1
      END

      IF @v_table_schema <> ''
      BEGIN
        -- Insert target schema line
        IF @v_load_type = 'P'
        BEGIN
          SET @v_stmt = 'if (-not (Test-Path "env:WSL_LOAD_SCHEMA")) { ${env:WSL_LOAD_SCHEMA} = ''' + @v_table_schema + '.'' }'
        END
        ELSE
        BEGIN
          SET @v_stmt = 'if not defined WSL_LOAD_SCHEMA SET WSL_LOAD_SCHEMA=' + @v_table_schema + '.'
        END
        -- Copy over the script
        INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id,
               @p_job_id,
               @p_sequence,
               @v_script_row,
               @v_stmt + CHAR(10)
        -- Advance new script row counter
        SET @v_script_row = @v_script_row + 1
      END

      -- Copy the rest of the script
      SET @v_step = 3915
      INSERT into ws_wrk_task_scr_line (
          wtsl_task_key,
          wtsl_job_key,
          wtsl_sequence,
          wtsl_line_no,
          wtsl_line
          )
      SELECT @p_task_id,
             @p_job_id,
             @p_sequence,
             @v_script_row + (sl_line_no - @v_min_script_row),
             ISNULL(dbo.WsParameterReplace(sl_line,4000),sl_line)
      FROM ws_scr_line
      WHERE sl_obj_key = @v_script_key
      AND   sl_line_no >= @v_min_script_row

      SELECT @v_row_count = @@ROWCOUNT
    END
    ELSE
    BEGIN
      SET @v_step = 3920
      INSERT into ws_wrk_task_scr_line (
          wtsl_task_key,
          wtsl_job_key,
          wtsl_sequence,
          wtsl_line_no,
          wtsl_line
          )
      SELECT @p_task_id,
             @p_job_id,
             @p_sequence,
             sl_line_no,
             ISNULL(dbo.WsParameterReplace(sl_line,4000),sl_line)
      FROM ws_scr_line
      WHERE sl_obj_key = @v_script_key

      SELECT @v_row_count = @@ROWCOUNT
    END

    --=====================================================
    -- Write out the task script header
    --=====================================================
    SET @v_step = 4000
    INSERT into ws_wrk_task_scr_hdr (
        wtsh_task_key,
        wtsh_job_key,
        wtsh_name,
        wtsh_sequence,
        wtsh_host_type,
        wtsh_script_type,
        wtsh_load_type,
        wtsh_work_dir,
        wtsh_connect_key,
        wtsh_load_key,
        wtsh_script_key
    ) values (
        @p_task_id,
        @p_job_id,
        @p_task_name,
        @p_sequence,
        @v_connect_dc_type,
        @v_script_type,
        @v_load_type,
        @v_work_dir,
        @v_connect_key,
        @v_load_key,
        @v_script_key
    )
    SELECT @v_row_count = @@ROWCOUNT

    COMMIT

  END
  --=====================================================
  -- XML based Load. Null script is generated
  --=====================================================
  IF  @v_script_type = @v_ws_load_xml
  BEGIN
    SET @v_connect_key = @v_load_lt_connect_key
    SET @v_load_key = @p_obj_key
    SET @v_script_key = 0

    --=====================================================
    -- Get the work directory from the connection
    -- IF  no Connection we have a problem
    --=====================================================
    IF  @v_connect_key > 0
    BEGIN
      SET @v_step = 4100
      SELECT
        @v_connect_dc_work_dir = dc_work_dir
      , @v_connect_dc_type = dc_type
      , @v_connect_dc_admin_userid = dc_admin_userid
      , @v_connect_dc_admin_pwd = dc_admin_pwd
      , @v_connect_dc_database_id = dc_database_id
      FROM ws_dbc_connect
      WHERE dc_obj_key = @v_connect_key

      SELECT @v_row_count = @@ROWCOUNT
    END
    ELSE
    BEGIN
      IF  @v_script_type = @v_ws_script_execute
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to execute script'
      END
      ELSE
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to perform load'
      END
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    SET @v_work_dir = @v_connect_dc_work_dir
    IF  SUBSTRING(@v_work_dir,LEN(@v_work_dir),1) <> '\' -- '
    BEGIN
      SET @v_work_dir = @v_work_dir + '\' -- '
    END

    --=====================================================
    -- Unix file based load. Build a UNIX script
    --=====================================================
    IF  @v_connect_dc_type = 'U'
    BEGIN
      SET @p_return_msg = 'Unix XML loads not supported'
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- Windows XML based load. Build a dummy windows script
    --=====================================================
    IF @v_connect_dc_type = 'W'
    BEGIN

      BEGIN TRANSACTION

      --=====================================================
      -- Write out the task script header
      --=====================================================
      SET @v_step = 4200
      INSERT into ws_wrk_task_scr_hdr (
          wtsh_task_key,
          wtsh_job_key,
          wtsh_name,
          wtsh_sequence,
          wtsh_host_type,
          wtsh_script_type,
          wtsh_load_type,
          wtsh_work_dir,
          wtsh_connect_key,
          wtsh_load_key,
          wtsh_script_key
      ) values (
          @p_task_id,
          @p_job_id,
          @p_task_name,
          @p_sequence,
          @v_connect_dc_type,
          @v_script_type,
          @v_load_type,
          @v_work_dir,
          @v_connect_key,
          @v_load_key,
          @v_script_key
      )
      SELECT @v_row_count = @@ROWCOUNT

      COMMIT

      SET @v_step = 4300
      SET @p_status_code = 1
      SET @p_result = 1
      RETURN 0
    END -- End of Windows XML
  END -- End of XML load

  --=====================================================
  -- File based Load. Build the script below once we work
  -- out IF  a Unix or Windows connection
  --=====================================================
  IF  @p_obj_type = @v_ws_obj_load
  AND @v_script_type = @v_ws_load_file
  BEGIN

    SET @v_connect_key = @v_load_lt_connect_key
    SET @v_load_key = @p_obj_key
    SET @v_script_key = 0

    --=====================================================
    -- Get the work directory from the connection
    -- IF  no Connection we have a problem
    --=====================================================
    IF  @v_connect_key > 0
    BEGIN
      SET @v_step = 4400
      SELECT
        @v_connect_dc_work_dir = dc_work_dir
      , @v_connect_dc_type = dc_type
      , @v_connect_dc_admin_userid = dc_admin_userid
      , @v_connect_dc_admin_pwd = dc_admin_pwd
      , @v_connect_dc_database_id = dc_database_id
      FROM ws_dbc_connect
      WHERE dc_obj_key = @v_connect_key

      SELECT @v_row_count = @@ROWCOUNT
    END
    ELSE
    BEGIN
      IF  @v_script_type = @v_ws_script_execute
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to execute script'
      END
      ELSE
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to perform load'
      END
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- Unix file based load. Build a unix script
    --=====================================================
    IF  @v_connect_dc_type = 'U'
    BEGIN
      SET @p_return_msg = 'Unix scripts not supported for SQL Server version'
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- Windows file based load. Build a windows script
    --=====================================================
    IF @v_connect_dc_type = 'W'
    BEGIN

      BEGIN TRANSACTION

      SET @v_step = 4500
      IF  SUBSTRING(@v_load_lt_file_path,LEN(@v_load_lt_file_path),1) <> '\' -- '
      BEGIN
        SET @v_load_lt_file_path = @v_load_lt_file_path + '\' -- '
      END

      -- Build up the command we are to run
      -- Not really a script but the scheduler will
      -- Know what to do with it WTF?!?!
      SET @v_stmt = 'BULK INSERT '

      IF @v_table_database <> ''
      BEGIN
        -- if schema is empty we get '..' for schema which works but may not be what we want...
        SET @v_table_with_owner = @v_table_database + '.' + @v_table_schema + '.'
      END
      ELSE IF @v_table_schema <> ''
      BEGIN
        SET @v_table_with_owner = @v_table_schema + '.'
      END
      ELSE
      BEGIN
        SET @v_table_with_owner = ''
      END
      SET @v_stmt = @v_stmt + @v_table_with_owner + @v_load_lt_table_name

      SET @v_stmt = @v_stmt + ' FROM '
      SET @v_stmt = @v_stmt + '''' + @v_load_lt_file_path + @v_load_lt_file_name
      SET @v_stmt = @v_stmt + ''' WITH ('

      IF @v_load_options IS NOT NULL
      BEGIN
        SET @v_stmt = @v_stmt + @v_load_options
      END

      SELECT @v_pos = PATINDEX('%DATAFILETYPE%',@v_load_options)
      IF ISNULL(@v_pos,0) = 0
      BEGIN
        IF @v_load_options IS NOT NULL
        BEGIN
          SET @v_stmt = @v_stmt + ', DATAFILETYPE=''char'''
        END
        ELSE
        BEGIN
          SET @v_stmt = @v_stmt + '  DATAFILETYPE=''char'''
        END
      END

      SELECT @v_pos = PATINDEX('%CODEPAGE%',@v_load_options)
      IF ISNULL(@v_pos,0) = 0
      BEGIN
        SET @v_stmt = @v_stmt + ', CODEPAGE=''raw'''
      END

      SELECT @v_pos = PATINDEX('%FIELDTERMINATOR%',@v_load_options)
      IF  @v_load_lt_file_delimiter <> ''
      BEGIN
        IF ISNULL(@v_pos,0) = 0
        BEGIN
          SET @v_stmt = @v_stmt + ', FIELDTERMINATOR = ''' + @v_load_lt_file_delimiter + ''''
        END
      END
      ELSE
      BEGIN
        IF @v_load_lt_file_parsed <> 'Y' OR @v_load_lt_file_parsed IS NULL
        BEGIN
          IF ISNULL(@v_pos,0) = 0
          BEGIN
            SET @v_stmt = @v_stmt + ', FIELDTERMINATOR = ''\n'''
          END
          SELECT @v_pos = PATINDEX('%ROWTERMINATOR%',@v_load_options)
          IF ISNULL(@v_pos,0) = 0
          BEGIN
            SET @v_stmt = @v_stmt + ', ROWTERMINATOR = ''\n'''
          END
        END
      END

      IF @v_load_lt_file_header_line = 'Y'
      BEGIN
        SELECT @v_pos = PATINDEX('%FIRSTROW%',@v_load_options)
        IF ISNULL(@v_pos,0) = 0
        BEGIN
          SET @v_stmt = @v_stmt + ', FIRSTROW = 2'
        END
      END

    IF @v_load_lt_file_parsed = 'Y'
    BEGIN
        -- Put a slash on the end of the work directory if one not there
        SET @v_work_dir = @v_connect_dc_work_dir
        SET @v_step = 4600
        IF SUBSTRING(@v_work_dir,LEN(@v_work_dir),1) <> '\' -- '
        BEGIN
            SET @v_work_dir = @v_work_dir + '\' -- '
        END

        SET @v_script = @v_work_dir + 'wsl' + CONVERT(varchar,@p_sequence) + 'j' + CONVERT(varchar,@p_job_id) + 't' + CONVERT(VARCHAR,@p_task_id)+ '.fmt'

        IF @v_load_lt_file_delimiter = '' OR @v_load_lt_file_delimiter IS NULL
        BEGIN
            -- There is no delimiter specified, therefore we treat it as 'fixed width'. That is, we expect the source columns to be be
            -- formatted thusly
            --		COL_width_xx
            -- where 'xx' is some number
            SET @v_step = 4700
            DECLARE c_Load CURSOR FAST_FORWARD READ_ONLY FOR
                SELECT lc_src_column, lc_col_name FROM ws_load_col WHERE lc_obj_key = @p_obj_key AND lc_src_column like 'COL%' ORDER BY lc_order

            OPEN c_Load
            FETCH NEXT FROM c_Load INTO @v_lc_src_column, @v_lc_col_name

            SET @v_row = 0
            SET @v_col = 0
            SET @v_output = ''
            SET @v_col_name = ''

            WHILE @@FETCH_STATUS = 0
            BEGIN
                SET @v_step = 4800
                SELECT @v_width = PATINDEX('%_width_%',@v_lc_src_column)

                IF @v_col_name <> '' AND @v_width > 0
                BEGIN
                    SET @v_output = @v_output + '""  ' + CONVERT(varchar,@v_col) + '  ' + @v_col_name + '  "">>' + @v_script

                    -- Copy over the script
                    SET @v_step = 4900

                    INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
                    SELECT @p_task_id, @p_job_id, @p_sequence, @v_row+2, @v_output

                    SELECT @v_row_count = @@ROWCOUNT

                    SET @v_output = ''
                END

                SET @v_col = @v_col + 1

                -- If width based then build up the format lines as follows:
                --        position in text file, data type, prefix = 0, column width, delimiter, table column number, table column name
                IF @v_width > 0
                BEGIN
                    SET @v_width = @v_width + 7
                    SET @v_col_name = @v_lc_col_name
                    SET @v_row = @v_row + 1
                    SET @v_step = 5000
                    SET @v_output = @v_output  +
						'--WS_HOST_CMD echo ' +
						CONVERT(varchar,@v_row) + '  SQLCHAR  0  ' + SUBSTRING(@v_lc_src_column,@v_width, LEN(@v_lc_src_column)-(@v_width-1)) + '  '
                END

                FETCH NEXT FROM c_Load INTO @v_lc_src_column, @v_lc_col_name
            END -- End of source column loop

            CLOSE c_Load
            DEALLOCATE c_Load

            -- Complete the command
            IF @v_col_name <> '' AND @v_output <> ''
            BEGIN
                -- If fixed width then no delimiter not even a /n
                IF UPPER(SUBSTRING(@v_rec_delimiter,1,4)) = 'FIX '
                BEGIN
                    SET @v_output = @v_output +'""  '
                END
                ELSE
                BEGIN
                    -- RED_970 use recdelim if available else default \r\n
                    IF @v_rec_delimiter <> ''
                    BEGIN
                        SET @v_output = @v_output +'"' + @v_rec_delimiter + '"  '
                    END
                    ELSE
                    BEGIN
                        SET @v_output = @v_output + '"\r\n"  '
                    END
                END

                SET @v_output = @v_output +  CONVERT(varchar,@v_col) + '  ' + @v_col_name + '  "">>' + @v_script

                -- Copy over the script
                SET @v_step = 5100
                INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
                SELECT @p_task_id, @p_job_id, @p_sequence, @v_row+2, @v_output

                SELECT @v_row_count = @@ROWCOUNT

                SET @v_output = ''
            END

            -- If we have width based stuff then put the headers on
            IF @v_row > 0
            BEGIN
                -- put the first line in
                SET @v_step = 5200
                SET @v_output = '--WS_HOST_CMD echo 8.0>' + @v_script

                -- Copy over the script
                SET @v_step = 5300

                INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
                SELECT @p_task_id, @p_job_id, @p_sequence, 1, @v_output

                SELECT @v_row_count = @@ROWCOUNT

                -- put the second line in
                SET @v_output = '--WS_HOST_CMD echo ' + CONVERT(varchar,@v_row) + ' >>' + @v_script

                -- Copy over the script
                SET @v_step = 5400
                INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
                SELECT @p_task_id, @p_job_id, @p_sequence, 2, @v_output

                SELECT @v_row_count = @@ROWCOUNT

                -- adding the format file name to our command
                SET @v_stmt = @v_stmt + ', '
            END
            ELSE
            BEGIN
                SET @v_row = -2
            END
        END
        ELSE
        BEGIN
			-- This is a non-fixed-width file load
            -- The column delimiter is in '@v_load_lt_file_delimiter'.
			-- The record delimiter is in '@v_rec_delimiter'
			-- The name of the format file is in '@v_script'.


			-- Count how many rows in this table have 'COL%' as the source column. This count is used
			-- to know when to use the record delimiter.
			SELECT @v_lc_src_column = lc_src_column, @v_lc_col_name = lc_col_name
			FROM ws_load_col
			WHERE lc_obj_key = @p_obj_key AND lc_src_column like 'COL%' ORDER BY lc_order
			SELECT @v_row_count = @@ROWCOUNT


			-- Build the output of the FORMATFILE. Make sure we loop through all rows, not just the 'COL%' rows.
			SET @v_row = 1
			SET @v_col = 1

            DECLARE c_Load CURSOR FAST_FORWARD READ_ONLY FOR
                SELECT lc_src_column, lc_col_name FROM ws_load_col WHERE lc_obj_key = @p_obj_key ORDER BY lc_order

            OPEN c_Load
            FETCH NEXT FROM c_Load INTO @v_lc_src_column, @v_lc_col_name

            WHILE @@FETCH_STATUS = 0
            BEGIN
				IF UPPER(SUBSTRING(@v_lc_src_column, 1, 3)) = 'COL'
				BEGIN
					SET @v_output =
							'--WS_HOST_CMD echo ' +
							CONVERT(varchar, @v_row) + ' ' +			-- File field number
							'SQLCHAR ' +								-- Column data type
							'0 ' +										-- Column prefix (0 = none)
							'0 '										-- Column width (0 = delimited)

					-- Specify a delimiter
					IF @v_row = @v_row_count
					BEGIN
						-- There is no next record, use the record delimiter, if there is one.
						IF @v_rec_delimiter <> ''
						BEGIN
							SET @v_rec_delimiter =	REPLACE(
													REPLACE(
													REPLACE(
													REPLACE(@v_rec_delimiter
														, CHAR(13), '\r')
														, CHAR(10), '\n')
														,  CHAR(9), '\t')
														,  CHAR(0), '\0')
							SET @v_output = @v_output +'"' + @v_rec_delimiter + '" '
						END
						ELSE
						BEGIN
							SET @v_output = @v_output + '"\r\n" '
						END
					END
					ELSE
					BEGIN
						SET @v_load_lt_file_delimiter = REPLACE(
														REPLACE(
														REPLACE(
														REPLACE(@v_load_lt_file_delimiter
															, CHAR(13), '\r')
															, CHAR(10), '\n')
															,  CHAR(9), '\t')
															,  CHAR(0), '\0')
						SET @v_output = @v_output + '"' + @v_load_lt_file_delimiter + '" '
					END

					-- Add the remaining column details to the string and insert it as our script line.
					SET @v_output = @v_output +
							CONVERT(varchar, @v_col) + ' ' +			-- Column number
							@v_lc_col_name + ' ' +						-- Column name
							'""' +										-- Column collation
							'>> ' + @v_script

					INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
					SELECT @p_task_id, @p_job_id, @p_sequence, @v_row + 2, @v_output
					SET @v_row = @v_row + 1
				END
				-- else we don't insert a script line for this column.

				SET @v_col = @v_col + 1
	            FETCH NEXT FROM c_Load INTO @v_lc_src_column, @v_lc_col_name
            END

            CLOSE c_Load
            DEALLOCATE c_Load

			SET @v_output = '--WS_HOST_CMD echo 8.0 > ' + @v_script
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
			SELECT @p_task_id, @p_job_id, @p_sequence, 1, @v_output

			SET @v_output = '--WS_HOST_CMD echo ' + CONVERT(varchar, @v_row - 1) + ' >> ' + @v_script		-- write the line count into the file
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)
			SELECT @p_task_id, @p_job_id, @p_sequence, 2, @v_output

            -- adding the format file name to our command
            SET @v_stmt = @v_stmt + ', '
        END
    END -- end of 'is a file parsed load'
    ELSE
    BEGIN
        SET @v_stmt = @v_stmt + ')'
        SET @v_script = NULL
        SET @v_row = -2
    END

      -- Copy over the script
      SET @v_step = 5500
      INSERT into ws_wrk_task_scr_line (
          wtsl_task_key,
          wtsl_job_key,
          wtsl_sequence,
          wtsl_line_no,
          wtsl_line
          )
      SELECT @p_task_id, @p_job_id, @p_sequence, @v_row+3, @v_stmt

      IF @v_script IS NOT NULL
      BEGIN
          SET @v_stmt = 'FORMATFILE=''' + @v_script + ''')'

          SET @v_step = 5550
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row+4, @v_stmt
      END

      SELECT @v_row_count = @@ROWCOUNT

      --=====================================================
      -- Write out the task script header
      --=====================================================
      SET @v_step = 5600
      INSERT into ws_wrk_task_scr_hdr (
          wtsh_task_key,
          wtsh_job_key,
          wtsh_name,
          wtsh_sequence,
          wtsh_host_type,
          wtsh_script_type,
          wtsh_load_type,
          wtsh_work_dir,
          wtsh_connect_key,
          wtsh_load_key,
          wtsh_script_key
      ) values (
          @p_task_id,
          @p_job_id,
          @p_task_name,
          @p_sequence,
          @v_connect_dc_type,
          @v_script_type,
          @v_load_type,
          @v_work_dir,
          @v_connect_key,
          @v_load_key,
          @v_script_key
      )

      SELECT @v_row_count = @@ROWCOUNT

      COMMIT

      SET @v_step = 5700
      SET @p_status_code = 1
      SET @p_result = 1
      RETURN 0

    END  -- end of windows file
  END  -- end of file based load

  --=====================================================
  -- File based Export. Build the script below once we work
  -- out if a Unix or Windows connection
  --=====================================================
  IF  @p_obj_type = @v_ws_obj_export   AND @v_script_type = @v_ws_load_file
  BEGIN
    SET @v_step = 5800
    SET @v_connect_key = @v_et_connect_key
    SET @v_load_key = @p_obj_key
    SET @v_script_key = 0

    SET @v_step = 5900
    --=====================================================
    -- Get the work directory from the connection
    -- IF  no Connection we have a problem
    --=====================================================
    IF  @v_connect_key > 0
    BEGIN
      SET @v_step = 6000
      SELECT
        @v_connect_dc_work_dir = dc_work_dir
      , @v_connect_dc_type = dc_type
      , @v_connect_dc_admin_userid = dc_admin_userid
      , @v_connect_dc_admin_pwd = dc_admin_pwd
      , @v_connect_dc_database_id = dc_database_id
      FROM ws_dbc_connect
      WHERE dc_obj_key = @v_connect_key

      SELECT @v_row_count = @@ROWCOUNT
    END
    ELSE
    BEGIN
      IF  @v_script_type = @v_ws_script_execute
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to execute script'
      END
      ELSE
      BEGIN
        SET @p_return_msg = 'No connection defined. Unable to perform export'
      END
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    SET @v_step = 6100

    --=====================================================
    -- Unix file based load. Build a Unix script
    --=====================================================
    IF  @v_connect_dc_type = 'U'
    BEGIN
      SET @p_return_msg = 'Unix scripts not supported for SQL Server version'
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- W I N D O W S                      W I N D O W S
    --=====================================================
    --=====================================================
    -- Windows file based load. Build a windows script
    --=====================================================
    IF @v_connect_dc_type = 'W'
    BEGIN

      -- Get the database version
      SET @v_step = 6200
      SELECT @v_db_version = SUBSTRING(CONVERT(VARCHAR,SERVERPROPERTY('ProductVersion'))
                                      ,1
                                      ,CHARINDEX('.',CONVERT(VARCHAR,SERVERPROPERTY('ProductVersion')))-1)

      -- Get name of export source object
      SET @v_step = 6300
      SELECT TOP 1 @v_ec_source_table = ec_src_table
      FROM ws_export_col
      WHERE ec_obj_key = @p_obj_key
      ORDER BY ec_order
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        SET @v_row = 1
        SET @v_stmt = '@echo off'
        SET @v_step = 6400
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      -- Get Server Name and Database Name
      SET @v_step = 6500
      SELECT @v_database_name = db_name()
           , @v_server_name = CONVERT(varchar(256), SERVERPROPERTY('servername'))
      SELECT @v_row_count = @@ROWCOUNT

      IF @v_table_database <> ''
      BEGIN
        SET @v_database_name = @v_table_database
      END

      -- Create a unique name for the ctrl files and log files
      SET @v_work_dir = @v_connect_dc_work_dir
      SET @v_step = 6600
      IF SUBSTRING(@v_work_dir,LEN(@v_work_dir),1) <> '\' -- '
      BEGIN
        SET @v_work_dir = @v_work_dir + '\' -- '
      END
      SET @v_script = 'wsl' + CONVERT(varchar,@p_sequence) + 'j' + CONVERT(varchar,@p_job_id) + 't' + CONVERT(VARCHAR,@p_task_id)
      --RED_2566 protect the files for if spaces in directory
      SET @v_audfile = '"'+@v_work_dir + @v_script + '.aud'+'"'
      SET @v_errfile = '"'+@v_work_dir + @v_script + '.err'+'"'
      SET @v_logfile = '"'+@v_work_dir + @v_script + '.log'+'"'
      SET @v_ctlfile = '"'+@v_work_dir + @v_script + '.ctl'+'"'
      SET @v_trgfile = '"'+@v_work_dir + @v_script + '.trg'+'"'

      SET @v_step = 6700
      IF ISNULL(@v_et_file_path,'') <> ''
        IF SUBSTRING(@v_et_file_path,LEN(@v_et_file_path),1) <> '\' -- '
        BEGIN
          SET @v_file_path = @v_et_file_path + '\' -- '
        END
        ELSE
        BEGIN
          SET @v_file_path = @v_et_file_path
        END
      ELSE
      BEGIN
        SET @v_file_path = ''
      END

      -- loop on a matching pair of $ signs in the file name
      -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
      BEGIN
        SET @v_spos = CHARINDEX('$',@v_et_file_name,1)
        WHILE @v_spos <> 0
        BEGIN
          SET @v_step = 6800
          SET @v_epos = CHARINDEX('$',@v_et_file_name,@v_spos+1)
          IF @v_epos <> 0
          BEGIN
            SET @v_step = 6900
            SET @v_command = SUBSTRING(@v_et_file_name,@v_spos+1,@v_epos-@v_spos-1)
            SET @v_new_command = @v_command
            IF CHARINDEX('SEQUENCE',@v_new_command) <> 0
            BEGIN
              SET @v_new_command = REPLACE(@v_new_command,'SEQUENCE',CONVERT(varchar,@p_sequence))
            END
            ELSE
            BEGIN
              SET @v_current_date = GETDATE()
              IF CHARINDEX('YYYY',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'YYYY',DATEPART(yyyy,@v_current_date))
              END
              ELSE
              BEGIN
                IF CHARINDEX('YY',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'YY',RIGHT('0'+CONVERT(VARCHAR,DATEPART(yy,@v_current_date)),2))
                END
              END
              IF CHARINDEX('MM',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'MM',RIGHT('0'+CONVERT(VARCHAR,DATEPART(mm,@v_current_date)),2))
              END
              IF CHARINDEX('DD',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'DD',RIGHT('0'+CONVERT(VARCHAR,DATEPART(dd,@v_current_date)),2))
              END
              IF CHARINDEX('HH',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'HH',RIGHT('0'+CONVERT(VARCHAR,DATEPART(hh,@v_current_date)),2))
              END
              IF CHARINDEX('MI',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'MI',RIGHT('0'+CONVERT(VARCHAR,DATEPART(mi,@v_current_date)),2))
              END
              IF CHARINDEX('SS',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'SS',RIGHT('0'+CONVERT(VARCHAR,DATEPART(ss,@v_current_date)),2))
              END
            END
            IF ISNULL(@v_new_command,'') <> ''
            BEGIN
              SET @v_et_file_name = REPLACE(@v_et_file_name,'$'+@v_command+'$',@v_new_command)
            END
          END -- end of epos found
          IF ((ISNULL(@v_new_command,'') <> '') AND (@v_epos <> 0))
          BEGIN
            SET @v_spos = CHARINDEX('$',@v_et_file_name,1)
          END
          ELSE
          BEGIN
            SET @v_spos = 0
          END
        END -- end of spos while
      END -- end of replace sequences and dates

      IF @v_et_export_routine = 'BCP'
      BEGIN

		SET @v_stmt = 'SET EXP_FILE="' + @v_file_path + @v_et_file_name + '"' + CHAR(10)

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7000
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

		SET @v_stmt = 'SET LOG_FILE="' + @v_logfile + '"' + CHAR(10)

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7010
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_stmt = 'bcp "SELECT '

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7020
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

        -- Add columns to select
        SET @v_count = 1
        SET @v_step = 7030

        DECLARE c_ExpCol CURSOR FAST_FORWARD READ_ONLY FOR
          SELECT ec_src_column FROM ws_export_col WHERE ec_obj_key = @p_obj_key ORDER BY ec_order

        OPEN c_ExpCol

        FETCH NEXT FROM c_ExpCol INTO @v_ec_src_column

        WHILE @@FETCH_STATUS = 0
        BEGIN
          SET @v_step = 7040

		  SET @v_stmt = ''
          IF @v_count > 1
          BEGIN
            SET @v_stmt = ', '
          END
          SET @v_stmt = @v_stmt + @v_ec_src_column
          SET @v_count = @v_count + 1

		  -- Insert '@v_stmt' into the metadata
          BEGIN
			  SET @v_row = @v_row + 1
			  SET @v_step = 7050
			  INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			  SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			  SELECT @v_row_count = @@ROWCOUNT
          END

          FETCH NEXT FROM c_ExpCol INTO @v_ec_src_column
        END -- End of source column loop

        CLOSE c_ExpCol
        DEALLOCATE c_ExpCol

        SET @v_stmt = ' FROM ' + @v_database_name
        IF @v_table_schema <> ''
        BEGIN
          SET @v_stmt = @v_stmt + '.' + @v_table_schema + '.' + @v_ec_source_table
        END
        ELSE
        BEGIN
          SET @v_stmt = @v_stmt + '.dbo.' + @v_ec_source_table
        END

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7060
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

		SET @v_stmt = ' '
        IF ( ISNULL(@v_et_where_clause,'') <> '' )
        BEGIN
          SET @v_stmt = @v_et_where_clause
        END

        SET @v_stmt = @v_stmt + '" queryout "%EXP_FILE%"'

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7070
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

        IF SUBSTRING(RTRIM(LTRIM(@v_et_export_format)),1,1) = 'D'
        BEGIN
          SET @v_stmt = ' -c '
        END
        ELSE
        BEGIN
          SET @v_stmt = ' -n '
        END

        IF ISNULL(RTRIM(LTRIM(CONVERT(VARCHAR,@v_et_export_options))),'') <> ''
        BEGIN
          SET @v_stmt = @v_stmt + ' '
          SET @v_stmt = @v_stmt + RTRIM(LTRIM(CONVERT(VARCHAR,@v_et_export_options)))
        END

        IF ISNULL(RTRIM(LTRIM(@v_et_file_delimiter)),'') <> ''
        BEGIN
          SET @v_stmt = @v_stmt + ' -t "'
          SET @v_stmt = @v_stmt + RTRIM(LTRIM(@v_et_file_delimiter))
          SET @v_stmt = @v_stmt + '"'
        END

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7080
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_stmt = ' -q -S ' + @v_server_name

        IF ISNULL(RTRIM(LTRIM(@v_connect_dc_admin_pwd)),'') = ''
        BEGIN
          SET @v_stmt = @v_stmt + ' -T '
        END
        ELSE
        BEGIN
          SET @v_stmt = @v_stmt + ' -U %WSL_USER% '
          SET @v_stmt = @v_stmt + ' -P %WSL_PWD% '
        END

        SET @v_stmt = @v_stmt + '> %LOG_FILE%'

		-- Insert '@v_stmt' into the metadata
        BEGIN
			SET @v_row = @v_row + 1
			SET @v_step = 7090
			INSERT into ws_wrk_task_scr_line (wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line )
			SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt
			SELECT @v_row_count = @@ROWCOUNT
        END

		SET @v_stmt = ''

      END -- End of BCP
      ELSE
      BEGIN
        -- Check Where Clause for any < or > and protect
        SET @v_et_where_clause = REPLACE(REPLACE(@v_et_where_clause,'<','^<'),'>','^>')
        IF @v_et_export_routine = 'isql'
        BEGIN

          SET @v_stmt = 'echo set nocount on > ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 8000
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo SELECT export_data >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 8010
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo FROM ( >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 8020
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          IF ISNULL(RTRIM(LTRIM(@v_et_header_row_ind)),'') <> ''
            AND RTRIM(LTRIM(@v_et_header_row_ind)) <> 'N'
            AND SUBSTRING(RTRIM(LTRIM(@v_et_export_format)),1,1) = 'D'
          BEGIN

            SET @v_stmt = 'echo SELECT TOP 1 '''
            SET @v_count = 0
            SET @v_length = 0

            SET @v_step = 8030
            DECLARE c_ExpCol CURSOR FAST_FORWARD READ_ONLY FOR
              SELECT ec_col_name
                   , ec_display_name
              FROM   ws_export_col
              WHERE  ec_obj_key = @p_obj_key
              ORDER BY ec_order

            OPEN c_ExpCol
            FETCH NEXT FROM c_ExpCol INTO
              @v_ec_col_name
            , @v_ec_display_name

            WHILE @@FETCH_STATUS = 0
            BEGIN

              SET @v_step = 8040
              IF @v_count = 1--8
              BEGIN
                SET @v_stmt = @v_stmt + 'echo            + ''^'
                SET @v_stmt = @v_stmt + @v_et_file_delimiter
                SET @v_count = 0
              END
              SET @v_count = @v_count + 1
              IF @v_count > 1
              BEGIN
                SET @v_stmt = @v_stmt + '^' + @v_et_file_delimiter
              END
              IF RTRIM(LTRIM(@v_et_header_row_ind)) = 'B'
              BEGIN
                SET @v_stmt = @v_stmt + @v_ec_display_name
                SET @v_length = @v_length + LEN(@v_ec_display_name)
              END
              ELSE
              BEGIN
                IF RTRIM(LTRIM(@v_et_header_row_ind)) = 'C'
                BEGIN
                  SET @v_stmt = @v_stmt + @v_ec_col_name
                  SET @v_length = @v_length + LEN(@v_ec_col_name)
                END
              END
              IF @v_count = 1--8
              BEGIN
                SET @v_stmt = @v_stmt + ''' >> ' + @v_ctlfile

                BEGIN
                  SET @v_row = @v_row + 1
                  -- Copy over the script
                  SET @v_step = 8050
                  INSERT into ws_wrk_task_scr_line (
                      wtsl_task_key,
                      wtsl_job_key,
                      wtsl_sequence,
                      wtsl_line_no,
                      wtsl_line
                      )
                  SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
                  SELECT @v_row_count = @@ROWCOUNT
                END

                SET @v_stmt = ''

              END

              FETCH NEXT FROM c_ExpCol INTO
                @v_ec_col_name
              , @v_ec_display_name

            END -- End of source column loop

            CLOSE c_ExpCol
            DEALLOCATE c_ExpCol

--            IF @v_stmt <> ''
--            BEGIN
--              SET @v_stmt = @v_stmt + ''' AS export_data >> ' + @v_ctlfile
              SET @v_stmt = 'echo               AS export_data >> ' + @v_ctlfile

                BEGIN
                  SET @v_row = @v_row + 1
                  -- Copy over the script
                  SET @v_step = 8060
                  INSERT into ws_wrk_task_scr_line (
                      wtsl_task_key,
                      wtsl_job_key,
                      wtsl_sequence,
                      wtsl_line_no,
                      wtsl_line
                      )
                  SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
                  SELECT @v_row_count = @@ROWCOUNT
                END

--            END

            SET @v_stmt = 'echo           , 1 AS sort_order >> ' + @v_ctlfile

            BEGIN
              SET @v_row = @v_row + 1
              -- Copy over the script
              SET @v_step = 8070
              INSERT into ws_wrk_task_scr_line (
                  wtsl_task_key,
                  wtsl_job_key,
                  wtsl_sequence,
                  wtsl_line_no,
                  wtsl_line
                  )
              SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
              SELECT @v_row_count = @@ROWCOUNT
            END

            SET @v_stmt = 'echo FROM '
            SET @v_stmt = @v_stmt + @v_database_name
            IF @v_table_schema <> ''
            BEGIN
              SET @v_stmt = @v_stmt + '.' + @v_table_schema + '.' + @v_ec_source_table + ' >> ' + @v_ctlfile
            END
            ELSE
            BEGIN
              SET @v_stmt = @v_stmt + '.dbo.' + @v_ec_source_table + ' >> ' + @v_ctlfile
            END

            BEGIN
              SET @v_row = @v_row + 1
              -- Copy over the script
              SET @v_step = 8080
              INSERT into ws_wrk_task_scr_line (
                  wtsl_task_key,
                  wtsl_job_key,
                  wtsl_sequence,
                  wtsl_line_no,
                  wtsl_line
                  )
              SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
              SELECT @v_row_count = @@ROWCOUNT
            END

            SET @v_stmt = 'echo UNION ALL >> ' + @v_ctlfile

            BEGIN
              SET @v_row = @v_row + 1
              -- Copy over the script
              SET @v_step = 8090
              INSERT into ws_wrk_task_scr_line (
                  wtsl_task_key,
                  wtsl_job_key,
                  wtsl_sequence,
                  wtsl_line_no,
                  wtsl_line
                  )
              SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
              SELECT @v_row_count = @@ROWCOUNT
            END
          END

          SET @v_stmt = 'echo SELECT ' -- RED_3574: remove RTRIM(

          SET @v_count = 0
          SET @v_length = 0

          SET @v_step = 8100
          DECLARE c_ExpCol CURSOR FAST_FORWARD READ_ONLY FOR
            SELECT ec_col_name
                 , ec_data_type
                 , ec_transform_code
                 , ec_src_column
            FROM   ws_export_col
            WHERE  ec_obj_key = @p_obj_key
            ORDER BY ec_order

          OPEN c_ExpCol
          FETCH NEXT FROM c_ExpCol INTO
            @v_ec_col_name
          , @v_ec_data_type
          , @v_ec_transform_code
          , @v_ec_src_column

          WHILE @@FETCH_STATUS = 0
          BEGIN

            SET @v_step = 8200
            SET @v_count = @v_count + 1

            IF SUBSTRING(RTRIM(LTRIM(@v_et_export_format)),1,1) = 'D'
            BEGIN

              IF @v_count > 1
              BEGIN
                SET @v_stmt = 'echo + ''^' + @v_et_file_delimiter + ''' + '
              END

              IF ISNULL(RTRIM(LTRIM(@v_ec_transform_code)),'') <> ''
              BEGIN
                SET @v_stmt = @v_stmt + RTRIM(LTRIM(@v_ec_transform_code))
              END
              ELSE
              BEGIN
                SET @v_step = 8300
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,7) = 'varchar'
                  OR SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,8) = 'nvarchar'
                  OR SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,4) = 'char'
                  OR SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,5) = 'nchar'
                BEGIN
                  IF LTRIM(RTRIM(@v_et_enclosed_by)) = ''''
                  BEGIN
                    SET @v_stmt = @v_stmt + '''''''''+'
                  END
                  ELSE IF ISNULL(LTRIM(RTRIM(@v_et_enclosed_by)),'') <> ''
                  BEGIN
                    SET @v_stmt = @v_stmt + '''' + @v_et_enclosed_by + '''+'
                  END
                  SET @v_stmt = @v_stmt + 'ISNULL(' + RTRIM(LTRIM(@v_ec_src_column)) + ','''')'
                  IF LTRIM(RTRIM(@v_et_enclosed_by)) = ''''
                  BEGIN
                    SET @v_stmt = @v_stmt + '+'''''''''
                  END
                  ELSE IF ISNULL(LTRIM(RTRIM(@v_et_enclosed_by)),'') <> ''
                  BEGIN
                    SET @v_stmt = @v_stmt + '+''' + @v_et_enclosed_by + ''''
                  END
                END
                ELSE
                BEGIN
                  SET @v_stmt = @v_stmt + 'ISNULL(CONVERT(VARCHAR,' + RTRIM(LTRIM(@v_ec_src_column)) + '),'''')'
                END
              END
              SET @v_stmt = @v_stmt + ' >> ' + @v_ctlfile

              BEGIN
                SET @v_row = @v_row + 1
                -- Copy over the script
                SET @v_step = 8400
                INSERT into ws_wrk_task_scr_line (
                    wtsl_task_key,
                    wtsl_job_key,
                    wtsl_sequence,
                    wtsl_line_no,
                    wtsl_line
                    )
                SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
                SELECT @v_row_count = @@ROWCOUNT
              END

            END
            ELSE
            BEGIN

              IF SUBSTRING(RTRIM(LTRIM(@v_et_export_format)),1,1) = 'W'
              BEGIN

                SET @v_step = 9000
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,8) = 'nvarchar'
                BEGIN
                  SET @v_length = 2 * CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,10,LEN(LTRIM(@v_ec_data_type))-10))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,5) = 'nchar'
                BEGIN
                  SET @v_length = 2*CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,7,LEN(LTRIM(LOWER(@v_ec_data_type)))-7))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,7) = 'varchar'
                BEGIN
                  SET @v_length = CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,9,LEN(LTRIM(LOWER(@v_ec_data_type)))-9))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,4) = 'char'
                BEGIN
                  SET @v_length = CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,6,LEN(LTRIM(LOWER(@v_ec_data_type)))-6))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,6) = 'binary'
                BEGIN
                  SET @v_length = 1+2*CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,8,LEN(LTRIM(LOWER(@v_ec_data_type)))-8))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,9) = 'varbinary'
                BEGIN
                  SET @v_length = 1+2*CONVERT(INTEGER,SUBSTRING(LTRIM(LOWER(@v_ec_data_type))
                                                           ,11,LEN(LTRIM(LOWER(@v_ec_data_type)))-11))
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,3) = 'bit'
                BEGIN
                  SET @v_length = 1
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,7) = 'tinyint'
                BEGIN
                  SET @v_length = 5
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,8) = 'smallint'
                BEGIN
                  SET @v_length = 7
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,3) = 'int'
                BEGIN
                  SET @v_length = 12
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,9) = 'timestamp'
                BEGIN
                  SET @v_length = 17
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,6) = 'bigint'
                BEGIN
                  SET @v_length = 19
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,8) = 'datetime'
                BEGIN
                  SET @v_length = 24
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,13) = 'smalldatetime'
                BEGIN
                  SET @v_length = 24
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,5) = 'float'
                BEGIN
                  SET @v_length = 30
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,4) = 'real'
                BEGIN
                  SET @v_length = 30
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,5) = 'money'
                BEGIN
                  SET @v_length = 30
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,10) = 'smallmoney'
                BEGIN
                  SET @v_length = 30
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,16) = 'uniqueidentifier'
                BEGIN
                  SET @v_length = 37
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,7) = 'decimal'
                BEGIN
                  SET @v_length = 41
                END
                IF SUBSTRING(LTRIM(LOWER(@v_ec_data_type)),1,7) = 'numeric'
                BEGIN
                  SET @v_length = 41
                END

                IF @v_count > 1
                BEGIN
                  SET @v_stmt = 'echo + '
                END

                IF ISNULL(RTRIM(LTRIM(@v_ec_transform_code)),'') <> ''
                BEGIN
                  SET @v_work = RTRIM(LTRIM(@v_ec_transform_code))
                END
                ELSE
                BEGIN
                  SET @v_work = RTRIM(LTRIM(@v_ec_src_column))
                END

                SET @v_stmt = @v_stmt + 'ISNULL(CONVERT(VARCHAR,' + @v_work
                                      + '),'''')+SPACE(' + CONVERT(VARCHAR,@v_length)
                                      + '-ISNULL(LEN(ISNULL(CONVERT(VARCHAR,' + @v_work
                                      + '),'''')),0))'

                SET @v_stmt = @v_stmt + ' >> ' + @v_ctlfile

                BEGIN
                  SET @v_row = @v_row + 1
                  -- Copy over the script
                  SET @v_step = 9010
                  INSERT into ws_wrk_task_scr_line (
                      wtsl_task_key,
                      wtsl_job_key,
                      wtsl_sequence,
                      wtsl_line_no,
                      wtsl_line
                      )
                  SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
                  SELECT @v_row_count = @@ROWCOUNT
                END

              END
            END

            FETCH NEXT FROM c_ExpCol INTO
              @v_ec_col_name
            , @v_ec_data_type
            , @v_ec_transform_code
            , @v_ec_src_column

          END -- End of source column loop

          CLOSE c_ExpCol
          DEALLOCATE c_ExpCol

          SET @v_stmt = 'echo  AS export_data >> ' + @v_ctlfile -- RED_3574: remove )

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9020
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo , 2 AS sort_order >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9030
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo FROM '
          SET @v_stmt = @v_stmt + @v_database_name
          IF @v_table_schema <> ''
          BEGIN
            SET @v_stmt = @v_stmt + '.' + @v_table_schema + '.' + @v_ec_source_table + ' >> ' + @v_ctlfile
          END
          ELSE
          BEGIN
            SET @v_stmt = @v_stmt + '.dbo.' + @v_ec_source_table + ' >> ' + @v_ctlfile
          END

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9040
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          IF ( ISNULL(@v_et_where_clause,'') <> '' )
          BEGIN
            SET @v_stmt = 'echo '
            SET @v_stmt = @v_stmt + @v_et_where_clause
            SET @v_stmt = @v_stmt + ' >> ' + @v_ctlfile

            BEGIN
              SET @v_row = @v_row + 1
              -- Copy over the script
              SET @v_step = 9050
              INSERT into ws_wrk_task_scr_line (
                  wtsl_task_key,
                  wtsl_job_key,
                  wtsl_sequence,
                  wtsl_line_no,
                  wtsl_line
                  )
              SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
              SELECT @v_row_count = @@ROWCOUNT
            END
          END

          SET @v_stmt = 'echo ) AS export_souce >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9060
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo ORDER BY sort_order >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9070
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'echo go >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9080
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'SET EXP_FILE="' + @v_file_path + @v_et_file_name + '"'

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9090
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'SET CTL_FILE=' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9100
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          SET @v_stmt = 'SET LOG_FILE=' + @v_logfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 9110
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END

          IF @v_db_version = '8'
          BEGIN
            SET @v_stmt = 'isql -S'
          END
          ELSE
          BEGIN
            SET @v_stmt = 'sqlcmd -S'
          END
          SET @v_stmt = @v_stmt + @v_server_name

          IF ISNULL(RTRIM(LTRIM(@v_connect_dc_admin_pwd)),'') = ''
          BEGIN
            SET @v_stmt = @v_stmt + ' -E '
          END
          ELSE
          BEGIN
            SET @v_stmt = @v_stmt + ' -U %WSL_USER%'
            --RED_4484
            --SET @v_stmt = @v_stmt + ' -P '
            --SET @v_stmt = @v_stmt + @v_connect_dc_admin_pwd
          END

          SET @v_stmt = @v_stmt + ' -d'
          SET @v_stmt = @v_stmt + @v_database_name
          SET @v_stmt = @v_stmt + ' -h-1 -s"" -w10000 -r'
          IF @v_db_version = '8'
          BEGIN
            SET @v_stmt = @v_stmt + ' -n'
          END
          SET @v_stmt = @v_stmt + ' -i %CTL_FILE%'
          SET @v_stmt = @v_stmt + ' -o '
          SET @v_stmt = @v_stmt + '%EXP_FILE%'
          IF ISNULL(RTRIM(LTRIM(CONVERT(VARCHAR,@v_et_export_options))),'') <> ''
          BEGIN
            SET @v_stmt = @v_stmt + ' '
            SET @v_stmt = @v_stmt + RTRIM(LTRIM(CONVERT(VARCHAR,@v_et_export_options)))
          END
          SET @v_stmt = @v_stmt + ' > %LOG_FILE%'

        END -- End of isql
      END

      BEGIN
        SET @v_row = @v_row + 1
        -- Copy over the script
        SET @v_step = 9500
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = '@echo off'
        SET @v_step = 9600
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'SET ERRLEV=%errorlevel%'
        SET @v_step = 9700
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'IF %ERRLEV% EQU 0 GOTO LABEL_EXIT'
        SET @v_step = 9800
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = ':LABEL_FAIL'
        SET @v_step = 9900
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'echo -2'
        SET @v_step = 10000
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'echo Export Failed.  A fatal error occurred in export utility'
        SET @v_step = 10100
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'type ' + @v_logfile + '>&2'
        SET @v_step = 10200
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'exit'
        SET @v_step = 10300
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = ':LABEL_EXIT'
        SET @v_step = 10400
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      -- Compress Output File
      IF  LTRIM(RTRIM(@v_et_compress_ind)) = 'Y'
      AND ISNULL(LTRIM(RTRIM(@v_et_compress_name)),'') <> ''
      BEGIN

        IF ISNULL(@v_et_compress_path,'') <> ''
        BEGIN
          SET @v_step = 10500
          IF SUBSTRING(@v_et_compress_path,LEN(@v_et_compress_path),1) <> '\' -- '
          BEGIN
            SET @v_compress_path = @v_et_compress_path + '\' -- '
          END
          ELSE
          BEGIN
            SET @v_compress_path = @v_et_compress_path
          END
        END
        ELSE
        BEGIN
          SET @v_compress_path = ''
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = '"' + @v_compress_path + LTRIM(RTRIM(@v_et_compress_name)) + '" '
                      + REPLACE(LTRIM(RTRIM(@v_et_compress_param)),'$EXPFILE$',@v_file_path+@v_et_file_name)
                      + ' >> "' + @v_script + '_a.aud"'
          SET @v_step = 10600
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'SET ERRLEV=%errorlevel%'
          SET @v_step = 10700
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'IF %errorlevel% EQU 0 GOTO LABEL_OKAY2'
          SET @v_step = 10800
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo -2'
          SET @v_step = 10900
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo Export compress failed with return status %ERRLEV% See error log for details'
          SET @v_step = 11000
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'type "' + @v_logfile + '" >&2'
          SET @v_step = 11100
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'exit'
          SET @v_step = 11200
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = ':LABEL_OKAY2'
          SET @v_step = 11300
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

      END

      -- Use query tool to generate a trigger file
      IF ISNULL(LTRIM(RTRIM(@v_et_trig_name)),'') <> ''
      AND ISNULL(LTRIM(RTRIM(@v_et_trig_param_1)),'') <> ''
      BEGIN

        IF ISNULL(@v_et_trig_path,'') <> ''
        BEGIN
          IF RIGHT(@v_et_trig_path,1) <> '\' -- '
          BEGIN
            SET @v_trig_path = @v_et_trig_path + '\' -- '
          END
          ELSE
          BEGIN
            SET @v_trig_path = @v_et_trig_path
          END
        END
        ELSE
        BEGIN
          SET @v_trig_path = ''
        END

        -- loop on a matching pair of $ signs in the trigger name
        -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
        BEGIN
          SET @v_spos = CHARINDEX('$',@v_et_trig_name,1)
          WHILE @v_spos <> 0
          BEGIN
            SET @v_epos = CHARINDEX('$',@v_et_trig_name,@v_spos+1)
            IF @v_epos <> 0
            BEGIN
              SET @v_step = 11400
              SET @v_command = SUBSTRING(@v_et_trig_name,@v_spos+1,@v_epos-@v_spos-1)
              SET @v_new_command = @v_command
              IF CHARINDEX('SEQUENCE',@v_new_command) <> 0
              BEGIN
                SET @v_new_command = REPLACE(@v_new_command,'SEQUENCE',CONVERT(varchar,@p_sequence))
              END
              ELSE
              BEGIN
                --@v_current_date used from creating data file so the same...
                IF CHARINDEX('YYYY',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'YYYY',DATEPART(yyyy,@v_current_date))
                END
                ELSE
                BEGIN
                  IF CHARINDEX('YY',@v_new_command) <> 0
                  BEGIN
                    SET @v_new_command = REPLACE(@v_new_command,'YY',RIGHT('0'+CONVERT(VARCHAR,DATEPART(yy,@v_current_date)),2))
                  END
                END
                IF CHARINDEX('MM',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'MM',RIGHT('0'+CONVERT(VARCHAR,DATEPART(mm,@v_current_date)),2))
                END
                IF CHARINDEX('DD',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'DD',RIGHT('0'+CONVERT(VARCHAR,DATEPART(dd,@v_current_date)),2))
                END
                IF CHARINDEX('HH',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'HH',RIGHT('0'+CONVERT(VARCHAR,DATEPART(hh,@v_current_date)),2))
                END
                IF CHARINDEX('MI',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'MI',RIGHT('0'+CONVERT(VARCHAR,DATEPART(mi,@v_current_date)),2))
                END
                IF CHARINDEX('SS',@v_new_command) <> 0
                BEGIN
                  SET @v_new_command = REPLACE(@v_new_command,'SS',RIGHT('0'+CONVERT(VARCHAR,DATEPART(ss,@v_current_date)),2))
                END
              END
              IF ISNULL(@v_new_command,'') <> ''
              BEGIN
                SET @v_et_trig_name = REPLACE(@v_et_trig_name,'$'+@v_command+'$',@v_new_command)
              END
            END -- end of epos found
            IF ((ISNULL(@v_new_command,'') <> '') AND (@v_epos <> 0))
            BEGIN
              SET @v_spos = CHARINDEX('$',@v_et_trig_name,1)
            END
            ELSE
            BEGIN
              SET @v_spos = 0
            END
          END -- end of spos while
        END -- end of replace sequences and dates

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo set nocount on > ' + @v_ctlfile
          SET @v_step = 11500
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        -- If trig column 1 is populated
        IF SUBSTRING(@v_et_trig_param_1,1,1) = 'R'
        BEGIN
          SET @v_work = 'CONVERT(VARCHAR,COUNT(*))'
        END
        ELSE
        BEGIN
          IF ISNULL(LTRIM(RTRIM(@v_et_trig_param_1)),'') <> ''
          BEGIN
            SET @v_work = 'CONVERT(VARCHAR,' + @v_et_trig_param_1 + ')'
          END
          ELSE
          BEGIN
            SET @v_work = NULL
          END
        END

        -- If trig column 2 is populated
        IF SUBSTRING(@v_et_trig_param_2,1,1) = 'R'
        BEGIN
          SET @v_work2 = 'CONVERT(VARCHAR,COUNT(*))' -- RED_4102
        END
        ELSE
        BEGIN
          IF ISNULL(LTRIM(RTRIM(@v_et_trig_param_2)),'') <> ''
          BEGIN
            SET @v_work2 = 'CONVERT(VARCHAR,' + @v_et_trig_param_2 + ')'
          END
          ELSE
          BEGIN
            SET @v_work2 = NULL
          END
        END

        -- If trig column 3 is populated
        SET @v_step = 11600
        IF SUBSTRING(@v_et_trig_param_3,1,1) = 'R'
        BEGIN
          SET @v_work3 = 'CONVERT(VARCHAR,COUNT(*))' -- RED_4102
        END
        ELSE
        BEGIN
          IF ISNULL(LTRIM(RTRIM(@v_et_trig_param_3)),'') <> ''
          BEGIN
            SET @v_work3 = 'CONVERT(VARCHAR,' + @v_et_trig_param_3 + ')'
          END
          ELSE
          BEGIN
            SET @v_work3 = NULL
          END
        END

        -- Put it all together

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo SELECT ' + @v_work + ' >> ' + @v_ctlfile
          SET @v_step = 11700
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        IF ISNULL(LTRIM(RTRIM(@v_et_trig_delimiter)),'') <> ''
        BEGIN
          SET @v_work = ' + ''^' + LTRIM(RTRIM(@v_et_trig_delimiter)) + ''' + '
        END
        ELSE
        BEGIN
          SET @v_work = ' + '' '' + '
        END

        IF ISNULL(@v_work2,'') <> ''
        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo ' + @v_work + @v_work2 + ' >> ' + @v_ctlfile
          SET @v_step = 11800
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        IF ISNULL(@v_work3,'') <> ''
        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo ' + @v_work + @v_work3 + ' >> ' + @v_ctlfile
          SET @v_step = 11900
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo FROM '
          SET @v_stmt = @v_stmt + @v_database_name
          IF @v_table_schema <> ''
          BEGIN
            SET @v_stmt = @v_stmt + '.' + @v_table_schema + '.' + @v_ec_source_table + ' >> ' + @v_ctlfile
          END
          ELSE
          BEGIN
            SET @v_stmt = @v_stmt + '.dbo.' + @v_ec_source_table + ' >> ' + @v_ctlfile
          END
          SET @v_step = 12000
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        IF ( ISNULL(@v_et_where_clause,'') <> '' )
        BEGIN
          SET @v_stmt = 'echo '
          SET @v_stmt = @v_stmt + @v_et_where_clause
          SET @v_stmt = @v_stmt + ' >> ' + @v_ctlfile

          BEGIN
            SET @v_row = @v_row + 1
            -- Copy over the script
            SET @v_step = 12100
            INSERT into ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
            SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
            SELECT @v_row_count = @@ROWCOUNT
          END
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo go' + ' >> ' + @v_ctlfile
          SET @v_step = 12200
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          IF @v_db_version = '8'
          BEGIN
            SET @v_stmt = 'isql -S'
          END
          ELSE
          BEGIN
            SET @v_stmt = 'sqlcmd -S'
          END
          SET @v_stmt = @v_stmt + @v_server_name
          IF ISNULL(RTRIM(LTRIM(@v_connect_dc_admin_pwd)),'') = ''
          BEGIN
            SET @v_stmt = @v_stmt + ' -E '
          END
          ELSE
          BEGIN
            SET @v_stmt = @v_stmt + ' -U %WSL_USER%'
            --RED_4484
            --SET @v_stmt = @v_stmt + ' -P '
            --SET @v_stmt = @v_stmt + @v_connect_dc_admin_pwd
          END
          SET @v_stmt = @v_stmt + ' -d'
          SET @v_stmt = @v_stmt + @v_database_name
          SET @v_stmt = @v_stmt + ' -h-1 -s"" -w10000 -r'
          IF @v_db_version = '8'
          BEGIN
            SET @v_stmt = @v_stmt + ' -n'
          END
          SET @v_stmt = @v_stmt + ' -i '  -- RED_4102: remove the double quotation mark
          SET @v_stmt = @v_stmt + @v_ctlfile
          SET @v_stmt = @v_stmt + ' ^'
          SET @v_step = 12250
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT

          SET @v_row = @v_row + 1
          SET @v_stmt = ' -o "' -- RED_4102: remove the double quotation mark
          SET @v_stmt = @v_stmt + @v_trig_path + @v_et_trig_name
          SET @v_stmt = @v_stmt + '" > ' + @v_logfile
          SET @v_step = 12300
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'SET ERRLEV=%errorlevel%'
          SET @v_step = 12400
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'IF %errorlevel% EQU 0 GOTO LABEL_OKAY3'
          SET @v_step = 12500
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo -2'
          SET @v_step = 12600
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'echo Export trigger creation failed with return status %ERRLEV% See error log for details'
          SET @v_step = 12700
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'type "' + @v_logfile + '" >@2'
          SET @v_step = 12800
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = 'exit'
          SET @v_step = 12900
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

        BEGIN
          SET @v_row = @v_row + 1
          SET @v_stmt = ':LABEL_OKAY3'
          SET @v_step = 13000
          INSERT into ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
          SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
          SELECT @v_row_count = @@ROWCOUNT
        END

      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'echo 1'
        SET @v_step = 13100
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'echo Export Completed Normally'
        SET @v_step = 13200
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'type ' + @v_logfile + '>&2'
        SET @v_step = 13300
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      BEGIN
        SET @v_row = @v_row + 1
        SET @v_stmt = 'exit'
        SET @v_step = 13400
        INSERT into ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT @p_task_id, @p_job_id, @p_sequence, @v_row, @v_stmt+CHAR(10)
        SELECT @v_row_count = @@ROWCOUNT
      END

      --=====================================================
      -- Write out the task script header
      --=====================================================
      SET @v_step = 13500

      INSERT into ws_wrk_task_scr_hdr (
          wtsh_task_key,
          wtsh_job_key,
          wtsh_name,
          wtsh_sequence,
          wtsh_host_type,
          wtsh_script_type,
          wtsh_load_type,
          wtsh_work_dir,
          wtsh_connect_key,
          wtsh_load_key,
          wtsh_script_key
      ) values (
          @p_task_id,
          @p_job_id,
          @p_task_name,
          @p_sequence,
          @v_connect_dc_type,
          @v_script_type,
          @v_load_type,
          @v_work_dir,
          @v_connect_key,
          @v_load_key,
          @v_script_key
      )
      SELECT @v_row_count = @@ROWCOUNT

      SET @v_step = 13700
      SET @p_status_code = 1
      SET @p_result = 1
      RETURN 0

    END -- End of Windows Export

  END -- End of Export

  SET @p_status_code = 1
  SET @p_return_msg = 'Script prepared'
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Load') >= -1
    BEGIN
      DEALLOCATE c_Load
    END
    IF CURSOR_STATUS('local','c_ExpCol') >= -1
    BEGIN
      DEALLOCATE c_ExpCol
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Initial_Build 
-- Notes / History
--
-- WMR 24/09/2001                 Added support for aggregates
-- WMR 22/01/2002 Version 1.0.0
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- WMR 10/05/2004                 Changed to custom procedure
-- WMR 26/03/2006 Version 5.6.0.0 Added support for retro copy v5.6.0.0
-- AP  09/04/2008 Version 6.0.0.0 Added support for ODS/Normal
-- AP  31/12/2008 Version 6.0.2.3 Added support for View
-- AP  19/03/2009 Version 6.0.3.1 New trapping of sql dependency error (@@trancount)
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2011 Version 6.5.5.1 RED-2382 Support Block Procedural Code
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  16/01/2018 Version 8.1.1.0 RED-8944 Adding support for Source Mapping
-- BC  17/07/2018 Version 8.3.1.0 RED-9312 Invoke procedure using fully-qualified procedure name.
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- BC  12/11/2018 Version 8.3.1.0 RED-9978 Increase size of procedure name variable to hold qualified name.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Initial_Build
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    :SQLServer
  -- Script Name  :ws_act_initial_build
  -- Description  :Execute the build procedure associated with a table
  --
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer

  , @v_ws_obj_job               integer
  , @v_ws_obj_source_mapping    integer

  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Initial_Build(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32

  , @v_ws_obj_job               = 50
  , @v_ws_obj_source_mapping    = 69

  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_procedure_key   integer
  , @v_procedure       varchar(256)
  , @v_procedure_type  varchar(1)
  , @v_procedure_status integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  SET @v_step = 100

  BEGIN TRY

  --=====================================================
  -- Check that we have a valid table type
  --=====================================================
  IF  @p_obj_type <> @v_ws_obj_dim
  AND @p_obj_type <> @v_ws_obj_dim_view
  AND @p_obj_type <> @v_ws_obj_view
  AND @p_obj_type <> @v_ws_obj_fact
  AND @p_obj_type <> @v_ws_obj_fact
  AND @p_obj_type <> @v_ws_obj_fact_kpi
  AND @p_obj_type <> @v_ws_obj_stage
  AND @p_obj_type <> @v_ws_obj_agg
  AND @p_obj_type <> @v_ws_obj_retro_copy
  AND @p_obj_type <> @v_ws_obj_ods
  AND @p_obj_type <> @v_ws_obj_normal
  AND @p_obj_type <> @v_ws_obj_hub
  AND @p_obj_type <> @v_ws_obj_satellite
  AND @p_obj_type <> @v_ws_obj_link
  AND @p_obj_type <> @v_ws_obj_custom1
  AND @p_obj_type <> @v_ws_obj_custom2
  AND @p_obj_type <> @v_ws_obj_source_mapping
  BEGIN
    SET @v_msgtext = 'Invalid table type for table ' + @p_task_name +
      '. Table type was ' + CONVERT(varchar,ISNULL(@p_obj_type,-1))
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name, @p_sequence,
                  @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    SET @p_status_code = -2
    SET @p_result = -2
    RETURN 0
  END
  --=====================================================
  -- See what table we have and get the build procedure
  --=====================================================
  SET @v_step = 200
  SET @p_result = 1
  SET @v_procedure_key = 0

  IF @p_obj_type = @v_ws_obj_dim
  BEGIN
      Select @v_procedure_key = dt_build_key
      From ws_dim_tab
      Where dt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_dim_view
  BEGIN
      Select @v_procedure_key = dt_build_key
      From ws_dim_tab
      Where dt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_view
  BEGIN
      Select @v_procedure_key = vt_build_key
      From ws_view_tab
      Where vt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_fact
  BEGIN
      Select @v_procedure_key = ft_build_key
      From ws_fact_tab
      Where ft_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_fact_kpi
  BEGIN
      Select @v_procedure_key = ft_build_key
      From ws_fact_tab
      Where ft_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_stage
  BEGIN
      Select @v_procedure_key = st_build_key
      From ws_stage_tab
      Where st_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_agg
  BEGIN
      Select @v_procedure_key = at_build_key
      From ws_agg_tab
      Where at_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_retro_copy
  BEGIN
      Select @v_procedure_key = rt_build_key
      From ws_retro_tab
      Where rt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_ods
  BEGIN
      Select @v_procedure_key = ot_build_key
      From ws_ods_tab
      Where ot_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_normal
  OR @p_obj_type = @v_ws_obj_hub
  OR @p_obj_type = @v_ws_obj_satellite
  OR @p_obj_type = @v_ws_obj_link
  OR @p_obj_type = @v_ws_obj_custom1
  OR @p_obj_type = @v_ws_obj_custom2
  BEGIN
      Select @v_procedure_key = nt_build_key
      From ws_normal_tab
      Where nt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_source_mapping
  BEGIN
      SELECT @v_procedure_key = smt_build_key
      FROM ws_source_mapping_tab
      WHERE smt_source_mapping_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END

  SET @v_step = 300

  IF @v_row_count = 0
  OR @v_procedure_key = 0
  OR @v_procedure_key = ''
  BEGIN

    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire custom (build) procedure for ' + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id

    BEGIN
      SET @v_msgtext = 'Please check that a custom (build) procedure has been defined'
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
            @p_return_msg,NULL,NULL, @p_task_id, @p_job_id
    END
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET @v_step = 400
  SELECT @v_procedure = CASE WHEN COALESCE(dt_database,'') <> '' THEN dt_database + '.' + COALESCE(dt_schema,'') + '.'
                             WHEN COALESCE(dt_schema,'') <> '' THEN dt_schema + '.' ELSE '' END + ph_name
       , @v_procedure_type = NULLIF(ph_type,'P')
  FROM   ws_pro_header
  JOIN   ws_obj_object ON ph_obj_key = oo_obj_key
  LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
  WHERE  ph_obj_key = @v_procedure_key
  SELECT @v_row_count = @@ROWCOUNT

  IF @v_row_count = 0
  OR @v_procedure iS NULL
  BEGIN
    SET @v_step = 500

    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire custom (build) procedure name for ' + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0
  END

  --=====================================================
  -- IF SQLBLOCK then return for calling
  --=====================================================
  SET @v_step = 600
  IF @v_procedure_type = 'B'
  BEGIN
    -- run a POST SQLBLOCK by returning a result of 17
    SET @p_result = 17
    SET @p_status_code = 2
    RETURN 0
  END

  --=====================================================
  -- Execute the procedure
  --=====================================================
  -- Execute the procedure
--  BEGIN TRANSACTION
  SET @v_step = 700

  EXEC @v_procedure_status = @v_procedure
        @p_sequence = @p_sequence
      , @p_job_name = @p_job_name
      , @p_task_name = @p_task_name
      , @p_job_id = @p_job_id
      , @p_task_id = @p_task_id
      , @p_return_msg = @p_return_msg OUTPUT
      , @p_status = @p_status_code OUTPUT
--  COMMIT

  -- Need to check for open transactions that can occur in SQLServer if procedure references
  -- and object that no longer exists
  -- Sql just bombs out, and cant gracefully trap in procedure!
  SET @v_step = 800

  IF @@trancount <> 0
  BEGIN
    ROLLBACK
    SET @p_status_code = -3
    SET @p_return_msg = 'Failure when calling custom (build) procedure. View full audit trail for job'

    SET @v_step = 900
    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Transactions left in open state by procedure'
    , @p_db_code     = NULL
    , @p_db_msg      = NULL
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id
  END

  SET @v_step = 1000
  IF @v_procedure_status <> 0
  BEGIN
    SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
         , @v_db_msg  = ERROR_MESSAGE()

    SET @v_step = 1100
    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Failure when executing procedure'
    , @p_db_code     = @v_db_code
    , @p_db_msg      = @v_db_msg
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id

    SET @p_return_msg = 'Unhandled Exception in custom procedure routine ' + @v_ws_pro_version + ' step ' +convert(varchar,@v_step)
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END
  SET @v_step = 1200

  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Load 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0.0
-- WMR 08/04/2002 Version 1.0.7.0  Added support for using lt_load_statement
-- WMR 01/05/2002 Version 1.0.7.6  Fixed problem with pre-load SQL.
-- WMR 18/06/2002 Version 1.1.0.0  Added support for Non mandatory columns
-- WMR 30/10/2002 Version 1.2.1.4  Converted to SQL Server
-- WMR 01/04/2003 Version 1.2.1.7  added support for OPENQUERY for Oracle db linked loads
-- WMR 16/05/2003 Version 1.2.1.8  added support for parameter replacement in where clause
-- WMR 15/09/2003 Version 4.1.0.1  fixed issue with brackets applied to Oracle OpenQuery commands
-- WMR 13/02/2004 Version 4.1.0.1  added support for XML based file loads
-- WMR 25/07/2004 Version 4.1.0.8  Allow comments in transformations
-- WMR 28/09/2004 Version 4.1.1.0  ODBC based statement overrides are handled in the scheduler
-- WMR 10/02/2005 Version 4.1.1.3  Add support for a DISTINCT select and version in error
-- WMR 19/04/2005 Version 4.1.2.2  Increased length of dc_dblink_id variable to 1024
-- WMR 27/03/2005 Version 5.0.1.4  Prevented a [[ ]] situation if [] already around a table or column
-- AP  29/01/2006 Version 5.5.0.8  Incorrectly processing if load col length > 4000
-- JML 22/03/2007 Version 5.5.0.17 support for Native ODBC loads Added. return = 12
-- WMR 22/05/2007 Version 5.6.0.6  Changed the status code returned by Odbc loads to 2 to prevent erroneous warning message.
-- AP  11/02/2008 Version 5.6.3.1  Call WsParameterReplace to allow parse of all fields for parameter substitution.
--                                 Added substitution of $JOB_SEQUENCE$ with @p_sequence
--                                 Removed the oracle 'append' hint from the insert statement
-- AP  11/02/2008 Version 6.0.4.1  Added handling of insert hint.
-- AP  10/06/2008 Version 6.0.4.1  Changes to workflow locking.and 2005+ TRY
-- AP  12/10/2010 Version 6.5.1.1  RED-546 Do Param replace as we go to minimise risk of exceed 4000 characters during replace.
-- AP  01/12/2010 Version 6.5.3.1  RED-??? Introduced SSIS Load - Type = 'I' - return = 14
-- AP  14/11/2011 Version 6.5.5.1  RED-2462 Correct order of ' replace for MSDAORA to be after parameter replace
-- HM  19/08/2014 Version 6.8.1.2  RED_3906 Added Schema support
-- AP  23/07/2015 Version 6.8.4.3  RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- BC  16/02/2016 Version 6.8.5.3  Added support for BDA Server operations
-- DLC 16/02/2016 Version 6.8.5.3  Added target columns into the generated SQL statement
--                                      INSERT INTO x SELECT (y.a, y.b, y.c) FROM y
--                                 Becomes
--                                      INSERT INTO x (a, b, c) SELECT (y.a, y.b, y.c) FROM y
-- RS  03/11/2016 Version 6.8.6.3  Added support for multi Sql-statement processing in Pre-Load operation
-- RS  21/12/2016 Version 6.8.6.3  Fixed issue with Pre-Load operation
-- HM  08/02/2017 Version 6.8.7.1  RED-7757 Added multi-database support (3-part naming)
-- HM  15/10/2018 Version 8.3.1.0  RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Load
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      : SQL Server
  -- Script Name    : ws_act_load
  -- Description    : Loads a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_document          integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_user1             integer
  , @v_ws_obj_user2             integer
  , @v_ws_obj_user3             integer
  , @v_ws_obj_user4             integer
  , @v_ws_obj_user5             integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Load(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_report            = 16
  , @v_ws_obj_user1             = 17
  , @v_ws_obj_user2             = 18
  , @v_ws_obj_user3             = 19
  , @v_ws_obj_user4             = 20
  , @v_ws_obj_user5             = 21
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext                            varchar(1024) -- Text in audit_trail
  , @v_step                               integer       -- step
  , @v_row_count                          integer
  , @v_db_code                            varchar(10)   -- Database error code
  , @v_db_msg                             varchar(1024) -- Database error message
  , @v_result                             integer       -- return code
  , @v_handled                            integer
  , @v_tabcol                             varchar(512)
  , @v_sql                                nvarchar(4000)
  , @v_insert_stmt                        nvarchar(4000)
  , @v_select_stmt                        nvarchar(4000)
  , @v_from_and_where_stmt                nvarchar(4000)
  , @v_select_col0                        nvarchar(4000)
  , @v_select_col1                        nvarchar(4000)
  , @v_select_col2                        nvarchar(4000)
  , @v_select_col3                        nvarchar(4000)
  , @v_insert_col0                        nvarchar(4000)
  , @v_insert_col1                        nvarchar(4000)
  , @v_insert_col2                        nvarchar(4000)
  , @v_insert_col3                        nvarchar(4000)
  , @v_create                             nvarchar(4000)
  , @v_count                              integer
  , @v_view                               integer
  , @v_cursor                             integer
  , @v_col_found                          integer
  , @v_row                                integer
  , @v_len                                integer
  , @v_len2                               integer
  , @v_len3                               integer
  , @v_len4                               integer
  , @v_MissingMsg                         varchar(4000) -- Message for missing columns
  , @v_MissingBug                         integer
  , @v_MissingRet                         varchar(1)
  , @v_where_clause                       nvarchar(4000)
  , @v_spos                               integer
  , @v_epos                               integer
  , @v_work                               nvarchar(4000)
  , @v_work2                              nvarchar(4000)
  , @v_parameter                          nvarchar(4000)
  , @v_t1pos                              integer
  , @v_t2pos                              integer
  , @v_distinct                           integer
  , @v_insert_hint                        nvarchar(4000)
  , @v_size                               integer
  , @v_table_database                     varchar(64)
  , @v_table_schema                       varchar(64)
  , @v_table_with_owner                   varchar(256)
  , @v_start_location                     integer
  , @v_end_location                       integer
  , @v_statement                          varchar(max)
  , @v_delimiter                          varchar(4000)

  --=====================================================
  -- Connection Variables
  --=====================================================
  DECLARE
    @v_dc_host_id         varchar(64)
  , @v_dc_dblink_id       varchar(1024)

  --=====================================================
  -- Load Table Variables
  --=====================================================
  DECLARE
    @v_lt_pre_action         varchar(1)
  , @v_lt_table_name         varchar(64)
  , @v_lt_pre_sql            varchar(4000)
  , @v_lt_load_statement     varchar(4000)
  , @v_lt_type               varchar(1)
  , @v_lt_connect_key        integer
  , @v_lt_transform_ind      varchar(1)
  , @v_lt_non_mandatory_ind  varchar(1)
  , @v_lt_source_schema      varchar(64)
  , @v_lt_source_columns     varchar(4000)
  , @v_lt_from_table         varchar(4000)
  , @v_lt_where_clause       varchar(4000)
  , @v_lt_missing_col_act    varchar(1)
  , @v_lt_load_options       varchar(4000)

  --=====================================================
  -- Load Column Variables
  --=====================================================
  DECLARE
    @v_lc_col_name          varchar(64)
  , @v_lc_src_column        varchar(64)
  , @v_lc_src_table         varchar(64)
  , @v_lc_transform_code    varchar(4000)
  , @v_lc_transform_type    varchar(1)


  SET @v_row = 0
  SET @v_step = 100

  BEGIN TRY

  SET @p_result = 1
  SET @v_MissingMsg = NULL
  SET @v_insert_hint = ''

  -- needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))

  --=====================================================
  -- First get the load table information
  --=====================================================
  SELECT
    @v_lt_pre_action = lt_pre_action
  , @v_lt_table_name = lt_table_name
  , @v_lt_pre_sql = lt_pre_sql
  , @v_lt_load_statement = lt_load_statement
  , @v_lt_type = lt_type
  , @v_lt_connect_key = lt_connect_key
  , @v_lt_transform_ind = lt_transform_ind
  , @v_lt_non_mandatory_ind = lt_non_mandatory_ind
  , @v_lt_source_schema = lt_source_schema
  , @v_lt_source_columns = lt_source_columns
  , @v_lt_from_table = lt_from_table
  , @v_lt_where_clause = lt_where_clause
  , @v_lt_missing_col_act = lt_missing_col_act
  , @v_lt_load_options = lt_load_options
  FROM   ws_load_tab
  WHERE  lt_obj_key = @p_obj_key

  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_lt_table_name

  SET @v_step = 200

  -- see if distinct specified
  SELECT @v_distinct = ISNULL(PATINDEX('%DISTINCT;%',@v_lt_load_options),0)

  -- Get the insert hint
  IF NULLIF(@v_lt_load_options,'') is NOT NULL
  BEGIN
    SELECT @v_t1pos = PATINDEX('%INSERT_HINT=%',@v_lt_load_options)
    IF ISNULL(@v_t1pos,0) >= 1
    BEGIN
      SET @v_step = 300
      SELECT @v_size = CONVERT(integer,SUBSTRING(@v_lt_load_options,@v_t1pos+12,4))
      IF @v_size > 0
      BEGIN
        SET @v_step = 400
        SELECT @v_insert_hint = SUBSTRING(@v_lt_load_options,@v_t1pos+17,@v_size)
        SET @v_insert_hint = 'WITH ( ' + @v_insert_hint + ' )'
      END
    END
  END

  -- make the insert hint always append-able
  IF NULLIF(@v_insert_hint,'') IS NULL
  BEGIN
    SET @v_insert_hint = ''
  END
  SET @v_insert_hint = ' ' + @v_insert_hint + ' '

  --=====================================================
  -- Handle any pre-load action
  --=====================================================
  IF @v_lt_pre_action = 'T'
  OR @v_lt_pre_action = 'B'
  BEGIN
    SET @v_insert_stmt = 'TRUNCATE TABLE ' + @v_table_with_owner

    SET @v_step = 500

    EXEC (@v_insert_stmt)
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @v_msgtext = 'Truncated table ' + @v_lt_table_name
      EXEC @v_result = WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
                    @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    END

  END

  IF @v_lt_pre_action = 'E'
  OR @v_lt_pre_action = 'B'
  BEGIN
    SET @v_step = 600

    SET @v_insert_stmt = rtrim(@v_lt_pre_sql)

    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$OBJECT$',@v_table_with_owner)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$DATABASE$',@v_table_database)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$SCHEMA$',@v_table_schema)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$TABLE$',@v_lt_table_name)

    -- Get the initial end location of the statement
    SET @v_start_location = 1
    SET @v_end_location = COALESCE(LEN(@v_insert_stmt),0)

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT @v_delimiter = CASE WHEN COALESCE(CAST(ta_text_3 AS VARCHAR(MAX)), '<EOS>') <> ''
                               THEN ta_text_3 ELSE '<EOS>'
                          END FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

    -- Loop through the override statement and execute each statement individually
    WHILE @v_end_location > 0
    BEGIN
       SET @v_end_location = CHARINDEX(@v_delimiter, @v_insert_stmt, @v_start_location)

       SELECT @v_statement = CASE
              WHEN @v_end_location > 0
              THEN SUBSTRING(@v_insert_stmt,@v_start_location,@v_end_location - @v_start_location)
              WHEN @v_start_location <= LEN(@v_insert_stmt)
			  THEN SUBSTRING(@v_insert_stmt,@v_start_location, LEN(@v_insert_stmt))
             END

        IF @v_statement IS NOT NULL
        BEGIN
            EXEC (@v_statement)
            SELECT @v_row_count = @@ROWCOUNT
        END

        SET @v_start_location = @v_end_location + LEN(@v_delimiter)
    END


    SET @v_msgtext = SUBSTRING('Execute pre load sql. ' + ISNULL(@v_lt_pre_sql,'NULL'),1,1023)
    EXEC @v_result = WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
                    @v_msgtext,NULL,NULL, @p_task_id, @p_job_id

  END

  --=====================================================
  -- L O A D     S T A T E M E N T
  --
  -- If a load statement then it overrides the load method
  -- and we will issue that statement to perform the load
  --=====================================================
  IF @v_lt_load_statement <> ''
  AND @v_lt_type = 'D'
  BEGIN
    --=====================================================
    -- Load using the load statement
    --=====================================================
    SET @v_insert_stmt = @v_lt_load_statement

    SET @v_step = 700
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$OBJECT$',@v_table_with_owner)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$DATABASE$',@v_table_database)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$SCHEMA$',@v_table_schema)
    SET @v_insert_stmt = REPLACE(@v_insert_stmt,'$TABLE$',@v_lt_table_name)
    --
    -- replace any parameters with their current values
    --
    SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_insert_stmt),0)
    WHILE  @v_spos > 0
    BEGIN
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_insert_stmt),0)
      IF @v_spos > 0
      BEGIN
        SET @v_step = 800
        SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@v_insert_stmt,@v_spos+2,LEN(@v_insert_stmt)-@v_spos-1)),0)
        IF @v_epos = 0
        BEGIN
          SET @v_spos = 0
        END
        ELSE
        BEGIN
          SET @v_step = 900
          SELECT @v_work = SUBSTRING(@v_insert_stmt,@v_spos+2,@v_epos-1);
          SELECT @v_parameter = dbo.WsParameterReadF(@v_work)
          SELECT @v_work = SUBSTRING(@v_insert_stmt,@v_spos,@v_epos+2)
          SELECT @v_insert_stmt = REPLACE(@v_insert_stmt,@v_work,@v_parameter)
        END
      END
    END

    EXEC (@v_insert_stmt)
    SELECT @v_row_count = @@ROWCOUNT

    SET @v_step = 1000

    SET @p_return_msg = CONVERT(varchar,ISNULL(@v_row_count,0)) +
      ' rows loaded (using load statement override) into ' + @v_lt_table_name
      + ' ' + @v_lt_type + ' ' + @v_lt_load_statement
    SET @v_step = 1100
    SET @p_status_code = 1
    SET @p_result = 1
    RETURN 0

  END

  --=====================================================
  -- See what type of load this is
  -- D = database Load
  -- O = Odbc based Load
  -- S = Script based load
  -- F = File based load
  -- X = XML File based load
  -- E = External load
  --=====================================================
  IF @v_lt_type = 'D'
  BEGIN
    --=====================================================
    -- Get the connection information
    --=====================================================
    SET @v_step = 1200
    SELECT
      @v_dc_host_id = dc_host_id
    , @v_dc_dblink_id = dc_dblink_id
    FROM ws_dbc_connect
    WHERE dc_obj_key = @v_lt_connect_key

    SELECT @v_row_count = @@ROWCOUNT

    IF @v_row_count = 0
    BEGIN
      SET @p_return_msg = 'Connection not found for load table. A valid connection must exist. ' + @v_lt_table_name

      BEGIN
        SET @v_db_code = NULL
        SET @v_db_msg = NULL
      END
      EXEC WsWrkAudit 'E', @p_job_name, @p_task_name, @p_sequence,
           @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
      SET @p_status_code = -2
      SET @p_result = -2
      RETURN 0
    END

    --=====================================================
    -- REMOTE VIEW CODE REMOVED. NOT SUPPORTED UNDER SQL SERVER
    --=====================================================

    --=====================================================
    -- Build the load statement
    --=====================================================

    SET @v_step = 1300
    SET @v_insert_stmt = 'INSERT INTO ' + @v_table_with_owner

    IF @v_dc_host_id = 'MSDAORA'
    BEGIN
      SET @v_insert_stmt = @v_insert_stmt + ' ' + @v_insert_hint
      IF @v_distinct > 0
      BEGIN
        SET @v_select_stmt = ' Select Distinct * From OPENQUERY('
      END
      ELSE
      BEGIN
        SET @v_select_stmt = ' Select * From OPENQUERY('
      END
      SET @v_select_stmt = @v_select_stmt + @v_dc_dblink_id + ',''Select '
    END
    ELSE
    BEGIN
      SET @v_insert_stmt = @v_insert_stmt + ' ' + @v_insert_hint
      IF @v_distinct > 0
      BEGIN
        SET @v_select_stmt = ' Select Distinct '
      END
      ELSE
      BEGIN
        SET @v_select_stmt = ' Select '
      END
    END

    SET @v_select_col0 = ''
    SET @v_select_col1 = ''
    SET @v_select_col2 = ''
    SET @v_select_col3 = ''

    SET @v_insert_col0 = ''
    SET @v_insert_col1 = ''
    SET @v_insert_col2 = ''
    SET @v_insert_col3 = ''

    --=====================================================
    -- Transformation or Ordinary Load
    --=====================================================
    IF ISNULL(@v_lt_transform_ind,'N') = 'Y'
    BEGIN
      --=====================================================
      -- Transformation
      --=====================================================
      SET @v_select_col3 = ''
      SET @v_MissingMsg = ''

      --=====================================================
      -- Cursor for all columns in the load table
      --=====================================================
      SET @v_step = 1400
      DECLARE c_Load CURSOR FAST_FORWARD READ_ONLY FOR
        SELECT
          lc_col_name
        , lc_src_column
        , lc_src_table
        , lc_transform_code
        , lc_transform_type
        FROM
          ws_load_col
        WHERE lc_obj_key = @p_obj_key
        ORDER BY lc_order

      OPEN c_Load
      FETCH NEXT FROM c_Load INTO
        @v_lc_col_name
      , @v_lc_src_column
      , @v_lc_src_table
      , @v_lc_transform_code
      , @v_lc_transform_type

      WHILE @@FETCH_STATUS = 0
      BEGIN

        SET @v_step = 1500
        SET @v_row = @v_row + 1
        IF @v_row > 1
        BEGIN
          SET @v_select_col3 = @v_select_col3 + ','
          SET @v_insert_col3 = @v_insert_col3 + ','

          -- RED-546 do param replace as we go as otherwise risk issue with
          --         param replace adding > 500 characters in one bash
          SET @v_step = 1600
          SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_select_col3 ),0)
          IF @v_spos > 0
          BEGIN
             SET @v_step = 1700
             SELECT @v_select_col3 = dbo.WsParameterReplace(@v_select_col3, 4000)
          END

          SET @v_step = 1650
          SELECT @v_spos = ISNULL(PATINDEX('%$P%',@v_insert_col3 ),0)
          IF @v_spos > 0
          BEGIN
             SET @v_step = 1700
             SELECT @v_insert_col3 = dbo.WsParameterReplace(@v_insert_col3, 4000)
          END

          -- If we have nearly filled this statement then use another
          IF LEN(@v_select_col3) > 3500
          BEGIN
            IF  @v_select_col0 = ''
            BEGIN
              SET @v_select_col0 = @v_select_col3
              SET @v_select_col3 = ''
            END
            IF @v_select_col1 = ''
            BEGIN
              SET @v_select_col1 = @v_select_col3
              SET @v_select_col3 = ''
            END
            IF @v_select_col2 = ''
            BEGIN
              SET @v_select_col2 = @v_select_col3
              SET @v_select_col3 = ''
            END
          END

          -- If we have nearly filled this statement then use another
          IF LEN(@v_insert_col3) > 3500
          BEGIN
            IF  @v_insert_col0 = ''
            BEGIN
              SET @v_insert_col0 = @v_insert_col3
              SET @v_insert_col3 = ''
            END
            IF @v_insert_col1 = ''
            BEGIN
              SET @v_insert_col1 = @v_insert_col3
              SET @v_insert_col3 = ''
            END
            IF @v_insert_col2 = ''
            BEGIN
              SET @v_insert_col2 = @v_insert_col3
              SET @v_insert_col3 = ''
            END
          END
        END

        --
        -- If we have non mandatory columns specified then check to ensure
        -- each column exists in the source
        SET @v_col_found = 1

        SET @v_handled = 0

        IF ISNULL(@v_lc_transform_type,'Z') = 'D'
        AND ( @v_lc_transform_code <> ''
              AND @v_lc_transform_code IS NOT NULL )
        BEGIN

          -- Get rid of any comments in the transform
          SELECT @v_work = @v_lc_transform_code
          SELECT @v_t1pos = ISNULL(PATINDEX('%'+CHAR(45)+CHAR(45)+'%',@v_work),0)
          WHILE @v_t1pos > 0
          BEGIN
            SELECT @v_work2 = SUBSTRING(@v_work,@v_t1pos,4000)
            SELECT @v_t2pos = ISNULL(PATINDEX('%'+CHAR(10)+'%',@v_work2),0)
            IF @v_t2pos > 0
            BEGIN
              SELECT @v_work2 = SUBSTRING(@v_work,1,@v_t1pos-1)
              IF @v_work2 IS NULL
              BEGIN
                SELECT @v_work = SUBSTRING(@v_work, @v_t2pos+@v_t1pos,4000)
              END
              ELSE
              BEGIN
                SELECT @v_work = @v_work2 + SUBSTRING(@v_work, @v_t2pos+@v_t1pos,4000)
              END
            END
            ELSE
            BEGIN
              SELECT @v_work = SUBSTRING(@v_work,1,@v_t1pos-1)
            END
            SELECT @v_t1pos = ISNULL(PATINDEX('%'+CHAR(45)+CHAR(45)+'%',@v_work),0)
          END -- end of remove comments from transform
          SELECT @v_lc_transform_code = LTRIM(RTRIM(@v_work))


          SET @v_handled = 1
          IF @v_col_found = 1
          BEGIN
            SET @v_select_col3 = @v_select_col3 + @v_lc_transform_code
            SET @v_insert_col3 = @v_insert_col3 + @v_lc_col_name
          END
          ELSE
          BEGIN
            SET @v_sql = @v_lc_transform_code
            SET @v_tabcol = @v_lc_src_table + '.' + @v_lc_src_column
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')
            SET @v_tabcol = Upper(@v_tabcol)
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')
            SET @v_tabcol = Lower(@v_tabcol)
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')
            SET @v_tabcol = @v_lc_src_column
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')
            SET @v_tabcol = Upper(@v_tabcol)
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')
            SET @v_tabcol = Lower(@v_tabcol)
            SET @v_sql = Replace(@v_sql,@v_tabcol,'NULL')

            SET @v_select_col3 = @v_select_col3 + @v_sql
            SET @v_insert_col3 = @v_insert_col3 + @v_lc_col_name
          END
        END

        IF @v_handled = 0
        BEGIN
          IF  @v_lc_src_column <> ''
          AND @v_lc_src_column IS NOT NULL
          BEGIN
            IF @v_col_found = 1
            BEGIN
              IF @v_lc_src_table <> ''
              AND @v_lc_src_table IS NOT NULL
              BEGIN
                IF @v_dc_host_id = 'MSDAORA'
                BEGIN
                  SET @v_select_col3 = @v_select_col3 + @v_lc_src_table + '.'
                END
                ELSE
                BEGIN
                  SELECT @v_spos = ISNULL(CHARINDEX(']',@v_lc_src_table),0)
                  IF  @v_spos > 0
                  BEGIN
                    SET @v_select_col3 = @v_select_col3 +  @v_lc_src_table + '.'
                  END
                  ELSE
                  BEGIN
                    SET @v_select_col3 = @v_select_col3 + '[' + @v_lc_src_table + '].'
                  END
               END
              END
              IF @v_dc_host_id = 'MSDAORA'
              BEGIN
                SET @v_select_col3 = @v_select_col3 + @v_lc_src_column
                SET @v_insert_col3 = @v_insert_col3 + @v_lc_col_name
              END
              ELSE
              BEGIN
                SELECT @v_spos = ISNULL(CHARINDEX(']',@v_lc_src_column),0)
                IF  @v_spos > 0
                BEGIN
                  SET @v_select_col3 = @v_select_col3 +  @v_lc_src_column
                END
                ELSE
                BEGIN
                  SET @v_select_col3 = @v_select_col3 + '[' + @v_lc_src_column + ']'
                END
                SELECT @v_spos = ISNULL(CHARINDEX(']',@v_lc_src_column),0)
                IF  @v_spos > 0
                BEGIN
                  SET @v_insert_col3 = @v_insert_col3 +  @v_lc_col_name
                END
                ELSE
                BEGIN
                  SET @v_insert_col3 = @v_insert_col3 + '[' + @v_lc_col_name + ']'
                END
             END
            END
            ELSE
            BEGIN
              SET @v_select_col3 = @v_select_col3 + 'NULL'
              SET @v_insert_col3 = @v_insert_col3 +  @v_lc_col_name
            END
          END
          ELSE
          BEGIN
            SET @v_select_col3 = @v_select_col3 + 'NULL'
            SET @v_insert_col3 = @v_insert_col3 +  @v_lc_col_name
          END
        END

        FETCH NEXT FROM c_Load INTO
          @v_lc_col_name
        , @v_lc_src_column
        , @v_lc_src_table
        , @v_lc_transform_code
        , @v_lc_transform_type

      END -- End of cursor loop

      CLOSE c_Load
      DEALLOCATE c_Load

    END --- End of transform indicator
    ELSE
    BEGIN
      SET @v_select_col3 = @v_lt_source_columns
      SET @v_insert_col3 = ''
    END

    SET @v_from_and_where_stmt = ' From '
    SET @v_from_and_where_stmt = @v_from_and_where_stmt + @v_lt_from_table
    IF @v_lt_where_clause <> ''
    AND @v_lt_where_clause IS NOT NULL
    BEGIN
      SET @v_where_clause = @v_lt_where_clause
      SET @v_from_and_where_stmt = @v_from_and_where_stmt + ' ' + @v_where_clause
    END

    --=====================================================
    -- Record any missing columns
    --=====================================================
    IF @v_MissingMsg <> ''
    BEGIN
      SET @v_msgtext = substring(@v_MissingMsg,1,1023)
      SET @v_MissingRet = 'I'
      IF @v_lt_missing_col_act = 'W'
      BEGIN
        SET @v_MissingRet = 'W'
      END
      IF @v_lt_missing_col_act = 'E'
      BEGIN
        SET @v_MissingRet = 'E'
      END
      IF @v_MissingBug = 1
      BEGIN
        SET @v_MissingRet = 'W'
      END
      EXEC WsWrkAudit @v_MissingRet, @p_job_name, @p_task_name, @p_sequence,
                      @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    END

    --=====================================================
    -- Replace any $JOB_SEQUENCE$
    --=====================================================
    SET @v_step = 1800
    SELECT @v_insert_stmt = REPLACE(@v_insert_stmt,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 1850
    SELECT @v_select_stmt = REPLACE(@v_select_stmt,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 1900
    SELECT @v_from_and_where_stmt = REPLACE(@v_from_and_where_stmt,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 1950
    SELECT @v_select_col0 = REPLACE(@v_select_col0,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2000
    SELECT @v_select_col1 = REPLACE(@v_select_col1,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2050
    SELECT @v_select_col2 = REPLACE(@v_select_col2,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2100
    SELECT @v_select_col3 = REPLACE(@v_select_col3,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2150
    SELECT @v_insert_col0 = REPLACE(@v_insert_col0,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2200
    SELECT @v_insert_col1 = REPLACE(@v_insert_col1,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2250
    SELECT @v_insert_col2 = REPLACE(@v_insert_col2,'$JOB_SEQUENCE$',@p_sequence)

    SET @v_step = 2300
    SELECT @v_insert_col3 = REPLACE(@v_insert_col3,'$JOB_SEQUENCE$',@p_sequence)

    --=====================================================
    -- Replace any $P parameters
    --=====================================================

    SET @v_step = 2350
    SELECT @v_insert_stmt = dbo.WsParameterReplace(@v_insert_stmt, 4000)

    SET @v_step = 2400
    SELECT @v_select_stmt = dbo.WsParameterReplace(@v_select_stmt, 4000)

    SET @v_step = 2450
    SELECT @v_from_and_where_stmt = dbo.WsParameterReplace(@v_from_and_where_stmt, 4000)

    SET @v_step = 2500
    SELECT @v_select_col0 = dbo.WsParameterReplace(@v_select_col0, 4000)

    SET @v_step = 2550
    SELECT @v_select_col1 = dbo.WsParameterReplace(@v_select_col1, 4000)

    SET @v_step = 2600
    SELECT @v_select_col2 = dbo.WsParameterReplace(@v_select_col2, 4000)

    SET @v_step = 2650
    SELECT @v_select_col3 = dbo.WsParameterReplace(@v_select_col3, 4000)

    SET @v_step = 2700
    SELECT @v_insert_col0 = dbo.WsParameterReplace(@v_insert_col0, 4000)

    SET @v_step = 2750
    SELECT @v_insert_col1 = dbo.WsParameterReplace(@v_insert_col1, 4000)

    SET @v_step = 2800
    SELECT @v_insert_col2 = dbo.WsParameterReplace(@v_insert_col2, 4000)

    SET @v_step = 2850
    SELECT @v_insert_col3 = dbo.WsParameterReplace(@v_insert_col3, 4000)

    --=====================================================
    -- Handle 's for MSDAORA
    --=====================================================

    IF @v_dc_host_id = 'MSDAORA'
    BEGIN
      SELECT @v_select_col0 = REPLACE(@v_select_col0,'''','''''')
      SELECT @v_select_col1 = REPLACE(@v_select_col1,'''','''''')
      SELECT @v_select_col2 = REPLACE(@v_select_col2,'''','''''')
      SELECT @v_select_col3 = REPLACE(@v_select_col3,'''','''''')
      SELECT @v_insert_col0 = REPLACE(@v_insert_col0,'''','''''')
      SELECT @v_insert_col1 = REPLACE(@v_insert_col1,'''','''''')
      SELECT @v_insert_col2 = REPLACE(@v_insert_col2,'''','''''')
      SELECT @v_insert_col3 = REPLACE(@v_insert_col3,'''','''''')
      SELECT @v_from_and_where_stmt = REPLACE(@v_from_and_where_stmt,'''','''''')
      SET @v_from_and_where_stmt = @v_from_and_where_stmt + ''')'
    END

    --=====================================================
    -- Perform the Load
    --=====================================================

    SET @v_step = 2800
    IF @v_insert_col3 = ''
    BEGIN
        EXEC (@v_insert_stmt + @v_select_stmt + @v_select_col0 + @v_select_col1 + @v_select_col2 + @v_select_col3 + @v_from_and_where_stmt)
    END
    ELSE
    BEGIN
        EXEC (@v_insert_stmt +
                    '(' + @v_insert_col0 + @v_insert_col1 + @v_insert_col2 + @v_insert_col3 + ')' +
              @v_select_stmt +
                    @v_select_col0 + @v_select_col1 + @v_select_col2 + @v_select_col3 +
              @v_from_and_where_stmt)
    END
    SELECT @v_row_count = @@ROWCOUNT

    SET @v_step = 2900

    SET @p_return_msg = CONVERT(varchar,ISNULL(@v_row_count,0)) + ' rows loaded into ' + @v_lt_table_name
    SET @v_step = 3000
    IF @v_view = 1
    BEGIN
      SET @v_insert_stmt = @p_return_msg + ' ( via rview )'
      SET @p_return_msg = substring(@v_insert_stmt,1,256)
    END
    SET @v_step = 3100
    SET @p_status_code = 1
    SET @p_result = 1
  END

  --**********************************
  -- File Load
  --**********************************
  IF @v_lt_type = 'F'
  BEGIN
    SET @v_step = 3200
    EXEC Ws_Act_Host_Script @p_sequence,@p_obj_type,@p_action, @p_obj_key,
        @p_job_name, @p_task_name, @p_job_id, @p_task_id,
        @p_return_msg OUTPUT, @p_status_code OUTPUT, @p_result OUTPUT
    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF @p_result = 1
    BEGIN
      SET @p_result = 2
      SET @p_status_code = 2
    END

  END

  --**********************************
  -- XML File Load
  --**********************************
  IF @v_lt_type = 'X'
  BEGIN
    SET @v_step = 3300
    EXEC Ws_Act_Host_Script @p_sequence,@p_obj_type,@p_action, @p_obj_key,
        @p_job_name, @p_task_name, @p_job_id, @p_task_id,
        @p_return_msg OUTPUT, @p_status_code OUTPUT, @p_result OUTPUT
    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF @p_result = 1
    BEGIN
      SET @p_result = 2
      SET @p_status_code = 2
    END

  END

  --**********************************
  -- Script Load
  --**********************************
  IF @v_lt_type = 'S'
  BEGIN
    SET @v_step = 3400
    EXEC Ws_Act_Host_Script @p_sequence,@p_obj_type,@p_action,@p_obj_key,
        @p_job_name, @p_task_name, @p_job_id, @p_task_id,
        @p_return_msg OUTPUT, @p_status_code OUTPUT, @p_result OUTPUT
    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF @p_result = 1
    BEGIN
      SET @p_result = 2
      SET @p_status_code = 2
    END
  END

  --**********************************
  -- ODBC Load
  --**********************************
  IF @v_lt_type = 'O'
  BEGIN
    -- run an ODBC load by returning a result of 3
    SET @p_result = 3
    SET @p_status_code = 2
  END

  --**********************************
  -- Native ODBC Load
  --**********************************
  IF @v_lt_type = 'N'
  BEGIN
    -- run a Native ODBC load by returning a result of 12
    SET @p_result = 12
    SET @p_status_code = 2
  END

  --**********************************
  -- Integration Services Load
  --**********************************
  IF @v_lt_type = 'I'
  BEGIN
    -- run a SSIS load by returning a result of 14
    SET @p_result = 14
    SET @p_status_code = 2
  END

  --**********************************
  -- Apache Sqoop Load
  --**********************************
  IF @v_lt_type = 'A'
  BEGIN
    -- run an Apache Sqoop load by returning a result of 91
    SET @p_return_msg = 'Apache Sqoop load'
    SET @p_result = 91
    SET @p_status_code = 2
  END

  --**********************************
  -- External Load
  --**********************************
  IF @v_lt_type = 'E'
  BEGIN
    SET @p_return_msg = 'Externally loaded'
    SET @p_status_code = 1
    SET @p_result = 1
  END

  --**********************************
  -- Unsupported Load type
  --**********************************
  IF @v_lt_type NOT IN ('D','F','S','O','E','X','N','I','A')
  BEGIN
    SET @v_msgtext = 'Unsupported Load Type '
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name, @p_sequence,
                      @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    SET @p_return_msg = 'Unsupport load type in ' + @v_ws_pro_version
    SET @p_status_code = -2
    SET @p_result = -2
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Load') >= -1
    BEGIN
      DEALLOCATE c_Load
    END

    -- Roll back any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Pre_Drop 
-- Notes / History
--
-- WMR 30/08/2001 Version 0.3.0.6 Added support for Primary Keys
-- WMR 21/01/2002 Version 1.0.0.0 Added support for Partitioned indexes
-- WMR 29/10/2002 Version 1.2.1.4 Converted to SQL Server
-- AP  01/08/2006 Version 5.5.0.5 Add Version Number as constant to out messages
--                                 Add call to wswrkerror for each index as drop/built
--                                 Corrected counts for when actually indexes dropped
--                                 Separated out check of existence for drop
--                                 Corrected setting of job task in call to wwrkaudit
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  30/10/2009 Version 6.0.5.2 RED-1329 New options on index create.
-- AP  31/03/2010 Version 6.1.0.1 RED-1493 Order added to index to do clustered LAST
-- MXU 31/10/2013 Version 6.7.4.1 RED_3264:Index create failure in scheduler causes failure in subsequent task index drop
-- HM  19/08/2014 Version 6.8.1.2 RED-3906 Add Schema support
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  08/02/2017 Version 6.8.7.1 RED-7757 Added multi-database support (3-part naming)
-- HM  21/02/2017 Version 6.8.7.1 RED-7796 Search for index to drop in correct database
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Pre_Drop
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      : SQl Server
  -- Script Name    : ws_act_pre_drop
  -- Description    : Drop any indexes specified as being dropped
  --                  before an update occurs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Pre_Drop(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext            varchar(1024) -- Text in audit_trail
  , @v_step               integer       -- step
  , @v_stmt               nvarchar(4000)
  , @v_row_count          integer
  , @v_db_code            varchar(10)   -- Database error code
  , @v_db_msg             varchar(1024) -- Database error message
  , @v_count              integer       -- counter
  , @v_index_exist        integer       -- counter for index existence
  , @v_table_database     varchar(64)
  , @v_table_schema       varchar(64)
  , @v_table_name         varchar(64)
  , @v_table_with_owner   varchar(256)

  DECLARE
    @v_ih_unique          varchar(1)
  , @v_ih_key_type        varchar(1)
  , @v_ih_table           varchar(64)
  , @v_ih_index_name      varchar(64)

  --=====================================================
  -- Cursor for all indexes
  --=====================================================
  DECLARE c_Index CURSOR LOCAL FAST_FORWARD READ_ONLY FOR --RED_3264
    SELECT
      ih_unique
    , ih_key_type
    , ih_table
    , ih_index_name
    FROM
      ws_index_header
    WHERE ih_obj_key = @p_obj_key
    AND   ih_pre_drop_flag = 'Y'
    ORDER BY ISNULL( ih_clustered_ind,'N') ASC  -- RED_1493


  SET @v_count = 0
  SELECT @v_step = 100

  BEGIN TRY

  -- needs to look up the database and schema from ws_dbc_target for the indexed tables schema
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
           , @v_table_name = oo_name
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_name

  --=====================================================
  -- Loop through all the indexes to drop
  -- May not be any
  --=====================================================
  SET @p_status_code = 1
  SET @p_result = 1
  SET @p_return_msg = ''

  SET @v_step = 200
  OPEN c_Index
  FETCH NEXT FROM c_Index INTO
    @v_ih_unique
  , @v_ih_key_type
  , @v_ih_table
  , @v_ih_index_name

  WHILE @@FETCH_STATUS = 0
  BEGIN
    SELECT @v_step = 300

    -- Azure SQL Database does not support 'DROP INDEX IF EXITS' so we have to do this
    SET @v_index_exist = 0
    SET @v_stmt = @v_table_database
    IF NULLIF(@v_stmt,'') IS NOT NULL
    BEGIN
        SET @v_stmt = @v_stmt + '.'
    END
    SET @v_stmt =
        'SELECT @v_index_exist = COUNT(*) FROM ' + @v_stmt + 'sys.indexes' +
        ' WHERE name = ''' + @v_ih_index_name + '''' +
        ' AND object_id = OBJECT_ID(''' + @v_table_with_owner + ''')'
        ;

    -- While it looks like output param isn't needed here (just checking ROWCOUNT should be fine) this is not the case.
    -- Accessing ROWCOUNT after EXECing the above statement when database IS SET fails catastrophically.  You CAN do it
    -- interactively in Management Studio, it works fine there, but in a stored procedure it causes a silent crash.
    -- Sometimes it returns correct value and then crashes on the next step, other times it crashes on ROWCOUNT access.
    -- Tested on 2016 and 2012.
    EXECUTE sp_executesql @v_stmt, N'@v_index_exist integer OUTPUT', @v_index_exist = @v_index_exist OUTPUT

    IF @v_index_exist > 0
    BEGIN
      IF @v_ih_unique = 'Y' AND @v_ih_key_type = 'A'
      BEGIN
        SET @v_stmt = 'ALTER TABLE ' + @v_table_with_owner + ' DROP CONSTRAINT ' + @v_ih_index_name
      END
      ELSE
      BEGIN
        SET @v_stmt = 'DROP INDEX ' + @v_ih_index_name + ' ON ' + @v_table_with_owner
      END

      SELECT @v_step = 400
      EXEC ( @v_stmt )
      SELECT @v_row_count = @@ROWCOUNT

      BEGIN
        SET @v_count = @v_count + 1

        SET @p_status_code = 1
        SET @v_msgtext = 'Index ' + @v_table_with_owner + '.' + @v_ih_index_name + ' dropped.'

        --=====================================================
        -- Put detail message
        --=====================================================
        SELECT @v_step = 500

        EXEC WsWrkError
          @p_status_code = 'I'
        , @p_job_name    = @p_job_name
        , @p_task_name   = @p_task_name
        , @p_sequence    = @p_sequence
        , @p_message     = @v_msgtext
        , @p_db_code     = NULL
        , @p_db_msg      = NULL
        , @p_task_key    = @p_task_id
        , @p_job_key     = @p_job_id
        , @p_msg_type    = NULL
      END -- return status check
    END -- index existed

    FETCH NEXT FROM c_Index INTO
      @v_ih_unique
    , @v_ih_key_type
    , @v_ih_table
    , @v_ih_index_name
  END

  CLOSE c_Index
  DEALLOCATE c_Index


  SELECT @v_step = 600
  -- tell them how many indexes we dropped
  IF @v_count = 0
  BEGIN
    SET @p_return_msg = 'No indexes to drop. ' + @p_return_msg
  END
  IF @v_count = 1
  BEGIN
    SET @p_return_msg = '1 index dropped. '
  END
  IF @v_count > 1
  BEGIN
    SET @p_return_msg = CONVERT(varchar,@v_count) + ' indexes dropped. '
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Index') >= -1 -- RED_3264
    BEGIN                                     -- RED_3264
      DEALLOCATE c_Index                      -- RED_3264
    END                                       -- RED_3264
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Post_Load 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- WMR 30/10/2002 Version 1.2.1.4 Converted to sql server
-- AP  19/03/2009 Version 6.0.3.1 New trapping of sql dependency error (@@trancount)
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2011 Version 6.5.5.1 RED-2382 Support Block Procedural Code
-- AP  17/11/2014 Version 6.8.1.2 Schema Support
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- BC  11/04/2017 Version 6.8.8.0 RED-8081 Fixed after-load transformations to use three-part naming for Multi-database support.
-- HM  03/05/2017 Version 6.9.1.0 RED-7969 Do not update DSS_LOAD_DATE if already set
-- BC  17/07/2018 Version 8.3.1.0 RED-9312 Invoke procedure using fully-qualified procedure name.
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- BC  12/11/2018 Version 8.3.1.0 RED-9978 Increase size of procedure name variable to hold qualified name.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Post_Load
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name         : SQL Server
  -- Script Name       : ws_act_post_load
  -- Description       : Execute the post load procedure associated with
  --                      a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Post_Load(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext                                      varchar(1024) -- Text in audit_trail
  , @v_step                                         integer       -- step
  , @v_procedure_status                             integer
  , @v_row_count                                    integer
  , @v_db_code                                      varchar(10)   -- Database error code
  , @v_db_msg                                       varchar(1024) -- Database error message
  , @v_after_msg                                    varchar(1024) -- Text from an after transformation
  , @v_proc_msg                                     varchar(1024) -- Text from a post load procedure
  , @v_procedure_key                                integer
  , @v_procedure                                    varchar(256)
  , @v_procedure_type                               varchar(1)
  , @v_stmt                                         varchar(4000)
  , @v_stmt2                                        varchar(4000)
  , @v_stmt3                                        varchar(4000)
  , @v_stmt4                                        varchar(4000)
  , @v_stmt5                                        varchar(4000)
  , @v_stmt_length                                  integer
  , @v_exp_length                                   integer
  , @v_row                                          integer
  , @v_len                                          integer
  , @v_len2                                         integer
  , @v_len3                                         integer
  , @v_dss_load_date_name                           varchar(255)  -- Configured name for DSS_LOAD_DATE
  , @v_run_after_load_transform_on_new_records_only integer

  --=====================================================
  -- Load Table Variables
  --=====================================================
  DECLARE
    @v_lt_pre_action                                varchar(1)
  , @v_lt_table_name                                varchar(64)
  , @v_lt_pre_sql                                   varchar(4000)
  , @v_lt_load_statement                            varchar(4000)
  , @v_lt_type                                      varchar(1)
  , @v_lt_connect_key                               integer
  , @v_lt_schema                                    varchar(64)
  , @v_lt_transform_ind                             varchar(1)
  , @v_lt_non_mandatory_ind                         varchar(1)
  , @v_lt_source_schema                             varchar(64)
  , @v_lt_source_columns                            varchar(4000)
  , @v_lt_from_table                                varchar(4000)
  , @v_lt_where_clause                              varchar(4000)
  , @v_lt_missing_col_act                           varchar(1)
  , @v_table_name                                   varchar(64)
  , @v_table_database                               varchar(64)
  , @v_table_schema                                 varchar(64)
  , @v_table_with_owner                             varchar(256)

  --=====================================================
  -- Load Column Variables
  --=====================================================
  DECLARE
    @v_lc_col_name                                  varchar(64)
  , @v_lc_transform_code                            varchar(4000)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2017

  SET @v_step = 100

  BEGIN TRY

  SET @p_return_msg = ''
  SET @p_result = 1
  SET @v_row = 0
  SET @p_status_code = 1
  SET @v_after_msg = ''

  --=====================================================
  -- Lookup DSS_LOAD_DATE name
  --=====================================================
  SET @v_dss_load_date_name = 'dss_load_date'
  SELECT @v_dss_load_date_name = COALESCE(mn_name, 'dss_load_date')
  FROM  ws_meta_names
  WHERE mn_object = 'dss_load_date'

  --=====================================================
  -- First get the load table information
  --=====================================================
  SELECT
    @v_lt_pre_action = lt_pre_action
  , @v_lt_table_name = lt_table_name
  , @v_lt_pre_sql = lt_pre_sql
  , @v_lt_load_statement = lt_load_statement
  , @v_lt_type = lt_type
  , @v_lt_connect_key = lt_connect_key
  , @v_lt_schema = lt_schema
  , @v_lt_transform_ind = lt_transform_ind
  , @v_lt_non_mandatory_ind = lt_non_mandatory_ind
  , @v_lt_source_schema = lt_source_schema
  , @v_lt_source_columns = lt_source_columns
  , @v_lt_from_table = lt_from_table
  , @v_lt_where_clause = lt_where_clause
  , @v_lt_missing_col_act = lt_missing_col_act
  FROM   ws_load_tab
  WHERE  lt_obj_key = @p_obj_key

  SET @v_step = 200

  --needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
           , @v_table_name = oo_name
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_name

  SET @v_step = 250

  --=====================================================
  -- Perform any after load transformations
  --=====================================================
  IF ISNULL(@v_lt_transform_ind,'N') = 'Y'
  OR ISNULL(@v_lt_type,'D') in ('F','S','E')
  BEGIN
    --=====================================================
    -- Transformation
    --=====================================================
    SET @v_stmt2 = ''
    SET @v_stmt3 = ''
    SET @v_stmt4 = ''
    SET @v_stmt5 = ''

    --=====================================================
    -- Cursor for all columns in the load table
    --=====================================================
    SET @v_step = 300
    DECLARE c_Load CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT
        lc_col_name
      , lc_transform_code
      FROM  ws_load_col
      WHERE lc_obj_key = @p_obj_key
      AND   lc_transform_type = 'A'
      ORDER BY lc_order

    OPEN c_Load
    FETCH NEXT FROM c_Load INTO
      @v_lc_col_name
    , @v_lc_transform_code

    SET @v_run_after_load_transform_on_new_records_only = 0

    WHILE @@FETCH_STATUS = 0
    BEGIN
      SET @v_step = 400
      IF @v_lc_transform_code <> ''
      BEGIN
        SET @v_row = @v_row + 1
        IF @v_row > 1
        BEGIN
         SET @v_stmt2 = @v_stmt2 + ','
        END
        -- If we have nearly filled this statement then use another
        SET @v_exp_length = LEN(@v_lc_col_name + ' = ' + RTRIM(@v_lc_transform_code))
        IF @v_exp_length > 4000 - 2
        BEGIN
          SET @v_db_code = NULL
          SET @v_db_msg = NULL

          SET @p_return_msg = 'Maximum length for post load expression exceeded (> 4000 chars) for '  + @p_task_name
          SET @p_status_code = -2
          SET @p_result = -2

          CLOSE c_Load
          DEALLOCATE c_Load
          RETURN 0
        END

        SET @v_stmt_length = LEN(@v_stmt2 + @v_lc_col_name + ' = ' + RTRIM(@v_lc_transform_code))
        IF @v_stmt_length > 4000
        BEGIN
          IF @v_stmt3 = ''
          BEGIN
            SET @v_stmt3 = @v_stmt2
            SET @v_stmt2 = ''
          END
          IF @v_stmt4 = ''
          BEGIN
            SET @v_stmt4 = @v_stmt2
            SET @v_stmt2 = ''
          END
          IF @v_stmt5 = ''
          BEGIN
            SET @v_stmt5 = @v_stmt2
            SET @v_stmt2 = ''
          END
          ELSE
          BEGIN
            SET @v_db_code = NULL
            SET @v_db_msg = NULL

            SET @p_return_msg = 'Maximum combined length (> 20000 chars) of transformation expressions exceeded for '  + @p_task_name

            SET @p_status_code = -2
            SET @p_result = -2

            CLOSE c_Load
            DEALLOCATE c_Load

            RETURN 0
          END
        END
        SET @v_stmt2 = @v_stmt2 + @v_lc_col_name + ' = '
        SET @v_stmt2 = @v_stmt2 + RTRIM(@v_lc_transform_code)

        IF @v_lc_col_name = @v_dss_load_date_name
        BEGIN
            SET @v_run_after_load_transform_on_new_records_only = 1
        END
      END

      FETCH NEXT FROM c_Load INTO
        @v_lc_col_name
      , @v_lc_transform_code

    END -- End of cursor loop

    CLOSE c_Load
    DEALLOCATE c_Load

    SET @v_step = 500
    --=====================================================
    -- See if any columns needed an after transformation
    -- If we have any then do the update
    --=====================================================
    IF LEN(@v_stmt2) > 0
    BEGIN

      --=====================================================
      -- Perform the after transformation update
      --=====================================================
      SET @v_step = 600
      SET @v_stmt = 'UPDATE ' + @v_table_with_owner + ' SET '
      IF @v_run_after_load_transform_on_new_records_only = 1
      BEGIN
        EXEC (@v_stmt+@v_stmt3+@v_stmt4+@v_stmt5+@v_stmt2+' WHERE '+@v_dss_load_date_name+' IS NULL')
      END
      ELSE
      BEGIN
        EXEC (@v_stmt+@v_stmt3+@v_stmt4+@v_stmt5+@v_stmt2)
      END
      SELECT @v_row_count = @@ROWCOUNT

      SET @p_return_msg = CONVERT(varchar,ISNULL(@v_row_count,0)) +
        ' rows updated for ' + @v_lt_table_name + ' '
      SET @v_after_msg = @p_return_msg
    END -- End of we have a transformation to perform
  END -- End of If setup for transformations

  --=====================================================
  -- Get the post load procedure if it exists
  --=====================================================
  SET @v_step = 700
  SET @v_procedure_key = 0
  SELECT
    @v_procedure_key = lt_procedure_key
  FROM ws_load_tab
  WHERE lt_obj_key = @p_obj_key

  SELECT @v_row_count = @@ROWCOUNT

  IF @v_row_count = 0
  OR @v_procedure_key = 0
  BEGIN
    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL

      SET @p_return_msg = 'No post load procedure defined for '  + @p_task_name

      SET @p_status_code = 1
      SET @p_result = 1
      RETURN 0
    END

  END

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET @v_step = 800
  SELECT @v_procedure = CASE WHEN COALESCE(dt_database,'') <> '' THEN dt_database + '.' + COALESCE(dt_schema,'') + '.'
                             WHEN COALESCE(dt_schema,'') <> '' THEN dt_schema + '.' ELSE '' END + ph_name
       , @v_procedure_type = NULLIF(ph_type,'P')
  FROM   ws_pro_header
  JOIN   ws_obj_object ON ph_obj_key = oo_obj_key
  LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
  WHERE  ph_obj_key = @v_procedure_key
  SELECT @v_row_count = @@ROWCOUNT

  IF @v_row_count = 0
  OR @v_procedure IS NULL
  BEGIN
    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire post load procedure name for '  + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0
  END

  SET @v_step = 900
  --=====================================================
  -- IF SQLBLOCK then return for calling
  --=====================================================
  IF @v_procedure_type = 'B'
  BEGIN
    -- run a POST SQLBLOCK by returning a result of 17
    SET @p_result = 17
    SET @p_status_code = 2
    RETURN 0
  END

  --=====================================================
  -- Execute the procedure
  --=====================================================
  -- Execute the procedure
--  BEGIN TRANSACTION
  SET @v_step = 1000
  EXEC @v_procedure_status = @v_procedure
        @p_sequence = @p_sequence
      , @p_job_name = @p_job_name
      , @p_task_name = @p_task_name
      , @p_job_id = @p_job_id
      , @p_task_id = @p_task_id
      , @p_return_msg = @v_proc_msg OUTPUT
      , @p_status = @p_status_code OUTPUT
--  COMMIT

  -- Need to check for open transactions that can occur in SQLServer if procedure references
  -- and object that no longer exists
  -- Sql just bombs out, and cant gracefully trap in procedure!
  IF @@trancount <> 0
  BEGIN
    ROLLBACK
    SET @p_status_code = -3
    SET @p_return_msg = 'Failure when calling post load procedure. View full audit trail for job'

    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Transactions left in open state by procedure'
    , @p_db_code     = NULL
    , @p_db_msg      = NULL
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id
  END

  SET @v_msgtext = LTRIM(RTRIM(@v_after_msg)) + @v_proc_msg
  SET @p_return_msg = substring(@v_msgtext,1,1023)

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Load') >= -1
    BEGIN
      DEALLOCATE c_Load
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Update 
-- Notes / History
--
-- WMR 23/09/2001                     added aggregate support
-- WMR 22/01/2002 Version 1.0.0
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- WMR 26/03/2006 Version 5.6.0.0 Added support for retro copy
-- AP  09/04/2008 Version 6.0.0.0 Added support for ODS/Normal
-- AP  31/12/2008 Version 6.0.2.3 Added support for View
-- AP  19/03/2009 Version 6.0.3.1 New trapping of sql dependency error (@@trancount)
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2011 Version 6.5.5.1 RED-2382 Support Block Procedural Code
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  03/10/2017 Version 8.1.1.0 RED-8704 Adding support for Source Mapping
-- BC  17/07/2018 Version 8.3.1.0 RED-9312 Invoke procedure using fully-qualified procedure name.
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- BC  12/11/2018 Version 8.3.1.0 RED-9978 Increase size of procedure name variable to hold qualified name.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Update
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : SQL Server
  -- Script Name  : ws_act_update
  -- Description  : Execute the update procedure associated with a table
  --
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_obj_source_mapping    integer

  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Update(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_obj_source_mapping    = 69

  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_procedure_key   integer
  , @v_procedure       varchar(256)
  , @v_procedure_type  varchar(1)
  , @v_procedure_status integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_step = 100

  BEGIN TRY

  --=====================================================
  -- Check that we have a valid table type
  --=====================================================
  IF  @p_obj_type <> @v_ws_obj_dim
  AND @p_obj_type <> @v_ws_obj_dim_view
  AND @p_obj_type <> @v_ws_obj_view
  AND @p_obj_type <> @v_ws_obj_fact
  AND @p_obj_type <> @v_ws_obj_fact
  AND @p_obj_type <> @v_ws_obj_fact_kpi
  AND @p_obj_type <> @v_ws_obj_stage
  AND @p_obj_type <> @v_ws_obj_agg
  AND @p_obj_type <> @v_ws_obj_retro_copy
  AND @p_obj_type <> @v_ws_obj_ods
  AND @p_obj_type <> @v_ws_obj_normal
  AND @p_obj_type <> @v_ws_obj_hub
  AND @p_obj_type <> @v_ws_obj_satellite
  AND @p_obj_type <> @v_ws_obj_link
  AND @p_obj_type <> @v_ws_obj_custom1
  AND @p_obj_type <> @v_ws_obj_custom2
  AND @p_obj_type <> @v_ws_obj_cube
  AND @p_obj_type <> @v_ws_obj_cube_virtual
  AND @p_obj_type <> @v_ws_obj_source_mapping
  BEGIN
    SET @v_msgtext = 'Update invalid for object type. Object is ' + @p_task_name +
      '. Table type was ' + CONVERT(varchar,ISNULL(@p_obj_type,-1))
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name, @p_sequence,
                  @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    SET @p_status_code = -2
    SET @p_result = -2
    RETURN 0
  END

  SET @v_step = 200
  --**********************************
  -- CUBE and CUBE Virtual processing
  --**********************************
  IF @p_obj_type = @v_ws_obj_cube
  OR @p_obj_type = @v_ws_obj_cube_virtual
  BEGIN
    -- run a Cube process by returning a result of 5
    SET @p_result = 5
    SET @p_status_code = 5
    RETURN 0
  END

  --=====================================================
  -- See what table we have and get the update procedure
  --=====================================================
  SET @v_step = 300
  SET @p_result = 1
  SET @v_procedure_key = 0

  IF @p_obj_type = @v_ws_obj_dim
  BEGIN
      SET @v_step = 400
      SELECT @v_procedure_key = dt_update_key
      FROM ws_dim_tab
      WHERE dt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_dim_view
  BEGIN
      SET @v_step = 500
      SELECT @v_procedure_key = dt_update_key
      FROM ws_dim_tab
      WHERE dt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_view
  BEGIN
      SET @v_step = 600
      SELECT @v_procedure_key = vt_update_key
      FROM ws_view_tab
      WHERE vt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_fact
  BEGIN
      SET @v_step = 700
      SELECT @v_procedure_key = ft_update_key
      FROM ws_fact_tab
      WHERE ft_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_fact_kpi
  BEGIN
      SET @v_step = 800
      SELECT @v_procedure_key = ft_update_key
      FROM ws_fact_tab
      WHERE ft_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_stage
  BEGIN
      SET @v_step = 900
      SELECT @v_procedure_key = st_update_key
      FROM ws_stage_tab
      WHERE st_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_agg
  BEGIN
      SET @v_step = 1000
      SELECT @v_procedure_key = at_update_key
      FROM ws_agg_tab
      WHERE at_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_retro_copy
  BEGIN
      SET @v_step = 1100
      SELECT @v_procedure_key = rt_update_key
      FROM ws_retro_tab
      WHERE rt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_ods
  BEGIN
      SET @v_step = 1200
      SELECT @v_procedure_key = ot_update_key
      FROM ws_ods_tab
      WHERE ot_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_normal
       OR @p_obj_type = @v_ws_obj_hub
       OR @p_obj_type = @v_ws_obj_satellite
       OR @p_obj_type = @v_ws_obj_link
       OR @p_obj_type = @v_ws_obj_custom1
       OR @p_obj_type = @v_ws_obj_custom2
  BEGIN
      SET @v_step = 1300
      SELECT @v_procedure_key = nt_update_key
      FROM ws_normal_tab
      WHERE nt_obj_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END
  ELSE IF @p_obj_type = @v_ws_obj_source_mapping
  BEGIN
      SET @v_step = 1400
      SELECT @v_procedure_key = smt_update_key
      FROM ws_source_mapping_tab
      WHERE smt_source_mapping_key = @p_obj_key
      SELECT @v_row_count = @@ROWCOUNT
  END

  IF @v_row_count = 0
  OR @v_procedure_key = 0
  OR @v_procedure_key = ''
  BEGIN

    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire update procedure for ' + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id

    BEGIN
      SET @v_msgtext = 'Please check that an update procedure has been defined'
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
            @p_return_msg,NULL,NULL, @p_task_id, @p_job_id
    END
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET @v_step = 1400
  SELECT @v_procedure = CASE WHEN COALESCE(dt_database,'') <> '' THEN dt_database + '.' + COALESCE(dt_schema,'') + '.'
                             WHEN COALESCE(dt_schema,'') <> '' THEN dt_schema + '.' ELSE '' END + ph_name
       , @v_procedure_type = NULLIF(ph_type,'P')
  FROM   ws_pro_header
  JOIN   ws_obj_object ON ph_obj_key = oo_obj_key
  LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
  WHERE  ph_obj_key = @v_procedure_key
  SELECT @v_row_count = @@ROWCOUNT

  IF @v_row_count = 0
  OR @v_procedure IS NULL
  BEGIN
    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire update procedure name for '  + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0
  END

  SET @v_step = 1500
  --=====================================================
  -- IF SQLBLOCK then return for calling
  --=====================================================
  IF @v_procedure_type = 'B'
  BEGIN
    -- run a UPDATE SQLBLOCK by returning a result of 16
    SET @p_result = 16
    SET @p_status_code = 2
    RETURN 0
  END

  --=====================================================
  -- Execute the procedure
  --=====================================================
  -- Execute the procedure
--  BEGIN TRANSACTION
  SET @p_status_code = -3
  SET @p_return_msg = 'Failure when calling update procedure. View full audit trail for job'
  SET @v_step = 1600
  EXEC @v_procedure_status = @v_procedure
        @p_sequence = @p_sequence
      , @p_job_name = @p_job_name
      , @p_task_name = @p_task_name
      , @p_job_id = @p_job_id
      , @p_task_id = @p_task_id
      , @p_return_msg = @p_return_msg OUTPUT
      , @p_status = @p_status_code OUTPUT
--  COMMIT

  SET @v_step = 1700
  -- Need to check for open transactions that can occur in SQLServer if procedure references
  -- and object that no longer exists
  -- Sql just bombs out, and cant gracefully trap in procedure!
  IF @@trancount <> 0
  BEGIN
    ROLLBACK
    SET @p_status_code = -3
    SET @p_return_msg = 'Failure when calling update procedure. View full audit trail for job'

    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Transactions left in open state by procedure'
    , @p_db_code     = NULL
    , @p_db_msg      = NULL
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id
  END

  IF @v_procedure_status <> 0
  BEGIN

    SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
         , @v_db_msg  = ERROR_MESSAGE()


    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Failure when executing procedure'
    , @p_db_code     = @v_db_code
    , @p_db_msg      = @v_db_msg
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id

    SET @p_return_msg = 'Unhandled Exception in ' + @v_ws_pro_version + ' step ' + convert(varchar,@v_step)
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END

  IF @p_status_code < -1
  BEGIN
    SET @p_result = -3
    RETURN 0

  END

  SET @v_step = 1800

  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Truncate 
-- Notes / History
--
-- WMR 01/03/2005 Version 4.1.1.3
-- AP  09/04/2008 Version 6.0.0.0  Added support for ODS/Normal
-- AP  10/06/2008 Version 6.0.4.1  Changes to work-flow locking.and 2005+ TRY
-- HM  19/08/2014 Version 6.8.1.2  Added Schema support
-- AP  23/07/2015 Version 6.8.4.3  RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- TA  01/02/2017 Version 6.8.7.1  RED-7757 Added multi-database support (3-part naming)
-- HM  15/10/2018 Version 8.3.1.0  RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Truncate
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : SQLServer
  -- Script Name  : ws_act_truncate
  -- Description  : Truncate a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Truncate(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext            varchar(1024) -- Text in audit_trail
  , @v_step               integer       -- step
  , @v_stmt               nvarchar(4000)
  , @v_row_count          integer
  , @v_db_code            varchar(10)   -- Database error code
  , @v_db_msg             varchar(1024) -- Database error message
  , @v_truncate           varchar(8000)
  , @v_table_database     varchar(64)
  , @v_table_schema       varchar(64)
  , @v_table_name         varchar(64)
  , @v_table_with_owner   varchar(256)

  SET @v_step = 100

  BEGIN TRY

  -- needs to look up the database and schema from ws_dbc_target
  SELECT     @v_table_database = COALESCE(dt_database, '')
           , @v_table_schema = COALESCE(dt_schema, '')
           , @v_table_name = oo_name
  FROM       ws_obj_object
  LEFT JOIN  ws_dbc_target
  ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
  WHERE      ws_obj_object.oo_obj_key = @p_obj_key

  SET @v_table_database = LTRIM(RTRIM(@v_table_database))
  SET @v_table_with_owner = @v_table_database
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_schema = LTRIM(RTRIM(@v_table_schema))
  SET @v_table_with_owner = @v_table_with_owner + @v_table_schema
  IF NULLIF(@v_table_with_owner,'') IS NOT NULL
  BEGIN
    SET @v_table_with_owner = @v_table_with_owner + '.'
  END

  SET @v_table_with_owner = @v_table_with_owner + @v_table_name

  --=====================================================
  -- Handle all the table types
  --=====================================================
  --=====================================================
  -- L O A D
  --=====================================================
  IF @p_obj_type = @v_ws_obj_load
  --=====================================================
  -- D I M E N S I O N
  --=====================================================
  OR @p_obj_type = @v_ws_obj_dim
  --=====================================================
  -- F A C T
  --=====================================================
  OR @p_obj_type = @v_ws_obj_fact
  OR @p_obj_type = @v_ws_obj_fact_kpi
  --=====================================================
  -- R E T R O      C O P Y
  --=====================================================
  OR @p_obj_type = @v_ws_obj_retro_copy
  --=====================================================
  -- S T A G E
  --=====================================================
  OR @p_obj_type = @v_ws_obj_stage
  --=====================================================
  -- A G G R E G A T E
  --=====================================================
  OR @p_obj_type = @v_ws_obj_agg
  --=====================================================
  -- O D S
  --=====================================================
  OR @p_obj_type = @v_ws_obj_ods
  --=====================================================
  -- N O R M A L
  --=====================================================
  OR @p_obj_type = @v_ws_obj_normal
  --=====================================================
  -- H U B
  --=====================================================
  OR @p_obj_type = @v_ws_obj_hub
  --=====================================================
  -- S A T E L L I T E
  --=====================================================
  OR @p_obj_type = @v_ws_obj_satellite
  --=====================================================
  -- L I N K
  --=====================================================
  OR @p_obj_type = @v_ws_obj_link
  --=====================================================
  -- C U S T O M 1
  --=====================================================
  OR @p_obj_type = @v_ws_obj_custom1
  --=====================================================
  -- C U S T O M 2
  --=====================================================
  OR @p_obj_type = @v_ws_obj_custom2
 BEGIN
    SET @v_step = 1500

    --=====================================================
    -- Build the truncate string
    --=====================================================
    SET @v_truncate = 'Truncate table ' + @v_table_with_owner

    --=====================================================
    -- Execute the truncate statement
    --=====================================================
    SET @v_step = 1600
    EXEC ( @v_truncate )
    SELECT @v_row_count = @@ROWCOUNT

    SET @p_status_code = 1
    SET @p_result = 1
    SET @p_return_msg = 'Table truncated ' + @v_table_with_owner
    RETURN 0

  END


  --=====================================================
  -- Unsupported object type
  --=====================================================
  SET @p_return_msg = 'Unsupported object type '
                    + CONVERT(varchar,ISNULL(@p_obj_type,-1))
                    + ' in ' + @v_ws_pro_version
  SET @p_status_code = -2
  SET @p_result = -2

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Export 
-- Notes / History
--
-- JML 17/04/2007 Version 5.6.0.0
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- HM  18/11/2014 Version 6.8.1.2 Fix unhandled exception error message
-- TA  20/05/2015 Version 6.8.3.4 RED-5063 Handle SSIS Export
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Export
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      : SQL Server
  -- Script Name    : ws_act_export
  -- Description    : Exports an export object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_user1             integer
  , @v_ws_obj_user2             integer
  , @v_ws_obj_user3             integer
  , @v_ws_obj_user4             integer
  , @v_ws_obj_user5             integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Export(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_report            = 16
  , @v_ws_obj_user1             = 17
  , @v_ws_obj_user2             = 18
  , @v_ws_obj_user3             = 19
  , @v_ws_obj_user4             = 20
  , @v_ws_obj_user5             = 21
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_result          integer       -- return code
  , @v_row             integer
  , @v_stmt            nvarchar(4000)
  , @v_MissingMsg      varchar(4000) -- Message for missing columns

  --=====================================================
  -- Connection Variables
  --=====================================================
  DECLARE
    @v_dc_host_id      varchar(64)
  , @v_dc_dblink_id    varchar(1024)

  --=====================================================
  -- Export Table Variables
  --=====================================================
  DECLARE
    @v_et_pre_action   varchar(1)
  , @v_et_table_name   varchar(64)
  , @v_et_pre_sql      varchar(4000)
  , @v_et_type         varchar(1)

  SET @v_row = 0
  SET @v_step = 100

  BEGIN TRY

  SET @p_result = 1
  SET @v_MissingMsg = NULL

  --=====================================================
  -- First get the export table information
  --=====================================================
  SELECT
    @v_et_table_name = et_table_name
  , @v_et_pre_action = et_pre_action
  , @v_et_pre_sql = et_pre_sql
  , @v_et_type = et_type
  FROM   ws_export_tab
  WHERE  et_obj_key = @p_obj_key

  SET @v_step = 200

  --=====================================================
  -- Handle any pre-export action
  --=====================================================
  IF @v_et_pre_action = 'E'
  BEGIN
    SET @v_stmt = rtrim(@v_et_pre_sql)
    SET @v_step = 300

    EXEC (@v_stmt)
    SELECT @v_row_count = @@ROWCOUNT

    BEGIN
      SET @v_msgtext = SUBSTRING('Execute pre export sql. ' + ISNULL(@v_et_pre_sql,'NULL'),1,1023)

      EXEC @v_result = WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
                    @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    END

  END

  --=====================================================
  -- See what type of export this is
  -- S = Script based export
  -- F = File based export
  -- I = Integration Services export
  -- E = External export
  --=====================================================
  --**********************************
  -- File export
  --**********************************
  IF @v_et_type = 'F'
  BEGIN
    SET @v_step = 400

    EXEC Ws_Act_Host_Script @p_sequence,@p_obj_type,@p_action, @p_obj_key,
        @p_job_name, @p_task_name, @p_job_id, @p_task_id,
        @p_return_msg OUTPUT, @p_status_code OUTPUT, @p_result OUTPUT
    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF @p_result = 1
    BEGIN
      SET @p_result = 2
      SET @p_status_code = 2
    END

  END

  --**********************************
  -- Script export
  --**********************************
  IF @v_et_type = 'S'
  BEGIN
    SET @v_step = 500

    EXEC Ws_Act_Host_Script @p_sequence,@p_obj_type,@p_action,@p_obj_key,
        @p_job_name, @p_task_name, @p_job_id, @p_task_id,
        @p_return_msg OUTPUT, @p_status_code OUTPUT, @p_result OUTPUT
    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF @p_result = 1
    BEGIN
      SET @p_result = 2
      SET @p_status_code = 2
    END
  END

  --**********************************
  -- Integration Services export
  --**********************************
  IF @v_et_type = 'I'
  BEGIN
    -- Indicate to our caller that it needs to perform an SSIS export by
    -- returning a result of 14
    SET @p_return_msg = 'Integration Services export'
    SET @p_result = 14
    SET @p_status_code = 2
  END

  --**********************************
  -- External export
  --**********************************
  IF @v_et_type = 'E'
  BEGIN
    SET @p_return_msg = 'Externally exported'
    SET @p_status_code = 1
    SET @p_result = 1
  END

  --**********************************
  -- Unsupported Export type
  --**********************************
  IF @v_et_type NOT IN ('F','S','I','E')
  BEGIN
    SET @v_msgtext = @v_ws_pro_version + ' Unsupported Export Type '
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name, @p_sequence,
                      @v_msgtext,NULL,NULL, @p_task_id, @p_job_id
    SET @p_return_msg = 'Unsupport export type in ' + @v_ws_pro_version
    SET @p_status_code = -2
    SET @p_result = -2
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_status_code = -2

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Act_Post_Export 
-- Notes / History
--
-- JML 17/04/2007 Version 5.6.0.0
-- AP  19/03/2009 Version 6.0.3.1 New trapping of sql dependency error (@@trancount)
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  17/11/2011 Version 6.5.5.1 RED-2382 Support Block Procedural Code
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Act_Post_Export
  @p_sequence        integer
, @p_obj_type        integer
, @p_action          integer
, @p_obj_key         integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_return_msg      varchar(1024) OUTPUT
, @p_status_code     integer       OUTPUT
, @p_result          integer       OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name        : SQL Server
  -- Script Name      : ws_act_post_export
  -- Description      : Execute the post export procedure associated with
  --                          a export object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Act_Post_Export(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 14
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_procedure_status integer
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_after_msg       varchar(1024) -- Text from an after transformation
  , @v_proc_msg        varchar(1024) -- Text from a post export procedure
  , @v_procedure_key   integer
  , @v_procedure       varchar(64)
  , @v_procedure_type  varchar(1)
  , @v_stmt            varchar(4000)
  , @v_stmt2           varchar(4000)
  , @v_stmt3           varchar(4000)
  , @v_stmt4           varchar(4000)
  , @v_stmt5           varchar(4000)
  , @v_row             integer
  , @v_len             integer
  , @v_len2            integer
  , @v_len3            integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_step = 100

  BEGIN TRY

  SET @p_return_msg = ''
  SET @p_result = 1
  SET @p_status_code = 1
  SET @v_after_msg = ''

  --=====================================================
  -- Get the post export procedure if it exists
  --=====================================================
  SET @v_procedure_key = 0
  SELECT
    @v_procedure_key = et_procedure_key
  FROM ws_export_tab
  WHERE et_obj_key = @p_obj_key

  SELECT @v_row_count = @@ROWCOUNT

  SET @v_step = 200
  IF  @v_row_count = 0
  OR @v_procedure_key = 0
  BEGIN
    SET @v_step = 300

    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL

      SET @p_return_msg = 'No post export procedure defined for '  + @p_task_name
--      EXEC WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
--            @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id

      SET @p_status_code = 1
      SET @p_result = 1
      RETURN 0
    END

  END

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET @v_step = 400
  SELECT @v_procedure      = ph_name
       , @v_procedure_type = NULLIF(ph_type,'P')
  FROM   ws_pro_header
  WHERE  ph_obj_key = @v_procedure_key
  SELECT @v_row_count = @@ROWCOUNT

  SET @v_step = 500
  IF @v_row_count = 0
  OR @v_procedure iS NULL
  BEGIN
    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END
    SET @p_return_msg = 'Unable to acquire post export procedure name for '  + @p_task_name
    EXEC WsWrkAudit 'F', @p_job_name, @p_task_name, @p_sequence,
          @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0
  END


  SET @v_step = 600
  --=====================================================
  -- IF SQLBLOCK then return for calling
  --=====================================================
  IF @v_procedure_type = 'B'
  BEGIN
    -- run a POST SQLBLOCK by returning a result of 17
    SET @p_result = 17
    SET @p_status_code = 2
    RETURN 0
  END

  --=====================================================
  -- Execute the procedure
  --=====================================================
  -- Execute the procedure
  SET @v_step = 700
  EXEC @v_procedure_status = @v_procedure
        @p_sequence = @p_sequence
      , @p_job_name = @p_job_name
      , @p_task_name = @p_task_name
      , @p_job_id = @p_job_id
      , @p_task_id = @p_task_id
      , @p_return_msg = @v_proc_msg OUTPUT
      , @p_status = @p_status_code OUTPUT

  -- Need to check for open transactions that can occur in SQLServer if procedure references
  -- and object that no longer exists
  -- Sql just bombs out, and cant gracefully trap in procedure!
  IF @@trancount <> 0
  BEGIN
    ROLLBACK
    SET @p_status_code = -3
    SET @p_return_msg = 'Failure when calling post export procedure. View full audit trail for job'

    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Transactions left in open state by procedure'
    , @p_db_code     = NULL
    , @p_db_msg      = NULL
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id
  END

  IF @v_procedure_status <> 0
  BEGIN
    SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
         , @v_db_msg  = ERROR_MESSAGE()
    EXEC WsWrkAudit
      @p_status_code = 'E'
    , @p_job_name    = @p_job_name
    , @p_task_name   = @p_task_name
    , @p_sequence    = @p_sequence
    , @p_message     = 'Failure when executing procedure'
    , @p_db_code     = @v_db_code
    , @p_db_msg      = @v_db_msg
    , @p_task_key    = @p_job_id
    , @p_job_key     = @p_task_id

    SET @p_return_msg = 'Unhandled Exception in '+ @v_ws_pro_version + ' step ' + convert(varchar,@v_step)
    SET @p_status_code = -3
    SET @p_result = -3
    RETURN 0

  END

  SET @v_msgtext = LTRIM(RTRIM(@v_after_msg)) + @v_proc_msg
  SET @p_return_msg = substring(@v_msgtext,1,1023)

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_status_code = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Wait 
-- Notes / History
--
-- WMR 05/11/2001                  Change status to pending when running a job
-- WMR 22/01/2002 Version 1.0.0
-- WMR 05/04/2002 Version 1.0.7    check for the appropriate scheduler type
-- WMR 25/10/2002                  Convert to SQL Server
-- WMR 23/07/2004                  Added job dependencies
-- AP  17/08/2006 Version 5.5.0.5  Add Version Number as constant to some output messages.
--                                 Tidy up of return values,was not setting to -1 when encountered error.
--                                 Corrected for restart to only release based on the job /sequence
--                                   previously only on job so if had 2 occurrences in job_run would
--                                   change both to pending, but would only run the one, leaving one
--                                   in a pending state. This situation arrived at when job dependencies
--                                   fail for the job in successive runs.
--                                 Change to fail-abort any of same job currently flagged as failed
--                                   when failing due to parent dependency failure.
--                                 Changed to set JOB to H rather than F for invalid wjc_type inline
--                                   with how done in oracle version
-- AP 07/05/2007 Ver 5.6.0.0       Check that dependent jobs completed okay.
-- AP 05/02/2009 Ver 6.0.2.3       New handling for resolve jobs stuck in pending state
-- AP 11/05/2009 Ver 6.0.4.1       Safety check added to ensure no other scheduler has updated to run
-- AP 10/06/2008 Version 6.0.4.1   Changes to work-flow locking.and 2005+ TRY
--                                 Corrected issue for if named scheduler does not exist
-- AP 23/07/2015 Version 6.8.4.3   RED-5279 Azure Support
-- BC 14/08/2015 Version 6.8.4.3   RED-5520 Replaced occurrences of the != SQL operator with <>
-- BC 30/03/2016 Version 6.8.5.4   RED-881  Support added to execute Failure Command when job fails due
--                                  to job dependency failure.
--                                          Also moved the delete of a failed Once-only Job Control record
--                                  down to occur last before exiting, so that a Job Run record can be
--                                  added for the failed job.
-- RS 09/08/2016 Version 6.8.6.2   RED-5624 Changed to report first failed job in parent-job dependency
-- HM 15/10/2018 Version 8.3.1.0   RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Job_Wait
  @p_sched_type    varchar(12)
, @p_sched_name    varchar(64)
, @p_job_name      varchar(64) OUTPUT
, @p_task_name     varchar(64) OUTPUT
, @p_restart_flag  varchar(12) OUTPUT
, @p_thread        integer     OUTPUT
, @p_sequence      integer     OUTPUT
, @p_result        integer     OUTPUT
AS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    :  SQL Server
  -- Script Name  :  ws_job_wait
  -- Description  :  Look for a job to execute
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Job_Wait(8.3.1.0)'

  DECLARE
    @v_msgtext                  varchar(255)  -- Text for audit_trail
  , @v_sql                      nvarchar(255) -- Text for sql statements
  , @v_set                      integer       -- commit set
  , @v_analyze_flag             integer       -- analyze flag
  , @v_step                     integer       -- return code
  , @v_update_count             integer       -- no of records updated
  , @v_insert_count             integer       -- no of records inserted
  , @v_count                    integer       -- General counter
  , @v_db_code                  varchar(10)   -- Database error code
  , @v_db_msg                   varchar(100)  -- Database error message

  --=====================================================
  -- General Variables
  --=====================================================
  DECLARE
    @v_result_code              integer
  , @v_row_count                integer       -- General row count
  , @v_job_count                integer
  , @v_thread_count             integer       -- thread count
  , @v_unix                     integer       -- unix scheduler flag
  , @v_windows                  integer       -- win scheduler flag
  , @v_poll                     integer       -- status poll request
  , @v_shut                     integer       -- shutdown request
  , @v_okay                     integer
  , @v_parent_okay              integer
  , @v_fail_job                 integer
  , @v_fail_cmd                 integer
  , @v_waited                   integer
  , @v_job_id                   integer
  , @v_child_job_name           varchar(64)
  , @v_parent_job_name          varchar(64)
  , @v_handled                  integer
  , @v_all_status               integer
  , @v_rec_count                integer
  , @v_result                   integer
  , @v_lock_result              integer
  , @v_wait                     char(12)

  --=====================================================
  -- Cursor Variables
  --=====================================================
  DECLARE
    @v_wjc_name                 varchar(64)
  , @v_wjc_max_threads          integer
  , @v_wjc_job_key              integer
  , @v_wjc_sequence             integer
  , @v_wjc_start_after          datetime
  , @v_wjc_status               varchar(1)
  , @v_now_timel                datetime
  , @v_wjc_scheduler            varchar(12)
  , @v_wjr_name                 varchar(64)
  , @v_wjr_max_threads          integer
  , @v_wjr_sequence             integer
  , @v_wjr_job_key              integer
  , @v_wjr_scheduler            varchar(12)
  , @v_wjc_type                 varchar(1)
  , @v_wjc_start_hour           integer
  , @v_wjc_start_minute         integer
  , @v_cust_sa_hh               integer
  , @v_cust_sa_mm               integer
  , @v_cust_sb_hh               integer
  , @v_cust_sb_mm               integer
  , @v_cust_min                 integer
  , @v_cust_days                integer
  , @v_wjd_parent_job_name      varchar(64)
  , @v_wjd_child_job_name       varchar(64)
  , @v_wjd_first_check_lag      integer
  , @v_wjd_wait_interval        integer
  , @v_wjd_require_parent       varchar(1)
  , @v_wjl_minutes              integer
  , @v_wjl_status               varchar(1)
  , @v_wjl_completed            datetime

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2015
  SET @v_step = 100
  SET @p_job_name = ''
  SET @p_sequence = 0
  SET @v_wjc_job_key = 0

  BEGIN TRY

  --=====================================================
  -- See what schedulers we have available
  --=====================================================
  Select @v_unix = ISNULL(COUNT(*),0)
  From   ws_wrk_scheduler
  Where  ws_type_ind = 'U'
  And    ws_stop_date is null
  And    DATEDIFF(mi,GETDATE(),ws_active_date) < 15

  SET @v_step = 200

  Select @v_windows = ISNULL(COUNT(*),0)
  From   ws_wrk_scheduler
  Where  ws_type_ind = 'W'
  And    ws_stop_date is null
  And    DATEDIFF(mi,GETDATE(),ws_active_date) < 15

  SET @v_step = 300
  --=====================================================
  -- See if a poll or shut-down requested for this scheduler
  --=====================================================
  SELECT @v_poll = ws_poll_flag
        ,@v_shut = ws_shut_flag
  FROM   ws_wrk_scheduler
  WHERE  ws_name = @p_sched_name

  --=====================================================
  -- If a shut-down or poll then the appropriate codes
  -- to tell the scheduler to action
  --=====================================================
  SET @p_result = 2
  IF @v_poll <> 0 OR @v_shut <> 0
  BEGIN

    IF @v_poll <> 0
    BEGIN
      SET @p_result = 5
    END

    IF @v_shut <> 0
    BEGIN
      SET @p_result = 9
      SET @v_step = 400

      UPDATE ws_wrk_scheduler
      SET    ws_shut_flag = 0
      WHERE  ws_name = @p_sched_name
    END

    RETURN 0
  END

  SET @v_step = 500
  --=====================================================
  -- Cursor for all ready jobs
  --=====================================================
  DECLARE c_Job CURSOR FAST_FORWARD READ_ONLY FOR
    SELECT wjc_name, wjc_max_threads, wjc_job_key, wjc_sequence,
           wjc_start_after, GETDATE() now_time, wjc_scheduler, wjc_type,
           wjc_start_hour, wjc_start_minute,
           ISNULL(wjc_cust_sa_hh,0) cust_sa_hh,
           ISNULL(wjc_cust_sa_mm,0) cust_sa_mm,
           ISNULL(wjc_cust_sb_hh,0) cust_sb_hh,
           ISNULL(wjc_cust_sb_mm,0) cust_sb_mm,
           ISNULL(wjc_cust_min,0)   cust_min,
           ISNULL(wjc_cust_days,0)  cust_days
    FROM   ws_wrk_job_ctrl
    -- job waiting and ready
    WHERE  ( wjc_status = 'W' AND    wjc_start_after < GETDATE() )
    -- job got 'lost' in pending state for over 5 minutes
    OR     ( wjc_status = 'P' AND    wjc_start_after < GETDATE() AND    DATEADD(mi, 5, wjc_submitted) < GETDATE()  )
    ORDER BY wjc_priority, wjc_start_after

  SET @v_step = 600
  --=====================================================
  -- Loop through the ready jobs
  -- We will just take the first one
  --=====================================================
  OPEN c_Job
  FETCH NEXT FROM c_Job INTO
    @v_wjc_name
  , @v_wjc_max_threads
  , @v_wjc_job_key
  , @v_wjc_sequence
  , @v_wjc_start_after
  , @v_now_timel
  , @v_wjc_scheduler
  , @v_wjc_type
  , @v_wjc_start_hour
  , @v_wjc_start_minute
  , @v_cust_sa_hh
  , @v_cust_sa_mm
  , @v_cust_sb_hh
  , @v_cust_sb_mm
  , @v_cust_min
  , @v_cust_days

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 700
    --=====================================================
    -- See if we match on the requested scheduler
    --=====================================================
    IF ( @v_wjc_scheduler is NULL )
    OR ( @v_wjc_scheduler = @p_sched_type )
    OR ( @v_wjc_scheduler = @p_sched_name )
    OR ( @v_wjc_scheduler = 'WANY' And @p_sched_type = 'WIN' )
    OR ( @v_wjc_scheduler = 'UANY' And @p_sched_type = 'UNIX' )
    OR ( @v_wjc_scheduler = 'WANY' And @v_windows = 0 )
    OR ( @v_wjc_scheduler = 'UANY' And @v_unix = 0 )
    BEGIN
      SET @p_job_name = @v_wjc_name
      SET @p_task_name = 'NO+JOB'
      SET @p_restart_flag = 'NEW'
      SET @p_thread = @v_wjc_max_threads

      SET @v_okay = 1

      --=====================================================
      -- See if the job has any job dependencies
      --=====================================================
      SET @v_child_job_name = @v_wjc_name
      SET @v_fail_job = 0
      SET @v_fail_cmd = 0
      SET @v_waited = DATEDIFF(mi,@v_wjc_start_after, GETDATE())


      SET @v_step = 800
      --=====================================================
      -- Cursor for dependent jobs
      --=====================================================
      DECLARE c_DepJob CURSOR FAST_FORWARD READ_ONLY FOR
        SELECT wjd_parent_job_name, wjd_child_job_name,
               wjd_first_check_lag, wjd_wait_interval, wjd_require_parent
        FROM   ws_wrk_job_dependency
        WHERE  wjd_child_job_name = @v_child_job_name

      SET @v_step = 900
      --=====================================================
      -- Loop through the dependent jobs
      --=====================================================
      OPEN c_DepJob
      FETCH NEXT FROM c_DepJob INTO
        @v_wjd_parent_job_name
      , @v_wjd_child_job_name
      , @v_wjd_first_check_lag
      , @v_wjd_wait_interval
      , @v_wjd_require_parent

      WHILE @@FETCH_STATUS = 0
      BEGIN

        SET @v_step = 1000
        SET @v_parent_job_name = @v_wjd_parent_job_name
        SET @v_parent_okay = 0

        SET @v_step = 1100
        --=====================================================
        -- Check the logs for the job to see if it has finished
        -- Cursor for job logs
        --=====================================================
        DECLARE c_JobLog CURSOR FAST_FORWARD READ_ONLY FOR
          SELECT DATEDIFF(mi,wjl_completed, GETDATE()),
                 wjl_status, wjl_completed
          FROM   ws_wrk_job_log
          WHERE  wjl_name = @v_parent_job_name
          AND    wjl_status = 'C'
          ORDER BY wjl_completed DESC

        SET @v_step = 1200
        --=====================================================
        -- Loop through the job logs
        -- If one has finished within our look-back period then all okay.
        --=====================================================
        OPEN c_JobLog
        FETCH NEXT FROM c_JobLog INTO
          @v_wjl_minutes
        , @v_wjl_status
        , @v_wjl_completed

        WHILE @@FETCH_STATUS = 0
        BEGIN

          SET @v_step = 1300
          -- If job finished in required look back period then all okay
          -- for this parent
          IF @v_wjl_minutes < @v_wjd_first_check_lag
          BEGIN
            SET @v_parent_okay = 1
          END

          -- get next job log
          FETCH NEXT FROM c_JobLog INTO
            @v_wjl_minutes
          , @v_wjl_status
          , @v_wjl_completed

        END -- End of log file checks for this parent
        CLOSE c_JobLog
        DEALLOCATE c_JobLog

        -- If parent not okay then see if we are past our wait time
        -- limit. If not past the limit then keep waiting
        -- If the parent is not required and past the wait limit
        -- then we will accept it as okay else fail it
        IF @v_parent_okay = 0
        BEGIN
          IF @v_waited > @v_wjd_wait_interval
          BEGIN
            IF @v_wjd_require_parent IN ('Y','F')
            BEGIN
              SET @v_fail_job = 1
              SET @v_okay = 0
              IF @v_wjd_require_parent = 'F'
              BEGIN
                SET @v_fail_cmd = 1
              END
              BREAK  -- Stop here to report the first failed parent job
            END
          END
          ELSE
          BEGIN
            SET @v_okay = 0
          END
        END -- end of parent not okay

        -- get next parent job
        FETCH NEXT FROM c_DepJob INTO
          @v_wjd_parent_job_name
        , @v_wjd_child_job_name
        , @v_wjd_first_check_lag
        , @v_wjd_wait_interval
        , @v_wjd_require_parent

      END -- End of dependent job checks

      CLOSE c_DepJob
      DEALLOCATE c_DepJob


      --=====================================================
      -- OKAY to Run get the sequence
      --=====================================================
      IF @v_okay = 1
      BEGIN
        SET @v_step = 1400

        INSERT INTO ws_wrk_sequence(ws_date)
        VALUES (GETDATE())
        SET @p_sequence = SCOPE_IDENTITY()

        BEGIN TRANSACTION JE011

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 1500
        -- Set the job to pending if we plan to run it
        UPDATE ws_wrk_job_ctrl
        SET    wjc_status = 'P'
             , wjc_submitted = GETDATE()
        WHERE  wjc_job_key = @v_wjc_job_key
	    AND  (( wjc_status = 'W' AND    wjc_start_after < GETDATE() )
        OR     ( wjc_status = 'P' AND    wjc_start_after < GETDATE() AND DATEADD(mi, 5, wjc_submitted) < GETDATE()  )
             )

        SELECT @v_row_count = @@ROWCOUNT

        COMMIT TRANSACTION JE011

        IF @v_row_count > 0
        BEGIN
          SET @p_result = 1
        END

        CLOSE c_Job
        DEALLOCATE c_Job
        RETURN 0
      END

      --=====================================================
      -- JOB needs to be FAILED
      --=====================================================
      IF @v_fail_job = 1
      BEGIN

        SET @v_step = 1600
        INSERT INTO ws_wrk_sequence(ws_date)
        VALUES (GETDATE())

        SET @p_sequence = SCOPE_IDENTITY()

        -- Now either modify or delete the control record
        -- and if required delete the task records
        -- If it is a once only job then delete it from job control
        -- If a once and hold then set its status to Hold
        -- In all other cases work out when it will next run
        -- and put it in a wait state.
        SET @v_handled = 0
        IF @v_wjc_type = 'O'
        BEGIN
          SET @v_handled = 1
          -- The delete of the Once-only Job Control record
          -- has been moved down to occur last before exiting, so that
          -- a Job Run record can be added for this failed job.
        END
        ELSE
        BEGIN

          SET @v_step = 1900
          -- Retrieve the next valid start time for this job.
          EXEC Ws_Job_Get_Start @v_wjc_job_key, @v_wjc_start_after OUT, @v_wjc_status OUT, @v_result_code OUT, @v_msgtext OUT

          IF @v_result_code <> 1 -- issue establishing next start
          BEGIN

            SET @v_msgtext = 'Failure to determine next start ' + @v_wjc_name + ' ' + @v_msgtext

            SELECT @v_db_code = CONVERT(varchar, ERROR_NUMBER())
                 , @v_db_msg  = ERROR_MESSAGE()

            EXEC @v_result = WsWrkAudit 'E',@v_wjc_name, @v_wjc_name, @p_sequence,
                                         @v_msgtext,@v_db_code,@v_db_msg,0, @v_wjc_job_key

          END
          ELSE
          BEGIN

            SET @v_step = 2000
            BEGIN TRANSACTION JE013


            SET @v_lock_result = -1
            WHILE @v_lock_result < 0
            BEGIN

              EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                  @LockMode = 'Update',
                                                  @LockTimeout = 0

              IF @v_lock_result < 0
              BEGIN
                SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                WAITFOR DELAY @v_wait
              END

            END

            -- Set new job status and start time.
            -- If in error, then correct values already passed back from Ws_Job_Starttime
            UPDATE ws_wrk_job_ctrl
            SET    wjc_status      = @v_wjc_status
                 , wjc_start_after = @v_wjc_start_after
            WHERE  wjc_job_key     = @v_wjc_job_key

            SELECT @v_rec_count     = @@ROWCOUNT

            COMMIT TRANSACTION JE013

            SET @v_handled = 1
          END
        END

        IF @v_handled = 0 -- issues encountered in determining next run
        BEGIN
          SET @v_step = 2500

          BEGIN TRANSACTION JE019

            SET @v_lock_result = -1
            WHILE @v_lock_result < 0
            BEGIN

              EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                  @LockMode = 'Update',
                                                  @LockTimeout = 0

              IF @v_lock_result < 0
              BEGIN
                SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                WAITFOR DELAY @v_wait
              END

            END

            UPDATE ws_wrk_job_ctrl
            SET    wjc_status = 'H',
                   wjc_start_after = GETDATE()
            WHERE  wjc_job_key = @v_wjc_job_key

            SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE019
        END

        -- 5.5.0.5
        -- CHECK if any JOBS already flagged failed and therefore need aborting
        -- normally processed in ws_job_exec if able to run

        BEGIN TRANSACTION JE020

        SET @v_step = 2600

        SELECT @v_job_count = count(*)
        FROM ws_wrk_job_run
        WHERE wjr_job_key = @v_wjc_job_key
        AND wjr_status = 'F'

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE020

        IF @v_job_count <> 0
        BEGIN
          SET @v_msgtext = 'Job ' + @v_wjc_name + ' has a previously Failed (incomplete) sequence. Now Aborted'
          EXEC @v_result = WsWrkAudit 'W',@v_wjc_name, @v_wjc_name, @p_sequence,
                                                 @v_msgtext,NULL,NULL,0,@v_wjc_job_key

          -- Update the job run record to be completed (Failed-Aborted)
          -- and set the completion date if it is null
          -- Move the job run record to the log record
          SET @v_all_status = 0
          BEGIN TRANSACTION JE021

          SET @v_step = 2700

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource    = 'JOB_RUN',
                                                @LockMode    = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 2800

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource    = 'JOB_LOG',
                                                @LockMode    = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 2900

          UPDATE ws_wrk_job_run
          SET    wjr_status = 'G'
          WHERE  wjr_job_key = @v_wjc_job_key

          SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 3000

          UPDATE ws_wrk_job_run
          SET    wjr_completed = GETDATE()
          WHERE  wjr_job_key = @v_wjc_job_key
          AND    wjr_completed is NULL

          SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 3100

          INSERT INTO ws_wrk_job_log
          SELECT *
          FROM   ws_wrk_job_run
          WHERE  wjr_job_key = @v_wjc_job_key

		  SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 3200

          DELETE FROM ws_wrk_job_run
          WHERE  wjr_job_key = @v_wjc_job_key

          SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE021

          -- Move the task run records to the log record
          SET @v_all_status = 0
          BEGIN TRANSACTION JE022

          SET @v_step = 3300

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 3400

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 3500

          INSERT INTO ws_wrk_task_log
          SELECT *
          FROM   ws_wrk_task_run
          WHERE  wtr_job_key = @v_wjc_job_key

		  SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 3600

          DELETE FROM ws_wrk_task_run
          WHERE  wtr_job_key = @v_wjc_job_key

          SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE022

        END-- old failed jobs to abort

        -- Create the failed Job run record
        BEGIN TRANSACTION JE023

        SET @v_step = 3700

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 3800

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 3900

        INSERT INTO ws_wrk_job_run (
              wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
              wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
              wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
              wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
              wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler)
        SELECT
              wjc_job_key, @p_sequence, 0, 'F', GETDATE(), GETDATE(), GETDATE(), 0,0,
              0,0,0,0,0,wjc_chkp_count,0, wjc_name, wjc_user_key, wjc_max_threads,
              wjc_publish_okay, wjc_publish_fail, wjc_scheduler
        FROM  ws_wrk_job_ctrl
        WHERE wjc_job_key = @v_wjc_job_key

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE023

        SET @v_step = 4000

        --=====================================================
        -- Cursor for all the task control records to be added to task run
        --=====================================================
        BEGIN TRANSACTION JE024
        SET @v_step = 4100

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 4200

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END


        SET @v_step = 4300
        INSERT INTO ws_wrk_task_run (
                wtr_task_key, wtr_job_key, wtr_sequence, wtr_restart, wtr_run_status,
                wtr_audit_status, wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
                wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg, wtr_type,
                wtr_abort_level, wtr_chkp_number, wtr_name, wtr_obj_type, wtr_action_type,
                wtr_obj_key, wtr_thread, wtr_order)
        SELECT
              wtc_task_key,
              wtc_job_key,
              @p_sequence,0,'H',NULL,NULL,NULL,0,0,
              0,0,0,
              'Job dependency failure on job '+@v_parent_job_name,
              wtc_type,
              wtc_abort_level,
              wtc_chkp_number,
              wtc_name,
              wtc_obj_type,
              wtc_action_type,
              wtc_obj_key,
              wtc_order,  -- order into the thread
              wtc_order
        FROM   ws_wrk_task_ctrl
        WHERE  wtc_job_key = @v_wjc_job_key

        SET @v_step = 4400

        COMMIT TRANSACTION JE024

        IF @v_wjc_type = 'O'
        BEGIN
          BEGIN TRANSACTION JE012

          SET @v_step = 4450

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          DELETE
          FROM  ws_wrk_job_ctrl
          WHERE wjc_job_key = @v_wjc_job_key

          SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 4460

          DELETE
          FROM  ws_wrk_task_ctrl
          WHERE wtc_job_key = @v_wjc_job_key

          SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE012

        END

        -- Provide a failure message
        SET @v_msgtext = 'Job ' + @v_wjc_name +
          ' failed dependency on job ' + @v_parent_job_name

        EXEC @v_result = WsWrkAudit 'F',@v_wjc_name, @v_wjc_name, @p_sequence,
                                   @v_msgtext,NULL,NULL,0,@v_wjc_job_key

        IF @v_fail_cmd = 1
        BEGIN
          SET @p_result = -98
        END

        CLOSE c_Job
        DEALLOCATE c_Job
        RETURN 0

      END -- End of fail a job

    END -- 6.0.4.1 End of scheduler match

    -- get the next job to consider for scheduling
    FETCH NEXT FROM c_Job INTO
      @v_wjc_name
    , @v_wjc_max_threads
    , @v_wjc_job_key
    , @v_wjc_sequence
    , @v_wjc_start_after
    , @v_now_timel
    , @v_wjc_scheduler
    , @v_wjc_type
    , @v_wjc_start_hour
    , @v_wjc_start_minute
    , @v_cust_sa_hh
    , @v_cust_sa_mm
    , @v_cust_sb_hh
    , @v_cust_sb_mm
    , @v_cust_min
    , @v_cust_days

  END -- end of Jobs potentially available to process

  CLOSE c_Job
  DEALLOCATE c_Job

  SET @v_step = 4500
  --=====================================================
  -- Cursor for all restarted jobs
  --=====================================================
  DECLARE c_Restart CURSOR FAST_FORWARD READ_ONLY FOR
    SELECT wjr_name, wjr_max_threads, wjr_sequence, wjr_job_key,
           wjr_scheduler
    FROM   ws_wrk_job_run
    WHERE  wjr_status = 'W'

  SET @v_step = 4600
  --=====================================================
  -- Loop through any potential restart jobs
  -- We will just take the first one
  --=====================================================
  OPEN c_Restart
  FETCH NEXT FROM c_Restart INTO
    @v_wjr_name
  , @v_wjr_max_threads
  , @v_wjr_sequence
  , @v_wjr_job_key
  , @v_wjr_scheduler

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 4700
    --=====================================================
    -- See if we match on the requested scheduler
    --=====================================================
    IF ( @v_wjr_scheduler is NULL )
    OR ( @v_wjr_scheduler = @p_sched_type )
    OR ( @v_wjr_scheduler = @p_sched_name )
    OR ( @v_wjr_scheduler = 'WANY' And @p_sched_type = 'WIN' )
    OR ( @v_wjr_scheduler = 'UANY' And @p_sched_type = 'UNIX' )
    OR ( @v_wjr_scheduler = 'WANY' And @v_windows = 0 )
    OR ( @v_wjr_scheduler = 'UANY' And @v_unix = 0 )
    BEGIN

      SET @v_step = 4800
      SELECT @v_thread_count = count(*)
      FROM ws_wrk_job_thread
      WHERE wjt_job_key = @v_wjr_job_key
      AND wjt_sequence = @v_wjr_sequence

      IF @v_thread_count = 0
      BEGIN

        SET @p_job_name = @v_wjr_name
        SET @p_task_name = 'NO+JOB'
        SET @p_restart_flag = 'RESTART'
        SET @p_thread = @v_wjr_max_threads
        SET @p_sequence = @v_wjr_sequence

        BEGIN TRANSACTION JE025
        SET @v_step = 4900

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        -- Set the job to pending if we plan to run it
        UPDATE ws_wrk_job_run
        SET    wjr_status = 'P'
        WHERE  wjr_job_key = @v_wjr_job_key
        --Ver 5.5.0.5 added sequence criteria
        AND    wjr_sequence = @v_wjr_sequence
        AND    wjr_status = 'W'

        SELECT @v_row_count = @@ROWCOUNT

        SET @v_step = 5000

        COMMIT TRANSACTION JE025

        IF @v_row_count > 0
        BEGIN
          SET @p_result = 1
        END

        CLOSE c_Restart
        DEALLOCATE c_Restart
        RETURN 0
      END
    END

    FETCH NEXT FROM c_Restart INTO
      @v_wjr_name
    , @v_wjr_max_threads
    , @v_wjr_sequence
    , @v_wjr_job_key
    , @v_wjr_scheduler

  END

  CLOSE c_Restart
  DEALLOCATE c_Restart

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @v_msgtext = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_job_name, @p_sequence,
        @v_msgtext,@v_db_code, @v_db_msg, 0, @v_wjc_job_key
    END TRY

    -----------
    BEGIN CATCH
    -----------

      IF CURSOR_STATUS('local','c_JobLog') >= -1
      BEGIN                                         
        DEALLOCATE c_JobLog
      END  

      IF CURSOR_STATUS('local','c_DepJob') >= -1
      BEGIN                                         
        DEALLOCATE c_DepJob
      END  

      IF CURSOR_STATUS('local','c_Job') >= -1
      BEGIN                                         
        DEALLOCATE c_Job
      END  

      IF CURSOR_STATUS('local','c_Restart') >= -1
      BEGIN                                         
        DEALLOCATE c_Restart
      END  

      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @v_msgtext    = @v_msgtext
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Abort 
-- Notes / History
--
-- WMR 08/03/2002    Version 1.0.0
-- WMR 06/11/2002    Version 1.2.1 Sql server port
-- WMR 10/02/2004    Version 4.1.0 Put transactions around updates
-- WMR 28/02/2005    Version 4.1.1.3 Handle jobs within jobs
-- WMR 07/07/2006    Version 5.0.1.6 Changed lock check to > 0 from = 0
-- AP  16/08/2006    Version 5.5.0.5 Implemented a lock time-out on the lock call
--                                    this should help address locking issues
-- AP  10/06/2008    Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015    Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015    Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018    Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Job_Abort
  @p_job_name           varchar(64)
, @p_job_sequence       integer
, @p_job_msg            varchar(256)
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name        :	SQL Server
  -- Script Name 		:	ws_job_abort
  -- Description 		:	Abort a job in a running state. Scheduler
  --                                cant find the job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(256) -- Text in audit_trail
  , @v_stmt            varchar(512)
  , @v_step            integer
  , @v_thread_count    integer
  , @v_job_id          integer
  , @v_sid             integer
  , @v_row_count       integer       -- General row count
  , @v_rec_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(100)  -- Database error message
  , @v_lock_result     integer
  , @v_wait            char(12)

  SELECT
    @v_thread_count = 0
  , @v_job_id = 0
  , @v_row_count = 0
  , @v_rec_count = 0
  , @v_ws_pro_version           = 'Ws_Job_Abort(8.3.10)'

  SET @v_step = 100

  BEGIN TRY

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018

  -- Get the job key for the job name. There should be one and
  -- only one key. Otherwise a fatal problem.
  SELECT @v_job_id = wjr_job_key
  FROM   ws_wrk_job_run
  WHERE  rtrim(upper(wjr_name)) = rtrim(upper(@p_job_name))

  SELECT @v_row_count = @@ROWCOUNT

  -- Make sure we are already running (i.e. have a job_run record)
  -- Otherwise a fatal problem.
  SET @v_step = 200

  SELECT @v_rec_count = count(1)
  FROM   ws_wrk_job_run
  WHERE  wjr_job_key  = @v_job_id
  AND    wjr_sequence = @p_job_sequence

  SELECT @v_row_count = @@ROWCOUNT

  IF @v_rec_count = 0
  BEGIN
    SET @v_msgtext = 'Job ' + ISNULL(@p_job_name,'none') +
      ' sequence ' + CONVERT(varchar,ISNULL(@p_job_sequence,-1)) +
      ' not running. Cannot abort. No Action.'

    BEGIN
      SET @v_db_code = NULL
      SET @v_db_msg = NULL
    END

    EXEC WsWrkAudit 'E', @p_job_name, @p_job_name, @p_job_sequence,
      @v_msgtext, @v_db_code, @v_db_msg, 0, @v_job_id
    RETURN 0
  END


  -- Have the job id now hold any tasks not started
  --
  BEGIN TRANSACTION JA001
    SET @v_step = 300

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    -- Halt any child job tasks
    SET @v_step = 400

    UPDATE ws_wrk_task_run
    SET    wtr_run_status = 'H'
    WHERE  wtr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @v_job_id
       AND    wjr_sequence = @p_job_sequence)
    AND   wtr_sequence = @p_job_sequence
    AND   wtr_run_status = 'W'

    SET @v_step = 500
    UPDATE ws_wrk_task_run
    SET   wtr_run_status = 'H'
    WHERE wtr_job_key = @v_job_id
    AND   wtr_sequence = @p_job_sequence
    AND   wtr_run_status = 'W'

  COMMIT TRANSACTION JA001

  -- Flag the job as failed
  --
  BEGIN TRANSACTION JA002
    SET @v_step = 600

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    -- fail any sub jobs
    SET @v_step = 700

    UPDATE ws_wrk_job_run
    SET    wjr_status = 'F',
           wjr_completed = GETDATE()
    WHERE  wjr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @v_job_id
       AND    wjr_sequence = @p_job_sequence)
    AND    wjr_sequence = @p_job_sequence

    SET @v_step = 800
    UPDATE ws_wrk_job_run
    SET    wjr_status = 'F',
           wjr_completed = GETDATE()
    WHERE  wjr_job_key = @v_job_id
    AND    wjr_sequence = @p_job_sequence

  COMMIT TRANSACTION JA002

  -- Fail any running tasks
  --
  BEGIN TRANSACTION JA003
    SET @v_step = 900

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    -- fail any job job tasks
    SET @v_step = 1000

    UPDATE ws_wrk_task_run
    SET    wtr_run_status = 'F',
           wtr_completed = GETDATE(),
           wtr_return_msg = @p_job_msg
    WHERE wtr_job_key IN
      (SELECT wjr_job_key from ws_wrk_job_run where wjr_chkp_count = @v_job_id
       AND   wjr_sequence = @p_job_sequence)
    AND    wtr_sequence = @p_job_sequence
    AND    wtr_run_status = 'R'

    SET @v_step = 1100
    UPDATE ws_wrk_task_run
    SET    wtr_run_status = 'F',
           wtr_completed = GETDATE(),
           wtr_return_msg = @p_job_msg
    WHERE  wtr_job_key = @v_job_id
    AND    wtr_sequence = @p_job_sequence
    AND    wtr_run_status = 'R'

  COMMIT TRANSACTION JA003

  --=====================================================
  -- Cursor to find all active tasks
  --=====================================================
  SET @v_step = 1200
  DECLARE c_Sid CURSOR FAST_FORWARD READ_ONLY FOR
    SELECT wjt_sid
    FROM   ws_wrk_job_thread
--    Where wjt_job_key = @v_job_id
    WHERE wjt_sequence = @p_job_sequence

  --=====================================================
  -- Loop through the ready jobs
  -- We will just take the first one
  --=====================================================
  OPEN c_Sid
  FETCH NEXT FROM c_Sid INTO
    @v_sid

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 1300
    IF @v_sid <> 0
    BEGIN
      -- Kill any running processes
      --
      SET @v_stmt = 'KILL ' + CONVERT(varchar,@v_sid)

      SET @v_step = 1500
      EXEC ( @v_stmt )

      SELECT @v_row_count = @@ROWCOUNT

    END

    FETCH NEXT FROM c_Sid INTO
      @v_sid

  END

  CLOSE c_Sid
  DEALLOCATE c_Sid

  If @p_job_msg <> ''
  BEGIN
    EXEC WsWrkAudit 'E',@p_job_name, @p_job_name, @p_job_sequence,
      @p_job_msg,NULL,NULL,0,@v_job_id
  END

  SET @v_msgtext = 'Job '+ @p_job_name + ' sequence '
                 + CONVERT(varchar,ISNULL(@p_job_sequence,-1)) + ' Aborted. '

  EXEC WsWrkAudit 'F',@p_job_name, @p_job_name, @p_job_sequence,
    @v_msgtext,NULL,NULL,0,@v_job_id

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Sid') >= -1
    BEGIN
      DEALLOCATE c_Sid
    END
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_msgtext    = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_job_name, @p_job_sequence,
        @v_msgtext,@v_db_code, @v_db_msg, 0, @v_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @v_msgtext    = @v_msgtext
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_msgtext,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------


  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Clear_Logs 
-- Notes / History
--
-- WMR 15/10/2003 Version 4.1.0.4
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  21/06/2011 Version 6.5.4.1 RED_2093 Implement to work-flow locking
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- FS  28/07/2017 Version 8.0.1.0 RED-8144 reduced scope of TRANSACTION to avoid deadlock
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Clear_Logs
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_job_to_clean     varchar(64)
, @p_keep_count       integer
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	ws_job_clear_logs
  -- Description 	:	Deletes and archives old job logs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_count       integer
  , @v_del_count       integer
  , @v_job_status      varchar(1)
  , @v_lock_result     integer       -- Result of attempt to secure lock
  , @v_wait            char(12)      -- work field to determine wait period

  SET @v_ws_pro_version           = 'Ws_Job_Clear_Logs(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_job_count = 0
  SET @v_del_count = 0

  SET @v_msgtext = 'Ws_Job_Clear_Logs: '
  + ' job to clean ' + @p_job_to_clean
  + ' keep count ' + CONVERT(VARCHAR,@p_keep_count)

  EXEC @v_result = WsWrkAudit 'I',@p_job_name, @p_task_name, @p_sequence,
                              @v_msgtext, NULL, NULL, @p_task_id, @p_job_id

  -- If zero specified in logs to keep then return
  IF @p_keep_count < 0
  BEGIN
    SET @p_return_code = 'W'
    SET @p_return_msg = 'Job '+ @p_job_to_clean +' negative value passed in log keep count. No action.'
    SET @p_result = 1
    RETURN 0
  END

  --***********************************************************************
  -- Loop through all the logs and archive. Skipp the first n logs
  --***********************************************************************

  DECLARE c_Logs CURSOR READ_ONLY FOR
    SELECT wjl_job_key, wjl_sequence
    FROM   ws_wrk_job_log
    WHERE  wjl_name = @p_job_to_clean
    ORDER BY wjl_sequence DESC

  OPEN c_Logs
  FETCH NEXT FROM c_Logs  INTO
    @v_job_key
  , @v_job_sequence

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 200
    SELECT @v_job_count = @v_job_count + 1

    IF @v_job_count > @p_keep_count
    BEGIN
      -- Have a log to delete so move the tasks, job, audit and error info

      BEGIN TRANSACTION JE001
      SET @v_step = 300

      --RED_2093 Secure a lock on the job log table
      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                             @LockTimeout = 0
        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      -- Copy the audit info to archive
      SET @v_step = 400

      INSERT INTO wx_wrk_audit_archive (
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
      SELECT
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
      FROM
        ws_wrk_audit_log
      WHERE wa_job_key = @v_job_key
      AND   wa_sequence = @v_job_sequence

      SELECT @v_row_count = @@ROWCOUNT

      SELECT @v_del_count = @v_del_count + 1

      -- Delete the audit info
      SET @v_step = 500

      DELETE FROM ws_wrk_audit_log
      WHERE wa_job_key = @v_job_key
      AND   wa_sequence = @v_job_sequence

      -- Copy the detail info to archive
      SET @v_step = 600

      INSERT INTO wx_wrk_error_archive (
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action )
      SELECT
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action
      FROM
        ws_wrk_error_log
      WHERE wd_job_key = @v_job_key
      AND   wd_sequence = @v_job_sequence

      SELECT @v_row_count = @@ROWCOUNT

      SELECT @v_del_count = @v_del_count + 1

      SET @v_step = 700

      -- Delete the detail info
      DELETE FROM ws_wrk_error_log
      WHERE wd_job_key = @v_job_key
      AND   wd_sequence = @v_job_sequence

      SET @v_step = 800

      -- Delete the task log
      DELETE FROM ws_wrk_task_log
      WHERE wtl_job_key = @v_job_key
      AND   wtl_sequence = @v_job_sequence

      SET @v_step = 900

      -- Delete the job log
      DELETE FROM ws_wrk_job_log
      WHERE wjl_job_key = @v_job_key
      AND   wjl_sequence = @v_job_sequence

      COMMIT TRANSACTION JE001
    END

    FETCH NEXT FROM c_Logs  INTO
      @v_job_key
    , @v_job_sequence

  END

  CLOSE c_Logs
  DEALLOCATE c_Logs

  SET @p_result = 1
  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_job_to_clean+' had '+
                     CONVERT(VARCHAR,ISNULL(@v_del_count,0))  + ' logs removed. '

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Logs') >= -1
    BEGIN
      DEALLOCATE c_Logs
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Maintain_Indexes 
-- Notes / History
--
-- V1.0.0.0 WMR 22/02/2002
-- WMR 25/10/2002 Version 1.2.1   Sql Server version
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Maintain_Indexes
  @p_sequence        integer
, @p_job_name        varchar(64)
, @p_task_name       varchar(64)
, @p_job_id          integer
, @p_task_id         integer
, @p_table_name      varchar(64)
, @p_parameter       varchar(64)
, @p_index_name      varchar(64)
, @p_option          varchar(64)
, @p_result          integer      OUTPUT
AS
  SET XACT_ABORT OFF

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 		:	ws_maintain_indexes
  -- Description 		:	Drop or create one or a group of indexes
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_compile           integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Maintain_Indexes(8.3.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(255)  -- Text in audit_trail
  , @v_step            integer       -- step
  , @v_stmt            nvarchar(4000)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(100)  -- Database error message
  , @v_count           integer
  , @v_handled         integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_return_msg      varchar(256)
  , @v_obj_type        integer
  , @v_obj_key         integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018

  SET @v_step = 100

  BEGIN TRY

  --=====================================================
  -- See IF an index name has been specified
  -- and IF so look up the object key for that index
  -- otherwise Look up the object key for our table
  -- IF we cant find it we have an error
  --=====================================================
  SET @v_specific_index = 0

  IF @p_index_name <> ''
  BEGIN
    SET @v_specific_index = 1
    SET @v_step = 200

    SELECT
      @v_obj_key =  oo_obj_key
    , @v_obj_type = oo_type_key
    FROM ws_obj_object
    WHERE upper(oo_name) = upper(@p_index_name)

    SELECT @v_row_count     = @@ROWCOUNT

  END
  ELSE
  BEGIN
    SET @v_step = 300

    SELECT
      @v_obj_key =  oo_obj_key
    , @v_obj_type = oo_type_key
    FROM ws_obj_object
    WHERE upper(oo_name) = upper(@p_table_name)

    SELECT @v_row_count     = @@ROWCOUNT

  END

  --=====================================================
  -- NO partition handling under SQL SERVER
  -- See IF a partition name has been specified
  -- and IF so set the flag to indicate a specific part
  --=====================================================

  SET  @v_specific_part = 0

  --=====================================================
  -- Process depending on the option selected.
  -- DROP, DROP ALL, BUILD, BUILD ALL
  --=====================================================
  SET @v_handled = 0
  IF upper(@p_option) = 'DROP' AND @v_obj_type = @v_ws_obj_index
  BEGIN
    SET @v_handled = 1
    SET @v_step = 400

    EXEC Ws_Act_Drop @p_sequence,
      @v_obj_type,
      @v_ws_act_drop,
      @v_obj_key,
      @p_job_name,
      @p_task_name,
      @p_job_id,
      @p_task_id,
      @v_return_msg OUTPUT,
      @v_status_code OUTPUT,
      @v_status OUTPUT
  END
  IF upper(@p_option) = 'DROP ALL'
  BEGIN
    SET @v_handled = 1
    SET @v_step = 500

    EXEC Ws_Act_Drop_All @p_sequence,
      @v_obj_type,
      @v_ws_act_drop,
      @v_obj_key,
      @p_job_name,
      @p_task_name,
      @p_job_id,
      @p_task_id,
      @v_return_msg OUTPUT,
      @v_status_code OUTPUT,
      @v_status OUTPUT
  END
  IF upper(@p_option) = 'PRE DROP'
  BEGIN
    SET @v_handled = 1
    SET @v_step = 600

    EXEC Ws_Act_Pre_Drop @p_sequence,
      @v_obj_type,
      @v_ws_act_drop,
      @v_obj_key,
      @p_job_name,
      @p_task_name,
      @p_job_id,
      @p_task_id,
      @v_return_msg OUTPUT,
      @v_status_code OUTPUT,
      @v_status OUTPUT
  END
  IF upper(@p_option) = 'BUILD'
  BEGIN
    SET @v_handled = 1
    SET @v_step = 700

    EXEC Ws_Act_Build @p_sequence,
      @v_obj_type,
      @v_ws_act_drop,
      @v_obj_key,
      @p_job_name,
      @p_task_name,
      @p_job_id,
      @p_task_id,
      @v_return_msg OUTPUT,
      @v_status_code OUTPUT,
      @v_status OUTPUT
  END
  IF upper(@p_option) = 'BUILD ALL'
  BEGIN
    SET @v_handled = 1
    SET @v_step = 800

    EXEC Ws_Act_Build_All @p_sequence,
      @v_obj_type,
      @v_ws_act_drop,
      @v_obj_key,
      @p_job_name,
      @p_task_name,
      @p_job_id,
      @p_task_id,
      @v_return_msg OUTPUT,
      @v_status_code OUTPUT,
      @v_status OUTPUT
  END

  IF @v_handled = 0
  BEGIN
    SET @v_msgtext = 'Invalid option '+ ISNULL(@p_option,'NULL') +
      ' in call to Ws_Maintain_Index. '+
      'Valid options are DROP (index specified) , DROP ALL, PRE DROP, BUILD, and BUILD ALL'
    EXEC WsWrkAudit 'E', @p_job_name, @p_job_name, @p_sequence,
      @v_msgtext,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    SET @p_result = -2
    RETURN 0
  END

  IF @v_status_code < 1
  BEGIN
    SET @p_result = -1
    EXEC WsWrkAudit 'W', @p_job_name, @p_job_name, @p_sequence,
      @v_return_msg,NULL,NULL, @p_task_id, @p_job_id
  END
  ELSE
  BEGIN
    SET @p_result = 1
    EXEC WsWrkAudit 'I', @p_job_name, @p_job_name, @p_sequence,
      @v_return_msg,NULL,NULL, @p_task_id, @p_job_id
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @v_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @v_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @v_return_msg = @v_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_return_msg = @v_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Restart 
-- Notes / History
--
-- WMR 20/03/2002 Version 1.0.6.0 
-- WMR 06/11/2002 Version 1.2.1.5 SQL Server port
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Restart
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_restart_job      varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name   :    SQL Server
  -- Script Name :    ws_job_restart
  -- Description :    Restarts a scheduled job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(2046) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(100)  -- Database error message
  , @v_stmt            nvarchar(1024)
  , @v_count           integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_status      varchar(1)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version           = 'Ws_Job_Restart(8.4.1.0)'
  SET @v_step = 10

  BEGIN TRY

  --***********************************************************************
  -- First see IF the job name specified is in a failed state
  -- IF not in a failed state report IF running, on hold, or not present
  --***********************************************************************
  SELECT
    @v_job_key =  wjr_job_key
  , @v_job_sequence = wjr_sequence
  , @v_job_status = wjr_status
  FROM ws_wrk_job_run
  WHERE rtrim(upper(wjr_name)) = rtrim(upper(@p_restart_job))

  SELECT @v_row_count     = @@ROWCOUNT

  SET @v_step = 20
  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF ISNULL(@v_job_key,0) = 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_restart_job +' is not in a running or Failed state. Cannot restart'
    SET @p_return_code = 'N'
    SET @p_result = -1
    RETURN 0
  END

  SET @v_step = 30
  --***********************************************************************
  -- IF running no need to restart
  --***********************************************************************
  IF @v_job_status = 'R'
  BEGIN
    SET @p_return_msg = 'Job '+ @p_restart_job+' is currently Running. Cannot restart'
    SET @p_return_code = 'R'
    SET @p_result = -1
    RETURN 0
  END

  SET @v_step = 40
  --***********************************************************************
  -- IF not failed no need to restart
  --***********************************************************************
  IF @v_job_status <> 'F' AND @v_job_status <> 'H'
  BEGIN
    SET @p_return_msg = 'Job '+@p_restart_job+' is currently in state '+@v_job_status+'. Cannot restart'
    SET @p_return_code = 'U'
    SET @p_result = -2
    RETURN 0
  END

  SET @v_step = 50
  --***********************************************************************
  -- First remove any threads that failed and didn't clean up
  -- the restart won't work IF it thinks threads are still active
  --***********************************************************************
  BEGIN TRANSACTION

  DELETE FROM ws_wrk_job_thread
  WHERE wjt_job_key = @v_job_key
  AND  wjt_sequence = @v_job_sequence

  SELECT @v_row_count     = @@ROWCOUNT

  COMMIT

  SET @v_step = 60
  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************
  BEGIN TRANSACTION

  UPDATE ws_wrk_job_run
  SET    wjr_status = 'W'
  WHERE  wjr_job_key = @v_job_key
  AND    wjr_sequence = @v_job_sequence
  AND    wjr_status in ('H','F')

  SELECT @v_row_count     = @@ROWCOUNT

  COMMIT

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_restart_job+' sequence '+
    CONVERT(varchar,ISNULL(@v_job_sequence,-1))+' restarted.'
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      -- The error message can have a maximum of 2,047 characters.  If the message contains 2,048
      -- or more characters, only the first 2,044 are displayed and an ellipsis is added to indicate
      -- that the message has been truncated.
      -- https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sqlS      
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Sched_Status 
-- Notes / History
--
-- WMR 05/04/2002 Version 1.0.7
-- WMR 29/10/2002 Version 1.2.1   Sql Server
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Sched_Status
  @p_action          varchar(12)
, @p_sched_type      varchar(12)
, @p_sched_name      varchar(12)
, @p_sched_host      varchar(64)
, @p_sched_msg       varchar(256)
, @p_sched_username  varchar(64)
, @p_sched_interval  integer
, @p_sched_version   integer
, @p_sched_job_count integer
AS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	      :	SQL Server
  -- Script Name 		:	ws_sched_status
  -- Description 		:	Reports a schedulers status
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_MsgText         varchar(256) -- Text in audit_trail
  , @v_step            integer  -- return code
  , @v_result          integer  -- return code
  , @v_found           integer  -- return code
  , @v_stop_date       datetime
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(100)  -- Database error message

  DECLARE
    @v_ws_stop_date       datetime
  , @v_ws_active_date     datetime
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018

  SET @v_ws_pro_version           = 'Ws_Sched_Status(8.3.1.0)'

  BEGIN TRY

  --=====================================================
  -- Read in any existing record for this scheduler.
  --=====================================================
  SET @v_step = 10

  SELECT
    @v_ws_active_date = ws_active_date
  , @v_ws_stop_date = ws_stop_date
  FROM  ws_wrk_scheduler
  WHERE ws_name = @p_sched_name

  SELECT @v_row_count = @@ROWCOUNT

  --=====================================================
  -- See what our action is
  --=====================================================
  SET @v_step = 15
  SET @v_stop_date = NULL
  IF @p_action = 'STOP' SET @v_stop_date = GETDATE()

  --=====================================================
  -- If the scheduler record did not exist then create it
  --=====================================================
  IF @v_row_count = 0
  BEGIN
    BEGIN TRANSACTION
    SET @v_step = 20
    INSERT INTO ws_wrk_scheduler (
        ws_type_ind,
        ws_name,
        ws_host,
        ws_username,
        ws_start_date,
        ws_active_date,
        ws_stop_date,
        ws_stop_msg,
        ws_job_count,
        ws_interval,
        ws_version,
        ws_poll_flag,
        ws_shut_flag
        ) VALUES (
        upper(substring(@p_sched_type,1,1)),
        @p_sched_name,
        @p_sched_host,
        @p_sched_username,
        GETDATE(),
        GETDATE(),
        @v_stop_date,
        @p_sched_msg,
        NULL,
        @p_sched_interval,
        @p_sched_version,
        0,
        0
        )
      COMMIT
      SET @v_result = 1
    END

    --=====================================================
    -- Scheduler record exists.
    -- See if we are updating the active time or are
    -- a new iteration for this scheduler
    --=====================================================
    ELSE
    BEGIN
      SET @v_step = 30
      --=====================================================
      -- If we have a stop date or more than .01 of a day (14.4 minutes)
      -- since the last active date then assume a new version
      --=====================================================
      IF @v_ws_stop_date <> ''
      OR DATEDIFF(mi,@v_ws_active_date,GETDATE()) > 15
      BEGIN
        SET @v_step = 40
        BEGIN TRANSACTION
        UPDATE ws_wrk_scheduler
        SET
            ws_stop_date = @v_stop_date,
            ws_stop_msg = @p_sched_msg,
            ws_start_date = GETDATE(),
            ws_active_date = GETDATE(),
            ws_type_ind = upper(substring(@p_sched_type,1,1)),
            ws_host = @p_sched_host,
            ws_username = @p_sched_username,
            ws_version = @p_sched_version,
            ws_job_count = 0,
            ws_interval = @p_sched_interval,
            ws_poll_flag = 0,
            ws_shut_flag = 0
        WHERE ws_name = @p_sched_name
        COMMIT
        SET @v_result = 1
      END
      ELSE
      BEGIN
        BEGIN TRANSACTION
        UPDATE ws_wrk_scheduler
        SET
            ws_stop_date = @v_stop_date,
            ws_stop_msg = @p_sched_msg,
            ws_active_date = GETDATE(),
            ws_type_ind = upper(substring(@p_sched_type,1,1)),
            ws_host = @p_sched_host,
            ws_username = @p_sched_username,
            ws_version = @p_sched_version,
            ws_job_count = 0,
            ws_interval = @p_sched_interval,
            ws_poll_flag = 0
        WHERE ws_name = @p_sched_name
        COMMIT
        SET @v_result = 1
      END
    END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @v_result = -2

    SET @v_MsgText = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @v_ws_pro_version, @v_ws_pro_version ,0,
        @v_MsgText,@v_db_code, @v_db_msg, 0, 0
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @v_MsgText = @v_MsgText
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@v_MsgText,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @v_MsgText = @v_MsgText + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------


  RETURN @v_result
_PROCEDWSL_ Ws_Api_Glossary 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- @p_result = Ws_Api_Glossary(@p_object_name, @p_term, @p_comments, @p_option)
-- ============================================================================
-- WMR 25/06/2002 Version 1.2.0
-- WMR 07/11/2002 Version 1.2.1.2 Sql Server
-- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.

CREATE PROCEDURE Ws_Api_Glossary
  @p_object_name      varchar(64)
, @p_term             varchar(256)
, @p_comments         varchar(4000)
, @p_option           varchar(12)
, @p_result           varchar(256) OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   Sql Server
  -- Script Name    :   Ws_Api_Glossary.sql
  -- Description    :   Add elements to the ws_doc_glossary table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_msgtext         varchar(255) -- Text in audit_trail
  , @v_step            integer  -- return code
  , @v_result          integer  -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(100)  -- Database error message


  SET @v_ws_pro_version           = 'Ws_Api_Glossary(8.3.1.0)'
  SET @v_step = 100

  BEGIN TRY

  -- =========================================================================
  -- Options are to insert or delete
  -- =========================================================================
  IF upper(@p_option) = 'ADD'
  BEGIN
    BEGIN TRANSACTION
    SET @v_step = 200
    INSERT into ws_doc_glossary ( dg_object_name, dg_term, dg_comments )
    VALUES ( substring(@p_object_name,1,64), substring(@p_term,1,256),
      substring(@p_comments,1,4000))

    SELECT @v_row_count     = @@ROWCOUNT

    COMMIT

    SET @p_result = @p_object_name + ' element inserted'
    RETURN 0
  END

  IF upper(@p_option) = 'DELETE'
  BEGIN
    SET @v_step = 300
    DELETE from ws_doc_glossary
    WHERE dg_object_name = substring(@p_object_name,1,64)
    AND dg_term = substring(@p_term,1,256)

    SELECT @v_row_count     = @@ROWCOUNT

    COMMIT

    SET @p_result = @p_object_name + ' element deleted'
    RETURN 0
  END

  SET @p_result = 'Invalid option. Options are ADD or DELETE'

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION


    SET @p_result = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

     -- Provide full message in return parameter
    SET @p_result = @p_result + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Schedule 
-- Notes / History
--
-- WMR 20/03/2002 Version 1.0.6.0
-- WMR 06/11/2002 Version 1.2.1.5 SQL Server port
-- WMR 18/10/2004 Version 4.1.1.2 Created from Ws_Job_Release
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Schedule
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_release_job      varchar(64)
, @p_release_time     datetime
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	ws_job_schedule
  -- Description 	:	Releases a held or waiting job at a specified time
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_status      varchar(1)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version           = 'Ws_Job_Schedule(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY
  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  SELECT
    @v_job_key =  wjc_job_key
  , @v_job_sequence = wjc_sequence
  , @v_job_status = wjc_status
  FROM ws_wrk_job_ctrl
  WHERE rtrim(upper(wjc_name)) = rtrim(upper(@p_release_job))

  SELECT @v_row_count     = @@ROWCOUNT

  SET @v_step = 200
  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF ISNULL(@v_job_key,0) = 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_release_job +' is not in a holding or waiting state. Cannot reschedule'
    SET @p_return_code = 'N'
    SET @p_result = -1
    RETURN 0
  END


  SET @v_step = 300
  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************
  BEGIN TRANSACTION

  SET @v_step = 400

  UPDATE ws_wrk_job_ctrl
  SET
    wjc_status = 'W',
    wjc_start_after = @p_release_time
  WHERE wjc_job_key = @v_job_key
  AND wjc_status in ('H','W');

  SELECT @v_row_count     = @@ROWCOUNT

  COMMIT

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_release_job+' rescheduled to '+CONVERT(varchar,@p_release_time)
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Release 
-- Notes / History
--
-- WMR 20/03/2002 Version 1.0.6.0
-- WMR 06/11/2002 Version 1.2.1.5 SQL Server port
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Release
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_release_job      varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	ws_job_release
  -- Description 	:	Releases a held or waiting job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_status      varchar(1)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version           = 'Ws_Job_Release(8.4.1.0)'

  SET @v_step = 10

  BEGIN TRY

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  SELECT
    @v_job_key =  wjc_job_key
  , @v_job_sequence = wjc_sequence
  , @v_job_status = wjc_status
  FROM ws_wrk_job_ctrl
  WHERE rtrim(upper(wjc_name)) = rtrim(upper(@p_release_job))

  SELECT @v_row_count     = @@ROWCOUNT

  SET @v_step = 20
  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF ISNULL(@v_job_key,0) = 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_release_job +' is not in a holding or waiting state. Cannot release'
    SET @p_return_code = 'N'
    SET @p_result = -1
    RETURN 0
  END


  SET @v_step = 60
  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************
  BEGIN TRANSACTION

  UPDATE ws_wrk_job_ctrl
  SET
    wjc_status = 'W',
    wjc_start_after = GETDATE()
  WHERE wjc_job_key = @v_job_key
  AND wjc_status in ('H','W');

  SELECT @v_row_count     = @@ROWCOUNT

  COMMIT

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_release_job+' released.'
  SET @p_result = 1
  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Create 
-- Notes / History
--
-- WMR 23/04/2004 Version 4.1.0.8 
-- WMR  5/10/2005 Version 5.0.0.0 Some variable set to 64 should have been 256
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- KH   1/11/2018 Version 8.3.1.0 RED-9838 wtc_action_ind added to task copy row.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Create
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_template_job     varchar(64)
, @p_new_job          varchar(64)
, @p_description      varchar(256)
, @p_state            varchar(64)
, @p_threads          integer
, @p_scheduler        varchar(64)
, @p_logs             integer
, @p_okay             varchar(256)
, @p_fail             varchar(256)
, @p_att1             varchar(64)
, @p_att2             varchar(64)
, @p_att3             varchar(64)
, @p_att4             varchar(64)
, @p_att5             varchar(64)
, @p_att6             varchar(64)
, @p_att7             varchar(64)
, @p_att8             varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	ws_job_create
  -- Description 	:	Create a job from a template
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_old_sequence    integer
  , @v_old_key         integer
  , @v_old_status      varchar(1)
  , @v_new_sequence    integer
  , @v_new_key         integer
  , @v_wjc_status      varchar(1)
  , @v_wjc_type        varchar(1)
  , @v_lock_result     integer
  , @v_wait            char(12)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version           = 'Ws_Job_Create(8.4.1.0)'

  SET @v_step = 100

  BEGIN TRY

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  SELECT @v_old_key =  wjc_job_key
       , @v_old_sequence = wjc_sequence
       , @v_old_status = wjc_status
  FROM   ws_wrk_job_ctrl
  WHERE  rtrim(upper(wjc_name)) = rtrim(upper(@p_template_job))

  SELECT @v_row_count     = @@ROWCOUNT

  SET @v_step = 200

  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF ISNULL(@v_old_key,0) = 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_template_job
                      +' is not in a holding or waiting state. Cannot create new job'
    SET @p_return_code = 'N'
    SET @p_result = -1
    RETURN 0
  END

  SET @v_step = 300
  --***********************************************************************
  -- Make sure we have no job that matches our new job name
  --***********************************************************************
  SET @v_count = 0

  SELECT @v_count = COUNT(*)
  FROM   ws_wrk_job_ctrl
  WHERE  rtrim(upper(wjc_name)) = rtrim(upper(@p_new_job))

  IF @v_count > 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_new_job
                      +' already exists. Cannot create a new job of the same name'
    SET @p_return_code = 'P'
    SET @p_result = -1
    RETURN 0
  END


  SET @v_step = 400
  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************

  --***********************************************************************
  -- Get the right state for the new job and the sequence
  --***********************************************************************
  SET @v_wjc_status = 'H'
  SET @v_wjc_type = 'H'

  IF rtrim(upper(@p_state)) = 'ONCE'
  BEGIN
    SET @v_wjc_status = 'W'
    SET @v_wjc_type = 'O'
  END
  IF rtrim(upper(@p_state)) = 'ONCE+HOLD'
  BEGIN
    SET @v_wjc_status = 'W'
    SET @v_wjc_type = 'S'
  END

  SET @v_step = 500

  INSERT INTO ws_wrk_sequence(ws_date)
  VALUES (GETDATE())
  SELECT @v_new_sequence = SCOPE_IDENTITY()

  BEGIN TRANSACTION

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END


    SET @v_step = 600
    --***********************************************************************
    -- Add the new job in a held state, so that we can add the tasks/dependencies
    --***********************************************************************
    INSERT into ws_wrk_job_ctrl
    (
      wjc_job_key
    , wjc_name
    , wjc_description
    , wjc_sequence
    , wjc_group_key
    , wjc_project_key
    , wjc_status
    , wjc_last_status
    , wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , wjc_start_after
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , wjc_avg_count
    , wjc_publish_okay
    , wjc_publish_fail
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , wjc_max_threads
    , wjc_priority
    , wjc_publish_flag
    , wjc_scheduler
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    )
    SELECT
      @v_new_sequence
    , @p_new_job
    , ISNULL(@p_description,wjc_description)
    , @v_new_sequence
    , wjc_group_key
    , wjc_project_key
    , 'H'
    , wjc_last_status
    , @v_wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , GETDATE()
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , ISNULL(@p_logs,wjc_avg_count)
    , ISNULL(@p_okay,wjc_publish_okay)
    , ISNULL(@p_fail,wjc_publish_fail)
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , ISNULL(@p_threads,wjc_max_threads)
    , wjc_priority
    , wjc_publish_flag
    , ISNULL(@p_scheduler,wjc_scheduler)
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    FROM ws_wrk_job_ctrl
    WHERE wjc_job_key = @v_old_key
    AND wjc_status in ('H','W')

    SET @v_step = 700

    --***********************************************************************
    -- Add all the tasks
    --***********************************************************************
    INSERT into ws_wrk_task_ctrl
    (
      wtc_job_key
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , wtc_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , wtc_action_ind
    )
    SELECT
      @v_new_sequence
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , @v_new_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , COALESCE(wtc_action_ind,'')
    FROM ws_wrk_task_ctrl
    WHERE wtc_job_key = @v_old_key

    SET @v_step = 800

    --***********************************************************************
    -- Add all the dependencies
    --***********************************************************************
    INSERT into ws_wrk_dependency
    (
      wdp_job_key
    , wdp_parent_task_key
    , wdp_child_task_key
    )
    SELECT
      @v_new_sequence,
      b_new.wtc_task_key,
      c_new.wtc_task_key
    FROM
      ws_wrk_dependency a,
      ws_wrk_task_ctrl b_old,
      ws_wrk_task_ctrl c_old,
      ws_wrk_task_ctrl b_new,
      ws_wrk_task_ctrl c_new
    WHERE a.wdp_job_key = @v_old_key
    AND b_new.wtc_job_key = @v_new_sequence
    AND c_new.wtc_job_key = @v_new_sequence
    AND a.wdp_parent_task_key = b_old.wtc_task_key
    AND a.wdp_child_task_key = c_old.wtc_task_key
    AND b_old.wtc_order = b_new.wtc_order
    AND c_old.wtc_order = c_new.wtc_order

    SET @v_step = 900
    --***********************************************************************
    -- Set the job to the request state
    --***********************************************************************
    UPDATE ws_wrk_job_ctrl
    SET wjc_status = @v_wjc_status
    WHERE wjc_job_key = @v_new_sequence
    AND wjc_sequence = @v_new_sequence

  COMMIT


  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_new_job+' created.'
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Load_Change 
-- Notes / History
--
-- WMR 7/10/2003  Version 4.1.0.4
-- WMR 19/8/2005  Version 5.0.0.0 Changed *= join to ANSI standard
-- AP  24/7/2007  Version 5.6.1.1 Fix issue with loop if multiple table source
--                                Fix issue where not handling native load
--                                Fix for final pass where doing a substring when should not have
--                                Fix to handle empty rather than null values
--                                Fix to also test for empty database name and only append the . if there is
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- JH  04/07/2011 Version 6.5.4.1 RED-2175 SSIS loads FROM CLAUSE
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Load_Change
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_action           varchar(64)
, @p_table            varchar(64)
, @p_new_value        varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : SQL Server
  -- Script Name         : Ws_Load_Change
  -- Description         : has code as per red.loaproperties and loareconnect
  --                        to allow changing of schema and/or connection
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_return_status   integer
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_status      varchar(1)
  , @v_action          integer
  , @v_load_obj_key    integer
  , @v_old_connect_key integer
  , @v_new_connect_key integer
  , @v_old_connect     varchar(256)
  , @v_old_schema      varchar(256)
  , @v_new_schema      varchar(256)
  , @v_source_table    varchar(4000)
  , @v_view_tables     varchar(4000)
  , @v_from_tables     varchar(4000)
  , @v_work            varchar(4000)
  , @v_work2           varchar(4000)
  , @v_view_name       varchar(256)
  , @v_old_load_type   varchar(1)
  , @v_new_load_type   varchar(1)
  , @v_old_transform   varchar(1)
  , @v_new_transform   varchar(1)
  , @v_old_dblink      varchar(256)
  , @v_new_dblink      varchar(256)
  , @v_old_database    varchar(256)
  , @v_new_database    varchar(256)
  , @v_old_host        varchar(256)
  , @v_new_host        varchar(256)
  , @v_old_value       varchar(256)
  , @v_load_options    varchar(4000) -- RED-2175
  , @v_work_schema     varchar(256) -- RED-2175
  , @v_work_table      varchar(4000) -- RED-2175
  , @v_work_alias      varchar(4000) -- RED-2175
  , @v_encap_start     varchar(1) -- RED-2175
  , @v_encap_end       varchar(1) -- RED-2175
  , @v_tables          integer
  , @v_spos            integer
  , @v_cpos            integer
  , @v_ppos            integer
  , @v_bpos            integer
  , @v_ch              varchar(5)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_step = 100

  SET @v_ws_pro_version           = 'Ws_Load_Change(8.4.1.0)'

  BEGIN TRY

  SELECT
    @v_action          = 0
  , @v_load_obj_key    = 0
  , @v_old_connect_key = 0
  , @v_new_connect_key = 0
  , @v_tables          = 0
  , @v_spos            = 0
  , @v_cpos            = 0
  , @v_ppos            = 0


  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  IF UPPER(@p_action) = 'SCHEMA'
  BEGIN
    SELECT @v_action = 1
  END
  ELSE
  BEGIN
    IF UPPER(@p_action) = 'CONNECTION'
    BEGIN
      SELECT @v_action = 2
    END
    ELSE
    BEGIN
      SET @p_return_code = 'E'
      SET @p_return_msg = 'Invalid action code. Valid actions are Schema and Connection.'
      EXEC WsWrkAudit 'E', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg,@p_task_id, @p_job_id
      SET @p_result = -2
      RETURN 0;
    END
  END

  SET @v_step = 200
  --***********************************************************************
  -- Get the info for the load table
  --***********************************************************************
  SELECT
    @v_load_obj_key = lt_obj_key,
    @v_old_connect_key = lt_connect_key,
    @v_old_schema = lt_source_schema,
    @v_source_table = lt_source_table,
    @v_view_name = NULLIF(lt_view_name,''),
    @v_old_load_type = lt_type,
    @v_old_transform = lt_transform_ind,
    @v_old_dblink = NULLIF(dc_dblink_id,''),
    @v_old_connect = dc_name,
    @v_old_database = NULLIF(dc_database_id,''),
    @v_old_host = dc_host_id,
    @v_load_options = NULLIF(CAST(lt_load_options AS varchar(4000)),'') -- RED-2175
  FROM
    ws_load_tab
  LEFT OUTER JOIN ws_dbc_connect
  ON
    lt_connect_key = dc_obj_key
  WHERE
    UPPER(lt_table_name) = UPPER(@p_table)

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_load_obj_key <= 0
  BEGIN
    SET @p_return_code = 'E'
    SET @p_return_msg = 'Failed to find load table ' + @p_table
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name ,@p_sequence,
      @p_return_msg,@v_db_code, @v_db_msg,@p_task_id, @p_job_id
    SET @p_result = -2
    RETURN 0;
  END

  --***********************************************************************
  -- If a connection change then get the new connect info
  --***********************************************************************
  IF @v_action = 2
  BEGIN
    SET @v_step = 300
    SELECT
      @v_new_connect_key = dc_obj_key,
      @v_new_load_type = dc_type,
      @v_new_dblink = NULLIF(dc_dblink_id,''),
      @v_new_database = NULLIF(dc_database_id,''),
      @v_new_host = dc_host_id
    FROM
      ws_dbc_connect
    WHERE
      UPPER(dc_name) = UPPER(@p_new_value)

    -- RED-2175
    -- assign a default type of load if the old one is no longer valid
    IF @v_new_load_type = 'U' OR @v_new_load_type = 'W'
    BEGIN
        IF @v_old_load_type <> 'F' AND @v_old_load_type <> 'S' AND @v_old_load_type <> 'E'
        BEGIN
            SELECT @v_new_load_type = 'F'
        END
        ELSE
        BEGIN
            SELECT @v_new_load_type = @v_old_load_type
        END
    END
    ELSE IF @v_new_load_type = 'O'
    BEGIN
        IF @v_old_load_type <> 'O' AND @v_old_load_type <> 'E' AND @v_old_load_type <> 'I'
        BEGIN
            SELECT @v_new_load_type = 'O'
        END
        ELSE
        BEGIN
            SELECT @v_new_load_type = @v_old_load_type
        END
    END
    ELSE IF @v_new_load_type = 'D'
    BEGIN
        IF @v_old_load_type <> 'D' AND @v_old_load_type <> 'E' AND @v_old_load_type <> 'I'
        BEGIN
            SELECT @v_new_load_type = 'D'
        END
        ELSE
        BEGIN
            SELECT @v_new_load_type = @v_old_load_type
        END
    END
    ELSE
    BEGIN
        SELECT @v_new_load_type = @v_old_load_type
    END

    IF @v_new_load_type = 'O'
    BEGIN
      SELECT @v_new_transform = 'Y'
    END
    ELSE
    BEGIN
      SELECT @v_new_transform = @v_old_transform
    END

    SELECT @v_row_count     = @@ROWCOUNT

  END
  ELSE
  BEGIN
    SELECT @v_new_connect_key = @v_old_connect_key
    SELECT @v_new_load_type = @v_old_load_type
    SELECT @v_new_dblink = @v_old_dblink
    SELECT @v_new_database = @v_old_database
    SELECT @v_new_host = @v_old_host
    SELECT @v_new_transform = @v_old_transform
  END

  --***********************************************************************
  -- If a schema change then get ready for it
  --***********************************************************************
  IF @v_action = 1
  BEGIN
    SELECT @v_new_schema = @p_new_value
    SELECT @v_old_value = @v_old_schema
  END
  ELSE
  BEGIN
    SELECT @v_new_schema = @v_old_schema
    SELECT @v_old_value = @v_old_connect
  END


  --***********************************************************************
  -- If a remote view is used and we have a schema change then fix the view
  -- This logic is sourced from LoaReconnect in the med application
  --***********************************************************************
  IF @v_action = 1
  BEGIN
    IF @v_view_name IS NOT NULL
    BEGIN
       IF @v_new_schema IS NOT NULL
       BEGIN
         SET @v_step = 400
         SELECT @v_view_tables = ''
         SELECT @v_work = @v_source_table
         SELECT @v_ch = '%,%'
         SELECT @v_cpos = PATINDEX(@v_ch,@v_work)
         WHILE  @v_cpos > 0
         BEGIN
           SELECT @v_ch = '%,%'
           SELECT @v_cpos = PATINDEX(@v_ch,@v_work)
           IF @v_cpos > 0
           BEGIN

             SELECT @v_tables = @v_tables + 1
             IF @v_tables > 1
             BEGIN
               SELECT @v_view_tables = @v_view_tables + ','
             END

             SELECT @v_ch = '%.%'
             SELECT @v_spos = PATINDEX(@v_ch,@v_work)
             IF @v_spos < @v_cpos AND @v_spos > 0
             BEGIN
               SELECT @v_step = 500
             END
             ELSE
             BEGIN
               SELECT @v_view_tables = @v_view_tables + @v_new_schema + '.'
             END
             SET @v_step = 600
             SELECT @v_view_tables = @v_view_tables + SUBSTRING(@v_work,1,@v_cpos-1)
             SET @v_step = 700
             SELECT @v_work = SUBSTRING(@v_work,@v_cpos+1,LEN(@v_work)-@v_cpos)
           END
         END

         IF @v_work IS NOT NULL
         BEGIN
           SET @v_step = 800
           SELECT @v_tables = @v_tables + 1
           IF @v_tables > 1
           BEGIN
             SELECT @v_view_tables = @v_view_tables + ','
           END

           SELECT @v_ch = '%.%'
           SELECT @v_spos = PATINDEX(@v_ch,@v_work)
           IF  @v_spos > 0
           BEGIN
             SELECT @v_step = 900
           END
           ELSE
           BEGIN
             SELECT @v_view_tables = @v_view_tables + @v_new_schema + '.'
           END
           SELECT @v_view_tables = @v_view_tables + @v_work
         END
       END
       ELSE
       BEGIN
         SELECT @v_view_tables = @v_source_table
       END
    END
  END

  --***********************************************************************
  -- Now fix up the from tables
  -- Code logic acquired from med application in LoaReconnect
  --***********************************************************************
  IF @v_new_schema IS NOT NULL
  BEGIN
    IF @v_new_load_type = 'I' -- RED-2175
    BEGIN
        SELECT @v_step = 950
        SELECT @v_encap_start = ''
        SELECT @v_encap_end = ''

        SELECT @v_cpos = PATINDEX('%COL_ENCAP=%',@v_load_options)+10
        IF @v_cpos > 10
        BEGIN
            SELECT @v_bpos = CAST(SUBSTRING(@v_load_options,@v_cpos,4) AS integer)
            IF @v_bpos > 0
            BEGIN
                SELECT @v_cpos = @v_cpos + 5
                SELECT @v_encap_start = SUBSTRING(@v_load_options,@v_cpos,1)
                SELECT @v_encap_end = SUBSTRING(@v_load_options,@v_cpos+@v_bpos-1,1)
            END
        END

        SELECT @v_from_tables = ''
        SELECT @v_work = LTRIM(@v_source_table)
        SELECT @v_tables = 0

        SELECT @v_cpos = PATINDEX('%,%',@v_work)
        WHILE @v_cpos > 0
        BEGIN
            SELECT @v_spos = CHARINDEX(@v_encap_start,@v_work)
            SELECT @v_bpos = CHARINDEX(@v_encap_end,@v_work,@v_spos+1)

            IF @v_spos <= 0 OR @v_bpos <= @v_spos OR @v_spos >= @v_cpos OR @v_bpos <= @v_cpos
            BEGIN
                SELECT @v_cpos = @v_cpos-1
                BREAK
            END

            SELECT @v_cpos = CHARINDEX(',',@v_work,@v_bpos+1)
        END

        IF @v_cpos = 0
        BEGIN
            SELECT @v_cpos = LEN(@v_work)
        END

        WHILE @v_cpos > 0
        BEGIN
            SELECT @v_step = 960
            SELECT @v_work_schema = LTRIM(@v_new_schema)
            SELECT @v_work_table = LTRIM(SUBSTRING(@v_work,1,@v_cpos))
            SELECT @v_work_alias = ''

            IF LEN(@v_work_table) > 0
            BEGIN
                SELECT @v_step = 970
                SELECT @v_tables = @v_tables + 1
                IF @v_tables > 1
                BEGIN
                    SELECT @v_from_tables = @v_from_tables + ','
                END

                SELECT @v_bpos = 0
                SELECT @v_ppos = PATINDEX('%.%',@v_work_table)
                WHILE @v_ppos > 0
                BEGIN
                    SELECT @v_spos = CHARINDEX(@v_encap_start,@v_work_table,@v_bpos+1)
                    SELECT @v_bpos = CHARINDEX(@v_encap_end,@v_work_table,@v_spos+1)

                    IF @v_spos <= 0 OR @v_bpos <= @v_spos OR @v_spos >= @v_ppos OR @v_bpos <= @v_ppos
                    BEGIN
                        BREAK
                    END

                    SELECT @v_ppos = CHARINDEX('.',@v_work_table,@v_bpos+1)
                END

                IF @v_ppos > 0
                BEGIN
                    SELECT @v_work_schema = SUBSTRING(@v_work_table,1,@v_ppos-1)
                    SELECT @v_work_table = SUBSTRING(@v_work_table,@v_ppos+1,LEN(@v_work_table)-@v_ppos)
                END

                SELECT @v_work_schema = LTRIM(RTRIM(@v_work_schema))
                SELECT @v_work_table = LTRIM(RTRIM(@v_work_table))

                IF LEN(@v_work_schema) > 0
                BEGIN
                    IF SUBSTRING(@v_work_schema,1,1) = @v_encap_start
                    BEGIN
                        SELECT @v_from_tables = @v_from_tables + @v_work_schema + '.'
                    END
                    ELSE
                    BEGIN
                        SELECT @v_from_tables = @v_from_tables + @v_encap_start + @v_work_schema + @v_encap_end + '.'
                    END
                END

                SELECT @v_bpos = 0
                SELECT @v_ppos = PATINDEX('% %',@v_work_table)
                WHILE @v_ppos > 0
                BEGIN
                    SELECT @v_spos = CHARINDEX(@v_encap_start,@v_work_table,@v_bpos+1)
                    SELECT @v_bpos = CHARINDEX(@v_encap_end,@v_work_table,@v_spos+1)

                    IF @v_spos <= 0 OR @v_bpos <= @v_spos OR @v_spos >= @v_ppos OR @v_bpos <= @v_ppos
                    BEGIN
                        BREAK
                    END

                    SELECT @v_ppos = CHARINDEX(' ',@v_work_table,@v_bpos+1)
                END

                IF @v_ppos = 0
                BEGIN
                    SELECT @v_work_alias = @v_work_table
                END
                ELSE
                BEGIN
                    SELECT @v_work_alias = SUBSTRING(@v_work_table,@v_ppos+1,LEN(@v_work_table)-@v_ppos)
                    SELECT @v_work_table = SUBSTRING(@v_work_table,1,@v_ppos)
                END

                SELECT @v_work_alias = LTRIM(RTRIM(@v_work_alias))
                SELECT @v_work_table = LTRIM(RTRIM(@v_work_table))

                IF SUBSTRING(@v_work_table,1,1) = @v_encap_start
                BEGIN
                    SELECT @v_from_tables = @v_from_tables + @v_work_table + ' '
                END
                ELSE
                BEGIN
                    SELECT @v_from_tables = @v_from_tables + @v_encap_start + @v_work_table + @v_encap_end + ' '
                END

                IF SUBSTRING(@v_work_alias,1,1) = @v_encap_start
                BEGIN
                    SELECT @v_from_tables = @v_from_tables + @v_work_alias + ' '
                END
                ELSE
                BEGIN
                    SELECT @v_from_tables = @v_from_tables + @v_encap_start + @v_work_alias + @v_encap_end + ' '
                END
            END

            SELECT @v_work = SUBSTRING(@v_work,@v_cpos+1,LEN(@v_work)-@v_cpos)
            IF LEN(@v_work) > 1 AND LTRIM(SUBSTRING(@v_work,1,1)) = ','
            BEGIN
                SELECT @v_work = SUBSTRING(@v_work,2,LEN(@v_work)-1)
            END
            SELECT @v_cpos = PATINDEX('%,%',@v_work)

            WHILE @v_cpos > 0
            BEGIN
                SELECT @v_spos = CHARINDEX(@v_encap_start,@v_work)
                SELECT @v_bpos = CHARINDEX(@v_encap_end,@v_work,@v_spos+1)

                IF @v_spos <= 0 OR @v_spos <= 0 OR @v_spos >= @v_cpos OR @v_bpos <= @v_cpos
                BEGIN
                    SELECT @v_cpos = @v_cpos-1
                    BREAK
                END

                SELECT @v_cpos = CHARINDEX(',',@v_work,@v_bpos+1)
            END

            IF @v_cpos = 0
            BEGIN
                SELECT @v_cpos = LEN(@v_work)
            END
        END
    END
    ELSE
    BEGIN
        SELECT @v_from_tables = ''
        SELECT @v_work = LTRIM(@v_source_table)
        SELECT @v_tables = 0
        SELECT @v_ch = '%,%'
        SELECT @v_cpos = PATINDEX(@v_ch,@v_work)
        WHILE  @v_cpos > 0
        BEGIN
          SELECT @v_ch = '%,%'
          SELECT @v_cpos = PATINDEX(@v_ch,@v_work)
          IF @v_cpos > 0
          BEGIN
            SET @v_step = 1000
            SELECT @v_tables = @v_tables + 1
            IF @v_tables > 1
            BEGIN
              SELECT @v_from_tables = @v_from_tables + ','
            END

            SELECT @v_ch = '%.%'
            SELECT @v_spos = PATINDEX(@v_ch,@v_work)

            IF @v_new_host <> 'MSDAORA'
            BEGIN

              IF @v_new_dblink IS NOT NULL
              BEGIN
                SELECT @v_from_tables = @v_from_tables + @v_new_dblink + '.'
              END

              IF @v_new_database IS NOT NULL
              BEGIN
                SELECT @v_from_tables = @v_from_tables + @v_new_database + '.'
              END
              ELSE
              BEGIN
                IF @v_new_load_type <> 'O' AND @v_new_load_type <> 'N'
                BEGIN
                  SELECT @v_from_tables = @v_from_tables + '.'
                END
              END

            END


            IF @v_spos < @v_cpos AND @v_spos > 0
            BEGIN
              SET @v_step = 1100
            END
            ELSE
            BEGIN
              SELECT @v_from_tables = @v_from_tables + @v_new_schema + '.'
            END

            SELECT @v_from_tables = @v_from_tables + SUBSTRING(@v_work,1,@v_cpos-1)
            SELECT @v_work2 = LTRIM(SUBSTRING(@v_work,1,@v_cpos-1))
            SELECT @v_ch = '%]%'
            SELECT @v_bpos = PATINDEX(@v_ch,@v_work2)
            IF @v_bpos > 0
            BEGIN
              SET @v_step = 1200
              IF LEN(@v_work2) > @v_bpos
              BEGIN
                SET @v_step = 1300
                SELECT @v_work2 = LTRIM(SUBSTRING(@v_work2,@v_bpos+1,LEN(@v_work2)-@v_bpos))
              END
              ELSE
              BEGIN
                SELECT @v_work2 = ''
              END
            END

            SELECT @v_ch = '% %'
            SELECT @v_bpos = PATINDEX(@v_ch,@v_work2)
            IF @v_bpos = 0
            BEGIN
              SET @v_step = 1400
              SELECT @v_from_tables = @v_from_tables + ' ' + SUBSTRING(@v_work,1,@v_cpos-1)
            END
          END

          SET @v_step = 1500
          SELECT @v_work = SUBSTRING(  @v_work, @v_cpos +1  , LEN(@v_work)-@v_cpos)

          SELECT @v_ch = '%,%'
          SELECT @v_cpos = PATINDEX(@v_ch,@v_work)

        END

        IF @v_work IS NOT NULL
        BEGIN
          SELECT @v_tables = @v_tables + 1
          IF @v_tables > 1
          BEGIN
            SELECT @v_from_tables = @v_from_tables + ','
          END

          SELECT @v_ch = '%.%'
          SELECT @v_spos = PATINDEX(@v_ch,@v_work)


          IF @v_new_host <> 'MSDAORA'
          BEGIN

            IF @v_new_dblink IS NOT NULL
            BEGIN
              SELECT @v_from_tables = @v_from_tables + @v_new_dblink + '.'
            END

            IF @v_new_database IS NOT NULL
            BEGIN
              SELECT @v_from_tables = @v_from_tables + @v_new_database + '.'
            END
            ELSE
            BEGIN
              IF @v_new_load_type <> 'O' AND @v_new_load_type <> 'N'
              BEGIN
                SELECT @v_from_tables = @v_from_tables + '.'
              END
            END
          END

          IF @v_spos > 0
          BEGIN
            SELECT @v_step = 1600
          END
          ELSE
          BEGIN
            SELECT @v_from_tables = @v_from_tables + @v_new_schema + '.'
          END

          SELECT @v_from_tables = @v_from_tables + @v_work
          SELECT @v_work2 = @v_work  --LTRIM(SUBSTRING(@v_work,1,@v_cpos-1))
          SELECT @v_ch = '%]%'
          SELECT @v_bpos = PATINDEX(@v_ch,@v_work2)
          IF @v_bpos > 0
          BEGIN
            IF LEN(@v_work2) > @v_bpos
            BEGIN
              SET @v_step = 1700
              SELECT @v_work2 = LTRIM(SUBSTRING(@v_work2,@v_bpos+1,LEN(@v_work2)-@v_bpos))
            END
            ELSE
            BEGIN
              SELECT @v_work2 = ''
            END
          END

          SELECT @v_ch = '% %'
          SELECT @v_bpos = PATINDEX(@v_ch,@v_work2)
          IF @v_bpos = 0
          BEGIN
            SELECT @v_from_tables = @v_from_tables + ' ' + @v_work
          END
        END
    END
  END
  ELSE
  BEGIN
    SELECT @v_from_tables = @v_source_table
  END
  --***********************************************************************
  -- Update the load table
  --***********************************************************************
  SET @v_step = 1800

  UPDATE ws_load_tab
  SET
    lt_connect_key = @v_new_connect_key,
    lt_source_schema = @v_new_schema,
    lt_view_table = @v_view_tables,
    lt_from_table = @v_from_tables,
    lt_transform_ind = @v_new_transform,
    lt_type = @v_new_load_type
  WHERE
    lt_obj_key = @v_load_obj_key

  SET @p_return_code = 'S'
  SET @p_return_msg = @p_action + ' changed from '+@v_old_value+' to '+@p_new_value+
    ' for load table '+@p_table
  EXEC WsWrkAudit 'I', @p_job_name, @p_task_name ,@p_sequence,
    @p_return_msg,NULL,NULL,@p_task_id, @p_job_id

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Exec_411 
-- Notes / History
--
-- WMR 24/08/2001     Reworked the task loop to prevent the holding open of the
--                    TaskRun cursor, causing a Rollback too old problem
-- WMR 24/08/2001     If a job has a previously failed Sequence then let the job go.
--                    If it has a running Sequence then put it into Hold
-- WMR 09/11/2001     If a restart then check job is pending. Change to ws_job_wait.
-- WMR 22/01/2002     Version 1.0.0
-- WMR 08/03/2002     Handle change of SID when breakout to perform host script
-- WMR 05/04/2002     Changed analyse from 1% to 3%. Handle new wj_scheduler column
-- WMR 06/04/2002     Handle ODBC based loads.
-- WMR 09/04/2002     Handle customer jobs in working out next scheduled time
--                    Handle blocked jobs. Release them when a job has finished or failed
-- WMR 23/05/2002     Additional info message and check if unable to rejoin a job
-- WMR 25/05/2002     All job_name comparisons use upper and rtrim
-- WMR 01/10/2002     Threads sleep for 30 seconds if no action and tasks still running
-- WMR 18/10/2002     Invalid return status now assumed to be a failure.
-- WMR 25/10/2002     SQL Server version
-- WMR 01/08/2003     Ensure only one thread writes the job complete stuff and executes
--                    and job complete or failed command
-- WMR 14/08/2003     Updates for version 4.1
-- WMR 30/09/2003     Missing commit before return
-- WMR 02/10/2003     Added cube creation and processing
-- WMR 10/10/2003     Restart failed due to invalid cursor read on ws_wrk_task_run
-- WMR 16/10/2003     Call to Ws_Job_Clear_Logs to remove old logs
-- WMR 31/10/2003     Added cube and database dim processing
-- WMR 03/11/2003     Added sp_getapplock to handle locking. Place named transactions
--                    on every transaction
-- WMR 19/11/2003     Handle an invalid return status ('U'). Fail the job
-- WMR 09/03/2004     Handle virtual cube create and process
-- WMR 10/05/2004     Added support for custom procedures
-- WMR 03/07/2004     Fixed custom scheduling. Was using datepart(dd) instead of (dw)
-- WMR 23/09/2004     Changed custom scheduling to us the day name instead of number
-- WMR 18/02/2005     Added ability to call another job from a running job
-- WMR 01/03/2005     Introduced Ws_Act_Truncate
-- WMR 17/03/2005     Put the task order into the wtr_thread field so that we can sort
--                    waiting tasks. It will be overwritten with the thread when the
--                    task starts.
-- WMR 18/03/2005     Scheduler incorrectly reporting failure due to dependency loop
-- WMR 27/05/2005     Scheduler incorrectly reporting failure due to dependency loop
--                    when two thread both try to get the last task.
-- WMR 04/04/2006     Changed custom job re-scheduling to prevent time creep.
-- WMR 04/04/2006     Pre drop and build of indexes during a process are now flagged as Information
-- WMR 03/05/2006     custom job re-scheduling was skipping a day in some cases.
-- WMR 13/06/2006     Scheduler incorrectly reporting failure due to dependency loop
-- AP  07/07/2006     Changed locking to handle a 1 return instead of just 0
-- AP  16/08/2006     Version 5.5.0.5
--                    Implemented a lock timeout on the lock call to address locking issues
--                    Removed transaction level lock timeout settings
--                    Added ordering default to cursor c_TaskRun.. eventually want to have this
--                      changed to use the sort order from the tasks but this reqs meta change
--                    Added version number to messages
--                    Added DSS parameter substitution for job fail/success message
-- WMR 11/02/2006     Scheduler incorrectly reporting failure due to dependency loop when child jobs
--                    where present at some sites due to join to ws_obj_object
-- JML 22/03/2007     Version 5.5.0.17 support for Native ODBC loads Added.
-- WMR 26/03/2007     Version 5.6.0.0 support for Retrofit ODBC loads Added.
-- JML 17/04/2007     Version 5.6.0.0 support for Export Objects Added.
-- WMR 23/04/2007     Changed Action Process code to fix bug and remove ELSE statement.
-- WMR 08/05/2007     Changed custom job re-schedule to use @v_start_after date instead of GETDATE()
--                    in case we go past midnight.
-- AP  26/07/2007     Version 5.6.1.1 Reset depend loop count as soon as find a task so as to minimise risk
--                     of erroneous dependency loop error message
--                    Corrected a couple of messages that would have failed due to not convert int to varchar.
-- AP  20/11/2007     Version 5.6.2.1 When deleting from ws_wrk_scr_* use parent job_key
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
--                    New wtr_order column included
--                    New override for wait for idle tasks
-- AP  16/04/2009     Version 6.0.4.1  Additional waitlocks added to avoid deadlocks.
--                    Cleanup of wrk_dependency for once only jobs
--                    Number of performance changes.
-- AP  10/06/2009     Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
--                    removal of transaction level setting etc
--                    Fixed for some where had v_ rather than @v_
--                    Implement new '-99' return code for blocked job so handle nicer
--                    Implement new '-98' return code for no active job found
-- AP  05/11/2009     Version 6.0.5.2 RED-1355 Fixed issue with restart of failed child jobs.
-- AP  05/11/2009     Version 6.1.0.0 Implement OLAP objects
--                    Provisional change for task action ind
-- AP  01/12/2010     Version 6.5.3.1 RED-??? Introduced SSIS Load - Type = 'I' - return = 14
-- AP  17/11/2011     Version 6.5.5.1 RED-2382 Support Block Procedural Code - return = 16 and 17
-- AP  20/02/2011     Version 6.5.6.1 RED-2575 partition tables require predrop performed to handle columnstore
-- AP  20/02/2011     Version 6.7.0.1 RED-???? support external objects - return = 18
-- HM  23/09/2014     Version 6.8.1.2 RED-3906 Schema support
-- RS  13/04/2015     Version 6.8.3.3 RED-4795 Removed explicit lock release to avoid race condition
-- AP  01/05/2015     Version 6.8.3.3 RED-4970 Corrected issue with sub tasks for target aware objects
-- RS  06/05/2015     Version 6.8.3.4 RED-4976 Fix issue with child jobs for tasks with target objects
-- RS  14/05/2015     Version 6.8.3.4 RED-5018 Fix issue with child jobs for tasks with SQLBLOCK
-- TA  20/05/2015     Version 6.8.3.4 RED-5063 Support SSIS Export
-- AP  23/07/2015     Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015     Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  22/12/2015     Version 6.8.5.2 RED-6122 Fixed issue with index build of remote target tables
-- AP  28/01/2016     Version 6.8.5.3 RED-6260 Fixed issue with child jobs when blocked
-- BC  16/02/2016     Version 6.8.5.3 Added support for BDA Server operations
-- HM  08/03/2016     Version 6.8.5.3 External objects target key retrieve for export objects
-- RS  21/03/2016     Version 6.8.5.3 Added support for ODBC load into Hive tables
-- TA  11/03/2016     Version 6.8.5.4 RED-5890 Added support for Database Link Loads into Hive targets
-- BC  07/04/2016     Version 6.8.5.4 Fixed execution of child BDA tasks to output task data from nested call
-- RS  10/06/2016     Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- AP  22/06/2016     Version 6.8.6.2 RED-3282 Support 'disabled' tasks
-- BC  28/09/2016     Version 6.8.6.2 RED-7268 Prevent Hive script loads and exports going to BDA.
-- HM  03/10/2016     Version 6.8.6.3 RED-7055 Add support for on-the-fly template DDL evaluation
-- HM  12/10/2016     Version 6.8.6.3 RED-7193 Assign new return code for on-the-fly template DDL evaluation
-- RS  14/12/2016     Version 6.8.6.3 RED-7626 Added check if object key is a child job before looking at BDA connection
-- RS  13/01/2017     Version 6.8.7.0 RED-7694 Moved into one transaction to avoid issue with permanently blocked job
-- FS  25/07/2017     Version 8.0.1.0 RED-8221 Livelock in Ws_Job_Exec_411()
-- FS  11/09/2017     Version 8.0.1.0 RED-8675 RED-8581 Fixed issue with child job cleanup for previous runs at job start
-- HM  03/10/2017     Version 8.1.1.0 RED-8704 Adding support for Source Mapping
-- BC  07/03/2018     Version 8.1.1.0 RED-9267 Fix check for external object when processing Source Mapping
-- AD  13/08/2018     Version 8.3.1.0 RED-9704 Fix high IO usage on scheduler query on Teradata
-- HM  15/10/2018     Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  14/11/2018     Version 8.3.1.0 RED-9992 Sub-jobs are not restarted; they should always run as new.
-- BC  10/12/2018     Version 8.3.1.0 RED-10107 Fix to prevent child job being reinserted into ws_wrk_job_run.
-- BC  12/12/2018     Version 8.3.1.0 RED-10122 Fix to prevent duplicate task log entries being inserted into ws_wrk_task_log.
-- BC  19/12/2018     Version 8.3.1.0 RED-10133 Fix to not treat a child job as an external object
-- HM  13/02/2019     Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.
-- HM  22/02/2019     Version 8.4.1.0 RED-7407 Increase max length of success/failure command.
-- HM  04/03/2019     Version 8.4.1.0 RED-10097 Fix grandparent job restart when failed grandchild marked as complete.
--
-- ****************************************************
-- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
-- ****************************************************
--

CREATE PROCEDURE Ws_Job_Exec_411
  @pi_job_name         varchar(64)
, @pi_task_name        varchar(64)
, @pi_action           varchar(12)
, @pi_thread           integer
, @pi_sequence         integer
, @pi_job_key          integer
, @pi_task_key         integer
, @pi_task_status      integer       -- used during rejoin to pass back a tasks status
, @pi_task_msg         varchar(256)
, @pm_job_name         varchar(64)   -- Master job name ( used in audit trail)
, @pm_job_key          integer       -- Master job key ( used in audit trail )
, @pm_rejoin_job_keys  varchar(256)  -- List of job keys to rejoin on.
, @pm_rejoin_task_keys varchar(256)  -- List of task keys to rejoin on.
, @po_result_code      integer       OUTPUT
, @po_result_msg       varchar(1024) OUTPUT
, @po_job_key          integer       OUTPUT
, @po_task_key         integer       OUTPUT
, @po_task_name        varchar(64)   OUTPUT
, @po_action_key       integer       OUTPUT
, @po_action_msg       varchar(4000) OUTPUT
, @ps_job_key_list     varchar(256)  OUTPUT -- ( list of jobs to pass task down to. Comma separated )
, @ps_task_key_list    varchar(256)  OUTPUT -- ( list of tasks to pass task down to. Comma separated )
, @po_task_data        varchar(4000) OUTPUT
AS
  SET XACT_ABORT OFF
--6.0.4.1  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name   : SQL Server
  -- Script Name : ws_job_exec_411
  -- Description : Executes a WhereScape Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_obj_source_mapping    integer

  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  , @v_wants_to_run             integer
  , @v_ws_act_disabled          CHAR(1)
  , @v_ws_act_disabled_once     CHAR(1)

  , @v_ws_create_ddl_type       CHAR(1)

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = 'Ws_Job_Exec_411(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_obj_source_mapping    = 69

  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  , @v_wants_to_run             = 1
  , @v_ws_act_disabled_once     = 'A'
  , @v_ws_act_disabled          = 'B'

  , @v_ws_create_ddl_type       = '3'

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE
    @p_sequence                integer
  , @p_job_name                varchar(64)
  , @p_task_name               varchar(64)
  , @p_task_id                 integer
  , @p_job_id                  integer
  , @p_subjob_status           varchar(1)
  , @p_subjob_id               integer
  , @p_return_msg              varchar(1024)
  , @p_status_code             integer
  , @p_return_msg_2            varchar(1024)
  , @p_status_code_2           integer
  , @p_return_msg_3            varchar(1024)
  , @p_status_code_3           integer
  , @p_result                  integer
  , @p_result_2                integer
  , @p_result_3                integer

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_step                    integer       -- step
  , @v_stmt                    nvarchar(4000)
  , @v_handled                 integer
  , @v_row_count               integer
  , @v_all_status              integer
  , @v_dep_cursor              integer       -- status for the dependency cursor
  , @v_task_cursor             integer       -- status for the task cursor
  , @v_db_code                 varchar(10)   -- Database error code
  , @v_db_msg                  varchar(1024) -- Database error message
  , @v_rec_count               integer
  , @v_job_count               integer
  , @v_task_count              integer
  , @v_child_key               integer
  , @v_run_status              varchar(1)
  , @v_audit_status            varchar(1)
  , @v_abort_level             integer
  , @v_halted                  integer
  , @v_okay                    integer
  , @v_checked                 integer
  , @v_running_count           integer
  , @v_failed_count            integer
  , @v_halted_count            integer
  , @v_job_status              varchar(1)
  , @v_loop_count              integer
  , @v_MsgText                 varchar(1024) -- Text in audit_trail
  , @v_OkayMsg                 varchar(1024) -- Okay result command
  , @v_FailMsg                 varchar(1024) -- Failure result command
  , @v_result                  integer
  , @v_status_code             varchar(1)
  , @v_child_job_pending_count integer
  , @v_just_done               integer
  , @v_idle_thread             integer
  , @v_job_type                varchar(1)
  , @v_sid                     integer
  , @v_serial                  integer
  , @v_process                 integer
  , @v_action_type             integer
  , @v_obj_type                integer
  , @v_obj_key                 integer
  , @v_task_key                integer
  , @v_ctrl_sequence           integer
  , @v_wjc_start_after         datetime
  , @v_wjc_status              varchar(1)
  , @v_procedure_type          varchar(1)
  , @v_any_hive_targets        integer
  , @v_bda_connect_key         integer
  , @v_is_hive_target          integer
  , @v_task_data               varchar(4000)
  , @v_is_template_ddl_target  integer

  , @v_getstart_status integer

  , @v_loop                    integer
  , @v_log_keep                integer
  , @v_lock_result             integer
  , @v_wait                    char(12)
  , @v_idle_thread_wait        integer -- wait interval for an idle thread
  , @v_idle_thread_wait_hh     integer -- wait interval for an idle thread
  , @v_idle_thread_wait_mm     integer -- wait interval for an idle thread
  , @v_idle_thread_wait_ss     integer -- wait interval for an idle thread
  , @v_idle_thread_wait_string varchar(255) -- wait interval for an idle thread

  , @v_retry                   integer -- variable to act as a boolean for retry/while loops
  , @v_retry_msg_count         integer -- counter of retries for message logging (want to try more often than report

  --=====================================================
  -- Variables for Task Run cursor
  --=====================================================
  DECLARE
    @v_wtr_task_key            integer
  , @v_wtr_job_key             integer
  , @v_wtr_obj_key             integer
  , @v_wtr_name                varchar(64)
  , @v_wtr_sequence            integer
  , @v_wtr_restart             integer
  , @v_wtr_run_status          varchar(1)
  , @v_wtr_audit_status        varchar(1)
  , @v_wtr_started             datetime
  , @v_wtr_completed           datetime
  , @v_wtr_elapsed_hh          integer
  , @v_wtr_elapsed_mi          integer
  , @v_wtr_info_count          integer
  , @v_wtr_warning_count       integer
  , @v_wtr_detail_count        integer
  , @v_wtr_return_msg          varchar(1024)
  , @v_wtr_type                varchar(1)
  , @v_wtr_obj_type            integer
  , @v_wtr_action_type         integer
  , @v_wtr_chkp_number         integer
  , @v_wtr_abort_level         integer
  , @v_wtr_thread              integer
  , @v_wtr_inserted            integer
  , @v_wtr_updated             integer
  , @v_wtr_replaced            integer
  , @v_wtr_deleted             integer
  , @v_wtr_discarded           integer
  , @v_wtr_rejected            integer
  , @v_wtr_errored             integer
  , @v_wtr_order               integer
  , @v_wtr_action_ind          varchar(1)


  --=====================================================
  -- Variables for Dependency cursor
  --=====================================================
  DECLARE
    @v_wdp_job_key             integer
  , @v_wdp_parent_task_key     integer
  , @v_wdp_child_task_key      integer

  --=====================================================
  -- Variables for jobs from jobs
  --=====================================================
  DECLARE
    @v_job_result_code         integer
  , @v_job_result_msg          varchar(1024)
  , @v_job_job_key             integer
  , @v_job_job_name            varchar(64)
  , @v_job_task_key            integer
  , @v_job_task_name           varchar(64)
  , @v_job_key_list            varchar(256)
  , @v_task_key_list           varchar(256)
  , @v_job_action_key          integer
  , @v_job_action_msg          varchar(4000)
  , @v_audit_job_id            integer
  , @v_audit_task_id           integer
  , @v_audit_job_name          varchar(64)
  , @v_audit_task_name         varchar(64)
  , @v_child_job               integer
  , @v_sub_job_key             integer
  , @v_sub_task_key            integer
  , @v_my_job_key              integer
  , @v_my_task_key             integer
  , @v_sub_job_name            varchar(64)
  , @v_my_task_name            varchar(64)
  , @v_rejoin_job_keys         varchar(256)
  , @v_rejoin_task_keys        varchar(256)
  , @v_cpos                    integer
  , @v_restart_flag            integer
  , @v_run_count               integer
  , @v_job_action              varchar(64)
  , @v_depend_loop             integer
  , @v_spos                    integer
  , @v_epos                    integer
  , @v_work                    nvarchar(4000)
  , @v_parameter               nvarchar(4000)
  , @v_part_table_key          integer
  , @v_objinfo_value           varchar(4000)
  , @v_objinfo_status          varchar(1)

  SET @v_step = 100
  -- setup the default audit log variables
  SELECT
    @v_audit_job_id = @pi_job_key -- 6.0.4.1 fixed from was set from @p_job_id
  , @v_audit_task_id = @pi_task_key
  , @v_audit_job_name = @pi_job_name
  , @v_audit_task_name = @pi_task_name

  IF @v_audit_job_id IS NULL
    SET @v_audit_job_id = 0

  BEGIN TRY

  SET @p_job_name = @pi_job_name
  SET @p_task_name = @pi_task_name
  SET @p_sequence = @pi_sequence
  SET @p_job_id = 0
  SET @p_task_id = 0

  SET @po_job_key = @p_job_id
  SET @po_task_key = @p_task_id
  SET @po_task_name = @p_task_name
  SET @po_task_data = ''

  SET @po_result_msg = 'no result'
  SET @v_child_job = 0
  SET @v_restart_flag = 0

  SET @v_idle_thread_wait        = 30  -- wait interval for an idle thread
  SET @v_idle_thread_wait_hh     = 0   -- wait interval for an idle thread
  SET @v_idle_thread_wait_mm     = 0   -- wait interval for an idle thread
  SET @v_idle_thread_wait_ss     = 0   -- wait interval for an idle thread
  SET @v_idle_thread_wait_string = '00:00:30'  -- wait interval for an idle thread

  -- If we have a calling job then setup to use it's keys in the audit log
  IF @pm_job_name IS NOT NULL and @pm_job_name <> ''
  BEGIN
    IF @pm_job_name <> @pi_job_name
    BEGIN
      SELECT
        @v_audit_job_id = @pm_job_key
      , @v_audit_job_name = @pm_job_name
      , @v_child_job = 1
    END -- end of pi_job_name <> pc_job_name
  END -- end of not null job name
  ELSE
  BEGIN
    SELECT
      @pm_job_key = @p_job_id
    , @pm_job_name = @pi_job_name
  END

--6.0.4.1  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

  --=====================================================
  --                  N E W       J O B
  --=====================================================
  -- If we are a New job then check we are not already running, under
  -- this or some other sequence number.
  -- Create the job_run and task_run records
  --=====================================================
  IF UPPER(@pi_action) = 'NEW'
  BEGIN
    SET @v_step = 200
    --=====================================================
    -- If we are thread 0 then do some checks and create the records
    --=====================================================
    IF @pi_thread = 0
    BEGIN

      -- Get the job key for the job name. There should be one and
      -- only one key. Otherwise a fatal problem.
      BEGIN TRANSACTION JE001

      SET @v_step = 300

      SELECT
        @p_job_id = wjc_job_key
      , @v_job_type = wjc_type
      , @v_ctrl_sequence = wjc_sequence
      , @v_FailMsg = wjc_publish_fail
      , @v_log_keep = ISNULL(wjc_avg_count,0)
      , @v_idle_thread_wait = ISNULL(wjc_idle_thread_wait,30)
      FROM  ws_wrk_job_ctrl
      WHERE RTRIM(UPPER(wjc_name)) = RTRIM(UPPER(@pi_job_name))

      SELECT
        @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE001

      SET @v_step = 400
      -- If we have a parent job then setup to use it's keys in the audit log
      IF @v_child_job = 0
      BEGIN
        SELECT
          @v_audit_job_id = @p_job_id
        , @pm_job_key = @p_job_id
      END

--SET @v_MsgText = 'Ws_Job_Exec invoked Job '+ @pi_job_name
--+ ' parent job ' + @pm_job_name
--+ ' job key ' + CONVERT(VARCHAR,@p_job_id)
--+ ' parent key ' + CONVERT(VARCHAR,@pm_job_key)
--+ ' audit key ' + CONVERT(VARCHAR,@v_audit_job_id)
--+ ' child flag ' + CONVERT(VARCHAR,@v_child_job)
--EXEC @v_result = WsWrkAudit 'A',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

      IF @v_rec_count <> 1
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job '+ @pi_job_name + ' passed invalid job name in New Job. ' +
          CONVERT(VARCHAR,@v_rec_count) + ' such records exist. No Action !!!'
        EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
                                       @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        RETURN 0
      END

      -- Setup to default for a failure if a Fail command has been provided
      IF @v_FailMsg <> '' AND @v_FailMsg IS NOT NULL
      BEGIN
         SET @po_action_key = 2
         SET @po_action_msg = @v_FailMsg
      END
      ELSE
      BEGIN
         SET @po_action_key = 0
         SET @po_action_msg = ''
      END

      -- Make sure we are not already running (i.e. have a job_run record)
      -- Otherwise a fatal problem.
      BEGIN TRANSACTION JE002

      SET @v_step = 500

      SELECT @v_rec_count = COUNT(*)
      FROM   ws_wrk_job_run
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_row_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE002

      IF @v_rec_count <> 0 AND @v_child_job = 0
      BEGIN
        SET @v_MsgText = 'Job ' + @pi_job_name + ' already running. ' +
                         'Cannot start a new iteration. No Action !!!'
        EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
                                   @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        RETURN 0
      END

      -- Make sure there is no other sequence of this job running
      -- Otherwise a fatal problem.
      -- WMR 24/08/2001. Put the job on hold, if there are running sequences.
      -- WMR 24/08/2001. If failed sequences then put out a warning and proceed.
      --AP 28/01/2016  retry logic added as need to loop if blocked job being called as a child job
      SET @v_retry = 1
      SET @v_retry_msg_count = 6 -- force message on first pass then will occur on every n ones
      WHILE @v_retry = 1
      BEGIN
        SET @v_retry = 0

        BEGIN TRANSACTION JE003
        SET @v_step = 600

        -- RED-7694 Moved into one transaction to avoid issue with permanently blocked job
        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait

-- uncomment for debugging
--            declare @errorMessage nvarchar(200)
--            set @errorMessage =
--            case @v_lock_result
--              when -1 then 'Applock request timed out.'
--            when -2 then 'Applock request canceled.'
--            when -3 then 'Applock involved in deadlock'
--            else 'Parameter validation or other call error.'
--          end
          END

        END

        SELECT @v_rec_count = COUNT(*)
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key = @p_job_id

        SELECT @v_row_count     = @@ROWCOUNT

        IF @v_child_job = 1
        BEGIN
            -- if we're the new thread 0 for the sub-job, then don't count our job run record
            -- when deciding if we're blocked

            -- (@p_job_id, @pi_sequence) should be the only job waiting to start
            SELECT @v_child_job_pending_count = COUNT(*)
            FROM   ws_wrk_job_run
            WHERE  wjr_job_key = @p_job_id
            AND wjr_sequence = @pi_sequence
            AND wjr_status = 'P'

            IF @v_child_job_pending_count = 1 AND @v_rec_count > 0
            BEGIN
                -- yes, the @v_rec_count > 0 is redundant but will call attention to the fact that
                -- we need to be on the lookout for our inserted child job record in job cleanup logic

                -- there's one valid record in pending state owned by us
                -- adjust @v_rec_count to not include our child job run record when cleaning up
                -- any previously failed instances of JobID = @p_job_id below
                set @v_rec_count = @v_rec_count - 1
            END
        END

        IF @v_rec_count <> 0
        BEGIN

          SET @v_step = 700

          SELECT @v_job_count = COUNT(*)
          FROM   ws_wrk_job_run
          WHERE  wjr_job_key = @p_job_id
          AND    wjr_status = 'F'

          IF @v_job_count <> @v_rec_count
          BEGIN
            -- there's at least one active job with @p_job_id

            SET @v_step = 800

            IF @v_child_job = 1
            BEGIN
                -- we should never get here.
                -- The calling thread should've verified there are no instances of @p_job_id in other than failed state

                SET @v_MsgText = '[Child Job] Job ' + @pi_job_name + ' already running. ' + 'Cannot start a new iteration. No Action !!!'
                EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name,
                    @v_ctrl_sequence, @v_MsgText,NULL,NULL,0,@v_audit_job_id
                SET @po_result_code = -2

                COMMIT TRANSACTION JE003

                RETURN 0
            END
            ELSE
            BEGIN
              SET @v_MsgText = 'Job ' + @pi_job_name + ' already has a running sequence. ' +
                                           ' Job Blocked, until current job completes.'

              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
                                              @v_MsgText,NULL,NULL,0,@v_audit_job_id

              SET @v_step = 900

              COMMIT TRANSACTION JE003

              -- prevent possible deadlock
              -- We don't need have JOB_RUN + JOB_CONTROL as Ws_Job_Wait() is the only other
              -- agent that test/sets new root level jobs to 'B'.
              BEGIN TRANSACTION JE004

              SET @v_lock_result = -1
              WHILE @v_lock_result < 0
              BEGIN
                EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

                IF @v_lock_result < 0
                BEGIN
                  SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                  WAITFOR DELAY @v_wait
                END

              END

              SET @v_step = 1000

              UPDATE ws_wrk_job_ctrl
              SET    wjc_status = 'B'
              WHERE  wjc_job_key = @p_job_id
              AND    wjc_sequence = @v_ctrl_sequence

              SELECT @v_row_count     = @@ROWCOUNT

              COMMIT TRANSACTION JE004

              SET @po_result_code = -99
              RETURN 0
            END
          END
          ELSE --@v_job_count <> @v_rec_count
          BEGIN
            -- we get here if either we're a root job and there are only other failed instances
            -- or, we're a child job with one pending record that is 'US' and at least one or more
            -- failed instances of previous jobs

            SET @v_MsgText = 'Job ' + @pi_job_name + ' has a previously Failed (incomplete) sequence. Now Aborted'

            SET @v_step = 1200
            EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                                   @v_MsgText,NULL,NULL,0,@v_audit_job_id

            -- Update the job run record to be completed (Failed-Aborted)
            -- and set the completion date if it is null
            -- Move the job run record to the log record
            SET @v_all_status = 0
            SET @v_step = 1300

            SET @v_lock_result = -1
            WHILE @v_lock_result < 0
            BEGIN

              EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                                  @LockMode = 'Update',
                                                  @LockTimeout = 0

              IF @v_lock_result < 0
              BEGIN
                SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                WAITFOR DELAY @v_wait
              END

            END

            SET @v_step = 1400
            UPDATE ws_wrk_job_run
            SET    wjr_status = 'G'
            WHERE  wjr_job_key = @p_job_id
            AND wjr_sequence <> @pi_sequence

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 1500
            UPDATE ws_wrk_job_run
            SET    wjr_completed = GETDATE()
            WHERE  wjr_job_key = @p_job_id
            AND    wjr_completed IS NULL
            AND wjr_sequence <> @pi_sequence

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 1600

            INSERT INTO ws_wrk_job_log
            SELECT *
            FROM   ws_wrk_job_run
            WHERE  wjr_job_key = @p_job_id
            AND wjr_sequence <> @pi_sequence

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 1700

            DELETE FROM ws_wrk_job_run
            WHERE  wjr_job_key = @p_job_id
            AND wjr_sequence <> @pi_sequence

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 1800

            -- Move the task run records to the log record
            SET @v_all_status = 0
            SET @v_step = 1900

            SET @v_step = 2000
            DELETE FROM ws_wrk_task_log
            WHERE  wtl_job_key = @p_job_id
            AND    wtl_sequence = @pi_sequence
            AND    wtl_task_key IN
            (SELECT wtr_task_key
             FROM   ws_wrk_task_run
             WHERE  wtr_job_key = @p_job_id
             AND    wtr_sequence = @pi_sequence)

            SET @v_step = 2100
            INSERT INTO ws_wrk_task_log
            SELECT *
            FROM   ws_wrk_task_run
            WHERE  wtr_job_key = @p_job_id

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 2200

            DELETE FROM ws_wrk_task_run
            WHERE  wtr_job_key = @p_job_id

            SELECT @v_rec_count     = @@ROWCOUNT

            SET @v_step = 2300

          END
        END  -- End of other sequences

        -- END RED-7694 Moved into one transaction to avoid issue with permanently blocked job
        COMMIT TRANSACTION JE003

      END -- Loop for in case a blocked child job

      --=====================================================
      -- Record this thread as being active
      --=====================================================
      BEGIN TRANSACTION JE008
      SELECT
        @v_sid = @@SPID
      , @v_serial = @@SPID

      SET @v_step = 2400

      INSERT INTO ws_wrk_job_thread (
              wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
      VALUES (@p_job_id, @pi_sequence, @pi_thread, @v_sid, @v_serial)

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE008

      -- Create the Job run record
      -- Set its initial state to P for pending until we have the task_run records built
      --      wjc_job_key, @pi_sequence, 0, 'P', GETDATE(), GETDATE(), NULL, 0,0,
      -- NOTE: wjr_chkp_count is used to hold the parent job number or 0 if we are the root job

      -- [wjr] record for (@p_job_id, @pi_sequence) was inserted by calling job
      IF @v_child_job = 0
      BEGIN
        BEGIN TRANSACTION JE009
        SET @v_step = 2500

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 2600

        INSERT INTO ws_wrk_job_run (
             wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
             wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
             wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
             wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
             wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler,wjr_idle_thread_wait)
        SELECT wjc_job_key, @pi_sequence, 0, 'P', GETDATE(), GETDATE(), NULL, 0,0,
             0,0,0,0,0,0,0, wjc_name, wjc_user_key, wjc_max_threads,
             wjc_publish_okay, wjc_publish_fail, wjc_scheduler,ISNULL(wjc_idle_thread_wait,30)
        FROM   ws_wrk_job_ctrl
        WHERE  wjc_job_key = @p_job_id

        SELECT @v_rec_count     = @@ROWCOUNT

        SET @v_step = 2700

        COMMIT TRANSACTION JE009
      END

      BEGIN TRANSACTION JE010

        SET @v_step = 2800

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 2900
        INSERT INTO ws_wrk_task_run (
               wtr_task_key, wtr_job_key,
               wtr_sequence, wtr_restart, wtr_run_status, wtr_audit_status,
               wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
               wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg,
               wtr_type,
               wtr_abort_level, wtr_chkp_number,
               wtr_name, wtr_obj_type, wtr_action_type,
               wtr_obj_key,
               wtr_thread,
               wtr_order,
               wtr_action_ind)
        SELECT wtc_task_key,
               wtc_job_key,
               @pi_sequence,0,'W',NULL,
               NULL,NULL,0,0,
               0,0,0,NULL,
               wtc_type,
               wtc_abort_level, wtc_chkp_number,
               wtc_name, wtc_obj_type, wtc_action_type,
               wtc_obj_key,
               wtc_order,  -- order into the thread
               wtc_order,
               COALESCE(wtc_action_ind,'')
        FROM   ws_wrk_task_ctrl
        WHERE  wtc_job_key = @p_job_id

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE010


      -- All tasks added
      -- Set the job status to running so our threads can start running the tasks
      BEGIN TRANSACTION JE011
      SET @v_step = 3000

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 3100
      UPDATE ws_wrk_job_run
      SET    wjr_status = 'R',
             wjr_started = GETDATE()
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE011

      SET @v_MsgText = 'Job ' + @pi_job_name + ' sequence ' + convert(varchar,@pi_sequence)
                              + ' Started. '
      EXEC @v_result = WsWrkAudit 'B',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                            @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id

      -- If set for disable just the once, then role it back to not disabled if not a once only job
      IF @v_job_type <> 'O'
      BEGIN
        BEGIN TRANSACTION JE011
        SET @v_step = 3150
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        UPDATE ws_wrk_task_ctrl
        SET    wtc_action_ind = NULL
        WHERE  wtc_job_key    = @p_job_id
        AND    wtc_action_ind = @v_ws_act_disabled_once

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE011
      END

      SET @v_step = 3200
      --=====================================================
      -- Clear out any old logs for this job unless we are a called job
      --=====================================================
      IF @v_child_job = 0
      BEGIN
        IF @v_log_keep > 0
        AND @v_child_job = 0
        BEGIN
          -- we will create a log as part of this log, so keep 1 less
          SET @v_log_keep = @v_log_keep - 1
          SET @v_step = 3300

          EXEC @v_result = Ws_Job_Clear_Logs @p_sequence,
                            @p_job_name, @p_task_name, @p_job_id, @p_task_id,
                            @p_job_name, @v_log_keep,
                            @v_status_code OUTPUT, @p_return_msg OUTPUT,
                            @p_result OUTPUT
        END
      END

      SET @v_step = 3400
      IF @v_child_job = 0
      BEGIN
        -- Now either modify or delete the control record
        -- and if required delete the task records
        -- If it is a once only job then delete it from job control
        -- If a once and hold then set its status to Hold
        -- In all other cases work out when it will next run
        -- and put it in a wait state.

        -- 6.0.4.1 add a lock and consolidated the transaction for this processing also

        SET @v_step = 3500

        SET @v_handled = 0

        IF @v_job_type = 'O'
        BEGIN
          SET @v_handled = 1
          BEGIN TRANSACTION JE012

          SET @v_step = 3600

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 3700

          DELETE FROM  ws_wrk_job_ctrl
          WHERE  wjc_job_key = @p_job_id

          SELECT @v_rec_count     = @@ROWCOUNT

          SET @v_step = 3800

          DELETE FROM  ws_wrk_task_ctrl
          WHERE  wtc_job_key = @p_job_id

          SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE012

        END
        ELSE
        BEGIN
          -- Retrieve the next valid starttime for this job.
          EXEC Ws_Job_Get_Start @p_job_id, @v_wjc_start_after OUT, @v_wjc_status OUT, @v_getstart_status OUT, @v_MsgText OUT

          IF @v_getstart_status <> 1 -- issue establishing next start
          BEGIN

            SET @v_MsgText = 'Failure to determine next start ' + @v_audit_job_name + ' ' + @v_MsgText
            EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_job_name, @p_sequence,
                                         @v_MsgText,NULL,NULL,0, @v_audit_job_id

          END
          ELSE
          BEGIN

            SET @v_step = 3900
            BEGIN TRANSACTION JE013

            SET @v_step = 4000

            SET @v_lock_result = -1
            WHILE @v_lock_result < 0
            BEGIN

              EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                  @LockMode = 'Update',
                                                  @LockTimeout = 0

              IF @v_lock_result < 0
              BEGIN
                SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                WAITFOR DELAY @v_wait
              END

            END

            -- Set new job status and starttime.
            -- If in error, then correct values already passed back from Ws_Job_Starttime
            SET @v_step = 4100

            UPDATE ws_wrk_job_ctrl
            SET    wjc_status      = @v_wjc_status
                 , wjc_start_after = @v_wjc_start_after
            WHERE  wjc_job_key     = @p_job_id

            SELECT @v_rec_count     = @@ROWCOUNT

            COMMIT TRANSACTION JE013

            SET @v_handled = 1
          END
        END

        SET @v_step = 4200
        IF @v_handled = 0 -- issues encountered in determining next run
        BEGIN
          SET @v_step = 4300

          BEGIN TRANSACTION JE019

            SET @v_step = 4400

            SET @v_lock_result = -1
            WHILE @v_lock_result < 0
            BEGIN

              EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                                  @LockMode = 'Update',
                                                  @LockTimeout = 0

              IF @v_lock_result < 0
              BEGIN
                SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
                WAITFOR DELAY @v_wait
              END

            END

            SET @v_step = 4500

            UPDATE ws_wrk_job_ctrl
            SET    wjc_status = 'H',
                   wjc_start_after = GETDATE()
            WHERE wjc_job_key = @p_job_id

            SELECT @v_rec_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE019
        END

      END -- End of only do if not a child job

    END -- End of Thread 0
    ELSE
    --=====================================================
    -- If we are any other thread then we can start processing once
    -- the job_run and task_run tables have been updated.
    -- We will sleep for 10 seconds just in case, to give thread 0
    -- time to compete its work
    --=====================================================
    BEGIN

      SET @v_step = 4600

      SET @v_rec_count  = 0

        -- Make sure we are running
        -- Otherwise wait some more then go. Wait maximum of 2 minutes
        BEGIN TRANSACTION JE020
        SET @v_step = 4700

        SELECT @v_run_status = wjr_status
             , @p_job_id = wjr_job_key
             , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
        FROM   ws_wrk_job_run
        WHERE  RTRIM(UPPER(wjr_name)) = RTRIM(UPPER(@pi_job_name))
        AND    wjr_sequence = @pi_sequence

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE020

--SET @v_MsgText = 'Ws_Job_Exec (sub thread) invoked Job '+ @pi_job_name
--+ ' parent job ' + @pm_job_name
--+ ' job key ' + CONVERT(VARCHAR,@p_job_id)
--+ ' parent key ' + CONVERT(VARCHAR,@pm_job_key)
--+ ' audit key ' + CONVERT(VARCHAR,@v_audit_job_id)
--+ ' child flag ' + CONVERT(VARCHAR,@v_child_job)
--EXEC @v_result = WsWrkAudit 'A',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

        IF @v_rec_count     <> 1
        BEGIN
          SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
                           CONVERT(varchar,@pi_sequence) + ' Thread ' +
                           CONVERT(varchar,@pi_thread) + ' failed to locate job. Terminating ...'
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                          @v_MsgText,NULL,NULL,0,@v_audit_job_id
          SET @po_result_code = -98
          RETURN 0
        END

        -- If we are the parent job then we need the job id
        IF @v_child_job = 0
        BEGIN
          SELECT
            @v_audit_job_id = @p_job_id
          , @pm_job_key = @p_job_id
        END

      --=====================================================
      -- Record this thread as being active
      --=====================================================
      BEGIN TRANSACTION JE021
      SELECT
        @v_sid = @@SPID
      , @v_serial = @@SPID

      SET @v_step = 4800

      INSERT INTO ws_wrk_job_thread (
              wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
      VALUES (@p_job_id, @pi_sequence, @pi_thread, @v_sid, @v_serial)

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE021

   END -- End Thread other than 0
  END -- End of NEW Job

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --                  R E S T A R T       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  -- If we are a Restart job then check we are in a waiting
  -- state.
  -- Archive the _run table to the log table
  -- Reset any failed jobs, change the restart counter and proceed
  --=====================================================
  IF UPPER(@pi_action) = 'RESTART'
  BEGIN
    SET @v_restart_flag = 1
    --=====================================================
    -- If we are thread 0 and not a child job then do some checks
    -- and reset any halted or failed tasks so that they will run
    --=====================================================
    IF @pi_thread = 0
    AND @v_child_job = 0
    BEGIN

      -- Make sure we are in run tables (i.e. have a job_run record)
      -- And have a waiting state
      -- Otherwise a fatal problem.
      BEGIN TRANSACTION JE022
        SET @v_step = 4900

        SELECT
          @v_run_status = wjr_status
        , @p_job_id = wjr_job_key
        , @v_FailMsg = wjr_publish_fail
        , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
        FROM  ws_wrk_job_run
        WHERE RTRIM(UPPER(wjr_name)) = RTRIM(UPPER(@pi_job_name))
        AND   wjr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE022

      BEGIN TRANSACTION JE023
        SET @v_step = 5000

        SELECT @v_rec_count = COUNT(*)
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key = @p_job_id
        AND    wjr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE023

      IF @v_rec_count <> 1
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
                         CONVERT(varchar,@pi_sequence) + ' not running. ' +
                        'Cannot restart. No Action !!!'
        EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                                 @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        RETURN 0
      END

      -- If we have a parent job then setup to use it's keys in the audit log
      IF @v_child_job = 0
      BEGIN
        SELECT
          @v_audit_job_id = @p_job_id
        , @pm_job_key = @p_job_id
      END

      -- Setup to default for a failure if a Fail command has been provided
      IF @v_FailMsg <> '' AND @v_FailMsg IS NOT NULL
      BEGIN
        SET @po_action_key = 2
        SET @po_action_msg = @v_FailMsg
      END
      ELSE
      BEGIN
        SET @po_action_key = 0
        SET @po_action_msg = ''
      END

      IF @v_run_status <> 'P'
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job '+ @pi_job_name + ' sequence ' +
                         CONVERT(varchar,@pi_sequence) + ' not prepared for re-run. ' +
                         'Cannot restart. No Action !!!'
        EXEC @v_result = WsWrkAudit'F',@pi_job_name, @pi_job_name, @pi_sequence,
                                                   @v_MsgText,NULL,NULL,0,@p_job_id
        SET @po_result_code = -2
        RETURN 0
      END

      --=====================================================
      -- Record this thread as being active
      --=====================================================
      BEGIN TRANSACTION JE024

        SELECT
          @v_sid = @@SPID
        , @v_serial = @@SPID

        SET @v_step = 5100

        INSERT into ws_wrk_job_thread (
                wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
        VALUES (@p_job_id, @pi_sequence, @pi_thread, @v_sid, @v_serial)

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE024

      BEGIN TRANSACTION JE025

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 5200

        UPDATE ws_wrk_job_run
        SET    wjr_status = 'P',
               wjr_restart = wjr_restart + 1
        WHERE  wjr_job_key = @p_job_id
        AND    wjr_sequence = @pi_sequence

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE025

      --=======================================================
      -- Cursor for all the task run records waiting to be run
      --=======================================================
      --6.0.4.1 changed to 2 set based updates

      SET @v_step = 5300

      BEGIN TRANSACTION JE026

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      UPDATE ws_wrk_task_run
      SET    wtr_started = NULL,
             wtr_completed = NULL,
             wtr_elapsed_hh = 0,
             wtr_elapsed_mi = 0,
             wtr_run_status = 'W',
             wtr_audit_status = NULL,
             wtr_info_count = 0,
             wtr_warning_count = 0,
             wtr_detail_count = 0,
             wtr_return_msg = NULL
      WHERE wtr_job_key = @p_job_id
      AND   wtr_sequence = @pi_sequence
      AND   wtr_run_status IN ( 'H'
                              , 'F'
                              , 'U')

      SELECT @v_rec_count     = @@ROWCOUNT

      SET @v_step = 5400
      -- Not sure why we update all tasks .. but that's how it is :-)

      UPDATE ws_wrk_task_run
      SET    wtr_restart  = wtr_restart + 1
      WHERE  wtr_job_key  = @p_job_id
      AND    wtr_sequence = @pi_sequence
      AND    wtr_run_status <> 'C'

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE026

      -- ======================
      -- Fix up any child jobs
      -- ======================
      BEGIN TRANSACTION JE0262

      SET @v_step = 5500

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 5600
      UPDATE ws_wrk_job_run
      SET    wjr_status = 'P',
             wjr_restart = wjr_restart + 1
      WHERE  wjr_chkp_count = @p_job_id
      AND    wjr_sequence = @pi_sequence
      AND    wjr_job_key NOT IN
      (SELECT wtr_obj_key
       FROM   ws_wrk_task_run
       WHERE  wtr_job_key = @p_job_id
       AND    wtr_sequence = @pi_sequence
       AND    wtr_run_status = 'C')

      COMMIT TRANSACTION JE0262

      BEGIN TRANSACTION JE0263
      SET @v_step = 5700

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 5800
      UPDATE ws_wrk_task_run
      SET    wtr_restart = wtr_restart + 1
      WHERE  wtr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND wtr_job_key NOT IN
      (SELECT wtr_obj_key
       FROM ws_wrk_task_run
       WHERE wtr_job_key = @p_job_id
       AND wtr_sequence = @pi_sequence
       AND wtr_run_status = 'C')
      AND wtr_sequence = @pi_sequence
      AND wtr_run_status <> 'C'

      COMMIT TRANSACTION JE0263

      BEGIN TRANSACTION JE0264
      SET @v_step = 5900

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END
      END

      SET @v_step = 6000
      UPDATE ws_wrk_task_run
      SET    wtr_started = NULL,
             wtr_completed = NULL,
             wtr_elapsed_hh = 0,
             wtr_elapsed_mi = 0,
             wtr_run_status = 'W',
             wtr_audit_status = NULL,
             wtr_info_count = 0,
             wtr_warning_count = 0,
             wtr_detail_count = 0,
             wtr_return_msg = NULL
      WHERE  wtr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND wtr_job_key NOT IN
      (SELECT wtr_obj_key
       FROM ws_wrk_task_run
       WHERE wtr_job_key = @p_job_id
       AND wtr_sequence = @pi_sequence
       AND wtr_run_status = 'C')
      AND wtr_sequence = @pi_sequence
      AND wtr_run_status IN ('H','F','U')

      COMMIT TRANSACTION JE0264

      BEGIN TRANSACTION JE0265
      SET @v_step = 6100

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 6200
      UPDATE ws_wrk_job_run
      SET    wjr_status = 'R'
      WHERE  wjr_chkp_count = @p_job_id
      AND    wjr_sequence = @pi_sequence
      AND    wjr_job_key NOT IN
      (SELECT wtr_obj_key
       FROM   ws_wrk_task_run
       WHERE  wtr_job_key = @p_job_id
       AND    wtr_sequence = @pi_sequence
       AND    wtr_run_status = 'C')

      COMMIT TRANSACTION JE0265

      -- End of child job fixup.

      -- Set the job status to running
      BEGIN TRANSACTION JE027

      SET @v_step = 6300

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 6400
      UPDATE ws_wrk_job_run
      SET    wjr_status = 'R'
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE027

      SET @v_MsgText = 'Job ' + @pi_job_name + ' sequence '+
        CONVERT(varchar,@pi_sequence) + ' Restarted. '
      EXEC @v_result = WsWrkAudit 'B',@pi_job_name, @pi_job_name, @pi_sequence,
                                            @v_MsgText,NULL,NULL,0,@p_job_id

    --====================================================================================
    -- If we are not thread 0 or are a a child job then wait for two minutes for the okay
    --====================================================================================
    END
    ELSE
    BEGIN
      -- Get the job key for the job name. There should be one and
      -- only one key. Otherwise a fatal problem.
      BEGIN TRANSACTION JE028
      SET @v_step = 6500

      SELECT @p_job_id = wjr_job_key
           , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
      FROM   ws_wrk_job_run
      WHERE  RTRIM(UPPER(wjr_name)) = RTRIM(UPPER(@pi_job_name))

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE028

      IF @v_rec_count <> 1
        BEGIN
          SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Sequence ' +
                           CONVERT(varchar,@pi_sequence) + ' Thread ' +
                           CONVERT(varchar,@pi_thread) + ' failed to locate job. Terminating ...'
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                          @v_MsgText,NULL,NULL,0,@v_audit_job_id
          SET @po_result_code = -98
          RETURN 0
        END

      -- If we have a parent job then setup to use it's keys in the audit log
      IF @v_child_job = 0
      BEGIN
        SELECT
          @v_audit_job_id = @p_job_id
        , @pm_job_key = @p_job_id
      END

      --=====================================================
        -- Record this thread as being active
      --=====================================================
      BEGIN TRANSACTION JE029
      SELECT
        @v_sid = @@SPID
      , @v_serial = @@SPID

      SET @v_step = 6600
      INSERT into ws_wrk_job_thread (
              wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
      VALUES (@p_job_id, @pi_sequence, @pi_thread, @v_sid, @v_serial)

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE029

      SET @v_loop_count = 0

      SET @v_loop = 0
      WHILE @v_loop = 0
      BEGIN
        -- Make sure we are running
        -- Otherwise wait some more then go. Wait maximum of 2 minutes
        BEGIN TRANSACTION JE030
        SET @v_step = 6700

        SELECT @v_run_status = wjr_status
             , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key = @p_job_id
        AND    wjr_sequence = @pi_sequence

        SELECT @v_rec_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE030

        IF @v_run_status = 'R'
        BEGIN
          SET @v_loop = 1
          BREAK
        END

        SET @v_loop_count = @v_loop_count + 1
        IF @v_loop_count < 13
        BEGIN
          WAITFOR DELAY '00:00:10'
        END
        ELSE
        BEGIN
          SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Sequence ' +
                           CONVERT(varchar,@pi_sequence) + ' Thread ' +
                           CONVERT(varchar,@pi_thread) + ' failed to locate job. Terminating ...'
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                          @v_MsgText,NULL,NULL,0,@v_audit_job_id
          SET @po_result_code = -98
          RETURN 0
        END
      END -- end check running loop

    END -- end of none thread zero for Restart

  END -- end of RESTART job

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --                  R E J O I N       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  -- If we are a Rejoin job then  we have completed a host
  -- subtask. So check we are in a running state.
  -- Set the result status for the task we have just actioned
  -- and proceed with other tasks
  --=====================================================
  IF LEFT(UPPER(@pi_action),6) = 'REJOIN' OR LEFT(UPPER(@pi_action),9) = 'EXTRETURN'
  BEGIN
    SET @v_step = 7000
    -- If there are child jobs then rejoin them
    SELECT @v_cpos = PATINDEX('%,%',ISNULL(@pm_rejoin_job_keys,''))
    IF @v_cpos > 0
    BEGIN
      SET @p_job_id = @pi_job_key

      -- Get the top job key off the list which should be my key
      SELECT @v_cpos = ISNULL(PATINDEX('%,%',@pm_rejoin_job_keys),0);
      IF @v_cpos > 0
      BEGIN
        SELECT @v_my_job_key = CONVERT(integer,ISNULL(SUBSTRING(@pm_rejoin_job_keys,1,@v_cpos-1),0))
        IF @v_my_job_key > 0
        BEGIN
          SELECT @v_rejoin_job_keys = SUBSTRING(@pm_rejoin_job_keys,@v_cpos+1,256)
        END
      END
      ELSE
      BEGIN
        SELECT @v_my_job_key = CONVERT(integer,ISNULL(@pm_rejoin_job_keys,0))
        SELECT @v_rejoin_job_keys= NULL
      END

      SET @v_step = 7100
      -- If not my job then a fatal problem
      IF @v_my_job_key <> @pi_job_key
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Encountered bad rejoin job key list.'
        EXEC @v_result = WsWrkAudit'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                  @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        SELECT @po_result_msg = @v_MsgText
        RETURN 0
      END


      SET @v_step = 7200
      -- Get the next job key off the list (child) and lookup the job name
      SELECT @v_cpos = ISNULL(PATINDEX('%,%',@v_rejoin_job_keys),0);
      IF @v_cpos > 0
      BEGIN
        SELECT @v_sub_job_key = CONVERT(integer,ISNULL(SUBSTRING(@v_rejoin_job_keys,1,@v_cpos-1),0))
      END
      ELSE
      BEGIN
        SELECT @v_sub_job_key = CONVERT(integer,ISNULL(@v_rejoin_job_keys,0))
      END

      SET @v_step = 7300
      -- If no key then a fatal problem
      IF @v_sub_job_key = 0
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Unable to rejoin to sub job. Bad key list '
        EXEC @v_result = WsWrkAudit'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                  @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        SELECT @po_result_msg = @v_MsgText
        RETURN 0
      END

      -- Get the sub job name
      SELECT @v_sub_job_name = ''

      SET @v_step = 7400

      SELECT
        @v_sub_job_name = wjr_name
      , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
      FROM ws_wrk_job_run
      WHERE wjr_job_key = @v_sub_job_key
      AND wjr_sequence = @pi_sequence

       -- If no running job to join to then a fatal problem
      IF @v_sub_job_name IS NULL OR @v_sub_job_name = ''
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Unable to rejoin to sub job. No such running job'
        EXEC @v_result = WsWrkAudit'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                  @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        SELECT @po_result_msg = @v_MsgText
        RETURN 0
      END

      SET @v_step = 7500
      -- Get the top task key off the list which should be my task key
      SELECT @v_cpos = ISNULL(PATINDEX('%,%',@pm_rejoin_task_keys),0);
      IF @v_cpos > 0
      BEGIN
        SELECT @v_my_task_key = CONVERT(integer,ISNULL(SUBSTRING(@pm_rejoin_task_keys,1,@v_cpos-1),0))
        IF @v_my_task_key > 0
        BEGIN
          SELECT @v_rejoin_task_keys = SUBSTRING(@pm_rejoin_task_keys,@v_cpos+1,256)
        END
      END
      ELSE
      BEGIN
        SELECT @v_my_task_key = CONVERT(integer,ISNULL(@pm_rejoin_task_keys,0))
        SELECT @v_rejoin_task_keys= NULL
      END

      SET @v_step = 7600
      -- Get the next task key off the list (child task) and lookup the task name
      SELECT @v_cpos = ISNULL(PATINDEX('%,%',@v_rejoin_task_keys),0);
      IF @v_cpos > 0
      BEGIN
        SELECT @v_sub_task_key = CONVERT(integer,ISNULL(SUBSTRING(@v_rejoin_task_keys,1,@v_cpos-1),0))
      END
      ELSE
      BEGIN
        SELECT @v_sub_task_key = CONVERT(integer,ISNULL(@v_rejoin_task_keys,0))
      END


      SET @v_step = 7700
      -- If no key then a fatal problem
      IF @v_my_task_key = 0
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Unable to locate calling task. Bad key list '
        EXEC @v_result = WsWrkAudit'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                  @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        SELECT @po_result_msg = @v_MsgText
        RETURN 0
      END

      -- Get sub task name
      SET @v_my_task_name = ''

      SET @v_step = 7800

      SELECT @v_my_task_name = wtr_name
      FROM ws_wrk_task_run
      WHERE wtr_job_key = @pi_job_key
      AND wtr_task_key = @v_my_task_key
      AND wtr_sequence = @pi_sequence

       -- If no task to then a fatal problem
      IF @v_my_task_name IS NULL OR @v_my_task_name = ''
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' Unable to rejoin to job. Unable to locate calling Task'
        EXEC @v_result = WsWrkAudit'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                  @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        SELECT @po_result_msg = @v_MsgText
        RETURN 0
      END


--SET @v_MsgText = 'Recall on sub Job '+ @v_sub_job_name
--+ ' parent job ' + @pm_job_name
--+ ' job key ' + CONVERT(VARCHAR,@v_sub_job_key)
--+ ' parent key ' + CONVERT(VARCHAR,@pm_job_key)
--+ ' child flag ' + CONVERT(VARCHAR,@v_child_job)
--EXEC @v_result = WsWrkAudit 'D',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

      SET @v_step = 7900

      -- Rejoin this sub job
      EXEC @v_result = Ws_Job_Exec_411 @v_sub_job_name,@pi_task_name,@pi_action,0,@pi_sequence,
                                       @v_sub_job_key, @pi_task_key,@pi_task_status,@pi_task_msg,
                                       @pm_job_name, @pm_job_key, @v_rejoin_job_keys, @v_rejoin_task_keys,
                                       @p_status_code OUTPUT,
                                       @p_return_msg OUTPUT,
                                       @v_job_job_key OUTPUT,
                                       @v_job_task_key OUTPUT,@v_job_task_name OUTPUT,
                                       @v_job_action_key OUTPUT, @v_job_action_msg OUTPUT,
                                       @v_job_key_list OUTPUT, @v_task_key_list OUTPUT,
                                       @v_task_data OUTPUT
      IF @p_status_code = -3
      BEGIN
        SELECT @p_return_msg = 'Called job ' + RTRIM(@v_sub_job_name) + ' FAILED with unhandled error'
      END
      IF @p_status_code = -2
      BEGIN
        SELECT @p_return_msg = 'Called job ' + RTRIM(@v_sub_job_name) + ' FAILED'
      END
      IF @p_status_code = -1
      BEGIN
        SELECT @p_return_msg = 'Called job ' + RTRIM(@v_sub_job_name) + ' completed with WARNINGS'
      END
      IF @p_status_code = 0
      BEGIN
        SELECT @p_return_msg = 'Called job ' + RTRIM(@v_sub_job_name) + ' FAILED with unhandled problem'
        SELECT @p_status_code = -2
      END
      IF @p_status_code = 1
      BEGIN
        SELECT @p_return_msg = 'Called job ' + RTRIM(@v_sub_job_name) + ' completed successfully'
      END
      IF @p_status_code > 1
      BEGIN
        SET @po_job_key       = @p_job_id
        SET @po_task_key      = @v_job_task_key
        SET @po_task_name     = @v_job_task_name
        SET @po_result_msg    = @p_return_msg
        SET @po_action_key    = @v_job_action_key
        SET @po_action_msg    = @v_job_action_msg
        SET @po_result_code   = @p_status_code
        SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id) + ',' + ISNULL(@v_job_key_list,'')
        SET @ps_task_key_list = CONVERT(VARCHAR,@v_my_task_key) + ',' + ISNULL(@v_task_key_list,'')
        SET @po_task_data     = @v_task_data
--SET @v_MsgText = 'Pass back from rejoined sub job '+ RTRIM(@p_task_name)
--+ ' parent job ' + RTRIM(@pm_job_name)
--+ ' job key ' + CONVERT(VARCHAR,@p_job_id)
--+ ' parent key ' + CONVERT(VARCHAR,@pm_job_key)
--+ ' audit key ' + CONVERT(VARCHAR,@v_audit_job_id)
--+ ' child flag ' + CONVERT(VARCHAR,@v_child_job)
--+ ' job key list ' + SUBSTRING(ISNULL(@ps_job_key_list,''),1,20)
--+ ' task key list ' + SUBSTRING(ISNULL(@ps_task_key_list,''),1,20)
--EXEC @v_result = WsWrkAudit 'G',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id
        RETURN 0;
      END

      -- put up my task key for the drop through on this rejoin.
      SET @p_task_id         = @v_my_task_key
      SET @pi_task_key       = @v_my_task_key
      SET @pi_task_name      = @v_my_task_name
      SET @v_audit_job_id    = @pm_job_key
      SET @v_audit_task_id   = @p_task_id
      SET @v_audit_task_name = @v_my_task_name
    END
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- else a rejoin from an external object.
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    ELSE IF LEFT(UPPER(@pi_action),9) = 'EXTRETURN'
    BEGIN

      SET @p_status_code     = @pi_task_status
      SET @p_return_msg      = @pi_task_msg
      SET @p_task_id         = @pi_task_key
      SET @p_job_id          = @pi_job_key
      SET @v_audit_job_id    = @pm_job_key
      SET @v_audit_task_id   = @p_task_id
      SET @v_audit_task_name = @pi_task_name

      --=====================================================
      -- Make sure we have a valid return status
      -- Otherwise make this a failure
      -- Update the status of the task we have completed.
      --=====================================================
      SET @v_handled = 0
      IF @p_status_code = 1
      BEGIN
        SET @v_audit_status = 'S'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -1
      BEGIN
        SET @v_audit_status = 'W'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -2
      BEGIN
        SET @v_audit_status = 'E'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END
      IF @p_status_code = -3
      BEGIN
        SET @v_audit_status = 'F'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END

      IF @v_handled = 0
      BEGIN
        SET @v_audit_status = 'U'
        SET @v_run_status   = 'U'
        SET @p_status_code  = -3

        SET @p_return_msg = 'Invalid return code ' + CONVERT(varchar, @pi_task_status) +
           '. Msg was ' + SUBSTRING(@pi_task_msg,1,150) +
           '. Expecting return code of 1,-1,-2, or -3'
      END


      --=====================================================
      -- Update the run record to indicate our final status
      --=====================================================
      SET @v_step = 6800
      BEGIN TRANSACTION JE036

      --Attain a lock
      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 6900

      UPDATE ws_wrk_task_run
      SET    wtr_run_status   = @v_run_status,
             wtr_audit_status = @v_audit_status,
             wtr_return_msg   = @p_return_msg,
             wtr_elapsed_hh   = CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60),
             wtr_elapsed_mi   = DATEDIFF(mi,wtr_started,GETDATE()) -
                                CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60)*60,
             wtr_completed    = GETDATE()
      WHERE  wtr_task_key = @pi_task_key
      AND    wtr_job_key  = @p_job_id

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE036
    END -- End of Rejoin from external object
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- else a normal rejoin.
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    ELSE
    BEGIN
      -- Setup our return codes
      SET @p_status_code     = @pi_task_status
      SET @p_return_msg      = @pi_task_msg
      SET @p_task_id         = @pi_task_key
      SET @p_job_id          = @pi_job_key
      SET @v_audit_job_id    = @pm_job_key
      SET @v_audit_task_id   = @p_task_id
      SET @v_audit_task_name = @pi_task_name
    END


--SET @v_MsgText = 'Completing Rejoin of Job '+ @pi_job_name
--+ ' parent job ' + ISNULL(@pm_job_name,'')
--+ ' job key ' + CONVERT(VARCHAR,ISNULL(@p_job_id,-9))
--+ ' parent key ' + CONVERT(VARCHAR,ISNULL(@pm_job_key,-9))
--+ ' task key ' + CONVERT(VARCHAR,ISNULL(@p_task_id,-9))
--+ ' audit job key ' + CONVERT(VARCHAR,ISNULL(@v_audit_job_id,-9))
--+ ' audit task key ' + CONVERT(VARCHAR,ISNULL(@v_audit_task_id,-9))
--+ ' child flag ' + CONVERT(VARCHAR,ISNULL(@v_child_job,-9))
--+ ' status code ' + CONVERT(VARCHAR,ISNULL(@p_status_code,-9))
--EXEC @v_result = WsWrkAudit 'K',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

    SET @v_step = 8000
    --=====================================================
    -- Make sure we have a valid return status
    -- Otherwise make this a failure
    -- Update the status of the task we have completed.
    --=====================================================
    SET @v_handled = 0
    IF @p_status_code = 1
    BEGIN
      SET @v_audit_status = 'S'
      SET @v_run_status   = 'C'
      SET @v_handled      = 1
    END
    IF @p_status_code = -1
    BEGIN
      SET @v_audit_status = 'W'
      SET @v_run_status   = 'C'
      SET @v_handled      = 1
    END
    IF @p_status_code = -2
    BEGIN
      SET @v_audit_status = 'E'
      SET @v_run_status   = 'F'
      SET @v_handled      = 1
    END
    IF @p_status_code = -3
    BEGIN
      SET @v_audit_status = 'F'
      SET @v_run_status   = 'F'
      SET @v_handled      = 1
    END

    IF @v_handled = 0
    BEGIN
      SET @v_audit_status = 'U'
      SET @v_run_status   = 'U'
      SET @p_status_code  = -3

      SET @p_return_msg = 'Invalid return code ' + CONVERT(varchar, @pi_task_status) +
         '. Msg was ' + SUBSTRING(@pi_task_msg,1,150) +
         '. Expecting return code of 1,-1,-2, or -3'
    END

    SET @v_step = 8100
    --=====================================================
    -- Record this thread as being active
    --=====================================================
    BEGIN TRANSACTION JE031
    SELECT
      @v_sid = @@SPID
    , @v_serial = @@SPID

    SET @v_step = 8200

    INSERT INTO ws_wrk_job_thread (
            wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
    VALUES (@p_job_id, @pi_sequence, @pi_thread, @v_sid, @v_serial)

    SELECT @v_rec_count     = @@ROWCOUNT
    COMMIT TRANSACTION JE031

    -- Delete the temporary script we have created for this
    -- task to use
    BEGIN TRANSACTION JE032

    SET @v_step = 8300

    DELETE FROM ws_wrk_task_scr_line
    WHERE  wtsl_task_key = @pi_task_key
    AND    wtsl_job_key = @v_audit_job_id                 -- 5.6.2.1 changed from @pi_job_key
    AND    wtsl_sequence = @pi_sequence

    SET @v_step = 8400

    DELETE FROM ws_wrk_task_scr_hdr
    WHERE  wtsh_task_key = @pi_task_key
    AND    wtsh_job_key = @v_audit_job_id                 -- 5.6.2.1 changed from  @pi_job_key
    AND    wtsh_sequence = @pi_sequence

    COMMIT TRANSACTION JE032

    -- Make sure we are in run tables (i.e. have a job_run record)
    -- And have a waiting state
    -- Otherwise a fatal problem.
    BEGIN TRANSACTION JE033
    SET @v_step = 8500

    SELECT @v_run_status       = wjr_status
         , @p_job_id           = wjr_job_key
         , @v_FailMsg          = wjr_publish_fail
         , @v_idle_thread_wait = ISNULL(wjr_idle_thread_wait,30)
    FROM   ws_wrk_job_run
    WHERE  RTRIM(UPPER(wjr_name)) = RTRIM(UPPER(@pi_job_name))
    AND    wjr_sequence = @pi_sequence

    SELECT @v_rec_count     = @@ROWCOUNT
    COMMIT TRANSACTION JE033

    IF @v_rec_count <> 1
    BEGIN
      SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
                       CONVERT(varchar,@pi_sequence) +
                       ' cannot rejoin. '+
                       ' no such job exists. No Action !!!'
      EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                 @v_MsgText,NULL,NULL,0,@v_audit_job_id

      -- See if we can work out what has happened to the job
      -- and let them know
      BEGIN TRANSACTION JE034
      SET @v_step = 8600

      SELECT @v_run_status = wjl_status
           , @v_FailMsg    = wjl_publish_fail
      FROM   ws_wrk_job_log
      WHERE  RTRIM(UPPER(wjl_name)) = RTRIM(UPPER(@pi_job_name))
      AND    wjl_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE034

      SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
                         CONVERT(varchar,@pi_sequence) + ' has a log entry with status ' +
                         CONVERT(varchar,@v_run_status) + ' ' + substring(@v_FailMsg,1,128)
      EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                   @v_MsgText,NULL,NULL, @p_task_id,@v_audit_job_id

      SET @v_handled = 0
      IF @p_status_code = 1
      BEGIN
        SET @v_audit_status = 'S'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -1
      BEGIN
        SET @v_audit_status = 'W'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -2
      BEGIN
        SET @v_audit_status = 'E'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END
      IF @p_status_code = -3
      BEGIN
        SET @v_audit_status = 'F'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END
      IF @v_handled = 0
      BEGIN
        SET @v_audit_status = 'U'
        SET @v_run_status   = 'U'
        SET @p_status_code  = -3
      END

      EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
               @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

      SET @po_result_code = -2
      RETURN 0
    END

    -- Setup to default for a failure if a Fail command has been provided
    IF @v_FailMsg <> '' AND @v_FailMsg IS NOT NULL
    BEGIN
      SET @po_action_key = 2
      SET @po_action_msg = @v_FailMsg
    END
    ELSE
    BEGIN
      SET @po_action_key = 0
      SET @po_action_msg = ''
    END

    -- Get some info about the task we have just completed
    BEGIN TRANSACTION JE035
    SET @v_step = 8700

    SELECT @v_obj_key     = wtr_obj_key
         , @v_obj_type    = wtr_obj_type
         , @v_action_type = wtr_action_type
    FROM   ws_wrk_task_run
    WHERE  wtr_job_key  = @p_job_id
    AND    wtr_task_key = @pi_task_key
    AND    wtr_sequence = @pi_sequence

    SELECT @v_rec_count     = @@ROWCOUNT
    COMMIT TRANSACTION JE035

    IF @v_rec_count <> 1
    BEGIN
      SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
                       CONVERT(varchar,@pi_sequence) +
                       ' Task ' + @pi_task_name + ' not running. ' +
                       'Cannot rejoin. No Action !!!'
      EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                               @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id

      SET @v_handled = 0
      IF @p_status_code = 1
      BEGIN
        SET @v_audit_status = 'S'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -1
      BEGIN
        SET @v_audit_status = 'W'
        SET @v_run_status   = 'C'
        SET @v_handled      = 1
      END
      IF @p_status_code = -2
      BEGIN
        SET @v_audit_status = 'E'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END
      IF @p_status_code = -3
      BEGIN
        SET @v_audit_status = 'F'
        SET @v_run_status   = 'F'
        SET @v_handled      = 1
      END
      IF @v_handled = 0
      BEGIN
        SET @v_audit_status = 'U'
        SET @v_run_status   = 'U'
        SET @p_status_code  = -3
      END

      EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
               @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

      SET @po_result_code = -2
      RETURN 0
    END


    --=====================================================
    -- If a Load then we have just completed the load phase
    -- And now need to run any post load procedure if the
    -- load was a success
    -- If a Load and the action is a process then we need
    -- to do any index builds as well
    --=====================================================
    SET @v_step = 8800
    IF @v_obj_type = @v_ws_obj_load
    BEGIN
      IF @p_status_code >= -1 -- Successful load
      BEGIN
        SET @v_step = 8900

        IF UPPER(@pi_action) = 'REJOIN' OR UPPER(@pi_action) = 'REJOIN91' -- not a procedure execute rejoin
        BEGIN

          SET @v_step = 9000
          EXEC @v_result = Ws_Act_Post_Load @p_sequence,@v_obj_type,@v_action_type,
                                @v_obj_key,
                                @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                @p_return_msg_2 OUTPUT,
                                @p_status_code_2 OUTPUT,
                                @p_result_2 OUTPUT


          IF @p_status_code_2 = 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                  @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END
          IF @p_status_code_2 < 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                  @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END

          -- If this procedure is a SQLBLOCK we will have a return value of 2
          -- skip out to process it
          -- When we Rejoin the job any post action will be run
          IF @p_status_code_2 = 2
          BEGIN

            -- Need to first output info message for the export step
            EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
              @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @p_task_id
            SET @po_task_name     = @p_task_name
            SET @po_result_msg    = 'execute sql'
            SET @po_action_key    = @v_obj_key
            SET @po_action_msg    = 'no action'
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
            SET @po_result_code   = @p_result_2 -- 16 or 17
            --=====================================================
            -- Remove this thread as being active
            --=====================================================
            SET @v_step = 9100
            IF @p_job_id > 0 AND @v_sid <> 0
            BEGIN
              BEGIN TRANSACTION JE053
              SET @v_step = 9200

              DELETE FROM ws_wrk_job_thread
              WHERE  wjt_job_key  = @p_job_id
              AND    wjt_thread   = @pi_thread
              AND    wjt_sequence = @pi_sequence
              AND    wjt_sid      = @v_sid
              AND    wjt_serial   = @v_serial

              COMMIT TRANSACTION JE053
            END
            RETURN 0
          END
        END-- Standard REJOIN
        ELSE
        BEGIN-- Procedure exec REJOIN
          SET @p_status_code_2 = @p_status_code;
          SET @p_return_msg_2  = @p_return_msg;
          SET @v_result        = 1;

          IF @p_status_code_2 = 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                  @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END
          IF @p_status_code_2 < 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                  @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END

        END


        IF @v_result >= -1 AND @v_action_type = @v_ws_act_process AND UPPER(@pi_action) <> 'EXTRETURN'
        BEGIN

          SET @v_step = 9300
          EXEC @v_result = Ws_Act_Build @p_sequence,@v_obj_type,@v_action_type,
                                        @v_obj_key,
                                        @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                        @p_return_msg_3 OUTPUT,
                                        @p_status_code_3 OUTPUT,
                                        @p_result_3 OUTPUT

          IF @p_status_code_3 = 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                         @p_return_msg_3,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END
          IF @p_status_code_3 < 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                         @p_return_msg_3,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END
        END
        ELSE
        BEGIN
          SET @p_status_code_2 = 1
        END

        -- If our post load procedure failed and the load worked then
        -- record the post load failure
        IF @p_status_code_2 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_2
        END
        IF @p_status_code_3 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_3
        END

      END -- end of successful load
    END -- end of load

    --=====================================================
    -- If an Export then we have just completed the export phase
    -- And now need to run any post export procedure if the
    -- export was a success
    --=====================================================
    SET @v_step = 9400
    IF @v_obj_type = @v_ws_obj_export
    BEGIN
      IF @p_status_code >= -1 -- Successful Export
      BEGIN
        IF UPPER(@pi_action) = 'REJOIN' -- not a procedure execute rejoin
        BEGIN

          SET @v_step = 9500
          EXEC @v_result = Ws_Act_Post_Export @p_sequence,@v_obj_type,@v_action_type,
                                              @v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg_2 OUTPUT,
                                              @p_status_code_2 OUTPUT,
                                              @p_result_2 OUTPUT

          -- If this procedure is a SQLBLOCK we will have a return value of 2
          -- skip out to process it
          -- When we Rejoin the job any post action will be run
          IF @p_status_code_2 = 2
          BEGIN

            -- Need to first output info message for the export step
            EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
              @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @p_task_id
            SET @po_task_name     = @p_task_name
            SET @po_result_msg    = 'execute sql'
            SET @po_action_key    = @v_obj_key
            SET @po_action_msg    = 'no action'
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
            SET @po_result_code   = @p_result_2 -- 16 or 17
            --=====================================================
            -- Remove this thread as being active
            --=====================================================
            SET @v_step = 9600
            IF @p_job_id > 0 AND @v_sid <> 0
            BEGIN
              BEGIN TRANSACTION JE053
              SET @v_step = 9700

              DELETE FROM ws_wrk_job_thread
              WHERE  wjt_job_key  = @p_job_id
              AND    wjt_thread   = @pi_thread
              AND    wjt_sequence = @pi_sequence
              AND    wjt_sid      = @v_sid
              AND    wjt_serial   = @v_serial

              COMMIT TRANSACTION JE053
            END
            RETURN 0
          END
        END-- Standard REJOIN
        ELSE
        BEGIN
          SET @p_status_code_2 = @p_status_code;
          SET @p_return_msg_2  = @p_return_msg;
          SET @v_result        = 1;
        END

        IF @p_status_code_2 = 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END
        IF @p_status_code_2 < 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END
        -- If our post export procedure failed and the export worked then
        -- record the post export failure
        IF @p_status_code_2 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_2
        END
        IF @p_status_code_3 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_3
        END

      END -- end of successful export
    END -- end of export

    --=====================================================
    -- If a Retro Initial load then we have just completed
    -- the load phase
    -- And now need to run any index creates if the
    -- load was a success

    -- EXTENDED TO ALL OBJECTTYPES FOR ACT_INITIAL
    --  AS MAY BE FROM EXIT FOR PROCEDURE/SQLBLOCK
    --=====================================================
    SET @v_step = 9800
    --IF @v_obj_type = @v_ws_obj_retro_copy
    --AND @v_action_type = @v_ws_act_initial
    IF @v_action_type = @v_ws_act_initial
    AND UPPER(@pi_action) <> 'REJOIN90' -- RED-6728 Not for objects handled by BDA
    BEGIN
      IF @p_status_code >= -1 -- Successful load
      BEGIN
        SET @v_step = 9900
        EXEC @v_result = Ws_Act_Build_All @p_sequence,@v_obj_type,@v_action_type,
                                          @v_obj_key,
                                          @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg_2 OUTPUT,
                                          @p_status_code_2 OUTPUT,
                                          @p_result_2 OUTPUT


        IF @p_status_code_2 = 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                      @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END
        IF @p_status_code_2 < 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                      @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END

        -- If our post load procedure failed and the load worked then
        -- record the post load failure
        IF @p_status_code_2 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_2
        END

      END -- end of successful retro_copy load
    END -- end of retro_copy

    --REJOIN AFTER UPDATE SQLBLOCK(REJOIN16)
    -- Need to do the build indexes for process action
    IF  @v_obj_type <> @v_ws_obj_cube
    AND @v_obj_type <> @v_ws_obj_cube_virtual
    AND @v_obj_type <> @v_ws_obj_olap_cube
    AND @v_obj_type <> @v_ws_obj_olap_dim
    AND @v_obj_type <> @v_ws_obj_olap_role
    AND @v_obj_type <> @v_ws_obj_load
    AND @v_obj_type <> @v_ws_obj_export
    AND @v_obj_type <> @v_ws_obj_job
    BEGIN
      IF @p_status_code >= -1
      AND @v_action_type = @v_ws_act_process
      AND UPPER(@pi_action) = 'REJOIN16'
      BEGIN

        SET @v_step = 10000
        EXEC @v_result = Ws_Act_Build @p_sequence,@v_obj_type,@v_action_type,
                                      @v_obj_key,
                                      @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                      @p_return_msg_2 OUTPUT,
                                      @p_status_code_2 OUTPUT,
                                      @p_result_2 OUTPUT

        IF @p_status_code_2 = 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                       @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END
        IF @p_status_code_2 < 1
        BEGIN
          EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                       @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        END

        IF @p_status_code_2 < @p_status_code
        BEGIN
          SET @p_status_code = @p_status_code_2
        END
      END
    END

    --=====================================================
    -- Log the results in the audit trail
    --=====================================================
    SET @v_step = 10100
    SET @v_handled = 0
    IF @p_status_code = 1
    BEGIN
      SET @v_audit_status = 'S'
      SET @v_run_status   = 'C'
      SET @v_handled      = 1
    END
    IF @p_status_code = -1
    BEGIN
      SET @v_audit_status = 'W'
      SET @v_run_status   = 'C'
      SET @v_handled      = 1
    END
    IF @p_status_code = -2
    BEGIN
      SET @v_audit_status = 'E'
      SET @v_run_status   = 'F'
      SET @v_handled      = 1
    END
    IF @p_status_code = -3
    BEGIN
      SET @v_audit_status = 'F'
      SET @v_run_status   = 'F'
      SET @v_handled      = 1
    END
    IF @v_handled = 0
    BEGIN
      SET @v_audit_status = 'U'
      SET @v_run_status   = 'U'
      SET @p_status_code  = -3
    END

    EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
             @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

    --=====================================================
    -- Update the run record to indicate our final status
    --=====================================================
    SET @v_step = 10200
    BEGIN TRANSACTION JE036

    --Attain a lock
    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 10300

    UPDATE ws_wrk_task_run
    SET    wtr_run_status   = @v_run_status,
           wtr_audit_status = @v_audit_status,
           wtr_return_msg   = @p_return_msg,
           wtr_elapsed_hh   = CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60),
           wtr_elapsed_mi   = DATEDIFF(mi,wtr_started,GETDATE()) -
                              CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60)*60,
           wtr_completed    = GETDATE()
    WHERE  wtr_task_key = @pi_task_key
    AND    wtr_job_key  = @p_job_id

    SELECT @v_rec_count     = @@ROWCOUNT

    COMMIT TRANSACTION JE036

--SET @v_MsgText = 'Completed Rejoin of Job '+ @pi_job_name
--+ ' parent job ' + @pm_job_name
--+ ' job key ' + CONVERT(VARCHAR,@p_job_id)
--+ ' parent key ' + CONVERT(VARCHAR,@pm_job_key)
--+ ' task key ' + CONVERT(VARCHAR,@p_task_id)
--+ ' audit job key ' + CONVERT(VARCHAR,@v_audit_job_id)
--+ ' audit task key ' + CONVERT(VARCHAR,@v_audit_task_id)
--+ ' child flag ' + CONVERT(VARCHAR,@v_child_job)
--+ ' status code ' + CONVERT(VARCHAR,@p_status_code)
--EXEC @v_result = WsWrkAudit 'L',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

  END -- End of Rejoin

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --                 C A N C E L       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  -- If we are a Cancel job then check we are in a halted or aborted
  -- state.
  -- Archive the _run table to the log table
  --=====================================================
  IF UPPER(@pi_action) = 'CANCEL'
  BEGIN

    SET @v_step = 10400
    --=====================================================
    -- If we are thread 0 then do some checks and archive
    --=====================================================
    IF @pi_thread = 0
    BEGIN

      -- Get the job key for the job name. There should be one and
      -- only one key. Otherwise a fatal problem.
      BEGIN TRANSACTION JE037
        SET @v_step = 10500

        SELECT @p_job_id = wjc_job_key
        FROM   ws_wrk_job_ctrl
        WHERE  RTRIM(UPPER(wjc_name)) = RTRIM(UPPER(@pi_job_name))

        SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE037

      -- Make sure we are already running (i.e. have a job_run record)
      -- Otherwise a fatal problem.
      BEGIN TRANSACTION JE038
      SET @v_step = 10600

      SELECT @v_row_count = COUNT(*)
      FROM   ws_wrk_job_run
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE038

      IF @v_row_count <> 1
      BEGIN

        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' sequence ' +
          CONVERT(varchar, @pi_sequence) + ' not running. ' +
          'Cannot cancel. No Action !!!'
        EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                                   @v_MsgText,NULL,NULL,0,@v_audit_job_id
        SET @po_result_code = -2
        RETURN 0
      END

      -- Move the job run record to the log record
      BEGIN TRANSACTION JE039
      SET @v_step = 10700

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      INSERT INTO ws_wrk_job_log
      SELECT *
      FROM   ws_wrk_job_run
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      DELETE FROM ws_wrk_job_run
      WHERE  wjr_job_key = @p_job_id
      AND    wjr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE039

      -- Move the task run records to the log record
      BEGIN TRANSACTION JE040
      SET @v_step = 10800

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      DELETE FROM ws_wrk_task_log
      WHERE  wtl_job_key = @p_job_id
      AND    wtl_sequence = @pi_sequence
      AND    wtl_task_key IN
      (SELECT wtr_task_key
       FROM   ws_wrk_task_run
       WHERE  wtr_job_key = @p_job_id
       AND    wtr_sequence = @pi_sequence)

      INSERT INTO ws_wrk_task_log
      SELECT * from ws_wrk_task_run
      WHERE  wtr_job_key = @p_job_id
      AND    wtr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      SET @v_step = 10900

      DELETE FROM ws_wrk_task_run
      WHERE  wtr_job_key = @p_job_id
      AND    wtr_sequence = @pi_sequence

      SELECT @v_rec_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE040

      -- Clean up any child jobs
      BEGIN  TRANSACTION JE0401
      SET @v_step = 11000

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      DELETE FROM ws_wrk_task_log
      WHERE  wtl_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND    wtl_sequence = @pi_sequence
      AND    wtl_task_key IN
      (SELECT wtr_task_key
       FROM   ws_wrk_task_run
       WHERE  wtr_job_key IN
       (SELECT wjr_job_key
        FROM   ws_wrk_job_run
        WHERE  wjr_chkp_count = @p_job_id
        AND    wjr_sequence = @pi_sequence)
       AND    wtr_sequence = @pi_sequence)

      INSERT INTO ws_wrk_task_log
      SELECT *
      FROM   ws_wrk_task_run
      WHERE  wtr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND wtr_sequence = @pi_sequence

      COMMIT TRANSACTION JE0401

      BEGIN  TRANSACTION JE0402
      SET @v_step = 11100

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      DELETE FROM  ws_wrk_task_run
      WHERE  wtr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND   wtr_sequence = @pi_sequence

      COMMIT TRANSACTION JE0402

      BEGIN  TRANSACTION JE0403
      SET @v_step = 11200

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      UPDATE  ws_wrk_task_log
      SET     wtl_job_key = @p_job_id
      WHERE   wtl_job_key in
      (SELECT  wjr_job_key
       FROM    ws_wrk_job_run
       WHERE   wjr_chkp_count = @p_job_id
       AND     wjr_sequence = @pi_sequence)
      AND     wtl_sequence = @pi_sequence

      COMMIT TRANSACTION JE0403

      BEGIN  TRANSACTION JE0404
      -- delete any child jobs
      SET @v_step = 11300

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      DELETE FROM ws_wrk_job_run
      WHERE  wjr_job_key IN
      (SELECT wjr_job_key
       FROM   ws_wrk_job_run
       WHERE  wjr_chkp_count = @p_job_id
       AND    wjr_sequence = @pi_sequence)
      AND    wjr_sequence = @pi_sequence

      COMMIT TRANSACTION JE0404

      SET @v_MsgText = 'Job ' + @pi_job_name + ' sequence ' +
        CONVERT(varchar, @pi_sequence) + ' Canceled. '
      EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                            @v_MsgText,NULL,NULL,0,@v_audit_job_id

    --=====================================================
    -- If we are not thread 0 then wait for ten seconds and proceed.
    --=====================================================
    END -- end thread 0
    ELSE
    BEGIN
      WAITFOR DELAY '00:00:10'
    END
  END -- End of cancel job


  -- not a New Cancel, Rejoin or Restart so we have a problem
  IF  UPPER(@pi_action) <> 'NEW'
  AND UPPER(@pi_action) <> 'RESTART'
  AND LEFT(UPPER(@pi_action),6) <> 'REJOIN'
  AND UPPER(@pi_action) <> 'EXTRETURN'
  AND UPPER(@pi_action) <> 'CANCEL'
  BEGIN

    SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name + ' passed invalid option: ' +
                      @pi_action + '. No Action !!!'
    EXEC @v_result = WsWrkAudit 'F',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                          @v_MsgText,NULL,NULL,0,@v_audit_job_id
  END

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --                  E X E C U T E      T A S K S
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --**********************************************************************
  -- Okay to start processing tasks. Three possible types of tasks
  -- will be handled. These Being (P)procedures, (F)functions and
  -- (C) checkpoints.
  -- Open the cursor we will use t run the tasks
  --**********************************************************************
  --=====================================================
  SET @v_task_count = 1
  SET @v_step = 11400
  SET @v_depend_loop = 0

  -- While More tasks loop
  WHILE @v_task_count > 0
  BEGIN


    SET @v_step = 11500
    SET @v_task_count = 0
    SET @v_running_count = 0
    SET @v_halted_count = 0
    SET @v_failed_count = 0
    SET @v_just_done = 0
    SET @v_idle_thread = 0
    SET @v_process = 0

    SET @v_step = 11600
    --======================================================
    -- Cursor for all the task run records waiting to be run
    --======================================================
    -- 6.0.4.1 filter to not completed and use wtr_order
    DECLARE c_TaskRun INSENSITIVE CURSOR FOR
    SELECT   ws_wrk_task_run.*
    FROM     ws_wrk_task_run
    WHERE    wtr_job_key = @p_job_id
    AND      wtr_sequence = @pi_sequence
    AND      ISNULL(wtr_run_status,'X') <> 'C'
    ORDER BY wtr_order,wtr_type desc,wtr_name
    FOR READ ONLY

    -- Loop through All the Task records.
    -- Clearing any halted or failed status
    SET @v_step = 11700
    OPEN c_TaskRun
    FETCH NEXT FROM c_TaskRun INTO
      @v_wtr_task_key
    , @v_wtr_job_key
    , @v_wtr_obj_key
    , @v_wtr_name
    , @v_wtr_sequence
    , @v_wtr_restart
    , @v_wtr_run_status
    , @v_wtr_audit_status
    , @v_wtr_started
    , @v_wtr_completed
    , @v_wtr_elapsed_hh
    , @v_wtr_elapsed_mi
    , @v_wtr_info_count
    , @v_wtr_warning_count
    , @v_wtr_detail_count
    , @v_wtr_return_msg
    , @v_wtr_type
    , @v_wtr_obj_type
    , @v_wtr_action_type
    , @v_wtr_chkp_number
    , @v_wtr_abort_level
    , @v_wtr_thread
    , @v_wtr_inserted
    , @v_wtr_updated
    , @v_wtr_replaced
    , @v_wtr_deleted
    , @v_wtr_discarded
    , @v_wtr_rejected
    , @v_wtr_errored
    , @v_wtr_order
    , @v_wtr_action_ind

    SELECT @v_task_cursor = @@FETCH_STATUS
    WHILE @v_task_cursor = 0
    BEGIN

      --=====================================================
      -- Check the status of each task
      -- If it is waiting then we will check dependencies etc.
      -- and see if it needs to be executed.
      --=====================================================
      SET @v_step = 11800
      SET @v_process = 0

      IF @v_wtr_run_status = 'W'
      BEGIN

        SET @v_step = 11900
        SET @v_task_count = 1
        --=====================================================
        -- Check the dependencies for the task
        --=====================================================
        BEGIN TRANSACTION JE041
        SET @v_step = 12000

        SELECT @v_rec_count = COUNT(*)
        FROM   ws_wrk_dependency
        WHERE  wdp_job_key        = @p_job_id
        AND    wdp_child_task_key = @v_wtr_task_key

        SELECT @v_row_count     = @@ROWCOUNT
        COMMIT TRANSACTION JE041

        -- If parent dependencies then check each to see if it has completed.
        SET @v_child_key = @v_wtr_task_key
        SET @v_halted = 0
        SET @v_okay = 0
        SET @v_checked = 0
        SET @v_step = 12100

        --=====================================================
        -- Cursor for all the parent dependencies of a particular task
        --=====================================================
        SET @v_step = 12200
        DECLARE c_Dependency INSENSITIVE CURSOR FOR
          SELECT *
          FROM   ws_wrk_dependency
          WHERE  wdp_job_key        = @p_job_id
          AND    wdp_child_task_key = @v_child_key
        FOR READ ONLY

        OPEN c_Dependency
        FETCH NEXT FROM c_Dependency INTO
          @v_wdp_job_key
        , @v_wdp_parent_task_key
        , @v_wdp_child_task_key

        SELECT @v_dep_cursor = @@FETCH_STATUS
        WHILE @v_dep_cursor = 0
        BEGIN

          -- get the parent task record from the task_run table
          BEGIN TRANSACTION JE042
          SET @v_step = 12300

          SELECT @v_run_status   = wtr_run_status
               , @v_audit_status = wtr_audit_status
               , @v_abort_level  = wtr_abort_level
          FROM   ws_wrk_task_run
          WHERE  wtr_job_key  = @p_job_id
          AND    wtr_task_key = @v_wdp_parent_task_key

          SELECT @v_row_count     = @@ROWCOUNT
          COMMIT TRANSACTION JE042

          SET @v_step = 12400

          -- Get the status for the parent task.
          -- If the parent is waiting or running then skip the rest of the tests as we cant go
          -- If the parent has been halted then set the flag to halt this task also.
          -- If the parent has failed or completed check the audit status
          -- The abort level will tell us if we should count this as a halt or an okay
          IF @v_run_status = 'W'
          BEGIN
            SET @v_dep_cursor = 1
            BREAK
          END

          ELSE IF @v_run_status = 'R'
          BEGIN
            SET @v_dep_cursor = 1
            BREAK
          END

          ELSE IF @v_run_status = 'H'
          BEGIN
            SET @v_halted = 1
            SET @v_dep_cursor = 1
            BREAK
          END

          ELSE IF @v_run_status = 'F'
          BEGIN
            IF @v_abort_level = 5
            BEGIN
              SET @v_checked = @v_checked + 1
            END
            ELSE
            BEGIN
              SET @v_halted = 1
              SET @v_dep_cursor = 1
              BREAK
            END
          END

          ELSE IF @v_run_status = 'U'
          BEGIN
            IF @v_abort_level = 5
            BEGIN
              SET @v_checked = @v_checked + 1
            END
            ELSE
            BEGIN
              SET @v_halted = 1
              SET @v_dep_cursor = 1
              BREAK
            END
          END

          ELSE IF @v_run_status = 'C'
          BEGIN
            IF @v_abort_level <= 3
            BEGIN
              IF @v_audit_status = 'W'
              BEGIN
                SET @v_halted = 1
                SET @v_dep_cursor = 1
                BREAK
              END
              ELSE
              BEGIN
                SET @v_checked = @v_checked + 1
              END
            END
            ELSE
            BEGIN
              SET @v_checked = @v_checked + 1
            END
          END
          ELSE
          BEGIN
            SET @v_dep_cursor = 1
            BREAK
          END

          FETCH NEXT FROM c_Dependency INTO
            @v_wdp_job_key
          , @v_wdp_parent_task_key
          , @v_wdp_child_task_key

          SELECT @v_dep_cursor = @@FETCH_STATUS

        END -- end of dependency cursor loop

        CLOSE c_Dependency
        DEALLOCATE c_Dependency

        -- See if we passed our dependency check
        -- We either passed, need to halt the task or need to skip this task
        -- 5.6.1.1 also reset the depend_loop now to minimise erroneous errors
        --         that result if tasks have contention etc
        IF @v_checked = @v_rec_count
        BEGIN
          SET @v_okay = 1
          SET @v_depend_loop = 0
        END
        SET @v_step = 12500

        --=====================================================
        -- See if the task is okay to run and a right type if so run it
        --=====================================================
        SET @v_wants_to_run = 1

        IF   @v_okay = 1
        AND  (   (@v_wtr_obj_type > 0 AND @v_wtr_obj_type <= @v_ws_obj_max)
              OR (@v_wtr_obj_type = @v_ws_obj_source_mapping)
              OR (@v_wtr_obj_type = @v_ws_obj_job)
             )
        BEGIN
          SET @v_step = 12600

          --=====================================================
          -- See if set to not be run, and if so, set to bypass
          --=====================================================

          IF  (@v_wtr_action_ind = @v_ws_act_disabled
          OR   @v_wtr_action_ind = @v_ws_act_disabled_once)
          BEGIN
            SET @v_wants_to_run = 0
          END

          --=====================================================
          -- Update the run record to indicate we are running.
          -- Need to lock the record first to prevent another thread from
          -- grabbing it, or in case another thread has already got it,
          -- or updated it
          --=====================================================
          --Loop for lock and correct for lock ok if result >= 0
          --SET LOCK_TIMEOUT 500 -- -- wait .5 seconds
--6.0.4.1          SET TRANSACTION ISOLATION LEVEL SERIALIZABLE

          BEGIN TRANSACTION JE043

          SET @v_step = 12700

          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

         -- if lock result is zero then we got the lock
          IF @v_lock_result >= 0
          BEGIN
            SET @v_step = 12800
            SET @v_run_status = 'Z'

            SELECT @v_run_status = wtr_run_status
            FROM   ws_wrk_task_run
            WHERE  wtr_task_key = @v_wtr_task_key
            AND    wtr_job_key  = @p_job_id
            AND    wtr_sequence = @pi_sequence

            -- if the task is still in a wait state
            -- then set it to running
            IF @v_run_status = 'W'
            BEGIN
              SET @v_step = 12900

              -- Is this a sub-job or a task restart?
              SELECT @v_run_count = COUNT(*)
              FROM   ws_wrk_job_run
              WHERE  wjr_job_key IN
              (SELECT wtr_obj_key
               FROM  ws_wrk_task_run
               WHERE wtr_job_key = @v_wtr_job_key
               AND   wtr_sequence = @v_wtr_sequence
               AND   wtr_task_key = @v_wtr_task_key
               AND   wtr_run_status = 'W'
              );

              IF @v_run_count = 0
              BEGIN
                 -- new sub-job
                 SET @v_restart_flag = 0
              END

              -- if task (@v_wtr_task_key, @p_Job_id, @pi_sequence) is a sub-job
              -- we need to check that there's not an instance already running

              IF (@v_wtr_obj_type = @v_ws_obj_job AND @v_restart_flag = 0 AND @v_wants_to_run = 1)
              BEGIN

                SELECT  @p_subjob_id = wjc_job_key, @p_subjob_status = wjc_status
                FROM  ws_wrk_job_ctrl
                WHERE RTRIM(UPPER(wjc_name)) = RTRIM(UPPER(@v_wtr_name))

                -- we count jobs in wjr with status 'W' so restarted jobs will take precedence
                -- over this sub-job task
                SELECT @v_run_count = COUNT(*)
                FROM   ws_wrk_job_run
                WHERE  wjr_job_key = @p_subjob_id
                AND    wjr_status NOT IN ('F', 'C');

                if (@v_run_count > 0)
                BEGIN
                  -- we can't run the sub-job so pass over it
                  SET @v_okay = 0
                  SET @v_wants_to_run = 2

                  -- If the sub-job we want to run is not currently in a blocked state
                  -- then count this task as running even though it's being prevented from
                  -- doing so by another instance of the same job as that instance can still
                  -- complete at which time we can run.
                  -- Otherwise, the dependency loop logic will get triggered when what we really
                  -- want to do is continue to loop until we can run this sub-job.

                  -- root jobs set 'B' in [wjc] when they cannot run
                  -- sub jobs busy wait in a thread owned by the launching parent so the task itself is still running
                  SET @v_running_count = @v_running_count + 1
                END
                ELSE
                BEGIN
                  -- mark this job as starting up as a sub-job
                  SET @v_wants_to_run = 3
                END
              END

              IF (@v_wants_to_run = 0)
              BEGIN
                SET @v_okay = 0
                SET @v_task_count = 0

                UPDATE ws_wrk_task_run
                SET    wtr_run_status = 'C'
                     , wtr_thread     = @pi_thread
                     , wtr_started    = GETDATE()
                     , wtr_audit_status = 'S'
                     , wtr_return_msg   = 'Task Disabled, Skipped.'
                     , wtr_elapsed_hh   = 0
                     , wtr_elapsed_mi   = 0
                     , wtr_completed    = GETDATE()
                WHERE  wtr_task_key = @v_wtr_task_key
                AND    wtr_job_key  = @p_job_id
              END
              ELSE IF (@v_wants_to_run = 1)
              BEGIN
                UPDATE ws_wrk_task_run
                SET    wtr_run_status = 'R'
                     , wtr_thread     = @pi_thread
                     , wtr_started    = GETDATE()
                WHERE  wtr_task_key = @v_wtr_task_key
                AND    wtr_job_key  = @p_job_id
              END
--            ELSE IF (@v_wants_to_run = 2)
--            BEGIN
                -- do nothing, busy wait and try this sub-job again later

                -- if we wanted to do something related to how many times we've passed through
                -- the loop waiting to run a sub-job, here's where we'd place it.
                -- Ex: a counter for the # of passes and abort after we've passed some threshold
--            END
              ELSE IF (@v_wants_to_run = 3)
              BEGIN
                UPDATE ws_wrk_task_run
                SET    wtr_run_status = 'R'
                     , wtr_thread     = @pi_thread
                     , wtr_started    = GETDATE()
                WHERE  wtr_task_key = @v_wtr_task_key
                AND    wtr_job_key  = @p_job_id;

                -- Create an preliminary state saying that this thread is starting up
                -- a new sub-job.  Between here and Ws_Job_Exec_411() invocation, we don't
                -- want some other thread to mess with the job state.

                -- we have to do the sub-job startup here to prevent anyone else from starting
                -- while we've got JOB_RUN and know that there's no other jobs running

                -- Previously, there was a disconnect between the setting the sub-job task
                -- in the parent job to running and the sub-job itself actually getting to run.
                -- This meant that if the sub-job got blocked, there was nowhere to go and it had
                -- to sit spinning in a loop until it could run.
                INSERT INTO ws_wrk_job_run (
                       wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
                       wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
                       wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
                       wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
                       wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler,wjr_idle_thread_wait)
                SELECT wjc_job_key, @pi_sequence, 0, 'P', GETDATE(), GETDATE(), NULL, 0,0,
                       0,0,0,0,0,@v_audit_job_id,0, wjc_name, wjc_user_key, wjc_max_threads,
                       wjc_publish_okay, wjc_publish_fail, wjc_scheduler,ISNULL(wjc_idle_thread_wait,30)
                FROM   ws_wrk_job_ctrl
                WHERE  wjc_job_key = @p_subjob_id
                AND    wjc_job_key NOT IN (SELECT wjr_job_key FROM ws_wrk_job_run WHERE wjr_job_key = @p_subjob_id AND wjr_sequence = @pi_sequence)
              END

              SELECT @v_row_count     = @@ROWCOUNT

            END -- end of status still waiting
            ELSE
            BEGIN
              -- someone else got the record
              SET @v_okay = 0
              SET @v_running_count = @v_running_count + 1
            END

            IF @v_run_status = 'R'
            BEGIN
              -- someone else got the record and is running it
              SET @v_task_count = 0
              SET @v_running_count = @v_running_count + 1
            END

            COMMIT TRANSACTION JE043

          END -- end of lock acquired
          -- failed to get the lock
          -- so wait and try again
          ELSE
          BEGIN
            -- someone else got the record or it is locked
            SET @v_okay = 0
            SET @v_running_count = @v_running_count + 1
            COMMIT TRANSACTION JE043
--6.0.4.1            SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
            WAITFOR DELAY '00:00:00.3'
          END

--6.0.4.1          SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
          --SET LOCK_TIMEOUT -1

          SET @v_step = 13000
          -- If we still have a go, then run it
          -- Break out of this loop and run the task by setting the @v_process flag
          IF @v_okay = 1
          BEGIN
            SET @v_process = 1
            SET @p_task_id = @v_wtr_task_key
            SET @p_task_name = @v_wtr_name
            SET @v_action_type = @v_wtr_action_type
            SET @v_obj_type = @v_wtr_obj_type
            SET @v_obj_key = @v_wtr_obj_key
            SET @v_task_key = @v_wtr_task_key
            SET @v_task_cursor = 1
            BREAK
          END

        END  -- end of okay to run and a normal task check

        --=====================================================
        -- CHECKPOINT HANDLING REMOVED
        --=====================================================

        SET @v_step = 13100
        --=====================================================
        -- See if the task needs a status update.
        --=====================================================
        IF @v_okay = 1 OR @v_halted = 1
        BEGIN
          --=====================================================
          -- Update the run record to indicate our final status
          -- If we have a halt then generate a message
          --=====================================================
          SET @v_step = 13200
          IF @v_halted = 1
          BEGIN
            SET @p_return_msg = 'Halted by dependency failure or halt'
            SET @v_run_status = 'H'
            SET @v_audit_status = NULL
          END

          BEGIN TRANSACTION JE044

          SET @v_step = 13300
          --Attain a lock
          SET @v_lock_result = -1
          WHILE @v_lock_result < 0
          BEGIN

            EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                                @LockMode = 'Update',
                                                @LockTimeout = 0

            IF @v_lock_result < 0
            BEGIN
              SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
              WAITFOR DELAY @v_wait
            END

          END

          SET @v_step = 13400

          UPDATE ws_wrk_task_run
          SET    wtr_run_status   = @v_run_status,
                 wtr_audit_status = @v_audit_status,
                 wtr_return_msg   = @p_return_msg,
                 wtr_elapsed_hh   = CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60),
                 wtr_elapsed_mi   = DATEDIFF(mi,wtr_started,GETDATE()) -
                                    CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60)*60,
                 wtr_completed    = GETDATE()
          WHERE  wtr_task_key = @v_wtr_task_key
          AND    wtr_job_key  = @p_job_id

          SELECT @v_row_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE044
        END  -- End of task status update
      END -- End if task status Waiting

      IF @v_wtr_run_status = 'R'
      BEGIN
        SET @v_running_count = @v_running_count + 1
      END
      ELSE IF @v_wtr_run_status = 'H'
      BEGIN
        SET @v_halted_count = @v_halted_count + 1
      END
      ELSE IF @v_wtr_run_status = 'F'
      BEGIN
        SET @v_failed_count = @v_failed_count + 1
      END
      ELSE IF @v_wtr_run_status = 'U'
      BEGIN
        SET @v_failed_count = @v_failed_count + 1
      END

      SET @v_step = 13500

      FETCH NEXT FROM c_TaskRun INTO
        @v_wtr_task_key
      , @v_wtr_job_key
      , @v_wtr_obj_key
      , @v_wtr_name
      , @v_wtr_sequence
      , @v_wtr_restart
      , @v_wtr_run_status
      , @v_wtr_audit_status
      , @v_wtr_started
      , @v_wtr_completed
      , @v_wtr_elapsed_hh
      , @v_wtr_elapsed_mi
      , @v_wtr_info_count
      , @v_wtr_warning_count
      , @v_wtr_detail_count
      , @v_wtr_return_msg
      , @v_wtr_type
      , @v_wtr_obj_type
      , @v_wtr_action_type
      , @v_wtr_chkp_number
      , @v_wtr_abort_level
      , @v_wtr_thread
      , @v_wtr_inserted
      , @v_wtr_updated
      , @v_wtr_replaced
      , @v_wtr_deleted
      , @v_wtr_discarded
      , @v_wtr_rejected
      , @v_wtr_errored
      , @v_wtr_order
      , @v_wtr_action_ind
      SELECT @v_task_cursor = @@FETCH_STATUS

    END -- end of cursor loop

    CLOSE c_TaskRun
    DEALLOCATE c_TaskRun

    SET @v_step = 13600

    -- A task that we are ready to run will break out of the Task loop
    -- with the @v_Process flag set, so proceed to process it.
    IF @v_process = 1
    BEGIN

      SELECT @v_audit_task_id = @p_task_id
      SELECT @v_audit_task_name = @p_task_name

      SET @v_step = 13700
      --=====================================================
      -- Work out the type of action and run the appropriate
      -- function.
      --=====================================================
      SET @p_status_code = -3
      SET @p_return_msg = 'Unhandled exception in action'
      SET @v_handled = 0

      SET @v_bda_connect_key = 0
      SET @v_is_hive_target = 0

      -- Determine if there is any Hive target
      BEGIN
        SET @v_any_hive_targets = 0
        SELECT @v_any_hive_targets = 1 FROM ws_dbc_connect
        JOIN ws_dbc_target ON dt_connect_key = dc_obj_key
        WHERE dc_db_type_ind = 8;
      END

      -- Get the BDA connection key for a BDA operation.
      -- There should be at most one key, otherwise a fatal problem.
      -- Attention: lt_obj_key can also hold a job key! We need to explicitly exclude job keys as they can accidentally point to a Hive or Hadoop object
      IF @v_any_hive_targets = 1 AND @v_obj_type <> @v_ws_obj_job
      BEGIN
          SELECT
            @v_bda_connect_key = bda.connect_key,
            @v_is_hive_target = bda.is_hive_target
          FROM (
            -- All Load tables using Apache Sqoop from Hive or Hadoop
            SELECT src_con.dc_obj_key connect_key, CASE WHEN tgt_con.dc_db_type_ind = 8 THEN 1 ELSE 0 END is_hive_target    -- 8 = WS_DB_HIVE
            FROM ws_load_tab
            JOIN ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
            JOIN ws_obj_object ON lt_obj_key = oo_obj_key
            LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
            LEFT JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE lt_obj_key = @v_obj_key
            AND (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))    -- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
                UNION ALL
            -- All other non-Script-based Load tables with Hive targets
            SELECT  CASE WHEN lt_type IN ('A','F','D') THEN tgt_con.dc_obj_key ELSE 0 END connect_key, 1 is_hive_target
            FROM ws_load_tab
            JOIN ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
            JOIN ws_obj_object ON lt_obj_key = oo_obj_key
            JOIN ws_dbc_target ON oo_target_key = dt_target_key
            JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE lt_obj_key = @v_obj_key
            AND NOT (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))    -- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
            AND tgt_con.dc_db_type_ind = 8        -- 8 = WS_DB_HIVE
                UNION ALL
            -- All other non-Load tables with Hive targets, except Script-based exports
            SELECT tgt_con.dc_obj_key connect_key, 1 is_hive_target
            FROM ws_obj_object
            JOIN ws_dbc_target ON oo_target_key = dt_target_key
            JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE oo_obj_key = @v_obj_key
            AND oo_type_key <> @v_ws_obj_load
            AND NOT (oo_type_key = @v_ws_obj_export AND (SELECT et_type from ws_export_tab WHERE et_obj_key = oo_obj_key) = 'S')
            AND tgt_con.dc_db_type_ind = 8        -- 8 = WS_DB_HIVE
          ) bda

          IF @@ROWCOUNT <> 1
          BEGIN
            SET @v_bda_connect_key = 0
            SET @v_is_hive_target = 0

            IF @@ROWCOUNT > 1
            BEGIN
              SET @v_MsgText = 'Multiple BDA connection keys found for job: ' + @pi_job_name + '.'
              EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
          END
      END

      -- Determine if the job requires on-the-fly DDL template evaluation.
      SET @v_is_template_ddl_target = 0
      IF @v_action_type = @v_ws_act_create
      BEGIN
        SELECT @v_is_template_ddl_target = 1
        FROM ws_table_attributes
        WHERE ta_obj_key = @v_obj_key
        AND ta_type = 'L'
        AND (  @v_ws_create_ddl_type = ta_ind_1
            OR @v_ws_create_ddl_type = ta_ind_2
            OR @v_ws_create_ddl_type = ta_ind_3
            OR @v_ws_create_ddl_type = ta_ind_4
            OR @v_ws_create_ddl_type = ta_ind_5
            OR @v_ws_create_ddl_type = ta_ind_6
            OR @v_ws_create_ddl_type = ta_ind_7
            OR @v_ws_create_ddl_type = ta_ind_8
            OR @v_ws_create_ddl_type = ta_ind_9
            OR @v_ws_create_ddl_type = ta_ind_10
            OR @v_ws_create_ddl_type = ta_ind_11
            OR @v_ws_create_ddl_type = ta_ind_12
            )

        -- override DDL trumps on-the-fly DDL template
        IF @v_is_template_ddl_target = 1
        BEGIN
          SELECT @v_work = COALESCE(ta_text_1, '')
          FROM ws_table_attributes
          WHERE ta_obj_key = @v_obj_key
          AND ta_type = 'D'

          IF RTRIM(@v_work) <> ''
          BEGIN
            SET @v_is_template_ddl_target = 0
          END
        END
      END

      IF @v_bda_connect_key > 0 AND @v_is_hive_target = 1
      BEGIN
        SET @v_step = 13750

        SET @po_job_key       = @p_job_id
        SET @po_task_key      = @p_task_id
        SET @po_task_name     = @p_task_name
        SET @po_result_msg    = 'BDA Server task with Hive target'
        SET @po_action_key    = 0
        SET @po_action_msg    = 'no action'
        SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
        SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
        SET @po_result_code   = 90

        -- Don't need to put BDA connection settings into task data (only used by the Linux/Unix Scheduler).
        SET @v_task_data = ''

        -- Put the BDA connection key into task data (used by the Windows Scheduler).
        SET @v_task_data = @v_task_data
          + 'SCH_BDA_ConnectKey[WSH]' + CONVERT(VARCHAR,@v_bda_connect_key) + '[WSH]'

        -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
        SET @v_task_data = @v_task_data
          + 'SCH_BDA_ObjKey[WSH]' + CONVERT(VARCHAR,@v_obj_key) + '[WSH]'
          + 'SCH_BDA_Action[WSH]' + CONVERT(VARCHAR,@v_action_type) + '[WSH]'

        SET @po_task_data = @v_task_data

        --=====================================================
        -- Remove this thread as being active
        --=====================================================
        SET @v_step = 13760
        IF @p_job_id > 0 AND @v_sid <> 0
        BEGIN
          BEGIN TRANSACTION JE0442
          SET @v_step = 13770

          DELETE FROM ws_wrk_job_thread
          WHERE  wjt_job_key  = @p_job_id
          AND    wjt_thread   = @pi_thread
          AND    wjt_sequence = @pi_sequence
          AND    wjt_sid      = @v_sid
          AND    wjt_serial   = @v_serial

          COMMIT TRANSACTION JE0442
        END

        RETURN 0
      END
      --=====================================================
      -- Process tables with on-the-fly template DDL as external objects
      --=====================================================
      ELSE IF @v_is_template_ddl_target = 1
      BEGIN
        SET @v_step = 13780

        SET @po_job_key       = @p_job_id
        SET @po_task_key      = @p_task_id
        SET @po_task_name     = @p_task_name
        SET @po_result_msg    = 'Table operation with template DDL'
        SET @po_action_key    = 0
        SET @po_action_msg    = 'no action'
        SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
        SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
        SET @po_result_code   = 22

        --=====================================================
        -- Remove this thread as being active
        --=====================================================
        SET @v_step = 13790
        IF @p_job_id > 0 AND @v_sid <> 0
        BEGIN
          BEGIN TRANSACTION JE0443
          SET @v_step = 13795

          DELETE FROM ws_wrk_job_thread
          WHERE  wjt_job_key  = @p_job_id
          AND    wjt_thread   = @pi_thread
          AND    wjt_sequence = @pi_sequence
          AND    wjt_sid      = @v_sid
          AND    wjt_serial   = @v_serial

          COMMIT TRANSACTION JE0443
        END

        RETURN 0
      END

      IF @v_obj_type <> @v_ws_obj_job
      BEGIN
        BEGIN TRANSACTION JER002
        -- ====================================================
        -- Determine if need to return to caller due to being
        -- an 'external object'
        -- ====================================================
        DECLARE @v_target_key integer;
        DECLARE @v_target_db_type integer;

        IF @v_obj_type = @v_ws_obj_source_mapping
        BEGIN
          SELECT    @v_target_key = COALESCE(ws_obj_object.oo_target_key, 0)
                  , @v_target_db_type = COALESCE(ws_dbc_connect.dc_db_type_ind, 2) -- Presume local
          FROM      ws_source_mapping_tab
          JOIN      ws_obj_object ON ws_source_mapping_tab.smt_parent_obj_key = ws_obj_object.oo_obj_key
          LEFT JOIN ws_dbc_target ON ws_obj_object.oo_target_key = ws_dbc_target.dt_target_key
          LEFT JOIN ws_dbc_connect ON ws_dbc_target.dt_connect_key = ws_dbc_connect.dc_obj_key
          WHERE ws_source_mapping_tab.smt_source_mapping_key = @v_obj_key
        END
        ELSE
        BEGIN
          SELECT    @v_target_key = COALESCE(ws_obj_object.oo_target_key, 0)
                  , @v_target_db_type = COALESCE(ws_dbc_connect.dc_db_type_ind, 2) -- Presume local
          FROM      ws_obj_object
          LEFT JOIN ws_dbc_target ON ws_obj_object.oo_target_key = ws_dbc_target.dt_target_key
          LEFT JOIN ws_dbc_connect ON ws_dbc_target.dt_connect_key = ws_dbc_connect.dc_obj_key
          WHERE (ws_obj_object.oo_obj_key = @v_obj_key AND ws_obj_object.oo_type_key <> @v_ws_obj_export)
          OR UPPER(ws_obj_object.oo_name) IN (
              SELECT DISTINCT UPPER(ws_export_col.ec_src_table)
              FROM ws_export_col
              WHERE ws_export_col.ec_obj_key = @v_obj_key
              )
        END

        SELECT @v_row_count = @@ROWCOUNT

        COMMIT TRANSACTION JER002

        -- we can only process target here if type for local SQL Server;
        -- something else (like Greenplum) needs to go to Odl
        -- TODO: remote SQL Server target job also needs to go to Odl but
        --       currently remote targets not supported for SQL server
        IF (@v_target_key <> 0) AND (@v_target_db_type <> 0) AND (@v_target_db_type <> 2)
        BEGIN
          -- If this execute is for an external object
          -- return value of 18
          -- passed back to the scheduler and let it do the processing
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'External Object'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @po_result_code   = 18
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)

          IF @v_bda_connect_key > 0
          BEGIN
            SET @po_result_msg = @po_result_msg + ' as BDA Server task with non-Hive target'

            -- Don't need to put BDA connection settings into task data (only used by the Linux/Unix Scheduler).
            SET @v_task_data = ''

            -- Put the BDA connection key into task data (used by the Windows Scheduler).
            SET @v_task_data = @v_task_data
              + 'SCH_BDA_ConnectKey[WSH]' + CONVERT(VARCHAR,@v_bda_connect_key) + '[WSH]'

            -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
            SET @v_task_data = @v_task_data
              + 'SCH_BDA_ObjKey[WSH]' + CONVERT(VARCHAR,@v_obj_key) + '[WSH]'
              + 'SCH_BDA_Action[WSH]' + CONVERT(VARCHAR,@v_action_type) + '[WSH]'

            SET @po_task_data = @v_task_data
          END

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 13800
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE045
            SET @v_step = 13900

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE045
          END
          RETURN 0
        END
      END

      --=====================================================
      -- E X E C U T E
      --=====================================================
      IF @v_action_type = @v_ws_act_execute
      BEGIN
        SET @v_handled = 1
        --=====================================================
        -- E X E C U T E      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_cube_virtual
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this execute is for a cube
          -- return value of 8
          -- pass back to the scheduler and let it do the create
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube execute'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @po_result_code   = 8
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 14000
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE045
            SET @v_step = 14100

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE045
          END
          RETURN 0
        END
        --=====================================================
        -- E X E C U T E    P R O C E D U R E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_procedure
        BEGIN
          SET @v_step = 14200
          SELECT @v_procedure_type = NULLIF(ph_type,'P')
          FROM   ws_pro_header
          WHERE  ph_obj_key = @v_obj_key

          SET @v_step = 14300
          --=====================================================
          -- IF SQLBLOCK then return for calling
          --=====================================================
          IF @v_procedure_type = 'B'
          BEGIN
             -- run an UPDATE SQLBLOCK by returning a result of 16
             SET @po_job_key       = @p_job_id
             SET @po_task_key      = @p_task_id
             SET @po_task_name     = @p_task_name
             SET @po_result_msg    = 'execute sql'
             SET @po_action_key    = @v_obj_key
             SET @po_action_msg    = 'no action'
             SET @po_result_code   = 16
             SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
             SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)

             --=====================================================
             -- Remove this thread as being active
             --=====================================================
             SET @v_step = 14400
             IF @p_job_id > 0 AND @v_sid <> 0
             BEGIN
               BEGIN TRANSACTION JE045
               SET @v_step = 14500

               DELETE FROM ws_wrk_job_thread
               WHERE  wjt_job_key  = @p_job_id
               AND    wjt_thread   = @pi_thread
               AND    wjt_sequence = @pi_sequence
               AND    wjt_sid      = @v_sid
               AND    wjt_serial   = @v_serial

               COMMIT TRANSACTION JE045
             END

             RETURN 0
          END

          SET @v_step = 14600
          EXEC @v_result = Ws_Act_Execute @p_sequence,@v_obj_type,@v_action_type,
                                          @v_audit_job_name, @p_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg OUTPUT, @p_status_code OUTPUT,
                                          @p_result OUTPUT
        END
        --=====================================================
        -- E X E C U T E    S C R I P T
        --=====================================================
        IF @v_obj_type = @v_ws_obj_script
        BEGIN
          SET @v_step = 14700
          EXEC @v_result = Ws_Act_Host_Script @p_sequence,@v_obj_type,@v_action_type,@v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg OUTPUT, @p_status_code OUTPUT,
                                              @p_result OUTPUT
          -- If script build worked then skip out to process it
          -- If it failed then the standard handling will deal with it.
          IF @p_result >= -1
          BEGIN
             SET @po_job_key       = @p_job_id
             SET @po_task_key      = @p_task_id
             SET @po_task_name     = @p_task_name
             SET @po_result_msg    = 'execute script'
             SET @po_action_key    = 0
             SET @po_action_msg    = 'no action'
             SET @po_result_code   = 2
             SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
             SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
             RETURN 0
          END
        END
        --=====================================================
        -- E X E C U T E    U N S U P P O R T E D
        --=====================================================
        IF @v_handled = 0
        BEGIN
          SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_task_name + ' sequence ' +
                            CONVERT(varchar, ISNULL(@pi_sequence,-1)) +
                           ' could not perform action. Unsupported action ' +
                           CONVERT(varchar, ISNULL(@v_action_type,-1))
                           + ' for object ' + CONVERT(varchar,ISNULL(@v_obj_type,-1))

          EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                          @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          SET @p_status_code  = -2
          SET @p_return_msg = 'Unsupported action ' +
              CONVERT(varchar, ISNULL(@v_action_type,-1))
              + ' for object ' + CONVERT(varchar,@v_obj_type)
          SET @v_result = 1
        END
      END


      --=====================================================
      -- L O A D
      --=====================================================
      IF @v_action_type = @v_ws_act_load
      BEGIN
        SET @v_handled = 1
        --=====================================================
        -- R E T R O     L O A D
        --=====================================================
        IF @v_obj_type = @v_ws_obj_retro_copy
        BEGIN
          -- If this a Retrofit ODBC based load then
          -- Skip out to process it
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'retro table'
          SET @po_action_key    = @v_obj_key
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 13
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 14800

          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE066
            SET @v_step = 14900

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE066
          END
          RETURN 0
        END
        --=====================================================
        -- L O A D     O B J E C T      L O A D
        --=====================================================
        ELSE
        BEGIN
          SET @v_step = 15000
          EXEC @v_result = Ws_Act_Load @p_sequence,@v_obj_type,@v_action_type,
                                       @v_obj_key,
                                       @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                       @p_return_msg OUTPUT, @p_status_code OUTPUT,
                                       @p_result OUTPUT
          IF @p_result >= -1
          BEGIN
            IF @p_status_code = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                     @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            IF @p_status_code <> 2 AND @p_status_code <> 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                     @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            -- If this load requires a host script then we will have a
            -- return value of 2
            -- If script build worked then skip out to process it
            -- If it failed then the standard handling will deal with it.
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 2
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'load table'
              SET @po_action_key    = 0
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 2
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 15100
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE046
                SET @v_step = 15200

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE046
              END
              RETURN 0
            END

            -- If this load requires an ODBC based load then we will have a
            -- return value of 3
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 3
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'load table'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 3
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 15300

              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE047
                SET @v_step = 15400

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE047
              END
              RETURN 0
            END

            -- If this load requires a Native ODBC based load
            --    then we will have a return value of 12
            -- If this load requires a SSIS based load
            --    then we will have a return value of 14
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 12
            OR @p_result = 14
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'load table'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 15500

              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE066
                SET @v_step = 15600

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE066
              END
              RETURN 0
            END -- end of result = 12/14

            -- If this load is a BDA Server operation with non-Hive target
            -- then we will have a return value of 91
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 91
            BEGIN
              SET @v_step = 15650

              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = @p_return_msg + ' with non-Hive target'
              SET @po_action_key    = 0
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 91

              -- Don't need to put BDA connection settings into task data (only used by the Linux/Unix Scheduler).
              SET @v_task_data = ''

              -- Put the BDA connection key into task data (used by the Windows Scheduler).
              SET @v_task_data = @v_task_data
                + 'SCH_BDA_ConnectKey[WSH]' + CONVERT(VARCHAR,@v_bda_connect_key) + '[WSH]'

              -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
              SET @v_task_data = @v_task_data
                + 'SCH_BDA_ObjKey[WSH]' + CONVERT(VARCHAR,@v_obj_key) + '[WSH]'
                + 'SCH_BDA_Action[WSH]' + CONVERT(VARCHAR,@v_action_type) + '[WSH]'

              SET @po_task_data = @v_task_data

              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 15660
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE0662
                SET @v_step = 15670

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE0662
              END

              RETURN 0
            END -- end of result = 91

            SET @v_step = 15700
            EXEC @v_result = Ws_Act_Post_Load @p_sequence,@v_obj_type,@v_action_type,
                                              @v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg_2 OUTPUT,
                                              @p_status_code_2 OUTPUT,
                                              @p_result OUTPUT
            IF @p_status_code_2 = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            IF @p_status_code_2 < 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            -- If this procedure is a SQLBLOCK we will have a return value of 2
            -- skip out to process it
            -- When we Rejoin the job any post action will be run
            IF @p_status_code_2 = 2
            BEGIN
              -- Need to first output info message for the export step
              EXEC @v_result = WsWrkAudit 'S', @v_audit_job_name, @v_audit_task_name, @p_sequence,
                @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'execute sql'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result -- 16 or 17
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 15800
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 15900

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

            -- If our post load procedure failed and the load worked then
            -- record the post load failure
            IF @p_status_code_2 < @p_status_code
            BEGIN
              SET @p_status_code = @p_status_code_2
            END
          END -- End of successful load
        END -- End of load object load
      END -- End of LOAD

      --=====================================================
      -- U P D A T E
      --=====================================================
      IF @v_action_type = @v_ws_act_update
      BEGIN
        --=====================================================
        -- U P D A T E      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this update is for a cube
          -- return value of 9
          -- pass back to the scheduler and let it do the create
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube update'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 9
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 16000
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE048
            SET @v_step = 16100

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE048
          END
          RETURN 0
        END
        ELSE
        BEGIN
          SET @v_handled = 1
          SET @v_step = 16200

          EXEC @v_result = Ws_Act_Update @p_sequence, @v_obj_type, @v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT

          -- If this procedure is a SQLBLOCK we will have a return value of 2
          -- skip out to process it
          -- When we Rejoin the job any post action will be run
          IF @p_status_code = 2
          BEGIN
            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @p_task_id
            SET @po_task_name     = @p_task_name
            SET @po_result_msg    = 'execute sql'
            SET @po_action_key    = @v_obj_key
            SET @po_action_msg    = 'no action'
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
            SET @po_result_code   = @p_result -- 16 or 17
            --=====================================================
            -- Remove this thread as being active
            --=====================================================
            SET @v_step = 16300
            IF @p_job_id > 0 AND @v_sid <> 0
            BEGIN
              BEGIN TRANSACTION JE053
              SET @v_step = 16400

              DELETE FROM ws_wrk_job_thread
              WHERE  wjt_job_key  = @p_job_id
              AND    wjt_thread   = @pi_thread
              AND    wjt_sequence = @pi_sequence
              AND    wjt_sid      = @v_sid
              AND    wjt_serial   = @v_serial

              COMMIT TRANSACTION JE053
            END
            RETURN 0
          END

        END
      END

      --=====================================================
      -- T R U N C A T E
      --=====================================================
      IF @v_action_type = @v_ws_act_truncate
      BEGIN
        SET @v_handled = 1

        SET @v_step = 16500

        EXEC @v_result = Ws_Act_Truncate @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT
      END

      --=====================================================
      -- C R E A T E
      --=====================================================
      IF @v_action_type = @v_ws_act_create
      BEGIN
        SET @v_handled = 1
        --=====================================================
        -- C R E A T E      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_cube_virtual
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this create is for a cube
          -- return value of 4
          -- pass back to the scheduler and let it do the create
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube create'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 4
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 16600
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE049
            SET @v_step = 16700

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE049
          END
          RETURN 0
        END
        ELSE
        BEGIN
        --=====================================================
        -- C R E A T E      A L L     O T H E R S
        --=====================================================

          SET @v_step = 16800
          EXEC @v_result = Ws_Act_Create @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT
        END
      END
      --=====================================================
      -- D R O P
      --=====================================================
      IF @v_action_type = @v_ws_act_drop
      BEGIN
        SET @v_handled = 1
        SET @v_step = 16900
        EXEC @v_result = Ws_Act_Drop @p_sequence,@v_obj_type,@v_action_type,
                                     @v_obj_key,
                                     @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                     @p_return_msg OUTPUT,
                                     @p_status_code OUTPUT,
                                     @p_result OUTPUT
      END
      --=====================================================
      -- D R O P    A L L
      --=====================================================
      IF @v_action_type = @v_ws_act_drop_all
      BEGIN
        SET @v_handled = 1
        SET @v_step = 17000
        EXEC @v_result = Ws_Act_Drop_All @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT ,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT
      END
      --=====================================================
      -- B U I L D
      --=====================================================
      IF @v_action_type = @v_ws_act_build
      BEGIN
        SET @v_handled = 1
        SET @v_step = 17100
        EXEC @v_result = Ws_Act_Build @p_sequence,@v_obj_type,@v_action_type,
                                      @v_obj_key,
                                      @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                      @p_return_msg OUTPUT,
                                      @p_status_code OUTPUT,
                                      @p_result OUTPUT
      END

      --=====================================================
      -- B U I L D    A L L
      --=====================================================
      IF @v_action_type = @v_ws_act_build_all
      BEGIN
        SET @v_handled = 1
        SET @v_step = 17200
        EXEC @v_result = Ws_Act_Build_All @p_sequence,@v_obj_type,@v_action_type,
                                          @v_obj_key,
                                          @v_audit_job_name,
                                          @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg OUTPUT,
                                          @p_status_code OUTPUT,
                                          @p_result OUTPUT
      END
      --=====================================================
      -- P R E   D R O P
      --=====================================================
      IF @v_action_type = @v_ws_act_pre_drop
      BEGIN
        SET @v_handled = 1
        SET @v_step = 17300
        EXEC @v_result = Ws_Act_Pre_Drop @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT
      END
      --=====================================================
      -- A N A L Y Z E
      --=====================================================
      IF @v_action_type = @v_ws_act_analyze
      BEGIN
        --=====================================================
        -- A N A L Y Z E      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_cube_virtual
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this analyse is for a cube
          -- return value of 8
          -- pass back to the scheduler and let it do the processing
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube analyze'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 8
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 17400
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE050
            SET @v_step = 17500

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE050
          END
          RETURN 0
        END
        ELSE
        BEGIN
          SET @v_handled = 1
          SET @v_step = 17600
          EXEC @v_result = Ws_Act_Analyze @p_sequence,@v_obj_type,@v_action_type, 100,
                                          @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg OUTPUT,
                                          @p_status_code OUTPUT,
                                          @p_result OUTPUT
        END
      END
      --=====================================================
      -- Q U I C K    A N A L Y Z E
      --=====================================================
      IF @v_action_type = @v_ws_act_quick_analyze
      BEGIN
        --=====================================================
        -- Q U I C K    A N A L Y Z E      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_cube_virtual
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this quick analyse is for a cube
          -- return value of 5
          -- pass back to the scheduler and let it do the processing
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube quick analyze'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 9
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 17700
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE051
            SET @v_step = 17800

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial
            COMMIT TRANSACTION JE051

          END
          RETURN 0
        END
        ELSE
        BEGIN
          SET @v_handled = 1
          EXEC @v_result = Ws_Act_Analyze @p_sequence,@v_obj_type,@v_action_type, 3,
                                          @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg OUTPUT,
                                          @p_status_code OUTPUT,
                                          @p_result OUTPUT
        END
      END
      --=====================================================
      -- S T A T I S T I C S
      --=====================================================
      IF @v_action_type = @v_ws_act_statistics
      BEGIN
        SET @v_handled = 1
        SET @v_step = 17900

        EXEC @v_result = Ws_Act_Dbms_Stats @p_sequence,@v_obj_type,@v_action_type, 100,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT
      END
      --=====================================================
      -- Q U I C K   S T A T S
      --=====================================================
      IF @v_action_type = @v_ws_act_quick_statistics
      BEGIN
        SET @v_handled = 1
        SET @v_step = 18000

        EXEC @v_result = Ws_Act_Dbms_Stats @p_sequence,@v_obj_type,@v_action_type, 3,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT
      END
      --=====================================================
      -- P R O C E S S
      --=====================================================
      IF @v_action_type = @v_ws_act_process
      BEGIN
        SET @v_handled = 1
        SET @v_step = 18100

        --=====================================================
        -- P R O C E S S      C U B E
        --=====================================================
        IF @v_obj_type = @v_ws_obj_cube
        OR @v_obj_type = @v_ws_obj_cube_virtual
        OR @v_obj_type = @v_ws_obj_olap_cube
        OR @v_obj_type = @v_ws_obj_olap_dim
        OR @v_obj_type = @v_ws_obj_olap_role
        BEGIN
          -- If this process is for a cube
          -- return value of 5
          -- pass back to the scheduler and let it do the processing
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'cube process'
          SET @po_action_key    = 0
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 5
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 18200
          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE052
            SET @v_step = 18300

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE052
          END
          RETURN 0
        END

        --=====================================================
        -- P R O C E S S      L O A D
        --=====================================================
        IF @v_obj_type = @v_ws_obj_load
        BEGIN
          SET @v_step = 18400
          EXEC @v_result = Ws_Act_Pre_Drop @p_sequence,@v_obj_type,@v_action_type,
                                           @v_obj_key,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT
          IF @p_result >= -1
          BEGIN
            IF @p_status_code = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            SET @v_step = 18500
            EXEC @v_result = Ws_Act_Load @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT

            -- If this load requires a host script then we will have a
            -- return value of 2
            -- If script build worked then skip out to process it
            -- If it failed then the standard handling will deal with it.
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 2
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'process table'
              SET @po_action_key    = 0
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 2
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 18600
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 18700

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

            -- If this load requires an ODBC load then we will have a
            -- return value of 3
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 3
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'process table'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 3
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 18800
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE054
                SET @v_step = 18900

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE054
              END
              RETURN 0
            END -- end of result = 3

            -- If this load requires a Native ODBC based load
            --    then we will have a return value of 12
            -- If this load requires a SSIS based load
            --    then we will have a return value of 14
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 12
            OR @p_result = 14
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'process table'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 19000
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE070
                SET @v_step = 19100

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE070
              END
              RETURN 0
            END -- end of result = 12/14

            -- If this load is a BDA Server operation with non-Hive target
            -- then we will have a return value of 91
            -- Skip out to process it
            -- When we Rejoin the job any post load procedure will be run
            IF @p_result = 91
            BEGIN
              SET @v_step = 19150

              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = @p_return_msg + ' with non-Hive target'
              SET @po_action_key    = 0
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = 91

              -- Don't need to put BDA connection settings into task data (only used by the Linux/Unix Scheduler).
              SET @v_task_data = ''

              -- Put the BDA connection key into task data (used by the Windows Scheduler).
              SET @v_task_data = @v_task_data
                + 'SCH_BDA_ConnectKey[WSH]' + CONVERT(VARCHAR,@v_bda_connect_key) + '[WSH]'

              -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
              SET @v_task_data = @v_task_data
                + 'SCH_BDA_ObjKey[WSH]' + CONVERT(VARCHAR,@v_obj_key) + '[WSH]'
                + 'SCH_BDA_Action[WSH]' + CONVERT(VARCHAR,@v_action_type) + '[WSH]'

              SET @po_task_data = @v_task_data

              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 19160
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE0702
                SET @v_step = 19170

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE0702
              END

              RETURN 0
            END -- end of result = 91

          END -- End of load okay

          IF @v_result >= -1
          BEGIN
            SET @v_step = 19200
            EXEC @v_result = Ws_Act_Post_Load @p_sequence,@v_obj_type,@v_action_type,
                                              @v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg_2 OUTPUT,
                                              @p_status_code_2 OUTPUT,
                                              @p_result_2 OUTPUT

            -- If this procedure is a SQLBLOCK we will have a return value of 2
            -- skip out to process it
            -- When we Rejoin the job any post action will be run
            IF @p_status_code_2 = 2
            BEGIN
              -- Need to first output info message for the load step
              EXEC @v_result = WsWrkAudit 'S', @v_audit_job_name, @v_audit_task_name, @p_sequence,
                @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'execute sql'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result_2 -- 16 or 17
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 19300
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 19400

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

          END
          ELSE
          BEGIN
            SET @p_status_code_2 = 1
          END

          IF @p_result_2 >= -1
          BEGIN
            IF @p_status_code_2 = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            SET @v_step = 19500
            EXEC @v_result = Ws_Act_Build @p_sequence,@v_obj_type,@v_action_type,
                                          @v_obj_key,
                                          @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg_3 OUTPUT,
                                          @p_status_code_3 OUTPUT,
                                          @p_result_3 OUTPUT

            IF @p_status_code_3 = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_3,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            IF @p_status_code_3 < 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_3,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
          END
          ELSE
          BEGIN
            SET @p_status_code_3 = 1
          END

          -- If our index build failed and the load worked then
          -- record the index failure
          IF @p_status_code_2 < @p_status_code
          BEGIN
            SET @p_status_code = @p_status_code_2
          END
          IF @p_status_code_3 < @p_status_code
          BEGIN
            SET @p_status_code = @p_status_code_3
          END
        END -- End of Process a load

        --=====================================================
        -- P R O C E S S      E X P O R T
        --=====================================================
        IF @v_obj_type = @v_ws_obj_export
        BEGIN
          SET @v_step = 19600
          EXEC @v_result = Ws_Act_Export @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT

          -- If this export requires a host script then we will have a
          -- return value of 2
          -- If script build worked then skip out to process it
          -- If it failed then the standard handling will deal with it.
          -- When we Rejoin the job any post load procedure will be run
          IF @p_result = 2
          BEGIN
            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @p_task_id
            SET @po_task_name     = @p_task_name
            SET @po_result_msg    = 'process table'
            SET @po_action_key    = 0
            SET @po_action_msg    = 'no action'
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
            SET @po_result_code   = 11
            --=====================================================
            -- Remove this thread as being active
            --=====================================================
            SET @v_step = 19700
            IF @p_job_id > 0 AND @v_sid <> 0
            BEGIN
              BEGIN TRANSACTION JE053
              SET @v_step = 19800

              DELETE FROM ws_wrk_job_thread
              WHERE  wjt_job_key  = @p_job_id
              AND    wjt_thread   = @pi_thread
              AND    wjt_sequence = @pi_sequence
              AND    wjt_sid      = @v_sid
              AND    wjt_serial   = @v_serial

              COMMIT TRANSACTION JE053
            END
            RETURN 0
          END
          -- If this export requires SSIS then we will have a
          -- return value of 14
          -- If script build worked then skip out to process it
          -- If it failed then the standard handling will deal with it.
          -- When we Rejoin the job any post load procedure will be run
          IF @p_result = 14
          BEGIN
            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @p_task_id
            SET @po_task_name     = @p_task_name
            SET @po_result_msg    = 'process table'
            SET @po_action_key    = 0
            SET @po_action_msg    = 'no action'
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
            SET @po_result_code   = 14
            --=====================================================
            -- Remove this thread as being active
            --=====================================================
            SET @v_step = 19850
            IF @p_job_id > 0 AND @v_sid <> 0
            BEGIN
              BEGIN TRANSACTION JE053
              SET @v_step = 19860

              DELETE FROM ws_wrk_job_thread
              WHERE  wjt_job_key  = @p_job_id
              AND    wjt_thread   = @pi_thread
              AND    wjt_sequence = @pi_sequence
              AND    wjt_sid      = @v_sid
              AND    wjt_serial   = @v_serial

              COMMIT TRANSACTION JE053
            END
            RETURN 0
          END

          IF @v_result >= -1
          BEGIN
            SET @v_step = 19900
            EXEC @v_result = Ws_Act_Post_Export @p_sequence,@v_obj_type,@v_action_type,
                                                @v_obj_key,
                                                @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                                @p_return_msg_2 OUTPUT,
                                                @p_status_code_2 OUTPUT,
                                                @p_result_2 OUTPUT

            -- If this procedure is a SQLBLOCK we will have a return value of 2
            -- skip out to process it
            -- When we Rejoin the job any post action will be run
            IF @p_status_code_2 = 2
            BEGIN
              -- Need to first output info message for the export step
              EXEC @v_result = WsWrkAudit 'S', @v_audit_job_name, @v_audit_task_name, @p_sequence,
                @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'execute sql'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result_2 -- 16 or 17
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 20000
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 20100

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

          END
          ELSE
          BEGIN
            SET @p_status_code_2 = 1
          END

          IF @p_result_2 >= -1
          BEGIN
            IF @p_status_code_2 = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
          END
          ELSE
          BEGIN
            SET @p_status_code_3 = 1
          END

        END -- End of Process a export

        --=====================================================
        -- P R O C E S S      J O B
        --=====================================================
        IF @v_obj_type = @v_ws_obj_job
        BEGIN

          SELECT @v_job_action = 'NEW'

          IF @v_restart_flag = 1
          BEGIN
            SET @v_step = 20200

            SELECT @v_run_count = COUNT(*)
            FROM   ws_wrk_job_run
            WHERE  wjr_name = @p_task_name
            AND    wjr_sequence = @pi_sequence;

            IF @v_run_count = 1
            BEGIN
               SELECT @v_job_action = 'RESTART'
            END

          END

          SET @v_step = 20300
          EXEC @v_result = Ws_Job_Exec_411 @p_task_name,NULL,@v_job_action,0,@pi_sequence,
                                           @p_job_id, @p_task_id,0,'',
                                           @pm_job_name, @pm_job_key,
                                           NULL,NULL,
                                           @p_status_code OUTPUT,
                                           @p_return_msg OUTPUT,
                                           @v_job_job_key OUTPUT,
                                           @v_job_task_key OUTPUT,@v_job_task_name OUTPUT,
                                           @v_job_action_key OUTPUT, @v_job_action_msg OUTPUT,
                                           @v_job_key_list OUTPUT, @v_task_key_list OUTPUT,
                                           @v_task_data OUTPUT

          IF @p_status_code = -99
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' BLOCKED'
          END
          IF @p_status_code = -3
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' FAILED with unhandled error'
          END
          IF @p_status_code = -2
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' FAILED'
          END
          IF @p_status_code = -1
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' completed with WARNINGS'
          END
          IF @p_status_code = 0
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' FAILED with unhandled problem'
            SELECT @p_status_code = -2
          END
          IF @p_status_code = 1
          BEGIN
            SELECT @p_return_msg = 'Called job ' + @p_task_name + ' completed successfully'
          END
          IF @p_status_code > 1
          BEGIN
            SET @po_job_key       = @p_job_id
            SET @po_task_key      = @v_job_task_key
            SET @po_task_name     = @v_job_task_name
            SET @po_result_msg    = @p_return_msg
            SET @po_action_key    = @v_job_action_key
            SET @po_action_msg    = @v_job_action_msg
            SET @po_result_code   = @p_status_code
            SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id) + ',' + ISNULL(@v_job_key_list,'')
            SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id) + ',' + ISNULL(@v_task_key_list,'')
            SET @po_task_data     = @v_task_data
            return 0;
          END

        END -- End of Job process

        IF  @v_obj_type <> @v_ws_obj_cube
        AND @v_obj_type <> @v_ws_obj_cube_virtual
        AND @v_obj_type <> @v_ws_obj_olap_cube
        AND @v_obj_type <> @v_ws_obj_olap_dim
        AND @v_obj_type <> @v_ws_obj_olap_role
        AND @v_obj_type <> @v_ws_obj_load
        AND @v_obj_type <> @v_ws_obj_export
        AND @v_obj_type <> @v_ws_obj_job
        BEGIN
        --=====================================================
        -- P R O C E S S      O T H E R     O B J E C T
        --=====================================================
          SET @v_step = 20400
          SET @v_part_table_key = 0
          -- Check to see if object has a partitioning key, and if so see if need to predrop any indexes on that table also
          -- need this for columnstore index processing
          EXEC @v_result = Ws_Object_Info @p_sequence,@v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                      @v_obj_key,NULL,'PARTKEY' ,
                                      @v_objinfo_status OUTPUT,
                                      @p_return_msg OUTPUT,
                                      @p_result OUTPUT,
                                      @v_objinfo_value OUTPUT

          IF @p_result >= -1
          BEGIN
            IF @p_result = 1
            BEGIN
              SET @v_step = 20500
              SET @v_part_table_key = CAST(@v_objinfo_value AS INTEGER)

--              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
--                                                  @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id

              SET @v_step = 20600
              EXEC @v_result = Ws_Act_Pre_Drop @p_sequence,@v_obj_type,@v_action_type,
                                               @v_part_table_key,
                                               @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                               @p_return_msg OUTPUT,
                                               @p_status_code OUTPUT,
                                               @p_result OUTPUT
              IF @p_result >= -1
              BEGIN
                IF @p_status_code = 1
                BEGIN
                  EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                                  @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
                END
                ELSE
                BEGIN
                  EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                                  @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
                END
              END
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
          END

          SET @v_step = 20700
          EXEC @v_result = Ws_Act_Pre_Drop @p_sequence,@v_obj_type,@v_action_type,
                                           @v_obj_key,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT
          IF @p_result >= -1
          BEGIN
            IF @p_status_code = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            SET @p_result = -3
            SET @p_return_msg = 'Unexpected error in call to update procedure'

            SET @v_step = 20800
            EXEC @v_result = Ws_Act_Update @p_sequence, @v_obj_type, @v_action_type,
                                           @v_obj_key,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT

            -- If this procedure is a SQLBLOCK we will have a return value of 2
            -- skip out to process it
            -- When we Rejoin the job any post action will be run
            IF @p_status_code = 2
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'execute sql'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result -- 16 or 17
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 20900
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 21000

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

          END
          IF @p_result >= -1
          BEGIN
            SET @v_step = 21100

            EXEC @v_result = Ws_Act_Build @p_sequence,@v_obj_type,@v_action_type,
                                          @v_obj_key,
                                          @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                          @p_return_msg_2 OUTPUT,
                                          @p_status_code_2 OUTPUT,
                                          @p_result_2 OUTPUT
            IF @p_status_code_2 = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @p_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            IF @p_status_code_2 < 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
          END
          ELSE
          BEGIN
            SET @p_status_code_2 = 1
          END

          -- If our index build failed and the update worked then
          -- record the index failure
          IF @p_status_code_2 < @p_status_code
          BEGIN
            SET @p_status_code = @p_status_code_2
          END
        END -- End of other object process
      END -- End of Update

      --=====================================================
      -- I N I T I A L     L O A D
      --=====================================================
      IF @v_action_type = @v_ws_act_initial
      BEGIN
        SET @v_handled = 1
        --=====================================================
        -- R E T R O     I N I T I A L     L O A D
        --=====================================================
        IF @v_obj_type = @v_ws_obj_retro_copy
        BEGIN

          SET @v_step = 21200
          -- First create the table
          EXEC @v_result = Ws_Act_Create @p_sequence,@v_obj_type,@v_action_type,
                                         @v_obj_key,
                                         @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                         @p_return_msg OUTPUT,
                                         @p_status_code OUTPUT,
                                         @p_result OUTPUT
          -- If this a Retrofit ODBC based load then
          -- Skip out to process it
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'retro table'
          SET @po_action_key    = @v_obj_key
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = 13
          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET @v_step = 21300

          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE066
            SET @v_step = 21400

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE066
          END
          RETURN 0
        END
        ELSE
        --==========================================================
        -- O T H E R     O B J E C T     I N I T I A L     B U I L D
        --==========================================================
        BEGIN
          SET @v_step = 21500
          EXEC @v_result = Ws_Act_Drop_All @p_sequence,@v_obj_type,@v_action_type,
                                           @v_obj_key,
                                           @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                           @p_return_msg OUTPUT,
                                           @p_status_code OUTPUT,
                                           @p_result OUTPUT
          IF @p_result >= -1
          BEGIN
            IF @p_status_code = 1
            BEGIN
              EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END
            ELSE
            BEGIN
              EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                              @p_return_msg,NULL,NULL,@v_audit_task_id,@v_audit_job_id
            END

            SET @v_step = 21600
            EXEC @v_result = Ws_Act_Initial_Build @p_sequence,@v_obj_type,@v_action_type,
                                                  @v_obj_key,
                                                  @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                                  @p_return_msg OUTPUT,
                                                  @p_status_code OUTPUT,
                                                  @p_result OUTPUT

            -- If this procedure is a SQLBLOCK we will have a return value of 2
            -- skip out to process it
            -- When we Rejoin the job any post action will be run
            IF @p_status_code = 2
            BEGIN
              SET @po_job_key       = @p_job_id
              SET @po_task_key      = @p_task_id
              SET @po_task_name     = @p_task_name
              SET @po_result_msg    = 'execute sql'
              SET @po_action_key    = @v_obj_key
              SET @po_action_msg    = 'no action'
              SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
              SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
              SET @po_result_code   = @p_result -- 16 or 17
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              SET @v_step = 21700
              IF @p_job_id > 0 AND @v_sid <> 0
              BEGIN
                BEGIN TRANSACTION JE053
                SET @v_step = 21800

                DELETE FROM ws_wrk_job_thread
                WHERE  wjt_job_key  = @p_job_id
                AND    wjt_thread   = @pi_thread
                AND    wjt_sequence = @pi_sequence
                AND    wjt_sid      = @v_sid
                AND    wjt_serial   = @v_serial

                COMMIT TRANSACTION JE053
              END
              RETURN 0
            END

          END
          IF @p_result >= -1
          BEGIN
            SET @v_step = 21900
            EXEC @v_result = Ws_Act_Build_All @p_sequence,@v_obj_type,@v_action_type,
                                              @v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg_2 OUTPUT,
                                              @p_status_code_2 OUTPUT,
                                              @p_result_2 OUTPUT
          END
          IF @p_status_code_2 = 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'I',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                            @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END
          IF @p_status_code_2 < 1
          BEGIN
            EXEC @v_result = WsWrkAudit 'W',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                            @p_return_msg_2,NULL,NULL,@v_audit_task_id,@v_audit_job_id
          END

          -- If our index build failed and the initial load worked then
          -- record the index failure
          IF @p_status_code_2 < @p_status_code
          BEGIN
            SET @p_status_code = @p_status_code_2
          END
        END -- End of other object initial load
      END -- End of initial load

      --=====================================================
      -- C U S T O M
      --=====================================================
      IF @v_action_type = @v_ws_act_custom
      BEGIN
        SET @v_handled = 1
        SET @v_step = 22000
        EXEC @v_result = Ws_Act_Initial_Build @p_sequence,@v_obj_type,@v_action_type,
                                              @v_obj_key,
                                              @v_audit_job_name, @v_audit_task_name, @v_audit_job_id, @v_audit_task_id,
                                              @p_return_msg OUTPUT,
                                              @p_status_code OUTPUT,
                                              @p_result OUTPUT
        -- If this procedure is a SQLBLOCK we will have a return value of 2
        -- skip out to process it
        -- When we Rejoin the job any further action will be run
        IF @p_status_code = 2
        BEGIN
          SET @po_job_key       = @p_job_id
          SET @po_task_key      = @p_task_id
          SET @po_task_name     = @p_task_name
          SET @po_result_msg    = 'execute sql'
          SET @po_action_key    = @v_obj_key
          SET @po_action_msg    = 'no action'
          SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
          SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
          SET @po_result_code   = @p_result -- 16 or 17

          --=====================================================
          -- Remove this thread as being active
          --=====================================================

          SET @v_step = 22100

          IF @p_job_id > 0 AND @v_sid <> 0
          BEGIN
            BEGIN TRANSACTION JE053
            SET @v_step = 22200

            DELETE FROM ws_wrk_job_thread
            WHERE  wjt_job_key  = @p_job_id
            AND    wjt_thread   = @pi_thread
            AND    wjt_sequence = @pi_sequence
            AND    wjt_sid      = @v_sid
            AND    wjt_serial   = @v_serial

            COMMIT TRANSACTION JE053
          END
          RETURN 0
        END

      END -- End of custom


      --=====================================================
      -- C U B E    D I M     P R O C E S S
      --=====================================================
      IF @v_action_type = @v_ws_act_cube_dim
      BEGIN
        SET @v_handled = 1
        -- If this process is for a cube
        -- return value of 6
        -- pass back to the scheduler and let it do the processing
        SET @po_job_key       = @p_job_id
        SET @po_task_key      = @p_task_id
        SET @po_task_name     = @p_task_name
        SET @po_result_msg    = 'cube dim process'
        SET @po_action_key    = 0
        SET @po_action_msg    = 'no action'
        SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
        SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
        SET @po_result_code   = 6
        --=====================================================
        -- Remove this thread as being active
        --=====================================================
        SET @v_step = 22300
        IF @p_job_id > 0 AND @v_sid <> 0
        BEGIN
          BEGIN TRANSACTION JE055
          SET @v_step = 22400

          DELETE FROM ws_wrk_job_thread
          WHERE  wjt_job_key  = @p_job_id
          AND    wjt_thread   = @pi_thread
          AND    wjt_sequence = @pi_sequence
          AND    wjt_sid      = @v_sid
          AND    wjt_serial   = @v_serial

          COMMIT TRANSACTION JE055
        END
        RETURN 0
      END

      --=====================================================
      -- C U B E    D A T A B A S E     D I M     P R O C E S S
      --=====================================================
      IF @v_action_type = @v_ws_act_db_dim
      BEGIN
        SET @v_handled = 1
        -- If this process is for a cube database dim processing
        -- return value of 7
        -- pass back to the scheduler and let it do the processing
        SET @po_job_key       = @p_job_id
        SET @po_task_key      = @p_task_id
        SET @po_task_name     = @p_task_name
        SET @po_result_msg    = 'cube database dim process'
        SET @po_action_key    = 0
        SET @po_action_msg    = 'no action'
        SET @ps_job_key_list  = CONVERT(VARCHAR,@p_job_id)
        SET @ps_task_key_list = CONVERT(VARCHAR,@p_task_id)
        SET @po_result_code   = 7
        --=====================================================
        -- Remove this thread as being active
        --=====================================================
        SET @v_step = 22500
        IF @p_job_id > 0 AND @v_sid <> 0
        BEGIN
          BEGIN TRANSACTION JE056
          SET @v_step = 22600

          DELETE FROM ws_wrk_job_thread
          WHERE  wjt_job_key  = @p_job_id
          AND    wjt_thread   = @pi_thread
          AND    wjt_sequence = @pi_sequence
          AND    wjt_sid      = @v_sid
          AND    wjt_serial   = @v_serial

          COMMIT TRANSACTION JE056
        END
        RETURN 0
      END

      --=====================================================
      -- U N S U P P O R T E D
      --=====================================================
      IF @v_handled = 0
      BEGIN
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_task_name + ' sequence ' +
                         CONVERT(varchar,ISNULL(@pi_sequence,-1)) +
                         ' could not perform action. Unsupported action ' +
                         CONVERT(varchar, ISNULL(@v_action_type,-1))
                         + ' for object ' + CONVERT(varchar,ISNULL(@v_obj_type,-1))
        EXEC @v_result = WsWrkAudit 'E',@v_audit_job_name, @v_audit_task_name, @pi_sequence,
                                         @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id
        SET @p_status_code  = -2
        SET @p_return_msg = 'Unsupported action ' +
          CONVERT(varchar, ISNULL(@v_action_type,-1)) +
          ' for object ' + CONVERT(varchar,ISNULL(@v_obj_type,-1))
        SET @v_result = 1
      END
      SET @v_step = 22700

      SET @v_just_done = 1
      SET @v_step = 22800

      --=====================================================
      -- Log the results in the audit trail
      --=====================================================
      SET @v_handled = 0
      IF @p_status_code = 1
      BEGIN
        SET @v_handled      = 1
        SET @v_audit_status = 'S'
        SET @v_run_status   = 'C'
      END
      IF @p_status_code = -1
      BEGIN
        SET @v_handled      = 1
        SET @v_audit_status = 'W'
        SET @v_run_status   = 'C'
      END
      IF @p_status_code = -2
      BEGIN
        SET @v_handled      = 1
        SET @v_audit_status = 'E'
        SET @v_run_status   = 'F'
      END
      IF @p_status_code = -3
      BEGIN
        SET @v_handled      = 1
        SET @v_audit_status = 'F'
        SET @v_run_status   = 'F'
      END
      IF @v_handled = 0
      BEGIN
        SET @v_audit_status = 'U'
        SET @v_run_status   = 'U'
        SET @p_status_code  = -3
      END

      EXEC @v_result = WsWrkAudit @v_audit_status, @v_audit_job_name, @v_audit_task_name, @p_sequence,
               @p_return_msg, NULL, NULL, @v_audit_task_id, @v_audit_job_id

      --=====================================================
      -- See if the task needs a status update.
      --=====================================================
      If @v_okay = 1 OR @v_halted = 1
      BEGIN
        --=====================================================
        -- Update the run record to indicate our final status
        -- If we have a halt then generate a message
        --=====================================================
        SET @v_step = 22900
        IF @v_halted = 1
        BEGIN
          SET @p_return_msg   = 'Halted by dependency failure or halt'
          SET @v_run_status   = 'H'
          SET @v_audit_status = NULL
        END

        BEGIN TRANSACTION JE057
--6.0.4.1        SET TRANSACTION ISOLATION LEVEL SERIALIZABLE

        SET @v_step = 23000
        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        -- if lock result is zero then we got the lock
        IF @v_lock_result >= 0
        BEGIN
          SET @v_step = 23100

          UPDATE ws_wrk_task_run
          SET    wtr_run_status   = @v_run_status,
                 wtr_audit_status = @v_audit_status,
                 wtr_return_msg   = @p_return_msg,
                 wtr_elapsed_hh   = CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60),
                 wtr_elapsed_mi   = DATEDIFF(mi,wtr_started,GETDATE()) -
                                  CONVERT(integer,DATEDIFF(mi,wtr_started,GETDATE())/60)*60,
                 wtr_completed    = GETDATE()
          WHERE  wtr_task_key = @v_task_key
          AND    wtr_job_key  = @p_job_id

          SELECT @v_row_count     = @@ROWCOUNT

          COMMIT TRANSACTION JE057
        END -- end got lock
        ELSE
        BEGIN
          COMMIT TRANSACTION JE057
        END

--6.0.4.1    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    --SET LOCK_TIMEOUT -1

      END  -- End of task record update
    END -- End of v_process_flag set to 1
    ELSE -- not processing, so must be an idle thread
    BEGIN
      SET @v_idle_thread = 1
      --
      -- Check that we have running tasks.
      -- If we have waiting tasks and no running tasks then we must have a dependency loop
      -- So tell them about it and abort.
      IF  @v_task_count = 1
      AND @v_running_count = 0
      BEGIN
        IF @v_depend_loop = 1
        BEGIN
          SET @v_task_count = 0 -- force a break out of the loop
        END
        ELSE
        BEGIN
          SET @v_depend_loop = 1
        END
      END

    END -- End of Processing of a task

    -- If just processed then sleep for 2 seconds and look for next task
    IF @v_just_done = 0
    BEGIN
      WAITFOR DELAY '00:00:02'
    END

    -- If the thread is idle then sleep for 30 seconds.
    IF @v_idle_thread = 1 AND @v_running_count > 0
    BEGIN
--      WAITFOR DELAY '00:00:30'
      IF @v_idle_thread_wait = 0
      OR @v_idle_thread_wait = 30
      BEGIN
        WAITFOR DELAY '00:00:30'
      END
      ELSE
      BEGIN

        SET @v_idle_thread_wait_hh     = @v_idle_thread_wait / 60 / 60
        SET @v_idle_thread_wait        = @v_idle_thread_wait - (@v_idle_thread_wait_hh * 60 * 60)
        SET @v_idle_thread_wait_mm     = @v_idle_thread_wait / 60
        SET @v_idle_thread_wait_ss     = @v_idle_thread_wait - (@v_idle_thread_wait_mm * 60)

        SET @v_idle_thread_wait_string = RIGHT('00'+RTRIM(CAST(@v_idle_thread_wait_hh AS CHAR)),2)
                                       + ':'
                                       + RIGHT('00'+RTRIM(CAST(@v_idle_thread_wait_mm AS CHAR)),2)
                                       + ':'
                                       + RIGHT('00'+RTRIM(CAST(@v_idle_thread_wait_ss AS CHAR)),2)

--        SET @v_MsgText = 'waiting for ' + @v_idle_thread_wait_string;
--        EXEC @v_result = WsWrkAudit 'A',@v_audit_job_name, @v_audit_job_name, @pi_sequence,
--                                             @v_MsgText,@v_db_code, @v_db_msg,0,@v_audit_job_id
        WAITFOR DELAY @v_idle_thread_wait_string
      END
    END

  END -- End of While More tasks Loop

  SET @v_step = 23200


  --=====================================================
  --      A L L      T A S K S      D O N E
  --=====================================================
  --=====================================================
  -- Here if no more waiting tasks. If no more running tasks
  -- then we must be the last thread, so update the job_run
  -- record to a completed state
  -- WMR Need to update the ctrl record and move the run records to the log tables. WMR
  --=====================================================
  SET @v_step = 23300
  SET @po_action_key = 0
  SET @po_action_msg = ''
  SET @po_result_code = 1

  IF @v_running_count = 0
  BEGIN
    SET @v_okay = 0

    IF @v_halted_count = 0 AND @v_failed_count = 0 AND @v_depend_loop = 0
    BEGIN
      SET @v_job_status = 'C'
      SET @v_audit_status = 'S'
      SET @v_MsgText = 'Job ' + @pi_job_name + ' sequence '
                     +  CONVERT(varchar,@pi_sequence) + ' Completed. '

      BEGIN TRANSACTION JE058
      SET @v_step = 23400

      SELECT @v_OkayMsg = wjr_publish_okay
      FROM   ws_wrk_job_run
      WHERE  wjr_job_key  = @p_job_id
      AND    wjr_sequence = @pi_sequence

      COMMIT TRANSACTION JE058
      SET @v_FailMsg = ''
    END
    ELSE
    BEGIN
      IF @v_depend_loop = 1 AND @v_failed_count = 0
      BEGIN
        SET @po_result_code = -2
        SET @v_job_status = 'F'
        SET @v_audit_status = 'F'
        SET @v_MsgText = @v_ws_pro_version + ': Job ' + @pi_job_name  + ' sequence ' +
                         CONVERT(varchar,@pi_sequence) + ' CANNOT COMPLETE. Possible task dependency loop. '

        BEGIN TRANSACTION JE059
        SET @v_step = 23500

        SELECT @v_FailMsg = wjr_publish_fail
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key  = @p_job_id
        AND    wjr_sequence = @pi_sequence

        COMMIT TRANSACTION JE059
        SET @v_OkayMsg = ''
      END
      ELSE
      BEGIN
        SET @po_result_code = -2
        SET @v_job_status = 'F'
        SET @v_audit_status = 'F'
        SET @v_MsgText = 'Job ' + @pi_job_name  + ' sequence '
                       + CONVERT(varchar,@pi_sequence) + ' FAILED. '

        BEGIN TRANSACTION JE059
        SET @v_step = 23600

        SELECT @v_FailMsg = wjr_publish_fail
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key  = @p_job_id
        AND    wjr_sequence = @pi_sequence

        COMMIT TRANSACTION JE059
        SET @v_OkayMsg = ''
      END
    END

    --=====================================================
    -- All tasks done
    -- Set the job status on the run record for the job and finish time.
    -- Need to lock the record first to prevent another thread from
    -- grabbing it, or in case another thread has already got it,
    -- or updated it
    --=====================================================
    --SET LOCK_TIMEOUT 500
--6.0.4.1    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
    BEGIN TRANSACTION JE060

    SET @v_step = 23700

    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    -- if lock result is zero then we got the lock
    IF @v_lock_result >= 0
    BEGIN
--SET @v_MsgText = 'Job Terminating '+ @pi_job_name
--+ ' parent job ' + @pm_job_name
--+ ' job key ' + CONVERT(VARCHAR,ISNULL(@p_job_id,-9))
--+ ' parent key ' + CONVERT(VARCHAR,ISNULL(@pm_job_key,-9))
--+ ' audit key ' + CONVERT(VARCHAR,ISNULL(@v_audit_job_id,-9))
--+ ' child flag ' + CONVERT(VARCHAR,ISNULL(@v_child_job,-9))
--+ ' status ' + CONVERT(VARCHAR,ISNULL(@po_result_code,-9))
--+ ' job key list ' + SUBSTRING(ISNULL(@ps_job_key_list,''),1,20)
--+ ' task key list ' + SUBSTRING(ISNULL(@ps_task_key_list,''),1,20)
--+ ' status msg ' + SUBSTRING(ISNULL(@po_result_msg,''),1,90)
--EXEC @v_result = WsWrkAudit 'M',@v_audit_job_name, @v_audit_job_name, @v_ctrl_sequence,
--@v_MsgText,NULL,NULL,0,@v_audit_job_id

      SET @v_run_status = 'Z'
      SET @v_step = 23800

      SELECT @v_run_status = wjr_status
      FROM   ws_wrk_job_run
      WHERE  wjr_job_key  = @p_job_id
      AND    wjr_sequence = @pi_sequence

      -- if the job is still running
      -- then we will finish it
      IF @v_run_status = 'R'
      BEGIN
        SET @v_okay = 1
        SET @v_step = 23900

        UPDATE ws_wrk_job_run
        SET    wjr_status     = @v_job_status,
               wjr_elapsed_hh = CONVERT(integer,DATEDIFF(mi,wjr_started,GETDATE())/60),
               wjr_elapsed_mi = DATEDIFF(mi,wjr_started,GETDATE()) -
                                CONVERT(integer,DATEDIFF(mi,wjr_started,GETDATE())/60)*60,
               wjr_completed  = GETDATE()
        WHERE  wjr_job_key  = @p_job_id
        AND    wjr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

      END -- end of status still running
      ELSE
      BEGIN
        -- someone else got the record
        SET @v_okay = 0
      END

      COMMIT TRANSACTION JE060

    END -- end of lock acquired
    -- failed to get the lock
    -- so wait and try again
    ELSE
    BEGIN
      -- someone else got the record or it is locked
      SET @v_okay = 0
      COMMIT TRANSACTION JE060
--6.0.4.1      SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    END


--6.0.4.1    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    --SET LOCK_TIMEOUT -1

    -- we are the updater so do the rest
    IF @v_okay = 1
    BEGIN

      IF @v_OkayMsg <> '' AND @v_OkayMsg IS NOT NULL
      BEGIN
        SET @po_action_key = 1
        SET @po_action_msg = @v_OkayMsg
      END
      IF @v_FailMsg <> '' AND @v_FailMsg IS NOT NULL
      BEGIN
        SET @po_action_key = 2
        SET @po_action_msg = @v_FailMsg
      END

      -- substitute any job variables.
      IF @po_action_msg <> '' AND @po_action_msg IS NOT NULL
      BEGIN
        SELECT @po_action_msg = REPLACE(@po_action_msg,'$JOB_KEY$',CONVERT(VARCHAR,ISNULL(@v_audit_job_id,0)))
        SELECT @po_action_msg = REPLACE(@po_action_msg,'$JOB_SEQ$',CONVERT(VARCHAR,ISNULL(@pi_sequence,0)))
        SELECT @po_action_msg = REPLACE(@po_action_msg,'$JOB_THREAD$',CONVERT(VARCHAR,ISNULL(@pi_thread,-1)))
        SELECT @po_action_msg = REPLACE(@po_action_msg,'$JOB_NAME$',@v_audit_job_name)
      END

      SET @v_step = 24000

    --
    -- replace any DSS parameters with their current values
    --
      SELECT @v_spos = ISNULL(PATINDEX('%$P%',@po_action_msg),0)
      WHILE  @v_spos > 0
      BEGIN
        SELECT @v_spos = ISNULL(PATINDEX('%$P%',@po_action_msg),0)
        IF @v_spos > 0
        BEGIN
          SELECT @v_epos = ISNULL(PATINDEX('%$%',SUBSTRING(@po_action_msg,@v_spos+2,LEN(@po_action_msg)-@v_spos-1)),0)
          IF @v_epos = 0
          BEGIN
            SET @v_spos = 0
          END
          ELSE
          BEGIN
            SELECT @v_work        = SUBSTRING(@po_action_msg,@v_spos+2,@v_epos-1);
            SELECT @v_parameter   = dbo.WsParameterReadF(@v_work)
            SELECT @v_work        = SUBSTRING(@po_action_msg,@v_spos,@v_epos+2)
            SELECT @po_action_msg = REPLACE(@po_action_msg,@v_work,@v_parameter)
          END
        END
      END

      EXEC @v_result = WsWrkAudit @v_audit_status,@v_audit_job_name, @v_audit_job_name, @pi_sequence,
                                                  @v_MsgText,NULL,NULL,@v_audit_task_id,@v_audit_job_id

      -- Set the job status on the control record for the job and finish time.
      -- WMR need to set the status to HOLD or Waiting depending on if another run.
      BEGIN TRANSACTION JE061

      SET @v_step = 24100

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      UPDATE ws_wrk_job_ctrl
      SET    wjc_last_status = @v_job_status,
             wjc_completed = GETDATE()
      WHERE  wjc_job_key = @p_job_id

      SELECT @v_row_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE061

      -- IF no update of control then must have been a once only so delete any job dependencies
      -- this will be common for jobs executed via ws_job_create
      -- should be nicer way to id this .. but just need fixed now!
      SET @v_step = 24200

      IF  @v_job_status = 'C'
      AND @v_child_job = 0
      AND @v_row_count = 0
      BEGIN
        BEGIN TRANSACTION JE062
        SET @v_step = 24300

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        DELETE FROM ws_wrk_dependency
        WHERE  wdp_job_key = @p_job_id

        COMMIT TRANSACTION JE062
      END

      SET @v_step = 24400
      IF @v_job_status = 'C'
      BEGIN
        -- Move the job run record to the log record
        SET @v_step = 24500
        BEGIN TRANSACTION JE063

        --Attain a lock
        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END


        SET @v_step = 24600

        INSERT INTO ws_wrk_job_log
        SELECT *
        FROM   ws_wrk_job_run
        WHERE  wjr_job_key = @p_job_id
        AND    wjr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

        IF @v_child_job = 1
        BEGIN
          SET @v_step = 24700

          DELETE FROM ws_wrk_job_log
          WHERE  wjl_job_key = @p_job_id
          AND    wjl_sequence = @pi_sequence
        END

        SET @v_step = 24800

        -- Delete parent job and its sub jobs
        DELETE FROM ws_wrk_job_run
        WHERE  (wjr_job_key = @p_job_id OR wjr_chkp_count = @p_job_id)
        AND wjr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE063

        -- Move the task run records to the log record
        SET @v_step = 24900
        BEGIN TRANSACTION JE064

        SET @v_step = 25000
        --Attain a lock
        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_RUN',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_lock_result = -1
        WHILE @v_lock_result < 0
        BEGIN

          EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                              @LockMode = 'Update',
                                              @LockTimeout = 0

          IF @v_lock_result < 0
          BEGIN
            SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
            WAITFOR DELAY @v_wait
          END

        END

        SET @v_step = 25100

        DELETE FROM ws_wrk_task_log
        WHERE  wtl_job_key = @p_job_id
        AND    wtl_sequence = @pi_sequence
        AND    wtl_task_key IN
        (SELECT wtr_task_key
         FROM   ws_wrk_task_run
         WHERE  wtr_job_key = @p_job_id
         AND    wtr_sequence = @pi_sequence)

        INSERT INTO ws_wrk_task_log
        SELECT *
        FROM   ws_wrk_task_run
        WHERE  wtr_job_key = @p_job_id
        AND    wtr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

        IF @v_child_job = 1
        BEGIN
          SET @v_step = 25200

          UPDATE ws_wrk_task_log
          SET    wtl_job_key = @v_audit_job_id
          WHERE  wtl_job_key = @p_job_id
          AND    wtl_sequence = @pi_sequence

        END

        SET @v_step = 25300

        -- Sub-job's tasks
        DELETE FROM ws_wrk_task_run
        WHERE wtr_job_key IN
        (SELECT wtr_obj_key
         FROM   ws_wrk_task_run
         WHERE  wtr_job_key = @p_job_id
         AND    wtr_sequence = @pi_sequence)
        AND wtr_sequence = @pi_sequence

        -- Parent's tasks and sub-jobs
        DELETE FROM ws_wrk_task_run
        WHERE  wtr_job_key = @p_job_id
        AND    wtr_sequence = @pi_sequence

        SELECT @v_row_count     = @@ROWCOUNT

        COMMIT TRANSACTION JE064
      END -- End of Job status = 'C'
      --

      -- If this job has a blocked iteration waiting then release it
      SET @v_step = 25400
      BEGIN TRANSACTION JE065

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                            @LockMode = 'Update',
                                            @LockTimeout = 0

        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 25500

      UPDATE ws_wrk_job_ctrl
      SET    wjc_status = 'W'
      WHERE  wjc_job_key = @p_job_id
      AND    wjc_status  = 'B'

      SELECT @v_row_count     = @@ROWCOUNT

      COMMIT TRANSACTION JE065

    END -- End of we are the updater

  END -- end of running_count = 0

  --=====================================================
  -- Remove this thread as being active
  --=====================================================
  SET @v_step = 25600
  IF @p_job_id > 0 And @v_sid <> 0
  BEGIN
    BEGIN TRANSACTION JE066

    DELETE FROM ws_wrk_job_thread
    WHERE  wjt_job_key  = @p_job_id
    AND    wjt_thread   = @pi_thread
    AND    wjt_sequence = @pi_sequence
    AND    wjt_sid      = @v_sid
    AND    wjt_serial   = @v_serial

    COMMIT TRANSACTION JE066
  END

  SET @v_step = 25700

  -- If the master job then set the result code to 1 to indicate that the job completed okay
  -- even if it may have failed.
  IF @v_child_job = 0
  BEGIN
    SET @po_result_code = 1
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    --DEALLOCATE any Cursors
    IF CURSOR_STATUS('local','c_Dependency') >= -1
    BEGIN
      DEALLOCATE c_Dependency
    END

    IF CURSOR_STATUS('local','c_TaskRun') >= -1
    BEGIN
      DEALLOCATE c_TaskRun
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @po_result_code = -2

    SET @po_result_msg= @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @v_audit_job_name, @v_audit_task_name ,@pi_sequence,
        @po_result_msg,@v_db_code, @v_db_msg, @v_audit_task_id, @v_audit_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @po_result_msg= @po_result_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@po_result_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @po_result_msg = @po_result_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Rep_Diagram_Build_Source 
CREATE PROCEDURE Ws_Rep_Diagram_Build_Source
  @p_table_name             VARCHAR(1024)
, @p_top_table_name         VARCHAR(1024)
, @p_obj_key                INT
, @p_user_key               INT
, @p_index                  INT
, @p_level                  INT
, @p_max_level              INT
, @p_counter                INT
, @p_index_out              INT OUTPUT
, @p_level_out              INT OUTPUT
, @p_max_level_out          INT OUTPUT
, @p_counter_out            INT OUTPUT
AS

  DECLARE
    @i                        INT
  , @j                        INT
  , @v_local_return           INT
  , @v_return_code            INT
  , @v_found                  INT
  , @v_row_count              INT

  DECLARE
    @v_index                  INT
  , @v_level                  INT
  , @v_max_level              INT
  , @v_counter                INT

  SET @v_index = @p_index
  SET @v_level = @p_level
  SET @v_max_level = @p_max_level
  SET @v_counter = @p_counter

  DECLARE
    @v_tab                    VARCHAR(64)
  , @v_lev                    INT

  DECLARE
    @v_tab_tmp                VARCHAR(64)
  , @v_src_tmp                VARCHAR(1024)
  , @v_lev_tmp                INT
  , @v_rmf_tmp                VARCHAR(1)
  , @v_cnt_tmp                INT
  , @v_slf_tmp                VARCHAR(1)

  DECLARE
    @v_sources_tmp TABLE(tab VARCHAR(64)
                       , src VARCHAR(1024)
                       , lev INT
                       , rmf VARCHAR(1)
                       , cnt INT)

  SET @v_level = @v_level + 1

  IF (@v_level > @v_max_level)
  BEGIN
    SET @v_max_level = @v_level
  END

  SELECT @v_row_count = COUNT(*)
  FROM   ws_rep_v_track_back
  WHERE  rb_table_name = @p_table_name

  IF (@v_row_count > 0)
  BEGIN

    SET @i = 1

    DECLARE c_sources_tmp CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
      SELECT rb_table_name
           , rb_src_table
           , @v_level
           , rb_remote_flag
           , @v_counter
           , CASE WHEN @v_level > 1 AND rb_table_name = @p_top_table_name THEN 'Y' ELSE 'N' END
      FROM   ws_rep_v_track_back
      WHERE  rb_table_name = @p_table_name

    OPEN c_sources_tmp
    FETCH NEXT FROM c_sources_tmp INTO
      @v_tab_tmp
    , @v_src_tmp
    , @v_lev_tmp
    , @v_rmf_tmp
    , @v_cnt_tmp
    , @v_slf_tmp

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_index = @v_index + 1
      SET @v_counter = @v_counter + 1

      INSERT INTO ws_rep_diagram
      ( rd_diagram_type
      , rd_obj_key
      , rd_table_name
      , rd_src_table
      , rd_level_no
      , rd_remote_flag
      , rd_record_no
      , rd_src_loop_flag
      , rd_user_key)
      VALUES
      ( 2
      , @p_obj_key
      , @v_tab_tmp
      , @v_src_tmp
      , @v_lev_tmp
      , @v_rmf_tmp
      , @v_cnt_tmp
      , @v_slf_tmp
      , @p_user_key)

      DECLARE c_sources CURSOR LOCAL FOR
        SELECT   rd_table_name
               , rd_level_no
        FROM     ws_rep_diagram
        WHERE    rd_diagram_type = 2
        AND      rd_obj_key = @p_obj_key
        FOR UPDATE OF rd_level_no

      OPEN c_sources
      FETCH NEXT FROM c_sources INTO
        @v_tab
      , @v_lev

      SET @v_found = 0

      WHILE @@FETCH_STATUS = 0
      BEGIN
        IF (@v_tab = @v_src_tmp) AND (@v_lev <> 1)
        BEGIN
          SET @v_found = 1
          IF (@v_level+1 > @v_lev)
          BEGIN
            UPDATE ws_rep_diagram
            SET    rd_level_no = @v_level+1
            WHERE CURRENT OF c_sources
          END
        END
        FETCH NEXT FROM c_sources INTO
          @v_tab
        , @v_lev
      END

      CLOSE c_sources
      DEALLOCATE c_sources

      IF (@v_found = 0) AND (@v_slf_tmp = 'N')
      BEGIN

        EXEC Ws_Rep_Diagram_Build_Source
              @v_src_tmp
            , @p_top_table_name
            , @p_obj_key
            , @p_user_key
            , @v_index
            , @v_level
            , @v_max_level
            , @v_counter
            , @v_index     OUTPUT
            , @v_level     OUTPUT
            , @v_max_level OUTPUT
            , @v_counter   OUTPUT

      END

      FETCH NEXT FROM c_sources_tmp INTO
        @v_tab_tmp
      , @v_src_tmp
      , @v_lev_tmp
      , @v_rmf_tmp
      , @v_cnt_tmp
      , @v_slf_tmp

      SET @i = @i + 1

    END

    CLOSE c_sources_tmp
    DEALLOCATE c_sources_tmp

  END

  SET @v_level = @v_level - 1

  SET @p_index_out = @v_index
  SET @p_level_out = @v_level
  SET @p_max_level_out = @v_max_level
  SET @p_counter_out = @v_counter
_PROCEDWSL_ Ws_Rep_Diagram_Build 
CREATE PROCEDURE Ws_Rep_Diagram_Build
  @p_top_table_name           VARCHAR(64)
, @p_diagram_type             INT
, @p_user_key                 INT
AS

  IF (@p_diagram_type = 2)
  BEGIN

    DECLARE
      @v_index                  INT
    , @v_level                  INT
    , @v_max_level              INT
    , @v_obj_key                INT
    , @v_counter                INT

    DECLARE
      @v_tab                    VARCHAR(64)
    , @v_src                    VARCHAR(1024)
    , @v_lev                    INT
    , @v_rmf                    VARCHAR(1)
    , @v_cnt                    INT

    SET @v_index = 0
    SET @v_level = 0
    SET @v_max_level = 0
    SET @v_counter = 0

    SELECT @v_obj_key = MAX(oo_obj_key)
    FROM   ws_obj_object
    WHERE  oo_name = @p_top_table_name

    DELETE ws_rep_diagram
    WHERE  rd_diagram_type = 2
    AND    rd_user_key = @p_user_key

    EXEC Ws_Rep_Diagram_Build_Source
          @p_top_table_name
        , @p_top_table_name
        , @v_obj_key
        , @p_user_key
        , @v_index
        , @v_level
        , @v_max_level
        , @v_counter
        , @v_index     OUTPUT
        , @v_level     OUTPUT
        , @v_max_level OUTPUT
        , @v_counter   OUTPUT

    DECLARE c_load CURSOR FAST_FORWARD READ_ONLY FOR
      SELECT rd_table_name
           , rd_src_table
           , rd_level_no
           , rd_remote_flag
           , rd_record_no
      FROM   ws_rep_diagram
      WHERE  rd_diagram_type = 2
      AND    rd_obj_key = @v_obj_key
      AND    rd_remote_flag = 'Y'
      AND    rd_src_loop_flag = 'N'
      AND    rd_user_key = @p_user_key

    OPEN c_load
    FETCH NEXT FROM c_load INTO
      @v_tab
    , @v_src
    , @v_lev
    , @v_rmf
    , @v_cnt

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_lev = @v_max_level
      SET @v_counter = @v_counter + 1

      INSERT INTO ws_rep_diagram
      ( rd_diagram_type
      , rd_obj_key
      , rd_table_name
      , rd_src_table
      , rd_level_no
      , rd_remote_flag
      , rd_record_no
      , rd_src_loop_flag
      , rd_user_key)
      VALUES
      ( 2
      , @v_obj_key
      , @v_src
      , NULL
      , @v_max_level + 1
      , 'S'
      , @v_counter
      , 'N'
      , @p_user_key
      )

      FETCH NEXT FROM c_load INTO
        @v_tab
      , @v_src
      , @v_lev
      , @v_rmf
      , @v_cnt

    END

    CLOSE c_load
    DEALLOCATE c_load

  END
_PROCEDWSL_ Ws_Connect_Replace 
-- Notes / History
--
-- V5.0.0.2 WMR 07/01/2006
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- RS  26/05/2014 Version 6.8.0.1 Changed to reflect new WS_DB_Connect column sizes
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- AD  24/04/2018 Version 8.2.1.0 RED-9385 Fix not updating Database Type in target connection
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Connect_Replace
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_action           varchar(64)
, @p_source           varchar(64)
, @p_target           varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name         : SQL Server
  -- Script Name       : ws_connect_replace
  -- Description       : Copies the contents of one connection to another
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)

  --=====================================================
  -- Source Connection Variables
  --=====================================================
  DECLARE
     @v_ws_pro_version       varchar(50)
  ,  @v_dc_obj_key           integer
  ,  @v_dc_name              varchar(64)
  ,  @v_dc_type              varchar(1)
  ,  @v_dc_method            varchar(64)
  ,  @v_dc_host_id           varchar(64)
  ,  @v_dc_dblink_id         varchar(1024)
  ,  @v_dc_database_id       varchar(1024)
  ,  @v_dc_odbc_source       varchar(64)
  ,  @v_dc_extract_userid    varchar(1024)
  ,  @v_dc_extract_pwd       varchar(1024)
  ,  @v_dc_admin_userid      varchar(1024)
  ,  @v_dc_admin_pwd         varchar(1024)
  ,  @v_dc_work_dir          varchar(256)
  ,  @v_dc_database_home     varchar(256)
  ,  @v_dc_pre_login_act     varchar(64)
  ,  @v_dc_login_prompt      varchar(64)
  ,  @v_dc_password_prompt   varchar(64)
  ,  @v_dc_post_login_act    varchar(64)
  ,  @v_dc_command_prompt    varchar(64)
  ,  @v_dc_telnet_attributes varchar(4000)
  ,  @v_dc_attributes        varchar(4000)
  ,  @v_dc_connect_string    varchar(4000)
  ,  @v_dc_server            varchar(4000)
  ,  @v_dc_doc_1             varchar(4000)
  ,  @v_dc_doc_2             varchar(4000)
  ,  @v_dc_doc_3             varchar(4000)
  ,  @v_dc_doc_4             varchar(4000)
  ,  @v_dc_doc_5             varchar(4000)
  ,  @v_dc_doc_6             varchar(4000)
  ,  @v_dc_doc_7             varchar(4000)
  ,  @v_dc_doc_8             varchar(4000)
  ,  @v_dc_doc_9             varchar(4000)
  ,  @v_dc_doc_10            varchar(4000)
  ,  @v_dc_doc_11            varchar(4000)
  ,  @v_dc_doc_12            varchar(4000)
  ,  @v_dc_doc_13            varchar(4000)
  ,  @v_dc_doc_14            varchar(4000)
  ,  @v_dc_doc_15            varchar(4000)
  ,  @v_dc_doc_16            varchar(4000)
  ,  @v_dc_wizard_set_key    integer
  ,  @v_dc_db_type_ind       integer
  ,  @v_dc_authentication    varchar(4000)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version      = 'Ws_Connect_Replace(8.4.1.0)'
  SET @v_step = 100


  BEGIN TRY
  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  IF UPPER(@p_action) = 'REPLACE'
  BEGIN
    SELECT @v_count = 1
  END
  ELSE
  BEGIN
    SET @p_return_code = 'E'
    SET @p_return_msg = 'Invalid action code in Ws_Connect_Replace. Valid action is Replace.'
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name ,@p_sequence,
      @p_return_msg,@v_db_code, @v_db_msg,@p_task_id, @p_job_id
    SET @p_result = -2
    RETURN 0;
  END

  --***********************************************************************
  -- Get the info for the source connect
  --***********************************************************************
  SET @v_step = 200

  SELECT
     @v_dc_obj_key = dc_obj_key
  ,  @v_dc_type = dc_type
  ,  @v_dc_method = dc_method
  ,  @v_dc_host_id = dc_host_id
  ,  @v_dc_dblink_id = dc_dblink_id
  ,  @v_dc_database_id = dc_database_id
  ,  @v_dc_odbc_source = dc_odbc_source
  ,  @v_dc_extract_userid = dc_extract_userid
  ,  @v_dc_extract_pwd = dc_extract_pwd
  ,  @v_dc_admin_userid = dc_admin_userid
  ,  @v_dc_admin_pwd = dc_admin_pwd
  ,  @v_dc_work_dir = dc_work_dir
  ,  @v_dc_database_home = dc_database_home
  ,  @v_dc_pre_login_act = dc_pre_login_act
  ,  @v_dc_login_prompt = dc_login_prompt
  ,  @v_dc_password_prompt = dc_password_prompt
  ,  @v_dc_post_login_act = dc_post_login_act
  ,  @v_dc_command_prompt = dc_command_prompt
  ,  @v_dc_telnet_attributes = CONVERT(varchar(4000),dc_telnet_attributes)
  ,  @v_dc_attributes = CONVERT(varchar(4000),dc_attributes)
  ,  @v_dc_connect_string = CONVERT(varchar(4000),dc_connect_string)
  ,  @v_dc_server = CONVERT(varchar(4000),dc_server)
  ,  @v_dc_doc_1 = CONVERT(varchar(4000),dc_doc_1)
  ,  @v_dc_doc_2 = CONVERT(varchar(4000),dc_doc_2)
  ,  @v_dc_doc_3 = CONVERT(varchar(4000),dc_doc_3)
  ,  @v_dc_doc_4 = CONVERT(varchar(4000),dc_doc_4)
  ,  @v_dc_doc_5 = CONVERT(varchar(4000),dc_doc_5)
  ,  @v_dc_doc_6 = CONVERT(varchar(4000),dc_doc_6)
  ,  @v_dc_doc_7 = CONVERT(varchar(4000),dc_doc_7)
  ,  @v_dc_doc_8 = CONVERT(varchar(4000),dc_doc_8)
  ,  @v_dc_doc_9 = CONVERT(varchar(4000),dc_doc_9)
  ,  @v_dc_doc_10 = CONVERT(varchar(4000),dc_doc_10)
  ,  @v_dc_doc_11 = CONVERT(varchar(4000),dc_doc_11)
  ,  @v_dc_doc_12 = CONVERT(varchar(4000),dc_doc_12)
  ,  @v_dc_doc_13 = CONVERT(varchar(4000),dc_doc_13)
  ,  @v_dc_doc_14 = CONVERT(varchar(4000),dc_doc_14)
  ,  @v_dc_doc_15 = CONVERT(varchar(4000),dc_doc_15)
  ,  @v_dc_doc_16 = CONVERT(varchar(4000),dc_doc_16)
  ,  @v_dc_wizard_set_key = dc_wizard_set_key
  ,  @v_dc_db_type_ind = dc_db_type_ind
  ,  @v_dc_authentication = CONVERT(varchar(4000),dc_authentication)
  FROM
    ws_dbc_connect
  WHERE
    UPPER(dc_name) = UPPER(@p_source)

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_dc_obj_key <= 0
  BEGIN
    SET @p_return_code = 'E'
    SET @p_return_msg = 'Failed to find source connection ' + @p_source
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name ,@p_sequence,
      @p_return_msg,@v_db_code, @v_db_msg,@p_task_id, @p_job_id
    SET @p_result = -2
    RETURN 0;
  END

  --***********************************************************************
  -- Update the target connection
  --***********************************************************************
  SET @v_step = 300
  UPDATE ws_dbc_connect
  SET
    dc_type = @v_dc_type
  , dc_method = @v_dc_method
  , dc_host_id = @v_dc_host_id
  , dc_dblink_id = @v_dc_dblink_id
  , dc_database_id = @v_dc_database_id
  , dc_odbc_source = @v_dc_odbc_source
  , dc_extract_userid = @v_dc_extract_userid
  , dc_extract_pwd = @v_dc_extract_pwd
  , dc_admin_userid = @v_dc_admin_userid
  , dc_admin_pwd = @v_dc_admin_pwd
  , dc_work_dir = @v_dc_work_dir
  , dc_database_home = @v_dc_database_home
  , dc_pre_login_act = @v_dc_pre_login_act
  , dc_login_prompt = @v_dc_login_prompt
  , dc_password_prompt = @v_dc_password_prompt
  , dc_post_login_act = @v_dc_post_login_act
  , dc_command_prompt = @v_dc_command_prompt
  , dc_telnet_attributes = @v_dc_telnet_attributes
  , dc_attributes = @v_dc_attributes
  , dc_connect_string = @v_dc_connect_string
  , dc_server = @v_dc_server
  , dc_doc_1 = @v_dc_doc_1
  , dc_doc_2 = @v_dc_doc_2
  , dc_doc_3 = @v_dc_doc_3
  , dc_doc_4 = @v_dc_doc_4
  , dc_doc_5 = @v_dc_doc_5
  , dc_doc_6 = @v_dc_doc_6
  , dc_doc_7 = @v_dc_doc_7
  , dc_doc_8 = @v_dc_doc_8
  , dc_doc_9 = @v_dc_doc_9
  , dc_doc_10 = @v_dc_doc_10
  , dc_doc_11 = @v_dc_doc_11
  , dc_doc_12 = @v_dc_doc_12
  , dc_doc_13 = @v_dc_doc_13
  , dc_doc_14 = @v_dc_doc_14
  , dc_doc_15 = @v_dc_doc_15
  , dc_doc_16 = @v_dc_doc_16
  , dc_wizard_set_key = @v_dc_wizard_set_key
  , dc_db_type_ind = @v_dc_db_type_ind
  , dc_authentication = @v_dc_authentication
  WHERE
    UPPER(dc_name) = UPPER(@p_target)

  SELECT @v_row_count     = @@ROWCOUNT

  IF @v_row_count <> 1
  BEGIN
    SET @p_return_msg = 'Failure to update target connection ' + @p_source + '. Connection not found'
    EXEC WsWrkAudit 'E', @p_job_name, @p_task_name ,@p_sequence,
      @p_return_msg,NULL,NULL,@p_task_id, @p_job_id
    SET @p_result = -2
    SET @p_return_code = 'E'
    RETURN 0;
  END

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Connection information for ' + @p_target + ' replaced from '+ @p_source
  EXEC WsWrkAudit 'I', @p_job_name, @p_task_name ,@p_sequence,
    @p_return_msg,NULL,NULL,@p_task_id, @p_job_id

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_return_code = 'E'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Clear_Logs_By_Date 
-- Notes / History
--
-- WMR 13/03/2006 Version 4.0.1.4
-- NRB 24/07/2007 Version 5.6.1.1 Modified to include archiving records from audit
--                                and error tables that have no entry in job log.
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- FS  28/07/2017 Version 8.0.1.0 RED-8144 reduced scope of TRANSACTION to avoid deadlock
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Clear_Logs_By_Date
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_job_to_clean     varchar(64)
, @p_day_count        integer
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	ws_job_clear_logs_by_date
  -- Description 	:	Deletes and archives old job logs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_job_sequence    integer
  , @v_job_key         integer
  , @v_job_count       integer
  , @v_del_count       integer
  , @v_job_status      varchar(1)
  , @v_delete_date     datetime      -- delete date
  , @v_lock_result     integer       -- Result of attempt to secure lock
  , @v_wait            char(12)      -- work field to determine wait period

  SET @v_ws_pro_version           = 'Ws_Job_Clear_Logs_By_Date(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_job_count = 0
  SET @v_del_count = 0

  SET @v_msgtext = 'Ws_Job_Clear_Logs_By_Date: '
  + ' job to clean ' + @p_job_to_clean
  + ' day count ' + CONVERT(VARCHAR,@p_day_count)

  EXEC @v_result = WsWrkAudit 'I',@p_job_name, @p_task_name, @p_sequence,
                              @v_msgtext, NULL, NULL, @p_task_id, @p_job_id

-- If zero specified in logs to keep then return
  IF @p_day_count < 0
  BEGIN
    SET @p_return_code = 'W'
    SET @p_return_msg = 'Job '+ @p_job_to_clean +' negative value passed in days to keep count. No action.'
    SET @p_result = 1
    RETURN 0
  END

  -- set delete date
  SELECT @v_delete_date = getdate() - @p_day_count;

  --***********************************************************************
  -- Loop through all the logs and archive. Skipp the first n logs
  --***********************************************************************
  DECLARE c_Logs CURSOR READ_ONLY FOR
    SELECT wjl_job_key, wjl_sequence
    FROM ws_wrk_job_log
    WHERE wjl_name like @p_job_to_clean
    AND wjl_completed < @v_delete_date

  OPEN c_Logs
  FETCH NEXT FROM c_Logs  INTO
    @v_job_key
  , @v_job_sequence

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 200
    SELECT @v_job_count = @v_job_count + 1

    BEGIN TRANSACTION JE001

      SET @v_lock_result = -1
      WHILE @v_lock_result < 0
      BEGIN

        EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_LOG',
                                            @LockMode = 'Update',
                                             @LockTimeout = 0
        IF @v_lock_result < 0
        BEGIN
          SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
          WAITFOR DELAY @v_wait
        END

      END

      SET @v_step = 300

      -- Have a log to delete so move the tasks, job, audit and error info

      SET @v_step = 400
      -- Copy the audit info to archive
      INSERT INTO wx_wrk_audit_archive (
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
      SELECT
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
      FROM
        ws_wrk_audit_log
      WHERE wa_job_key = @v_job_key
      AND   wa_sequence = @v_job_sequence

      SELECT @v_row_count = @@ROWCOUNT

      SET @v_step = 500
      -- Delete the audit info
      DELETE FROM ws_wrk_audit_log
      WHERE wa_job_key = @v_job_key
      AND   wa_sequence = @v_job_sequence

      SET @v_step = 600
      -- Copy the detail info to archive
      INSERT INTO wx_wrk_error_archive (
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action )
      SELECT
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action
      FROM
        ws_wrk_error_log
      WHERE wd_job_key = @v_job_key
      AND   wd_sequence = @v_job_sequence

      SELECT @v_row_count = @@ROWCOUNT

      SELECT @v_del_count = @v_del_count + 1

      SET @v_step = 700
      -- Delete the detail info
      DELETE FROM ws_wrk_error_log
      WHERE wd_job_key = @v_job_key
      AND   wd_sequence = @v_job_sequence

      SET @v_step = 800
      -- Delete the task log
      DELETE FROM ws_wrk_task_log
      WHERE wtl_job_key = @v_job_key
      AND   wtl_sequence = @v_job_sequence

      SET @v_step = 900
      -- Delete the job log
      DELETE FROM ws_wrk_job_log
      WHERE wjl_job_key = @v_job_key
      AND   wjl_sequence = @v_job_sequence

    COMMIT TRANSACTION JE001

    FETCH NEXT FROM c_Logs  INTO
      @v_job_key
    , @v_job_sequence

  END

  CLOSE c_Logs
  DEALLOCATE c_Logs

  --***********************************************************************
  -- Archive Detail and audit info for records with no parent in job log
  --***********************************************************************
  SET @v_step = 1000
  -- Copy the audit info to archive
  INSERT INTO wx_wrk_audit_archive (
    wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
    wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
  SELECT
    wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
    wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
  FROM
    ws_wrk_audit_log
  WHERE wa_time_stamp < @v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_audit_log.wa_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_audit_log.wa_sequence = ws_wrk_job_log.wjl_sequence);


  SET @v_step = 1100
  -- Delete the audit info
  DELETE FROM ws_wrk_audit_log
  WHERE wa_time_stamp < @v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_audit_log.wa_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_audit_log.wa_sequence = ws_wrk_job_log.wjl_sequence);

  SET @v_step = 1200
  -- Copy the detail info to archive
  INSERT INTO wx_wrk_error_archive (
    wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
    wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
    wd_severity, wd_action )
  SELECT
    wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
    wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
    wd_severity, wd_action
  FROM
    ws_wrk_error_log
  WHERE wd_time_stamp < @v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_error_log.wd_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_error_log.wd_sequence = ws_wrk_job_log.wjl_sequence);

  SET @v_step = 1300
  -- Delete the detail info
  DELETE FROM ws_wrk_error_log
  WHERE wd_time_stamp < @v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_error_log.wd_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_error_log.wd_sequence = ws_wrk_job_log.wjl_sequence);


  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_job_to_clean+' had '+
                     CONVERT(VARCHAR,ISNULL(@v_del_count,0))  + ' logs removed. '
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Logs') >= -1
    BEGIN
      DEALLOCATE c_Logs
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Dependency 
-- Notes / History
--
-- WMR 02/11/2006 Version 5.5.0.6
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Dependency
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_action           varchar(64)
, @p_parent           varchar(64)
, @p_child            varchar(64)
, @p_required         varchar(1)
, @p_look_back        integer
, @p_max_wait         integer
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      : SQL Server
  -- Script Name    : Ws_Job_Dependency
  -- Description    : Maintain job dependencies
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_MsgText         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_stmt            varchar(256)
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_msg             varchar(4000)
  , @v_action          integer
  , @v_existing        integer

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

 SET @v_ws_pro_version           = 'Ws_Job_Dependency(8.4.1.0)'
 SET @v_step = 100

  BEGIN TRY

 SELECT
    @v_result          = 0  -- return code
  , @v_action          = 0
  , @v_existing        = 0


  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  SELECT @v_step = 200
  IF UPPER(@p_action) = 'ADD'
    BEGIN
    SET @v_action = 1
    END
  ELSE
    BEGIN
    IF UPPER(@p_action) = 'DELETE'
       BEGIN
       SET @v_action = 2
       END
    ELSE
       BEGIN
       SET @p_return_code = 'E'
       SET @p_return_msg = 'Invalid action code. Valid actions are ADD and DELETE.'
       EXEC WsWrkAudit 'W', @p_job_name, @p_job_name, @p_sequence,
           @p_return_msg,SQLCODE,SQLERRM, @p_task_id, @p_job_id

       SET @p_result = -2
       RETURN 0
       END
    END

  --***********************************************************************
  -- Check to see if the entry is present
  --***********************************************************************
  SELECT @v_step = 300

  SET @v_existing = 0

  SELECT @v_existing = COUNT(*)
  FROM   ws_wrk_job_dependency
  WHERE  wjd_parent_job_name = @p_parent
  AND    wjd_child_job_name = @p_child

  SELECT @v_row_count     = @@ROWCOUNT

  --***********************************************************************
  -- If an Add then add a new record if not already present
  --***********************************************************************
  SELECT @v_step = 400
  IF @v_action = 1
  BEGIN
    IF @v_existing = 1
    BEGIN
      SET @p_return_code = 'W'
      SET @p_return_msg = 'Job Dependency already exists. Can not add.'
      EXEC WsWrkAudit 'W', @p_job_name, @p_job_name, @p_sequence,
          @p_return_msg,NULL,NULL, @p_task_id, @p_job_id

      SET @p_result = -1
      RETURN 0
    END

    SET @v_step = 500
    INSERT INTO ws_wrk_job_dependency(
      wjd_parent_job_name
    , wjd_child_job_name
    , wjd_first_check_lag
    , wjd_wait_interval
    , wjd_require_parent )
    VALUES (
      @p_parent
    , @p_child
    , @p_look_back
    , @p_max_wait
    , @p_required )

    SELECT @v_row_count     = @@ROWCOUNT

  END -- action 1

  --***********************************************************************
  -- If a Delete then delete the record if present
  --***********************************************************************

  SELECT @v_step = 600
  IF @v_action = 2
  BEGIN
    IF @v_existing = 0
    BEGIN
      SET @p_return_code = 'W'
      SET @p_return_msg = 'Job Dependency does not exist. Can not delete.'
      EXEC WsWrkAudit 'W', @p_job_name, @p_job_name, @p_sequence,
          @p_return_msg,NULL,NULL, @p_task_id, @p_job_id

      SET @p_result = -1
      RETURN 0
    END

    SET @v_step = 700

    DELETE FROM ws_wrk_job_dependency
    WHERE wjd_parent_job_name = @p_parent
    AND   wjd_child_job_name = @p_child

    SELECT @v_row_count     = @@ROWCOUNT

  END -- action 2

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job ' + @p_child + ' dependent on Job ' + @p_parent + ' ' + @p_action + 'ed'
  EXEC WsWrkAudit 'I', @p_job_name, @p_job_name, @p_sequence,
    @p_return_msg,NULL,NULL, @p_task_id, @p_job_id

  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_CreateWait 
-- Notes / History
--
-- WMR 01/11/2006 Version 5.5.0.6
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- KH  1/11/2018  Version 8.3.1.0 RED-9838 wtc_action_ind added to task copy row.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_CreateWait
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_template_job     varchar(64)
, @p_new_job          varchar(64)
, @p_description      varchar(256)
, @p_state            varchar(64)
, @p_release_time     datetime
, @p_threads          integer
, @p_scheduler        varchar(64)
, @p_logs             integer
, @p_okay             varchar(256)
, @p_fail             varchar(256)
, @p_att1             varchar(64)
, @p_att2             varchar(64)
, @p_att3             varchar(64)
, @p_att4             varchar(64)
, @p_att5             varchar(64)
, @p_att6             varchar(64)
, @p_att7             varchar(64)
, @p_att8             varchar(64)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	Ws_Job_CreateWait
  -- Description 	:	Creates a new job at a scheduled time
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version  varchar(50)
  , @v_msgtext         varchar(1024) -- Text in audit_trail
  , @v_step            integer       -- return code
  , @v_result          integer       -- return code
  , @v_row_count       integer
  , @v_db_code         varchar(10)   -- Database error code
  , @v_db_msg          varchar(1024) -- Database error message
  , @v_stmt            nvarchar(256)
  , @v_count           integer
  , @v_part_count      integer
  , @v_specific_index  integer
  , @v_specific_part   integer
  , @v_status          integer
  , @v_status_code     integer
  , @v_msg             varchar(4000)
  , @v_old_sequence    integer
  , @v_old_key         integer
  , @v_old_status      varchar(1)
  , @v_new_sequence    integer
  , @v_new_key         integer
  , @v_wjc_status      varchar(1)
  , @v_wjc_type        varchar(1)
  , @v_lock_result     integer
  , @v_wait            char(12)

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET @v_ws_pro_version           = 'Ws_Job_CreateWait(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  SELECT
    @v_old_key =  wjc_job_key
  , @v_old_sequence = wjc_sequence
  , @v_old_status = wjc_status
  FROM ws_wrk_job_ctrl
  WHERE rtrim(upper(wjc_name)) = rtrim(upper(@p_template_job))

  SELECT @v_row_count     = @@ROWCOUNT

  SET @v_step = 200

  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF ISNULL(@v_old_key,0) = 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_template_job
                      +' is not in a holding or waiting state. Cannot create new job'
    SET @p_return_code = 'N'
    SET @p_result = -1
    RETURN 0
  END

  SET @v_step = 300

  --***********************************************************************
  -- Make sure we have no job that matches our new job name
  --***********************************************************************
  SET @v_count = 0
  BEGIN
    SELECT @v_count = COUNT(*)
    FROM ws_wrk_job_ctrl
    WHERE rtrim(upper(wjc_name)) = rtrim(upper(@p_new_job))
  END;

  IF @v_count > 0
  BEGIN
    SET @p_return_msg = 'Job '+ @p_new_job
                      +' already exists. Cannot create a new job of the same name'
    SET @p_return_code = 'P'
    SET @p_result = -1
    RETURN 0
  END

  SET @v_step = 400
  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************

  --***********************************************************************
  -- Get the right state for the new job and the sequence
  --***********************************************************************
  SET @v_wjc_status = 'H'
  SET @v_wjc_type = 'H'

  IF rtrim(upper(@p_state)) = 'ONCE'
  BEGIN
    SET @v_wjc_status = 'W'
    SET @v_wjc_type = 'O'
  END
  IF rtrim(upper(@p_state)) = 'ONCE+HOLD'
  BEGIN
    SET @v_wjc_status = 'W'
    SET @v_wjc_type = 'S'
  END

  SET @v_step = 600

  INSERT INTO ws_wrk_sequence(ws_date)
  VALUES (GETDATE())

  SELECT @v_new_sequence = SCOPE_IDENTITY()

  BEGIN TRANSACTION

    SET @v_step = 500
    SET @v_lock_result = -1
    WHILE @v_lock_result < 0
    BEGIN

      EXEC @v_lock_result = sp_getapplock @Resource = 'JOB_CONTROL',
                                          @LockMode = 'Update',
                                          @LockTimeout = 0

      IF @v_lock_result < 0
      BEGIN
        SET @v_wait =  '00:00:00.' + CAST((DATEPART(ms, GETDATE())) AS VARCHAR)
        WAITFOR DELAY @v_wait
      END

    END

    SET @v_step = 700

    --***********************************************************************
    -- Add the new job in a held state, so that we can add the tasks/dependencies
    --***********************************************************************
    INSERT into ws_wrk_job_ctrl
    (
      wjc_job_key
    , wjc_name
    , wjc_description
    , wjc_sequence
    , wjc_group_key
    , wjc_project_key
    , wjc_status
    , wjc_last_status
    , wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , wjc_start_after
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , wjc_avg_count
    , wjc_publish_okay
    , wjc_publish_fail
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , wjc_max_threads
    , wjc_priority
    , wjc_publish_flag
    , wjc_scheduler
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    )
    SELECT
      @v_new_sequence
    , @p_new_job
    , ISNULL(@p_description,wjc_description)
    , @v_new_sequence
    , wjc_group_key
    , wjc_project_key
    , 'H'
    , wjc_last_status
    , @v_wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , @p_release_time
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , ISNULL(@p_logs,wjc_avg_count)
    , ISNULL(@p_okay,wjc_publish_okay)
    , ISNULL(@p_fail,wjc_publish_fail)
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , ISNULL(@p_threads,wjc_max_threads)
    , wjc_priority
    , wjc_publish_flag
    , ISNULL(@p_scheduler,wjc_scheduler)
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    FROM ws_wrk_job_ctrl
    WHERE wjc_job_key = @v_old_key
    AND wjc_status in ('H','W')

    --***********************************************************************
    -- Add all the tasks
    --***********************************************************************
    SET @v_step = 800

    INSERT into ws_wrk_task_ctrl
    (
      wtc_job_key
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , wtc_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , wtc_action_ind
    )
    SELECT
      @v_new_sequence
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , @v_new_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , COALESCE(wtc_action_ind,'')
    FROM  ws_wrk_task_ctrl
    WHERE wtc_job_key = @v_old_key

    --***********************************************************************
    -- Add all the dependencies
    --***********************************************************************
    SET @v_step = 900

    INSERT into ws_wrk_dependency
    (
      wdp_job_key
    , wdp_parent_task_key
    , wdp_child_task_key
    )
    SELECT
      @v_new_sequence,
      b_new.wtc_task_key,
      c_new.wtc_task_key
    FROM
      ws_wrk_dependency a,
      ws_wrk_task_ctrl b_old,
      ws_wrk_task_ctrl c_old,
      ws_wrk_task_ctrl b_new,
      ws_wrk_task_ctrl c_new
    WHERE a.wdp_job_key = @v_old_key
    AND b_new.wtc_job_key = @v_new_sequence
    AND c_new.wtc_job_key = @v_new_sequence
    AND a.wdp_parent_task_key = b_old.wtc_task_key
    AND a.wdp_child_task_key = c_old.wtc_task_key
    AND b_old.wtc_order = b_new.wtc_order
    AND c_old.wtc_order = c_new.wtc_order

    --***********************************************************************
    -- Set the job to the request state
    --***********************************************************************
    SET @v_step = 1000

    UPDATE ws_wrk_job_ctrl
    SET wjc_status = @v_wjc_status
    WHERE wjc_job_key = @v_new_sequence
    AND wjc_sequence = @v_new_sequence

  SET @v_step = 1100

  COMMIT


  SET @p_return_code = 'S'
  SET @p_return_msg = 'Job '+@p_new_job+' created.'
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Version_Clear 
-- Notes / History
--
-- NRB 27/06/2007 Version 5.6.0.9 Original Version
-- AP  30/08/2007 Version 5.6.1.1 Delete based on obj name not key, as indexes etc get new key
--                                when regenerate
-- AP  10/06/2008 Version 6.0.4.1 Version  Changes to workflow locking.and 2005+ TRY
-- JML 30/03/2010 Version 6.1.0.1 Changes to write to wx...archive tables before deleting for:
--                                - ws_obj_object
--                                - ws_pro_header_v
--                                - ws_pro_line_v
--                                - ws_scr_header_v
--                                - ws_scr_line_v
-- AP  23/08/2010 Version 6.5.0.1 RED-1754 Correct bugs for case sensitive DB's introduced by above change
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  10/06/2016 Version 6.8.6.1 Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Version_Clear
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_day_count        integer
, @p_keep_count       integer
, @p_options          varchar(256)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            :     SQL Server
  -- Script Name          :     Ws_Version_Clear
  -- Description          :     Deletes old version records
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE
    @v_ws_pro_version           varchar(50)
  , @v_ws_obj_procedure         integer
  , @v_ws_obj_fact_kpi          integer
  , @v_ws_obj_script            integer
  , @v_ws_obj_template          integer
  , @v_ws_obj_fact              integer
  , @v_ws_obj_dim               integer
  , @v_ws_obj_stage             integer
  , @v_ws_obj_load              integer
  , @v_ws_obj_agg               integer
  , @v_ws_obj_index             integer
  , @v_ws_obj_connect           integer
  , @v_ws_obj_dim_view          integer
  , @v_ws_obj_export            integer
  , @v_ws_obj_cube              integer
  , @v_ws_obj_cube_virtual      integer
  , @v_ws_obj_report            integer
  , @v_ws_obj_view              integer
  , @v_ws_obj_file              integer
  , @v_ws_obj_join              integer
  , @v_ws_obj_retro             integer
  , @v_ws_obj_retro_copy        integer
  , @v_ws_obj_olap_cube         integer
  , @v_ws_obj_olap_dim          integer
  , @v_ws_obj_olap_role         integer
  , @v_ws_obj_ods               integer
  , @v_ws_obj_normal            integer
  , @v_ws_obj_hub               integer
  , @v_ws_obj_satellite         integer
  , @v_ws_obj_link              integer
  , @v_ws_obj_custom1           integer
  , @v_ws_obj_custom2           integer
  , @v_ws_obj_max               integer

  , @v_ws_obj_job               integer
  , @v_ws_act_drop              integer
  , @v_ws_act_create            integer
  , @v_ws_act_drop_all          integer
  , @v_ws_act_pre_drop          integer
  , @v_ws_act_load              integer
  , @v_ws_act_update            integer
  , @v_ws_act_execute           integer
  , @v_ws_act_process           integer
  , @v_ws_act_build             integer
  , @v_ws_act_build_all         integer
  , @v_ws_act_analyze           integer
  , @v_ws_act_quick_analyze     integer
  , @v_ws_act_statistics        integer
  , @v_ws_act_quick_statistics  integer
  , @v_ws_act_initial           integer
  , @v_ws_act_cube_dim          integer
  , @v_ws_act_db_dim            integer
  , @v_ws_act_custom            integer
  , @v_ws_act_truncate          integer

  --=====================================================
  -- Constants Initialized
  --=====================================================
  SELECT
    @v_ws_pro_version           = '(8.4.1.0)'
  , @v_ws_obj_procedure         = 1
  , @v_ws_obj_fact_kpi          = 2
  , @v_ws_obj_script            = 3
  , @v_ws_obj_template          = 4
  , @v_ws_obj_fact              = 5
  , @v_ws_obj_dim               = 6
  , @v_ws_obj_stage             = 7
  , @v_ws_obj_load              = 8
  , @v_ws_obj_agg               = 9
  , @v_ws_obj_index             = 10
  , @v_ws_obj_connect           = 11
  , @v_ws_obj_dim_view          = 12
  , @v_ws_obj_export            = 13
  , @v_ws_obj_cube              = 15
  , @v_ws_obj_cube_virtual      = 16
  , @v_ws_obj_report            = 17
  , @v_ws_obj_view              = 18
  , @v_ws_obj_file              = 19
  , @v_ws_obj_join              = 20
  , @v_ws_obj_retro             = 21
  , @v_ws_obj_retro_copy        = 22
  , @v_ws_obj_olap_cube         = 23
  , @v_ws_obj_olap_dim          = 24
  , @v_ws_obj_olap_role         = 25
  , @v_ws_obj_ods               = 26
  , @v_ws_obj_normal            = 27
  , @v_ws_obj_hub               = 28
  , @v_ws_obj_satellite         = 29
  , @v_ws_obj_link              = 30
  , @v_ws_obj_custom1           = 31
  , @v_ws_obj_custom2           = 32
  , @v_ws_obj_max               = 32

  , @v_ws_obj_job               = 50
  , @v_ws_act_drop              = 1
  , @v_ws_act_create            = 2
  , @v_ws_act_drop_all          = 3
  , @v_ws_act_pre_drop          = 4
  , @v_ws_act_load              = 5
  , @v_ws_act_update            = 6
  , @v_ws_act_execute           = 7
  , @v_ws_act_process           = 8
  , @v_ws_act_build             = 9
  , @v_ws_act_build_all         = 10
  , @v_ws_act_analyze           = 11
  , @v_ws_act_quick_analyze     = 12
  , @v_ws_act_statistics        = 13
  , @v_ws_act_quick_statistics  = 14
  , @v_ws_act_initial           = 15
  , @v_ws_act_cube_dim          = 16
  , @v_ws_act_db_dim            = 17
  , @v_ws_act_custom            = 18
  , @v_ws_act_truncate          = 19

  --===============================================================
  -- Control variables used in most programs
  --===============================================================
  DECLARE
    @v_msgtext               varchar(1024) -- Text for audit_trail
  , @v_step                  integer       -- return code
  , @v_version_delete_count  integer       -- no of records deleted
  , @v_version_insert_count  integer       -- no of records inserted
  , @v_delete_count          integer       -- no of records deleted
  , @v_insert_count          integer       -- no of records inserted
  , @v_count                 integer       -- General counter
  , @v_row_count             integer       -- Query returned row count
  , @v_db_code               varchar(10)   -- Database error code
  , @v_db_msg                varchar(1024) -- Database error message

  --=====================================================
  -- General Variables
  --=====================================================
  DECLARE
    @v_version_no            integer       -- Version no
  , @v_obj_key               integer       -- Object key
  , @v_obj_name              varchar(100)  -- Object name
  , @v_creation_date         datetime      -- creation date for record
  , @v_retain_till_date      datetime      -- retain date
  , @v_table_name            varchar(100)  -- table name
  , @v_column_name           varchar(100)  -- column name
  , @v_delete_date           datetime      -- delete date
  , @v_prev_obj_name         varchar(100)  -- previous Object name
  , @v_process_flag          bit           -- identifies if record can be processed
  , @v_delete_sql            nvarchar(500) -- delete sql statement
  , @v_insert_sql            nvarchar(500) -- insert sql statement

  --===============================================================
  -- Main
  --===============================================================

  BEGIN TRY

  SET @v_step = 100

  SET @v_delete_count = 0
  SET @v_insert_count = 0
  SET @v_version_delete_count = 0
  SET @v_version_insert_count = 0
  SET @v_prev_obj_name = '_'
  SET @v_count = 0
  SET @v_process_flag = 0

  --===============================================================
  -- check to see if need to delete based on datetime
  --===============================================================
  IF @p_day_count >= 0
  BEGIN
    SELECT @v_delete_date = getdate() - @p_day_count

    -- log min date to keep records
    SET @p_return_msg = 'Delete Date: ' + CONVERT(varchar, @v_delete_date)
    EXEC WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
             @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
  END
  ELSE
  BEGIN
    SELECT @v_delete_date = getdate()
  END

  --===============================================================
  -- check to see if need to keep minimum number of versioned records
  --===============================================================
  IF @p_keep_count > 0
  BEGIN
    -- log min versions to keep
    SET @p_return_msg = 'Versions to Keep: ' + CONVERT(varchar, @p_keep_count)
    EXEC WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
             @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
  END

  SET @v_step = 200
  --===============================================================
  -- Cursor to get Version records for deletion
  --===============================================================
  DECLARE c_Versions CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
    SELECT
      ov_version_no
    , ov_obj_key
    , ov_obj_name
    , ov_creation_date
    , ov_retain_till_date
    FROM
      ws_obj_versions
    ORDER BY ov_obj_name
           , ov_creation_date desc

  OPEN c_Versions
  FETCH NEXT FROM c_Versions INTO
    @v_version_no
  , @v_obj_key
  , @v_obj_name
  , @v_creation_date
  , @v_retain_till_date

  BEGIN TRANSACTION

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SET @v_step = 300
    --===============================================================
    -- check to see if object key has changed & reset counter
    --===============================================================
    IF @v_prev_obj_name <> @v_obj_name
    BEGIN
      SET @v_prev_obj_name = @v_obj_name
      SET @v_count = 0
      SET @v_process_flag = 0
    END

    -- increment counter for object key
    SELECT @v_count = @v_count + 1

    --==============================================================
    -- reset flag if deleting based on retain date, as
    -- need to check each individual record
    --==============================================================
    IF @p_day_count < 0
    BEGIN
      SET @v_process_flag = 0
    END

    --==============================================================
    -- check to see if versioned record can be deleted.
    --==============================================================
    IF @v_process_flag = 0
    BEGIN
      -- check to see if min versions to keep has been passed
      IF @v_count > @p_keep_count
      BEGIN

        -- check to see if deleting records old enough
        IF @p_day_count >= 0
        BEGIN
          IF @v_delete_date >= @v_creation_date
          BEGIN
            SET @v_process_flag = 1
          END
        END
        ELSE
        BEGIN
          IF @v_delete_date >= @v_retain_till_date
          BEGIN
            SET @v_process_flag = 1
          END
        END

      END -- end check for min versions to keep
    END  -- Process

    SET @v_step = 400
    --===============================================================
    -- If flag set, delete version record
    --===============================================================
    IF @v_process_flag = 1
    BEGIN
      --===============================================================
      -- Delete rows from ws_obj_versions
      --===============================================================
      SET @v_step = 500

      INSERT
      INTO   wx_obj_versions_archive
      SELECT *
      FROM   ws_obj_versions
      WHERE  ov_version_no = @v_version_no

      SET @v_version_insert_count = @v_version_insert_count + 1

      --===============================================================
      -- Delete rows from ws_obj_versions
      --===============================================================
      SET @v_step = 600

      DELETE FROM ws_obj_versions
      WHERE ov_version_no = @v_version_no

      SET @v_version_delete_count = @v_version_delete_count + 1

      --===============================================================
      -- Commit after every 500
      --===============================================================
      IF @v_version_delete_count%500 = 0
      BEGIN
        COMMIT
        BEGIN TRANSACTION
      END

    END -- end process flag

    FETCH NEXT FROM c_Versions  INTO
      @v_version_no
    , @v_obj_key
    , @v_obj_name
    , @v_creation_date
    , @v_retain_till_date

  END

  CLOSE c_Versions
  DEALLOCATE c_Versions

  COMMIT

  BEGIN TRANSACTION

  IF @v_version_delete_count > 0
  BEGIN
    SET @v_step = 700
    --===============================================================
    -- Cursor to dynamically get Metadata tables to delete from
    --===============================================================
    DECLARE c_Tables CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
      SELECT
        a.name table_name
      , b.name column_name
      FROM
        sysobjects a
      , syscolumns b
      WHERE
          a.id = b.id
      AND a.name LIKE 'ws_%_v'
      AND b.name LIKE '%_version_no'

    OPEN c_Tables
    FETCH NEXT FROM c_Tables INTO
        @v_table_name
      , @v_column_name

    WHILE @@FETCH_STATUS = 0
    BEGIN

      SET @v_step = 800

      --================================================================
      -- If the detail table is procedure/script headers/lines
      -- then archive the rows before deleting
      --================================================================
      IF UPPER(@v_table_name) IN ('WS_PRO_HEADER_V','WS_PRO_LINE_V','WS_SCR_HEADER_V','WS_SCR_LINE_V')
      BEGIN

        SET @v_step = 900

        --===============================================================
        -- generate INSERT SQL and then issue
        --===============================================================
        SET @v_insert_sql = 'INSERT INTO ' + 'wx' + SUBSTRING(@v_table_name,3,LEN(@v_table_name)-2) + '_archive '
                          + 'SELECT * '
                          + 'FROM ' + @v_table_name
                          + ' WHERE NOT EXISTS (SELECT 1 '
                          + 'FROM ws_obj_versions b '
                          + 'WHERE ' + @v_table_name + '.' + @v_column_name
                          + ' = b.ov_version_no)'

        SET @v_step = 1000

        EXECUTE sp_executesql @v_insert_sql

        SELECT @v_insert_count = @@ROWCOUNT

        IF @v_insert_count > 0
        BEGIN
          SET @p_return_msg = CONVERT(varchar, @v_insert_count)
                            +' records archived to '
                            +'WX' + SUBSTRING(@v_table_name,3,LEN(@v_table_name)-2) + '_ARCHIVE'
          EXEC WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
               @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id

          COMMIT
          BEGIN TRANSACTION
        END

      END

      SET @v_step = 1100
      --===============================================================
      -- generate DELETE SQL and then issue
      --===============================================================
      SET @v_delete_sql = 'DELETE FROM ' + @v_table_name
                        + ' WHERE NOT EXISTS (SELECT 1 '
                        + 'FROM ws_obj_versions b '
                        + 'WHERE ' + @v_table_name + '.' + @v_column_name
                        + ' = b.ov_version_no)'

      SET @v_step = 1200

      EXECUTE sp_executesql @v_delete_sql

      SELECT @v_delete_count = @@ROWCOUNT

      IF @v_delete_count > 0
      BEGIN
        SET @p_return_msg = CONVERT(varchar, @v_delete_count)
                          +' records deleted from '
                          + @v_table_name
        EXEC WsWrkAudit 'I', @p_job_name, @p_task_name, @p_sequence,
             @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id

        COMMIT
        BEGIN TRANSACTION
      END

      FETCH NEXT FROM c_Tables INTO
        @v_table_name
      , @v_column_name

    END

    CLOSE c_Tables
    DEALLOCATE c_Tables

  END

  COMMIT

  SET @v_step = 1300

  SET @p_return_code = 'S'
  SET @p_return_msg = 'Version Records deleted:  '
                      + CONVERT(varchar,ISNULL(@v_version_delete_count,0))
  SET @p_result = 1

  END TRY
  -----------
  BEGIN CATCH
  -----------
    IF CURSOR_STATUS('local','c_Versions') >= -1
    BEGIN
      DEALLOCATE c_Versions
    END
    IF CURSOR_STATUS('local','c_Tables') >= -1
    BEGIN
      DEALLOCATE c_Tables
    END

    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -3

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Clear_Archive 
-- Notes / History
--
-- NB  19/07/2007 Original Version
-- NB  04/10/2007 Pre-calculate the delete date prior to issuing SQL statement
-- AP  10/06/2008 Version 6.0.4.1 Changes to work-flow locking.and 2005+ TRY
-- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
-- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE PROCEDURE Ws_Job_Clear_Archive
  @p_sequence         integer
, @p_job_name         varchar(64)
, @p_task_name        varchar(64)
, @p_job_id           integer
, @p_task_id          integer
, @p_day_count        integer
, @p_job              varchar(64)
, @p_options          varchar(256)
, @p_return_code      varchar(1)    OUTPUT
, @p_return_msg       varchar(1024) OUTPUT
, @p_result           integer       OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    :	SQL Server
  -- Script Name 	:	Ws_Job_Clear_Archive
  -- Description 	:	Deletes from archives old job logs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --===============================================================
  -- Control variables used in most programs
  --===============================================================
  DECLARE
    @v_ws_pro_version        varchar(50)
  , @v_msgtext               varchar(1024) -- Text for audit_trail
  , @v_step                  integer       -- return code
  , @v_version_delete_count  integer       -- no of records deleted
  , @v_delete_count          integer       -- no of records deleted
  , @v_count                 integer       -- General counter
  , @v_row_count             integer       -- Query returned row count
  , @v_db_code               varchar(10)   -- Database error code
  , @v_db_msg                varchar(1024) -- Database error message

  --=====================================================
  -- General Variables
  --=====================================================
  DECLARE
    @v_audit_del_count       integer       -- counter for audit records deleted
  , @v_detail_del_count      integer       -- counter for detail audit records deleted
  , @v_sql                   nvarchar(500) -- delete sql statement
  , @v_trunc_flag            integer       -- flag indicating to truncate table
  , @v_job                   varchar(64)   -- job to delete
  , @v_delete_date           datetime      -- delete date

  --===============================================================
  -- Main
  --===============================================================
  SET @v_ws_pro_version      = 'Ws_Job_Clear_Archive(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_audit_del_count = 0
  SET @v_detail_del_count = 0
  SET @v_trunc_flag = 0


  -- If zero specified in logs to keep then return
  IF @p_day_count  < 0
  BEGIN
    SET @p_return_code = 'W'
    SET @p_return_msg = ' negative value passed in days to keep count. No action.  '
    SET @p_result = 1

    RETURN 1
  END

  SET @v_job = ISNULL(@p_job, '')

  --===============================================================
  -- Process Options
  --===============================================================
  IF @p_options is not null
  BEGIN
    IF UPPER(@p_options) = 'TRUNCATE'
    BEGIN
      SET @v_trunc_flag = 1
    END
  END


  --***********************************************************************
  -- Delete relevant archive records
  --***********************************************************************
  SET @v_step  = 200

  IF @v_trunc_flag = 1
  BEGIN
    SET @v_step  = 300
    BEGIN TRANSACTION
    --***********************************************************************
    -- truncate audit and detail archive info
    --***********************************************************************
    --=====================================================
    -- Execute the truncate statement
    --=====================================================
    TRUNCATE TABLE wx_wrk_audit_archive

    SET @v_step = 400
    TRUNCATE TABLE wx_wrk_error_archive

    COMMIT

  END
  ELSE
  BEGIN
    SET @v_step  = 500

    -- set delete date
    SELECT @v_delete_date = getdate() - @p_day_count;

    --***********************************************************************
    -- construct and process DELETE statements
    --***********************************************************************
    IF LEN(@v_job) > 0
    BEGIN
      SET @v_step  = 600
      --***********************************************************************
      -- delete includes job name (possibly with wildcard)
      --***********************************************************************
      BEGIN TRANSACTION
      DELETE
      FROM   wx_wrk_audit_archive
      WHERE  wa_time_stamp < @v_delete_date
      AND    wa_job like @p_job;

      SELECT @v_audit_del_count  = @@ROWCOUNT

      COMMIT

      SET @v_step = 700
      BEGIN TRANSACTION
      DELETE
      FROM   wx_wrk_error_archive
      WHERE  wd_time_stamp < @v_delete_date
      AND    wd_job like @p_job;

      SELECT @v_detail_del_count  = @@ROWCOUNT

      COMMIT

    END
    ELSE
    BEGIN
      SET @v_step  = 800
      --***********************************************************************
      -- Delete based on just the day count
      --***********************************************************************
      BEGIN TRANSACTION
      DELETE
      FROM   wx_wrk_audit_archive
      WHERE  wa_time_stamp < @v_delete_date;

      SELECT @v_audit_del_count  = @@ROWCOUNT

      COMMIT

      SET @v_step = 900
      BEGIN TRANSACTION
      DELETE
      FROM   wx_wrk_error_archive
      WHERE  wd_time_stamp < @v_delete_date;

      SELECT @v_detail_del_count  = @@ROWCOUNT

      COMMIT

    END  -- end if length(v_job)
  END  -- end if v_trunc_flag


  SET @v_step = 1000

  SET @p_result = 1
  SET @p_return_code = 'S'
  IF @v_trunc_flag = 1
  BEGIN
    SET @p_return_msg  = 'audit archive logs and detail archive logs tables truncated.';
  END
  ELSE
  BEGIN
    SET @p_return_msg  = CONVERT(varchar, @v_audit_del_count) + ' audit archive logs removed and '
                      + CONVERT(varchar, @v_detail_del_count)  + ' detail archive logs removed. '
  END

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_result = -2

    SET @p_return_code = 'F'

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

     -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN 0
_PROCEDWSL_ Ws_Job_Status 
CREATE PROCEDURE Ws_Job_Status
  @p_sequence            INTEGER
, @p_job_name            VARCHAR(64)
, @p_task_name           VARCHAR(64)
, @p_job_id              INTEGER
, @p_task_id             INTEGER
, @p_check_sequence      INTEGER
, @p_check_job           VARCHAR(64)
, @p_started_in_last_mi  INTEGER
, @p_started_after_dt    DATETIME
, @p_return_code         VARCHAR(1)     OUTPUT
, @p_return_msg          VARCHAR(1024)  OUTPUT
, @p_result              INTEGER        OUTPUT
, @p_job_status_simple   VARCHAR(1)     OUTPUT
, @p_job_status_standard VARCHAR(1)     OUTPUT
, @p_job_status_enhanced VARCHAR(2)     OUTPUT
AS
  SET XACT_ABORT OFF  -- Turn off auto abort on errors
  SET NOCOUNT ON      -- Turn off row count messages

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		    :	SQL Server
  -- Script Name 		:	ws_job_status
  -- Description 		:	Returns the status of a job.
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- JML 19/11/2007 Version 5.6.3.0 First Version
  -- AP  10/06/2008 Version 6.0.4.1 Changes to workflow locking.and 2005+ TRY
  -- AP  23/07/2015 Version 6.8.4.3 RED-5279 Azure Support
  -- BC  14/08/2015 Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
  -- BC  03/11/2015 Version 6.8.4.4 RED-5392 Eliminate a potential race condition when getting
  --                                the details of a running job which could have completed in
  --                                the mean time, where its details will have been moved out of
  --                                ws_wrk_job_run into ws_wrk_job_log.
  -- HM  15/10/2018 Version 8.3.1.0 RED-9774 Remove encryption.
  -- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE
    @v_ws_pro_version         VARCHAR(50)
  , @v_msgtext                VARCHAR(1024) -- Text in audit_trail
  , @v_step                   INTEGER       -- Return code
  , @v_db_code                VARCHAR(10)   -- Database error code
  , @v_db_msg                 VARCHAR(1024) -- Database error message
  , @v_job_not_found          CHAR(1)
  , @v_job_sequence           INTEGER
  , @v_job_status_simple      VARCHAR(1)
  , @v_job_status_standard    VARCHAR(1)
  , @v_job_status_enhanced    VARCHAR(2)
  , @v_job_state              VARCHAR(20)
  , @v_job_status_msg         VARCHAR(256)
  , @v_task_count             INTEGER
  , @v_started_after_dt       DATETIME

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- Main
  --=====================================================
  SET @v_ws_pro_version           = 'Ws_Job_Status(8.4.1.0)'
  SET @v_step = 100

  BEGIN TRY

  SET @v_job_not_found = 'N'
  SET @p_return_code = 'S'
  SET @p_result = 1

  SET @v_step = 200

  -- Check to ensure neither time based parameters have been specified if check sequence has been.
  -- Abort in this case.
  IF (( @p_check_sequence IS NOT NULL ) AND (( @p_started_in_last_mi IS NOT NULL) OR ( @p_started_after_dt IS NOT NULL )))
  BEGIN

    SET @v_step = 300

    SET @p_job_status_simple = '0'
    SET @p_job_status_standard = '0'
    SET @p_job_status_enhanced = '0'
    SET @p_return_msg = 'Unable to proceed: neither p_started_in_last_mi or p_started_after_dt may not be specified if p_check_sequence is specified.'
    SET @p_return_code = 'E'
    SET @p_result = -2

    RETURN @p_result

  END

  -- Check to ensure zero or one time based parameters have been specified.
  -- Abort if both have been specified.
  ELSE
  BEGIN

    IF (( @p_started_in_last_mi IS NOT NULL) AND ( @p_started_after_dt IS NOT NULL ))
    BEGIN

      SET @v_step = 400

      SET @p_job_status_simple = '0'
      SET @p_job_status_standard = '0'
      SET @p_job_status_enhanced = '0'
      SET @p_return_msg = 'Unable to proceed: both p_started_in_last_mi and p_started_after_dt have been set. At most one of these may be set.'
      SET @p_return_code = 'E'
      SET @p_result = -2

      RETURN @p_result

    END

    ELSE
    BEGIN

      IF ((( @p_started_in_last_mi IS NOT NULL) OR ( @p_started_after_dt IS NOT NULL )) AND ( @p_check_job IS NULL ))
      BEGIN

        SET @v_step = 500

        SET @p_job_status_simple = '0'
        SET @p_job_status_standard = '0'
        SET @p_job_status_enhanced = '0'
        SET @p_return_msg = 'Unable to proceed: if p_started_in_last_mi or p_started_after_dt have been set, then p_check_job must also be set.'
        SET @p_return_code = 'E'
        SET @p_result = -2

        RETURN @p_result

      END

    END

  END

  SET @v_step = 600

  -- If the job sequence has been specified, see if it is in the control, run
  -- or log tables.
  IF ( @p_check_sequence IS NOT NULL )
  BEGIN

    SET @v_step = 700

    SELECT DISTINCT
           @v_job_state = '0'
    FROM   ws_wrk_job_ctrl
    WHERE  wjc_sequence = @p_check_sequence
    AND    wjc_status = 'B'

    IF ( @v_job_state IS NULL )
    BEGIN

      SET @v_step = 800
      SELECT DISTINCT
             @v_job_state = '1'
      FROM   ws_wrk_job_run
      WHERE  wjr_sequence = @p_check_sequence

      IF ( @v_job_state IS NULL )
      BEGIN

        SET @v_step = 900
        SELECT DISTINCT
               @v_job_state = '2'
        FROM   ws_wrk_job_log
        WHERE  wjl_sequence = @p_check_sequence

      END

        IF ( @v_job_state IS NULL )
        BEGIN

          SET @v_step = 1000
          SELECT DISTINCT
                 @v_job_state = '3'
          FROM   ws_wrk_job_ctrl
          WHERE  wjc_sequence = @p_check_sequence
          AND    wjc_status <> 'B'

          IF ( @v_job_state IS NULL )
          BEGIN

            SET @v_job_state = '0'
            SET @v_job_sequence = 0

          END

        END

    END

    SET @v_step = 1100

    IF ( @v_job_state = 0 )
    BEGIN

      SET @v_step = 1200

      SET @p_job_status_simple = '0'
      SET @p_job_status_standard = '0'
      SET @p_job_status_enhanced = '0'
      SET @p_return_msg = 'Unable to locate specified job sequence.'
      SET @p_return_code = 'E'
      SET @p_result = -1

      RETURN @p_result

    END

    SET @v_job_sequence = @p_check_sequence

  END

  ELSE
  BEGIN

    -- If either date and time parameter has been specified...
    IF (( @p_started_in_last_mi IS NOT NULL ) OR ( @p_started_after_dt IS NOT NULL ))
    BEGIN

      -- If the started in the last X minutes parameter has been specified, then
      -- convert this into a day.
      IF ( @p_started_in_last_mi IS NOT NULL )
      BEGIN

        SET @v_step = 1300

        -- Work out allowable start date and store in v_started_after_dt using the day, hour
        -- and minute interval values.
        SET @v_started_after_dt = DATEADD(mi,0-@p_started_in_last_mi,GETDATE())

      END

      -- Start after date parameter specified, so assign this to v_started_after_dt.
      ELSE
      BEGIN

        IF ( @p_started_after_dt IS NOT NULL )
        BEGIN

          SET @v_started_after_dt = @p_started_after_dt

        END

      END

      SET @v_step = 1400

      -- Get the sequence of the job and see if it is in the control, run
      -- or log tables.
      -- Note order of precedence: has run, is running, has not yet run.
      SELECT TOP 1
             @v_job_state = '0'
           , @v_job_sequence = MAX(wjc_sequence)
      FROM   ws_wrk_job_ctrl
      WHERE  wjc_name = @p_check_job
      AND    wjc_started >= @v_started_after_dt
      AND    wjc_status = 'B'
      ORDER BY 1 ASC, 2 DESC

      IF ( @v_job_sequence  IS NULL )
      BEGIN

        SET @v_step = 1500
        SELECT TOP 1
               @v_job_state = '1'
             , @v_job_sequence = MAX(wjr_sequence)
        FROM   ws_wrk_job_run
        WHERE  wjr_name = @p_check_job
        AND    wjr_started >= @v_started_after_dt
        ORDER BY 1 ASC, 2 DESC

        IF ( @v_job_sequence IS NULL )
        BEGIN

          SET @v_step = 1600
          SELECT TOP 1
                 @v_job_state = '2'
               , @v_job_sequence = MAX(wjl_sequence)
          FROM   ws_wrk_job_log
          WHERE  wjl_name = @p_check_job
          AND    wjl_started >= @v_started_after_dt
          ORDER BY 1 ASC, 2 DESC

          IF ( @v_job_sequence IS NULL )
          BEGIN

            SET @v_step = 1700
            SELECT TOP 1
                   @v_job_state = '3'
                 , @v_job_sequence = MAX(wjc_sequence)
            FROM   ws_wrk_job_ctrl
            WHERE  wjc_name = @p_check_job
            AND    wjc_started >= @v_started_after_dt
            AND    wjc_status <> 'B'
            ORDER BY 1 ASC, 2 DESC

            IF ( @v_job_sequence IS NULL )
            BEGIN

              SET @v_job_state = '0'
              SET @v_job_sequence = 0

            END

          END

        END

      END

      -- If job sequence hasn't been found, SET @v_job_not_found to Y for later use.
      IF ( @v_job_sequence = 0 )
      BEGIN

        SET @v_job_not_found = 'Y'

      END

    END

  END

  -- If the sequence parameter or neither date parameters has been specified or
  -- both previous checks failed to find the job look for the max sequence of
  -- the specified job.
  -- Note order of precedence: has run, is running, has not yet run.
  IF ((( @p_check_sequence IS NULL ) AND ( @p_started_in_last_mi IS NULL ) AND ( @p_started_after_dt IS NULL )) OR ( @v_job_not_found = 'Y' ))
  BEGIN

    SET @v_step = 1800

    SELECT TOP 1
           @v_job_state = '0'
         , @v_job_sequence = MAX(wjc_sequence)
    FROM   ws_wrk_job_ctrl
    WHERE  wjc_name = @p_check_job
    AND    wjc_status = 'B'
    ORDER BY 1 ASC, 2 DESC

    IF ( @v_job_sequence IS NULL )
    BEGIN

      SET @v_step = 1900
      SELECT TOP 1
             @v_job_state = '1'
           , @v_job_sequence = MAX(wjr_sequence)
      FROM   ws_wrk_job_run
      WHERE  wjr_name = @p_check_job
      ORDER BY 1 ASC, 2 DESC

      IF ( @v_job_sequence IS NULL )
      BEGIN

        SET @v_step = 2000
        SELECT TOP 1
               @v_job_state = '2'
             , @v_job_sequence = MAX(wjl_sequence)
        FROM   ws_wrk_job_log
        WHERE  wjl_name = @p_check_job
        ORDER BY 1 ASC, 2 DESC

        IF ( @v_job_sequence IS NULL )
        BEGIN

          SET @v_step = 2100
          SELECT TOP 1
                 @v_job_state = '3'
               , @v_job_sequence = MAX(wjc_sequence)
          FROM   ws_wrk_job_ctrl
          WHERE  wjc_name = @p_check_job
          AND    wjc_status <> 'B'
          ORDER BY 1 ASC, 2 DESC

          IF ( @v_job_sequence IS NULL )
          BEGIN

            SET @v_job_state = '0'
            SET @v_job_sequence = 0

          END

        END

      END

    END

  END

  SET @v_step = 2200

  -- If the job could not be found, abort.
  IF ( @v_job_sequence = 0 )
  BEGIN

    SET @v_step = 2300

    SET @p_job_status_simple = '0'
    SET @p_job_status_standard = '0'
    SET @p_job_status_enhanced = '0'
    SET @p_return_msg = 'Unable to locate job.'
    SET @p_return_code = 'E'
    SET @p_result = -1

    RETURN @p_result

  END

  -- If the job exists but not starting in the last X minutes then abort.
  ELSE
  BEGIN

    IF ( @p_started_in_last_mi IS NOT NULL AND @v_job_not_found = 'Y' )
    BEGIN

      SET @v_step = 2400

      SET @p_job_status_simple = '0'
      SET @p_job_status_standard = '0'
      SET @p_job_status_enhanced = '0'
      SET @p_return_msg = 'Job Not Found having started in the last ' + CONVERT(VARCHAR,@p_started_in_last_mi) + ' minutes.'
      SET @p_return_code = 'N'
      SET @p_result = -1

      RETURN @p_result

    END
    -- If the job exists but not starting since the specified date and time then abort.
    ELSE
    BEGIN

      IF ( @p_started_after_dt IS NOT NULL AND @v_job_not_found = 'Y' )
      BEGIN

        SET @v_step = 2500

        SET @p_job_status_simple = '0'
        SET @p_job_status_standard = '0'
        SET @p_job_status_enhanced = '0'
        SET @p_return_msg = 'Job Not Found having started after ' + CONVERT(VARCHAR,@p_started_after_dt,120) + '.'
        SET @p_return_code = 'N'
        SET @p_result = -1

        RETURN @p_result

      END

    END

  END

  SET @v_step = 2600

  -- If the job was found and has completed running, get it's details.
  IF ( @v_job_state = '1' )
  BEGIN

    SET @v_step = 2700

    SELECT @v_job_status_simple = ISNULL(MAX(
           CASE job_status
             WHEN 'H' THEN 'N'
             WHEN 'W' THEN 'N'
             WHEN 'B' THEN 'N'
             WHEN 'P' THEN 'N'
             WHEN 'R' THEN 'R'
             WHEN 'F' THEN 'F'
             WHEN 'C' THEN 'C'
             WHEN 'G' THEN 'F'
             WHEN 'E' THEN 'F'
             ELSE '0'
           END),'0')
         , @v_job_status_standard = ISNULL(MAX(job_status),'0')
         , @v_job_status_enhanced = ISNULL(MAX(
           CASE job_status
             WHEN 'H' THEN '1'
             WHEN 'W' THEN '2'
             WHEN 'B' THEN '3'
             WHEN 'P' THEN '4'
             WHEN 'R' THEN '5'
             WHEN 'F' THEN '8'
             WHEN 'C' THEN '9'
             WHEN 'G' THEN '11'
             WHEN 'E' THEN '12'
             ELSE '0'
           END),'0')
         , @v_job_status_msg = ISNULL(MAX(CAST(CASE job_status
             WHEN 'H' THEN 'On Hold'
             WHEN 'R' THEN 'Running'
             WHEN 'P' THEN 'Pending'
             WHEN 'W' THEN 'Waiting'
             WHEN 'C' THEN 'Completed'
             WHEN 'B' THEN 'Blocked'
             WHEN 'F' THEN 'Failed'
             WHEN 'G' THEN 'Failed - Aborted'
             WHEN 'E' THEN 'Error Completion'
             ELSE 'Unknown'
           END AS VARCHAR(200))),'Unknown')
    FROM (
        SELECT wjr_status AS job_status
        FROM ws_wrk_job_run
        WHERE wjr_sequence = @v_job_sequence
          UNION
        SELECT wjl_status AS job_status
        FROM ws_wrk_job_log
        WHERE wjl_sequence = @v_job_sequence
    ) AS sequence_data

    SET @v_step = 2800

    -- If the job is still running, check to see if any completed tasks
    -- have any errors or warning.   Then enhance the return message and
    -- status.   If there are both warnings and errors then report as a
    -- running with errors.
    IF ( @v_job_status_enhanced = '5' )
    BEGIN

      SET @v_step = 2900

      SELECT @v_task_count = COUNT(*)
      FROM   ws_wrk_task_run
      WHERE  wtr_sequence = @v_job_sequence
      AND    wtr_audit_status IN ('E','F')

      SET @v_step = 3000

      IF ( @v_task_count > 0 )
      BEGIN

        SET @v_step = 3100

        SET @v_job_status_enhanced = '6'
        SET @v_job_status_msg = 'Running with Errors'

      END

      ELSE
      BEGIN

        SET @v_step = 3200

        SELECT @v_task_count = COUNT(*)
        FROM   ws_wrk_task_run
        WHERE  wtr_sequence = @v_job_sequence
        AND    wtr_audit_status = 'W'

        SET @v_step = 3300

        IF ( @v_task_count > 0 )
        BEGIN

          SET @v_step = 3400

          SET @v_job_status_enhanced = '7'
          SET @v_job_status_msg = 'Running with Warnings'

        END

      END

    END

  END

  -- If the job was found and is currently running or has failed and not been
  -- aborted, get it's details.
  ELSE
  BEGIN

    IF ( @v_job_state = '2' )
    BEGIN

      SET @v_step = 3500

      SELECT @v_job_status_simple = ISNULL(MAX(
             CASE wjl_status
               WHEN 'H' THEN 'N'
               WHEN 'W' THEN 'N'
               WHEN 'B' THEN 'N'
               WHEN 'P' THEN 'N'
               WHEN 'R' THEN 'R'
               WHEN 'F' THEN 'F'
               WHEN 'C' THEN 'C'
               WHEN 'G' THEN 'F'
               WHEN 'E' THEN 'F'
               ELSE '0'
             END),'0')
           , @v_job_status_standard = ISNULL(MAX(wjl_status),'0')
           , @v_job_status_enhanced = ISNULL(MAX(
             CASE wjl_status
               WHEN 'H' THEN '1'
               WHEN 'W' THEN '2'
               WHEN 'B' THEN '3'
               WHEN 'P' THEN '4'
               WHEN 'R' THEN '5'
               WHEN 'F' THEN '8'
               WHEN 'C' THEN '9'
               WHEN 'G' THEN '11'
               WHEN 'E' THEN '12'
               ELSE '0'
             END),'0')
           , @v_job_status_msg = ISNULL(MAX(CAST(CASE wjl_status
               WHEN 'H' THEN 'On Hold'
               WHEN 'R' THEN 'Running'
               WHEN 'P' THEN 'Pending'
               WHEN 'W' THEN 'Waiting'
               WHEN 'C' THEN 'Completed'
               WHEN 'B' THEN 'Blocked'
               WHEN 'F' THEN 'Failed'
               WHEN 'G' THEN 'Failed - Aborted'
               WHEN 'E' THEN 'Error Completion'
               ELSE 'Unknown'
             END AS VARCHAR(200))),'Unknown')
      FROM   ws_wrk_job_log
      WHERE  wjl_sequence = @v_job_sequence

      SET @v_step = 3600

      -- If the job completed successfully, check to see if there were
      -- any warnings.   Then enhance the return message and status.
      IF ( @v_job_status_enhanced = '9' )
      BEGIN

        SET @v_step = 3700

        SELECT @v_task_count = COUNT(*)
        FROM   ws_wrk_task_log
        WHERE  wtl_sequence = @v_job_sequence
        AND    wtl_audit_status = 'W'

        SET @v_step = 3800

        IF ( @v_task_count > 0 )
        BEGIN

          SET @v_step = 3900

          SET @v_job_status_enhanced = '10'
          SET @v_job_status_msg = 'Completed with Warnings'

        END

      END


    END

    -- If the job was found and has not yet run, get it's details.
    ELSE
    BEGIN

      IF ( @v_job_state IN ( '0', '3' ))
      BEGIN

        SET @v_step = 4000

        SELECT @v_job_status_simple = ISNULL(MAX(
               CASE wjc_status
                 WHEN 'H' THEN 'N'
                 WHEN 'W' THEN 'N'
                 WHEN 'B' THEN 'N'
                 WHEN 'P' THEN 'N'
                 WHEN 'R' THEN 'R'
                 WHEN 'F' THEN 'F'
                 WHEN 'C' THEN 'C'
                 WHEN 'G' THEN 'F'
                 WHEN 'E' THEN 'F'
                 ELSE '0'
               END),'0')
             , @v_job_status_standard = ISNULL(MAX(wjc_status),'0')
             , @v_job_status_enhanced = ISNULL(MAX(
               CASE wjc_status
                 WHEN 'H' THEN '1'
                 WHEN 'W' THEN '2'
                 WHEN 'B' THEN '3'
                 WHEN 'P' THEN '4'
                 WHEN 'R' THEN '5'
                 WHEN 'F' THEN '8'
                 WHEN 'C' THEN '9'
                 WHEN 'G' THEN '11'
                 WHEN 'E' THEN '12'
                 ELSE '0'
               END),'0')
             , @v_job_status_msg = ISNULL(MAX(CAST(CASE wjc_status
                 WHEN 'H' THEN 'On Hold'
                 WHEN 'R' THEN 'Running'
                 WHEN 'P' THEN 'Pending'
                 WHEN 'W' THEN 'Waiting'
                 WHEN 'C' THEN 'Completed'
                 WHEN 'B' THEN 'Blocked'
                 WHEN 'F' THEN 'Failed'
                 WHEN 'G' THEN 'Failed - Aborted'
                 WHEN 'E' THEN 'Error Completion'
                 ELSE 'Unknown'
               END AS VARCHAR(200))),'Unknown')
        FROM   ws_wrk_job_ctrl
        WHERE  wjc_sequence = @v_job_sequence
      END

    END

  END

  SET @v_step = 4100

  SET @p_job_status_simple = @v_job_status_simple
  SET @p_job_status_standard = @v_job_status_standard
  SET @p_job_status_enhanced = @v_job_status_enhanced
  SET @p_return_msg = 'Job Sequence ' + CONVERT(VARCHAR,@v_job_sequence) + ' ' + @v_job_status_msg

  END TRY
  -----------
  BEGIN CATCH
  -----------
    -- Rollback any transaction in progress.
    -- Must do this first, so that we can log the error.
    IF XACT_STATE() <> 0
      ROLLBACK TRANSACTION

    SET @p_job_status_simple = '0'
    SET @p_job_status_standard = '0'
    SET @p_job_status_enhanced = '0'
    SET @p_return_code = 'F'
    SET @p_result = -3

    SET @p_return_msg = @v_ws_pro_version
                      + ' step '            + CAST(COALESCE(@v_step          ,0) AS varchar)
                      + ': '                +      COALESCE(ERROR_PROCEDURE(),'Null')
                      + ' failed at line '  + CAST(COALESCE(ERROR_LINE()     ,0) AS varchar)

    SET @v_db_code    =                       CAST(COALESCE(ERROR_NUMBER()  ,0) AS varchar)
    SET @v_db_msg     =   'Severity '       + CAST(COALESCE(ERROR_SEVERITY(),0) AS varchar)
                      + ' "'                +      COALESCE(ERROR_MESSAGE() ,'Null')
                      + '"'

    BEGIN TRY
      EXEC WsWrkAudit 'F', @p_job_name, @p_task_name ,@p_sequence,
        @p_return_msg,@v_db_code, @v_db_msg, @p_task_id, @p_job_id
    END TRY

    -----------
    BEGIN CATCH
    -----------
      IF XACT_STATE() <> 0
        ROLLBACK TRANSACTION

      SET @p_return_msg = @p_return_msg
                        + ': '                +                 ERROR_PROCEDURE()
                        + ' failed at line '  + CONVERT(varchar,ERROR_LINE())
                        + ' DBCode '          + CONVERT(varchar,ERROR_NUMBER())
                        + ' "'                +                 ERROR_MESSAGE()
                        + '"'

      -- Fairly serious by this point, attempt to log to SQL logs
      RAISERROR(@p_return_msg,18,1) SQLNONADMIN WITH LOG

    -----------
    END CATCH
    -----------

    -- Provide full message in return parameter
    SET @p_return_msg = @p_return_msg + ', ' + @v_db_msg

  -----------
  END CATCH
  -----------

  RETURN @p_result
