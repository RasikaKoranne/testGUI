_PROCEDURE_ Ws_Procedure_Compile 
-- Notes / History
--
-- WMR  22/01/2002     Version 1.0.0

CREATE OR REPLACE procedure Ws_Procedure_Compile
    (
    p_name        IN  varchar2,
    p_stmt        IN  varchar2,
    p_ret_msg     OUT varchar2,
    p_result      OUT number
    )
    AUTHID CURRENT_USER
    AS
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name               :	Oracle
    -- Script Name             :	ws_procedure_copile
    -- Description             :	Compile a procedure/function or package
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================
      
    v_command     varchar2(256);
    v_command_len integer;
    v_step        integer;
    v_create_pos  integer;
    v_name_pos    integer;
    v_type_pos    integer;
    v_body_start  integer;
    v_body_end    integer;
    v_body_size   integer;
    v_head_start  integer;
    v_head_end    integer;
    v_head_size   integer;


BEGIN

    v_step := 10;
    -- =============================================================================
    -- Find the create command
    -- If we cant find the create command then just try and compile what we have
    -- =============================================================================
    v_step := 20;
    v_create_pos := instr(lower(p_stmt),'create',1,1);

    If v_create_pos = 0 Then
        v_step := 21;
        GoTo Execute;
    End If;

    -- =============================================================================
    -- Find the function/procedure or package name
    -- If we cant find the name then just try and compile what we have
    -- =============================================================================
    v_step := 30;
    v_name_pos := instr(lower(p_stmt),lower(p_name),v_create_pos,1);

    If v_name_pos = 0 Then
        v_step := 31;
        GoTo Execute;
    End If;

    -- =============================================================================
    -- Find out if this is a package
    -- If we cant find the type then just try and compile what we have
    -- =============================================================================
    v_step := 40;
    v_command_len := v_name_pos - v_create_pos;
    If v_command_len > 255 Then
        v_step := 41;
        GoTo Execute;
    End If;

    v_command := substr(p_stmt,v_create_pos, v_command_len+1);
    v_type_pos := instr(lower(v_command),'package',1,1);

    If v_type_pos = 0 Then
        v_step := 45;
        GoTo Execute;
    End If;

    -- =============================================================================
    -- P A C K A G E
    -- =============================================================================

    -- =============================================================================
    -- We have a package so work out where the header and body of the package start
    -- and end. Then compile the header and then the body
    -- =============================================================================
    v_step := 50;
    v_body_end := instr(lower(p_stmt),'package body',v_name_pos,1);
    If v_body_end = 0 Then
        v_step := 51;
        GoTo Execute;
    End If;

    v_body_start := instr(lower(p_stmt),'create',v_body_end-25,1);
    If v_body_start = 0 Then
        v_step := 52;
        GoTo Execute;
    End If;

    v_head_start := 1;
    v_head_end := v_body_start - 1;
    v_body_end := length(p_stmt);
    v_body_size := (v_body_end - v_body_start) + 1;
    v_head_size := (v_head_end - v_head_start) + 1;

    -- =============================================================================
    -- Compile the package head
    -- =============================================================================
    BEGIN
        execute immediate substr(p_stmt,v_head_start,v_head_size);
    EXCEPTION WHEN OTHERS THEN
        If SQLCODE = -24344 THEN
           p_ret_msg := 'Compilation Errors in Package Header';
           p_result := -1;
           RETURN;
        Else
           p_ret_msg := 'Unexpected Error in Ws_Procedure_Compile, Package Header compile '||SQLERRM;
           p_result := -2;
           RETURN;
        End If;
    END;

    -- =============================================================================
    -- Compile the package body
    -- =============================================================================
    BEGIN
        execute immediate substr(p_stmt,v_body_start,v_body_size);
    EXCEPTION WHEN OTHERS THEN
        If SQLCODE = -24344 THEN
           p_ret_msg := 'Compilation Errors in Package Body';
           p_result := -1;
           RETURN;
        Else
           p_ret_msg := 'Unexpected Error in Ws_Procedure_Compile, Package Body compile '||SQLERRM;
           p_result := -2;
           RETURN;
        End If;
    END;

    v_step := 900;
    p_result := 1;
    p_ret_msg := 'Compiled okay';
    COMMIT;
    RETURN;

-- =============================================================================
-- Default compile if not a package
-- or unable to ascertain
-- =============================================================================
<<Execute>>
    BEGIN
        execute immediate p_stmt;
    EXCEPTION WHEN OTHERS THEN
        If SQLCODE = -24344 THEN
           p_ret_msg := 'Compilation Errors';
           p_result := -1;
           RETURN;
        Else
           p_ret_msg := 'Unexpected Error in Ws_Procedure_Compile '||SQLERRM;
           p_result := -2;
           RETURN;
        End If;
    END;

<<Compiled>>
    v_step := 900;
    p_result := 1;
    p_ret_msg := 'Compiled okay';
    COMMIT;
    RETURN;

EXCEPTION
    WHEN OTHERS THEN
       p_ret_msg := 'Unexpected Error in Ws_Procedure_Compile, step '||
                    v_step||' '||SQLERRM;
       p_result := -3;
       ROLLBACK;
       RETURN;

END Ws_Procedure_Compile;
 
_PROCEDURE_ Ws_Procedure_Save 
-- Notes / History
--
-- WMR 22/01/2002  Version 1.0.0
-- DLC 04/11/2014  Version 6.8.1.2 Increased the line length to 4000
-- HM  13/02/2019  Version 8.4.1.0 Ensure p_ret_msg does not exceed 1023; increase line variable size from 256 to 4000.

CREATE OR REPLACE procedure Ws_Procedure_Save
    (
    p_obj_key     IN  number,
    p_lines0      IN  varchar2,
    p_lines1      IN  varchar2,
    p_lines2      IN  varchar2,
    p_lines3      IN  varchar2,
    p_lines4      IN  varchar2,
    p_lines5      IN  varchar2,
    p_lines6      IN  varchar2,
    p_lines7      IN  varchar2,
    p_lines8      IN  varchar2,
    p_lines9      IN  varchar2,
    p_ret_msg     OUT varchar2,
    p_result      OUT number
    )
    AUTHID CURRENT_USER
    AS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_procedure_save
    -- Description    :    Save a procedure to ws_pro_line
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_line_no         integer := 0;  -- line counter
    v_stmt            varchar2(4000);
    v_lined           varchar2(32767);
    v_cursor          number;
    v_step            number;
    v_pos             number;
    v_loop            integer;
    v_start           integer;
    v_end             integer;
    v_size            integer;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --=====================================================
    -- If a key of 0 and a string of CHECK is passed then
    -- return -98 to indicate this procedure is incompatible
    -- with the version of RED in use
    --=====================================================
    If p_obj_key = 0 And p_lines0 = 'CHECK' Then
        v_step := 20;
        p_result := -98;
        p_ret_msg := 'Please upgrade meta data';
        RETURN;
    End If;

    --=====================================================
    -- If a key of 0 and a string of CHECK is passed then
    -- return -99 to indicate this procedure is active
    --=====================================================
    If p_obj_key = 0 And p_lines0 = 'CHECKIT' Then
        v_step := 21;
        p_result := -99;
        p_ret_msg := 'Ready';
        RETURN;
    End If;

    --=====================================================
    -- Delete the previous lines in this procedure
    -- All treated as one transaction with a rollback
    -- If the insert fails
    --=====================================================
    Delete from ws_pro_line
    Where pl_obj_key = p_obj_key;

    --=====================================================
    -- If a total delete
    -- I.e. the new data is null then return
    --=====================================================
    If p_lines0 is NULL Then
        p_result := 0;
        p_ret_msg := 'procedure deleted';
        COMMIT;
        RETURN;
    End If;
    --=====================================================
    -- Loop through the text passed
    -- saving a line after each newline character
    -- a line is a max of 4000 bytes long
    --=====================================================
    v_line_no := 0;
    v_start := 0;
    v_end := 0;
    v_lined := '';
    FOR v_stmt_no IN 0..9 LOOP
        v_step := 30;

        If v_start < v_end Then
            v_size := (v_end - v_start) + 1;
            v_lined := substr(v_lined,v_start,v_size);
        Else
            v_lined := '';
        End If;

        If v_stmt_no = 0 Then
            v_lined := p_lines0;
        ElsIf v_stmt_no = 1 Then
            v_lined := v_lined||p_lines1;
        ElsIf v_stmt_no = 2 Then
            v_lined := v_lined||p_lines2;
        ElsIf v_stmt_no = 3 Then
            v_lined := v_lined||p_lines3;
        ElsIf v_stmt_no = 4 Then
            v_lined := v_lined||p_lines4;
        ElsIf v_stmt_no = 5 Then
            v_lined := v_lined||p_lines5;
        ElsIf v_stmt_no = 6 Then
            v_lined := v_lined||p_lines6;
        ElsIf v_stmt_no = 7 Then
            v_lined := v_lined||p_lines7;
        ElsIf v_stmt_no = 8 Then
            v_lined := v_lined||p_lines8;
        ElsIf v_stmt_no = 9 Then
            v_lined := v_lined||p_lines9;
        End If;

        v_start := 1;
        v_end := nvl(length(v_lined),0);
        v_step := 40;
        If v_end < v_start Then
            v_loop := 0;
        Else
            v_loop := 1;
        End If;


        WHILE v_loop = 1 LOOP
            v_step := 50;
            v_pos := instr(v_lined,CHR(10),v_start,1);
            v_step := 60;
            If v_pos < 1 Then
                v_loop := 0 ;
            Else
                v_step := 70;
                v_size := (v_pos - v_start) + 1;
                -- Maximum of 4000 characters in a line
                If v_size > 4000 Then
                    v_size := 4000;
                End If;
                v_stmt := substr(v_lined,v_start,v_size);
                v_step := 80;
                v_line_no := v_line_no + 1;
                v_step := 90;
                Insert into ws_pro_line (
                    pl_obj_key,
                    pl_line_no,
                    pl_line
                    ) values (
                    p_obj_key,
                    v_line_no,
                    v_stmt
                    );
                v_start := v_pos + 1;
                v_step := 100;
                If v_start >= v_end Then
                    v_loop := 0;
                End If;
            End If;
        END LOOP;
    END LOOP;

    v_step := 900;
    p_result := v_line_no;
    p_ret_msg := 'procedure saved';
    COMMIT;
    RETURN;

EXCEPTION
    WHEN OTHERS THEN
       -- truncate SQL to leave space for db error message
       p_ret_msg := substr('Unexpected Error in Ws_Procedure_Save, step '||
                           v_step||'\n'||substr(v_stmt,v_start,256)||'\n'||SQLERRM, 1, 1023);
       p_result := -1;
       ROLLBACK;
       RETURN;

END ws_procedure_save;
 
_PROCEDURE_ Ws_Exec_Immediate 
-- Notes / History
--
-- Required to enable the compiling of a package, which cannot be done from ODBC
-- WMR 22/01/2002   Version 1.0.0
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Ensure return message is no more than 1024 characters.

CREATE OR REPLACE procedure Ws_Exec_Immediate
    (
    p_stmt        IN  varchar2,
    p_ret_msg     OUT varchar2,
    p_result      OUT number
    )
    AUTHID CURRENT_USER
    AS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_exec_immediate
    -- Description    :    Execute a chunk of SQL.
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_step        integer;

BEGIN

    v_step := 10;
    execute immediate p_stmt;

    v_step := 900;
    p_result := 1;
    p_ret_msg := 'executed';
    COMMIT;
    RETURN;

EXCEPTION
    WHEN OTHERS THEN
       p_ret_msg := SUBSTR('Unexpected Error in Ws_Exec_Immediate, step '||
                           v_step||' '||SQLERRM, 1, 1023);
       p_result := -1;
       ROLLBACK;
       RETURN;

END ws_exec_immediate;
 
_PROCEDURE_ WsWrkAudit 
-- Notes / History:
-- Inserts messages into the ws_wrk_audit_log table
-- Called by the scheduler or ws_job_execute when ever a task completes.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
--
-- ============================================================================
-- Calling:
-- v_result :=WsWrkAudit(v_status_code, v_job_name, v_task_name, v_sequence,
--                       v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key);
-- ============================================================================
-- WMR  22/01/2002   Version 1.0.0
-- WMR  01/08/2003   Version 4.1.0 added insert of wa_row_number
-- BC   14/08/2015   Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM   13/02/2019   Version 8.4.1.0 Fix comments.

CREATE OR REPLACE FUNCTION WsWrkAudit (
    v_status_code    varchar2,
    v_job_name       varchar2,
    v_task_name      varchar2,
    v_sequence       number,
    v_message        varchar2,
    v_db_code        varchar2,
    v_db_msg         varchar2,
    v_task_key       number,
    v_job_key        number
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name     :   Oracle
    -- Script Name   :   WsWrkAudit.sql
    -- Description   :   Writes row to audit log and if applicable to job_run and task_run
    -- Author        :   Wayne Richmond
    -- Date          :   2 December 1996
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_okay_count     number := 0;
    v_info_count     number := 0;
    v_warn_count     number := 0;
    v_error_count    number := 0;
    v_return         number := 1;

BEGIN
    -- =========================================================================
    -- Insert the message into the audit log. Catch all errors as we do not want to halt the
    -- calling procedure in the case of an insert failure
    -- =========================================================================

        Insert into ws_wrk_audit_log
        (
            wa_time_stamp,
            wa_sequence,
            wa_job,
            wa_task,
            wa_status,
            wa_message,
            wa_db_msg_code,
            wa_db_msg_desc,
            wa_task_key,
            wa_job_key,
            wa_row_number
        )
        Values
        (
            sysdate,
            v_sequence,
            v_job_name,
            v_task_name,
            v_status_code,
            v_message,
            v_db_code,
            v_db_msg,
            v_task_key,
            v_job_key,
            ws_audit_log_seq.nextval
        );

    -- =========================================================================
    -- If the task or job key is not zero we need to know which counter to increment
    -- =========================================================================

       If  v_task_key <> 0  Or  v_job_key <> 0 Then
             If  v_status_code  = 'S' Then
                 v_okay_count := 1;
             ElsIf  v_status_code  = 'I' Then
                 v_info_count := 1;
             ElsIf  v_status_code  = 'W' Then
                 v_warn_count := 1;
             ElsIf  v_status_code  = 'E' Then
                 v_error_count := 1;
             ElsIf  v_status_code  = 'F' Then
                 v_error_count := 1;
             End If;
       End If;

    -- =========================================================================
    -- If the task key is not zero attempt to update the counters in the task_run table.
    -- =========================================================================
       If ( v_task_key <> 0 ) Then
           BEGIN
                Update ws_wrk_task_run
                Set
                        wtr_info_count = wtr_info_count + v_info_count,
                        wtr_warning_count = wtr_warning_count + v_warn_count
                Where wtr_task_key = v_task_key
                And wtr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
                v_return := 0;
           END;

       End If;

    -- =========================================================================
    -- If the job key is not zero attempt to update the counters in the job_run table.
    -- =========================================================================
       If ( v_job_key <> 0 ) Then
           BEGIN
                Update ws_wrk_job_run
                Set
                        wjr_okay_count = wjr_okay_count + v_okay_count,
                        wjr_info_count = wjr_info_count + v_info_count,
                        wjr_warning_count = wjr_warning_count + v_warn_count,
                        wjr_error_count = wjr_error_count + v_error_count
                Where wjr_job_key = v_job_key
                And wjr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
                v_return := 0;
           END;

       End If;

    -- =========================================================================
    --Commit the message. This may be undesirable!!
    -- =========================================================================
     Commit;
     Return v_return;   -- insert OK, or a warning on the update

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- insert failed
END WsWrkAudit;
 
_PROCEDURE_ WsWrkError 
-- Notes / History:
-- Inserts messages into the Ws_wrk_error_log table
-- Called by procedures wishing to log detail information.
-- Passed the following parameters:
--
-- status_code         - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                        (W)arning, (E)rror, (F)atal
-- job_name            - Name of the Job, or some other name for result grouping
-- task_name           - Name of the procedure or Task or procedure
-- sequence            - Sequence number of the run
-- message             - Textual message to be placed in the audit log
-- rdbms_code          - The database error code if appropriate
-- rdbms_msg           - The database message if appropriate
-- task_id             - Key to the Ws scheduler task
-- job_id              - Key to the Ws scheduler job
-- msg_type            - Key to the message type table
-- severity            - Application specific severity indicator
-- action              - Possible corrective action
--
-- ============================================================================
-- Calling:
-- v_result := WsWrkError(v_status_code, v_job_name, v_task_name, v_sequence,
--                        v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key,
--                        v_msg_type, v_severity, v_action);
-- ============================================================================
-- WMR 22/01/2002   Version 1.0.0
-- WMR 01/08/2003   Version 4.1.0   added insert of wd_row_number
-- BC  14/08/2015   Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019   Version 8.4.1.0 Fix comments.

CREATE OR REPLACE FUNCTION WsWrkError (
    v_status_code   varchar2,
    v_job_name      varchar2,
    v_task_name     varchar2,
    v_sequence      number,
    v_message       varchar2,
    v_db_code       varchar2,
    v_db_msg        varchar2,
    v_task_key      number,
    v_job_key       number,
    v_msg_type      varchar2
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name     :   Oracle
    -- Script Name   :   WsWrkError.sql
    -- Description   :   Writes row to the error log
    -- Author        :   Wayne Richmond
    -- Date          :   2 December 1996
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

BEGIN
    -- =========================================================================
    -- Insert the message into the log table. Catch any error as we do not want to hinder the
    -- calling procedure if we fail on our insert
    -- =========================================================================

        Insert into Ws_wrk_error_log
        (
            wd_time_stamp,
            wd_sequence,
            wd_job,
            wd_task,
            wd_status,
            wd_message,
            wd_db_msg_code,
            wd_db_msg_desc,
            wd_task_key,
            wd_job_key,
            wd_msg_type_code,
            wd_row_number
        )
        Values
        (
            sysdate,
            v_sequence,
            v_job_name,
            v_task_name,
            v_status_code,
            v_message,
            v_db_code,
            v_db_msg,
            v_task_key,
            v_job_key,
            v_msg_type,
            ws_error_log_seq.nextval
        );


    -- =========================================================================
    -- If the task key is not zero attempt to update the counters in the task_run table.
    -- =========================================================================
       If ( v_task_key <> 0 ) Then
           BEGIN
                Update ws_wrk_task_run
                Set
                        wtr_detail_count = wtr_detail_count + 1
                Where wtr_task_key = v_task_key
                And wtr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
               NULL;
           END;

       End If;

    -- =========================================================================
    -- If the job key is not zero attempt to update the counters in the job_run table.
    -- =========================================================================
       If ( v_job_key <> 0 ) Then
           BEGIN
                Update ws_wrk_job_run
                Set
                      wjr_detail_count = wjr_detail_count + 1
                Where wjr_job_key = v_job_key
                And wjr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
                NULL;
           END;

       End If;

    -- =========================================================================
    --Commit the message. This may be undesirable!!
    -- =========================================================================
     Commit;
     Return 1;   -- insert OK

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- insert failed
END WsWrkError;
 
_PROCEDURE_ WsWrkTask 
-- Notes / History:
-- ============================================================================
-- BC  14/08/2015   Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019   Version 8.4.1.0  Fix comments.

CREATE OR REPLACE FUNCTION WsWrkTask (
    v_job_key       number,
    v_task_key      number,
    v_sequence      number,
    v_inserted      number,
    v_updated       number,
    v_replaced      number,
    v_deleted       number,
    v_discarded     number,
    v_rejected      number,
    v_errored       number
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name     :   Oracle
    -- Script Name   :   WsWrkTask.sql
    -- Description   :   Updates counters in task_run
    -- Author        :   Wayne Richmond
    -- Date          :   28 November 2003
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_return        number := 1;

BEGIN

    -- =========================================================================
    -- check that all required fields are present.
    -- =========================================================================
    IF NVL(v_job_key,0) = 0
    OR NVL(v_task_key,0) = 0
    OR NVL(v_sequence,0) = 0
    THEN
      RETURN -1;
    END IF;

    -- =========================================================================
    -- If the task key is not zero attempt to update the counters in the task_run table.
    -- =========================================================================
     If ( v_task_key <> 0 ) Then
         BEGIN
              Update ws_wrk_task_run
              Set
                wtr_rec_inserted = v_inserted,
                wtr_rec_updated = v_updated,
                wtr_rec_replaced = v_replaced,
                wtr_rec_deleted = v_deleted,
                wtr_rec_discarded = v_discarded,
                wtr_rec_rejected = v_rejected,
                wtr_rec_errored = v_errored
              Where wtr_task_key = v_task_key
              And wtr_sequence = v_sequence;
         EXCEPTION WHEN OTHERS THEN
              v_return := -3;
         END;

     End If;

    -- =========================================================================
    --Commit the message. This may be undesirable!!
    -- =========================================================================
     Commit;
     Return v_return;   -- insert OK, or a warning on the update

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- insert failed
END WsWrkTask;
 
_PROCEDURE_ WsWrkAuditBulk 
-- Notes / History:
-- Inserts messages into the ws_wrk_audit_log table
-- Called by the scheduler or ws_job_execute when ever a task completes.
-- Also called by procedures wishing to log additional information.
-- Passed the following parameters:
--
-- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                       (W)arning, (E)rror, (F)atal
-- job_name           - Name of the Job, or some other name for result grouping
-- task_name          - Name of the procedure or Task or procedure
-- sequence           - Sequence number of the run
-- message            - Textual message to be placed in the audit log
-- rdbms_code         - The database error code if appropriate
-- rdbms_msg          - The database message if appropriate
-- task_id            - Key to the pms scheduler task
-- job_id             - Key to the pms scheduler job
--
-- ============================================================================
-- Calling:
-- v_result :=WsWrkAudit(v_status_code, v_job_name, v_task_name, v_sequence,
--                       v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key);
-- ============================================================================
-- WMR  22/01/2002   Version 1.0.0
-- WMR  01/08/2003   Version 4.1.0 added insert of wa_row_number
-- BC   14/08/2015   Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM   13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION WsWrkAuditBulk (
    v_status_code    varchar2,
    v_job_name       varchar2,
    v_task_name      varchar2,
    v_sequence       number,
    v_message        varchar2,
    v_db_code        varchar2,
    v_db_msg         varchar2,
    v_task_key       number,
    v_job_key        number
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name     :   Oracle
    -- Script Name   :   WsWrkAuditBulk.sql
    -- Description   :   Writes rows to audit log and if applicable to job_run and task_run
    -- Author        :   Wayne Richmond
    -- Date          :   2 December 1996
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_okay_count      number := 0;
    v_info_count      number := 0;
    v_warn_count      number := 0;
    v_error_count     number := 0;
    v_row_count       number := 0;
    v_stmt            varchar2(1024);
    v_return          number := 1;
    v_step            number;
    v_pos             number;
    v_loop            integer;
    v_start           integer;
    v_end             integer;
    v_size            integer;
    v_tilde           integer := 0;
    v_rows            integer := 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
    -- =========================================================================
    -- Insert the messages into the audit log. Catch all errors as we do not want to halt the
    -- calling procedure in the case of an insert failure
    -- =========================================================================

    --=====================================================
    -- Loop through the text passed
    -- saving a line after each newline character
    -- a line is a max of 1024 bytes long
    --=====================================================
    v_step := 30;
    v_loop := 1;
    v_start := 1;
    v_end := length(v_message);
    v_step := 40;

    WHILE v_loop = 1 LOOP
        v_step := 50;
        v_pos := instr(v_message,CHR(10),v_start,1);
        If nvl(v_pos,0) < 1 Then
            v_pos := instr(v_message,'~',v_start,1);
            If nvl(v_pos,0) >= 1 Then
               v_tilde := 1;
            Else
               v_tilde := 0;
            End If;
        Else
            v_tilde := 0;
        End If;
        v_step := 60;
        If nvl(v_pos,0) < 1 Then
            v_size := nvl(length(v_message),-1);
            v_loop := 0 ;
            v_size := (v_size - v_start);
            If v_tilde = 0 Then
                v_size := v_size + 1;
            End If;
            If v_size > 0 Then
                -- Maximum of 1024 characters in a line
                If v_size > 1024 Then
                    v_size := 1024;
                End If;
                v_stmt := substr(v_message,v_start,v_size);
                v_step := 81;
                v_row_count := v_row_count +1;
                v_step := 91;
                Insert into ws_wrk_audit_log
                (
                    wa_time_stamp,
                    wa_sequence,
                    wa_job,
                    wa_task,
                    wa_status,
                    wa_message,
                    wa_db_msg_code,
                    wa_db_msg_desc,
                    wa_task_key,
                    wa_job_key,
                    wa_row_number
                )
                Values
                (
                    sysdate,
                    v_sequence,
                    v_job_name,
                    v_task_name,
                    v_status_code,
                    v_stmt,
                    v_db_code,
                    v_db_msg,
                    v_task_key,
                    v_job_key,
                    ws_audit_log_seq.nextval
                );
            End If;
        Else
            v_step := 70;
            v_size := (v_pos - v_start);
            If v_tilde = 0 Then
                v_size := v_size + 1;
            End If;
            -- Maximum of 1024 characters in a line
            If v_size > 1024 Then
                v_size := 1024;
            End If;
            v_stmt := substr(v_message,v_start,v_size);
            v_step := 80;
            v_row_count := v_row_count +1;
            v_step := 90;
            Insert into ws_wrk_audit_log
            (
                wa_time_stamp,
                wa_sequence,
                wa_job,
                wa_task,
                wa_status,
                wa_message,
                wa_db_msg_code,
                wa_db_msg_desc,
                wa_task_key,
                wa_job_key,
                wa_row_number
            )
            Values
            (
                sysdate,
                v_sequence,
                v_job_name,
                v_task_name,
                v_status_code,
                v_stmt,
                v_db_code,
                v_db_msg,
                v_task_key,
                v_job_key,
                ws_audit_log_seq.nextval
            );
            v_start := v_pos + 1;
            v_step := 100;
            If v_start >= v_end Then
                v_loop := 0;
            End If;
        End If;

        -- only allow a maximum of 1000 rows from one task to
        -- prevent a blowout of the audit trail.
        v_rows := v_rows + 1;
        If v_rows >999 Then
           v_loop := 0;
           v_stmt := 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkAuditBulk';
            Insert into ws_wrk_audit_log
            (
                wa_time_stamp,
                wa_sequence,
                wa_job,
                wa_task,
                wa_status,
                wa_message,
                wa_db_msg_code,
                wa_db_msg_desc,
                wa_task_key,
                wa_job_key,
                wa_row_number
            )
            Values
            (
                sysdate,
                v_sequence,
                v_job_name,
                v_task_name,
                v_status_code,
                v_stmt,
                v_db_code,
                v_db_msg,
                v_task_key,
                v_job_key,
                ws_audit_log_seq.nextval
            );
       End If;
    END LOOP;



    -- =========================================================================
    -- If the task or job key is not zero we need to know which counter to increment
    -- =========================================================================

    If  v_task_key <> 0  Or  v_job_key <> 0 Then
         If  v_status_code  = 'S' Then
             v_okay_count := v_row_count;
         ElsIf  v_status_code  = 'I' Then
             v_info_count := v_row_count;
         ElsIf  v_status_code  = 'W' Then
             v_warn_count := v_row_count;
         ElsIf  v_status_code  = 'E' Then
             v_error_count := v_row_count;
         ElsIf  v_status_code  = 'F' Then
             v_error_count := v_row_count;
         End If;
    End If;

    -- =========================================================================
    -- If the task key is not zero attempt to update the counters in the task_run table.
    -- =========================================================================
    If ( v_task_key <> 0 ) Then
       BEGIN
            Update ws_wrk_task_run
            Set
                    wtr_info_count = wtr_info_count + v_info_count,
                    wtr_warning_count = wtr_warning_count + v_warn_count
            Where wtr_task_key = v_task_key
            And wtr_sequence = v_sequence;
       EXCEPTION WHEN OTHERS THEN
            v_return := 0;
       END;
    End If;

    -- =========================================================================
    -- If the job key is not zero attempt to update the counters in the job_run table.
    -- =========================================================================
    If ( v_job_key <> 0 ) Then
       BEGIN
            Update ws_wrk_job_run
            Set
                    wjr_okay_count = wjr_okay_count + v_okay_count,
                    wjr_info_count = wjr_info_count + v_info_count,
                    wjr_warning_count = wjr_warning_count + v_warn_count,
                    wjr_error_count = wjr_error_count + v_error_count
            Where wjr_job_key = v_job_key
            And wjr_sequence = v_sequence;
       EXCEPTION WHEN OTHERS THEN
            v_return := 0;
       END;
    End If;

    -- =========================================================================
    --Commit the message. This may be undesirable!!
    -- =========================================================================
    Commit;
    Return v_return;   -- insert OK, or a warning on the update

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- insert failed
END WsWrkAuditBulk;
 
_PROCEDURE_ WsWrkErrorBulk 
-- Notes / History:
-- Inserts messages into the Ws_wrk_error_log table
-- Called by procedures wishing to log detail information.
-- Passed the following parameters:
--
-- status_code         - Normal codes are (B)egin, (I)nformation, (S)uccess,
--                                        (W)arning, (E)rror, (F)atal
-- job_name            - Name of the Job, or some other name for result grouping
-- task_name           - Name of the procedure or Task or procedure
-- sequence            - Sequence number of the run
-- message             - Textual message to be placed in the audit log
-- rdbms_code          - The database error code if appropriate
-- rdbms_msg           - The database message if appropriate
-- task_id             - Key to the Ws scheduler task
-- job_id              - Key to the Ws scheduler job
-- msg_type            - Key to the message type table
-- severity            - Application specific severity indicator
-- action              - Possible corrective action
--
-- ============================================================================
-- Calling:
-- v_result := WsWrkBulkError(v_status_code, v_job_name, v_task_name, v_sequence,
--                        v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key,
--                        v_msg_type, v_severity, v_action);
-- ============================================================================
-- WMR 22/01/2002   Version 1.0.0
-- WMR 01/08/2003   Version 4.1.0   added insert of wd_row_number
-- BC  14/08/2015   Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION WsWrkErrorBulk (
    v_status_code   varchar2,
    v_job_name      varchar2,
    v_task_name     varchar2,
    v_sequence      number,
    v_message       varchar2,
    v_db_code       varchar2,
    v_db_msg        varchar2,
    v_task_key      number,
    v_job_key       number,
    v_msg_type      varchar2
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name     :   Oracle
    -- Script Name   :   WsWrkErrorBulk.sql
    -- Description   :   Writes bulk rows to the error log
    -- Author        :   Wayne Richmond
    -- Date          :   2 December 1996
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_row_count       number := 0;
    v_stmt            varchar2(1024);
    v_return          number := 1;
    v_step            number;
    v_pos             number;
    v_loop            integer;
    v_start           integer;
    v_end             integer;
    v_size            integer;
    v_tilde           integer := 0;
    v_rows            integer := 0;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
    -- =========================================================================
    -- Insert the messages into the log table. Catch any error as we do not want to hinder the
    -- calling procedure if we fail on our insert
    -- =========================================================================

     --=====================================================
    -- Loop through the text passed
    -- saving a line after each newline character
    -- a line is a max of 256 bytes long
    --=====================================================
    v_step := 30;
    v_loop := 1;
    v_start := 1;
    v_end := length(v_message);
    v_step := 40;

    WHILE v_loop = 1 LOOP
        v_step := 50;
        v_pos := instr(v_message,CHR(10),v_start,1);
        If nvl(v_pos,0) < 1 Then
            v_pos := instr(v_message,'~',v_start,1);
            If nvl(v_pos,0) >= 1 Then
               v_tilde := 1;
            Else
               v_tilde := 0;
            End If;
        Else
            v_tilde := 0;
        End If;
        v_step := 60;
        If nvl(v_pos,0) < 1 Then
            v_size := nvl(length(v_message),0);
            v_loop := 0 ;
            v_size := (v_size - v_start);
            If v_tilde = 0 Then
               v_size := v_size + 1;
            End If;
            If v_size > 0 Then
                -- Maximum of 1024 characters in a line
                If v_size > 1024 Then
                    v_size := 1024;
                End If;
                v_stmt := substr(v_message,v_start,v_size);
                v_step := 81;
                v_row_count := v_row_count +1;
                v_step := 91;
                Insert into Ws_wrk_error_log
                 (
                    wd_time_stamp,
                    wd_sequence,
                    wd_job,
                    wd_task,
                    wd_status,
                    wd_message,
                    wd_db_msg_code,
                    wd_db_msg_desc,
                    wd_task_key,
                    wd_job_key,
                    wd_msg_type_code,
                    wd_row_number
                 )
                 Values
                 (
                    sysdate,
                    v_sequence,
                    v_job_name,
                    v_task_name,
                    v_status_code,
                    v_stmt,
                    v_db_code,
                    v_db_msg,
                    v_task_key,
                    v_job_key,
                    v_msg_type,
                    ws_error_log_seq.nextval
                );
            End If;
        Else
            v_step := 70;
            v_size := (v_pos - v_start);
            If v_tilde = 0 Then
               v_size := v_size + 1;
            End If;
            -- Maximum of 1024 characters in a line
            If v_size > 1024 Then
                v_size := 1024;
            End If;
            v_stmt := substr(v_message,v_start,v_size);
            v_step := 80;
            v_row_count := v_row_count +1;
            v_step := 90;
            Insert into Ws_wrk_error_log
             (
                wd_time_stamp,
                wd_sequence,
                wd_job,
                wd_task,
                wd_status,
                wd_message,
                wd_db_msg_code,
                wd_db_msg_desc,
                wd_task_key,
                wd_job_key,
                wd_msg_type_code,
                wd_row_number
             )
             Values
             (
                sysdate,
                v_sequence,
                v_job_name,
                v_task_name,
                v_status_code,
                v_stmt,
                v_db_code,
                v_db_msg,
                v_task_key,
                v_job_key,
                v_msg_type,
                ws_error_log_seq.nextval
            );
            v_start := v_pos + 1;
            v_step := 100;
            If v_start >= v_end Then
                v_loop := 0;
            End If;
        End If;
        -- only allow a maximum of 2000 rows from one task to
        -- prevent a blowout of the error trail.
        v_rows := v_rows + 1;
        If v_rows >1999 Then
           v_loop := 0;
           v_stmt := 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkErrorBulk';
             Insert into Ws_wrk_error_log
             (
                wd_time_stamp,
                wd_sequence,
                wd_job,
                wd_task,
                wd_status,
                wd_message,
                wd_db_msg_code,
                wd_db_msg_desc,
                wd_task_key,
                wd_job_key,
                wd_msg_type_code,
                wd_row_number
             )
             Values
             (
                sysdate,
                v_sequence,
                v_job_name,
                v_task_name,
                v_status_code,
                v_stmt,
                v_db_code,
                v_db_msg,
                v_task_key,
                v_job_key,
                v_msg_type,
                ws_error_log_seq.nextval
            );
       End If;
    END LOOP;



    -- =========================================================================
    -- If the task key is not zero attempt to update the counters in the task_run table.
    -- =========================================================================
       If ( v_task_key <> 0 ) Then
           BEGIN
                Update ws_wrk_task_run
                Set
                        wtr_detail_count = wtr_detail_count + v_row_count
                Where wtr_task_key = v_task_key
                And wtr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
               NULL;
           END;

       End If;

    -- =========================================================================
    -- If the job key is not zero attempt to update the counters in the job_run table.
    -- =========================================================================
       If ( v_job_key <> 0 ) Then
           BEGIN
                Update ws_wrk_job_run
                Set
                      wjr_detail_count = wjr_detail_count + v_row_count
                Where wjr_job_key = v_job_key
                And wjr_sequence = v_sequence;
           EXCEPTION WHEN OTHERS THEN
                NULL;
           END;

       End If;

    -- =========================================================================
    --Commit the message. This may be undesirable!!
    -- =========================================================================
     Commit;
     Return 1;   -- insert OK

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- insert failed
END WsWrkErrorBulk;
 
_PROCEDURE_ WsWrkChkPoint 
-- Notes / History:
-- Updated the checkpoint number in the ws_wrk_job_run table
-- Called by the scheduler or ws_job_execute when a checkpoint task is encountered.
-- Also called by procedures wishing to utilize checkpoints.
-- Passed the following parameters:
--
-- job_id                - The job key
-- sequence              - The job sequence number
-- checkpoint_number     - The number to insert into the job table
--
-- ============================================================================
-- Calling:
-- v_result := PmsWrkChkPoint(v_job_id, v_sequence, v_chkpoint);
-- ============================================================================
-- WMR  22/01/2002   Version 1.0.0

CREATE OR REPLACE FUNCTION WsWrkChkPoint (
    v_job_key	        	number,
    v_sequence		number,
    v_chkpoint		number
    )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   WsWrkChkPoint.sql
    -- Description    :   Writes row to the detail log
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================

BEGIN
    -- =========================================================================
    -- Update the job run table. Catch any error as we do not want to hinder the
    -- calling procedure if we fail on our update
    -- =========================================================================

        Update ws_wrk_job_run
        Set        wjr_chkp_number = v_chkpoint
        Where   wjr_job_key = v_job_key
        And        wjr_sequence = v_sequence;


    -- =========================================================================
    --Commit the change. This may be undesireable !!
    -- =========================================================================
     Commit;
     Return 1;   -- update OK

EXCEPTION
    WHEN OTHERS Then
    Return -3;  -- update failed
END WsWrkChkPoint;
 
_PROCEDURE_ WsParameterRead 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterRead(v_parameter_name);
-- ============================================================================
-- WMR  22/01/2002   Version 1.0.0

CREATE OR REPLACE FUNCTION WsParameterRead (
    v_parameter        	varchar2
    )
    RETURN varchar2
    AUTHID CURRENT_USER
    IS
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   WsParameterRead.sql
    -- Description    :   Reads an entry from the parameter table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================
   
    v_value                varchar2(2000);

BEGIN
    -- =========================================================================
    -- Select the parameter from the table and return the value
    -- =========================================================================

    Select dss_parameter_value into v_value
    from dss_parameter
    where upper(ltrim(rtrim(dss_parameter_name))) = upper(ltrim(rtrim(v_parameter)));

    Return v_value;   -- return the parameter value

EXCEPTION
    WHEN OTHERS Then
    v_value := '';
    Return v_value;  -- return null
END WsParameterRead;
 
_PROCEDURE_ WsParameterReadG 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterReadG(v_parameter_name, job_key, task_key);
-- ============================================================================
-- WMR  14/01/2003   Version 41.0
-- BC   27/06/2016   Version 6.8.6.1  RED-6790: Don't match on the job key, because a child job gets given the job key of its parent job (if any) so that auditing is all accurate.

CREATE OR REPLACE FUNCTION WsParameterReadG (
    p_parameter   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number
    )
    RETURN varchar2
    AUTHID CURRENT_USER
    IS
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   WsParameterReadG.sql
    -- Description    :   Reads a Global parameter
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================
   
    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    --=====================================================
    -- Variables
    --=====================================================
    v_value           varchar2(2000);
    v_obj_key         integer := 0;
    v_obj_type        integer := 0;

BEGIN
  -- =========================================================================
  -- If the job number is zero then the task number is the object id
  -- otherwise we need to find the object from the task.
  -- =========================================================================
  IF p_job_id IS NULL or p_job_id = 0 THEN
    v_obj_key := p_task_id;
  ELSE
    SELECT wtr_obj_key INTO v_obj_key
    FROM   ws_wrk_task_run
    WHERE  wtr_task_key = p_task_id
-- RED-6790: Don't match on the job key, because a child job gets given the job key of its parent job (if any) so that auditing is all accurate.
--    AND    wtr_job_key = p_job_id
    ;
  END IF;

  -- =========================================================================
  -- make sure we have a valid object key else quit
  -- =========================================================================
  IF v_obj_key IS NULL OR v_obj_key  = 0 THEN
    v_value := '';
    RETURN v_value;  -- return null
  END IF;

  -- =========================================================================
  -- get the object type
  -- =========================================================================
  SELECT oo_type_key INTO v_obj_type
  FROM   ws_obj_object
  WHERE  oo_obj_key = v_obj_key;

  -- =========================================================================
  -- make sure we have a valid object type else quit
  -- =========================================================================
  IF v_obj_type IS NULL OR v_obj_type  = 0 THEN
    v_value := '';
    RETURN v_value;  -- return null
  END IF;

  -- =========================================================================
  -- If the parameter is $$TABLE_NAME then return the table name
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(p_parameter))) = '$$TABLE_NAME' THEN
    IF v_obj_type = v_ws_obj_load THEN
      v_value := '';
      SELECT lt_table_name INTO v_value
      FROM ws_load_tab
      WHERE lt_obj_key = v_obj_key;
      RETURN v_value;
    END IF;
  END IF;

  -- =========================================================================
  -- If the parameter is $$SOURCE_TABLE then return the source table
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(p_parameter))) = '$$SOURCE_TABLE' THEN
    IF v_obj_type = v_ws_obj_load THEN
      v_value := '';
      SELECT max(lc_src_table) INTO v_value
      FROM ws_load_col
      WHERE lc_obj_key = v_obj_key;
      RETURN v_value;
    END IF;
  END IF;


  v_value := '';
  Return v_value;  -- return null

EXCEPTION
    WHEN OTHERS Then
    v_value := '';
    Return v_value;  -- return null
END WsParameterReadG;
 
_PROCEDURE_ WsParameterReadJ 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_value := WsParameterReadJ(v_parameter_name, job_key);
-- ============================================================================
-- WMR  23/04/2004   Version 4.1.0.8

CREATE OR REPLACE FUNCTION WsParameterReadJ (
    p_parameter   IN  varchar2,
    p_job_id      IN  number
    )
    RETURN varchar2
    AUTHID CURRENT_USER
    IS
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   WsParameterReadJ.sql
    -- Description    :   Reads job parameters
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================
   
    --=====================================================
    -- Variables
    --=====================================================
    v_value           varchar2(2000);

BEGIN

  -- =========================================================================
  -- make sure we have a valid job key else quit
  -- =========================================================================
  IF p_job_id IS NULL OR p_job_id  = 0 THEN
    v_value := '';
    RETURN v_value;  -- return null
  END IF;

  -- =========================================================================
  -- If the parameter is NAME then return the job name
  -- =========================================================================
  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'NAME' THEN
    v_value := '';
    SELECT wjr_name INTO v_value
    FROM ws_wrk_job_run
    WHERE wjr_job_key = p_job_id;
    RETURN v_value;
  END IF;


--  -- =========================================================================
--  -- If the parameter is DESCRIPTION then return the job description
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'DESCRIPTION' THEN
--    v_value := '';
--    SELECT wjr_description INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE1 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE1' THEN
--    v_value := '';
--    SELECT wjr_attribute1 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE2 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE2' THEN
--    v_value := '';
--    SELECT wjr_attribute2 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE3 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE3' THEN
--    v_value := '';
--    SELECT wjr_attribute3 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE4 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE4' THEN
--    v_value := '';
--    SELECT wjr_attribute4 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE5 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE5' THEN
--    v_value := '';
--    SELECT wjr_attribute5 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE6 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE6' THEN
--    v_value := '';
--    SELECT wjr_attribute6 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE7 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE7' THEN
--    v_value := '';
--    SELECT wjr_attribute7 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;
--
--  -- =========================================================================
--  -- If the parameter is ATRRIBUTE8 then return the attribute
--  -- =========================================================================
--  IF UPPER(LTRIM(RTRIM(p_parameter))) = 'ATTRIBUTE8' THEN
--    v_value := '';
--    SELECT wjr_attribute8 INTO v_value
--    FROM ws_wrk_job_run
--    WHERE wjr_job_key = p_job_id;
--    RETURN v_value;
--  END IF;


  v_value := '';
  Return v_value;  -- return null

EXCEPTION
    WHEN OTHERS Then
    v_value := '';
    Return v_value;  -- return null
END WsParameterReadJ;
 
_PROCEDURE_ WsParameterWrite 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_result := WsParameterWrite(v_parameter_name, v_value, v_comments);
-- ============================================================================
-- WMR 22/01/2002  Version 1.0.0
-- WMR 23/05/2005  Version 4.2.0.0 Added pragma autonomous
-- WMR 06/03/2006  Version 5.0.1.1 Leave comments alone if null passed

CREATE OR REPLACE FUNCTION WsParameterWrite (
    v_parameter      IN    varchar2,
    v_value          IN    varchar2,
    v_comments       IN    varchar2
    )
    RETURN varchar2
    AUTHID CURRENT_USER
    AS PRAGMA AUTONOMOUS_TRANSACTION;
    
    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   WsParameterWrite.sql
    -- Description    :   Write or update an entry in the parameter table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
    -- =============================================================================

    v_result               integer;
    v_comment              varchar2(256);


BEGIN
    -- =========================================================================
    -- Update or Insert the parameter
    -- =========================================================================
    v_comment := v_comments;

    Update dss_parameter
    Set dss_parameter_value = v_value,
        dss_parameter_comments = NVL(v_comment, dss_parameter_comments)
    where upper(ltrim(rtrim(dss_parameter_name))) = upper(ltrim(rtrim(v_parameter)));

    IF SQL%NOTFOUND THEN

       Insert into dss_parameter (dss_parameter_name, dss_parameter_value,
                                dss_parameter_comments)
        Values (
            v_parameter,
            v_value,
            NVL(v_comment,'Inserted via WsParamaterWrite'));
        v_result := 2;
    Else
        v_result := 1;
    End If;

    COMMIT;

    Return v_result;   -- return an indicator 1=done, 2 = added

EXCEPTION
    WHEN OTHERS Then
    v_result := -3;
    Return v_result;  -- return an error
END WsParameterWrite;
 
_PROCEDURE_ WsParameterReplace 
-- Notes / History:
--
-- :============================================================================
-- Calling:
-- v_return_value := WsParameterReplace(v_incoming_string, max_length);
-- :============================================================================
-- AP  19/09/2006   Version 5.5.0.5
-- AP  07/11/2006   Version 5.5.0.9 Ensure no replace of values in params
--                                  Don't process as $P if has "'s around it
--                                  Leave parameter name there if no value exits
--                                  Decided to not use the "'s logic so force to not work    
-- AP  19/02/2008   Version 5.6.3.1 Increased storage to 10k which is max for a function to return
-- AP  20/07/2011   Version 6.5.4.1 When no param found continue search from after the found $P
--                                  previously it searched from after terminating $ and hence risked missing
--                                  the next $P
-- AP  09/07/2012   Version 6.6.2.0 Corrected issue introduced above where testing on v_work not v_parameter
-- HM  11/07/2014   Version 6.8.1.1 Extended varchar2 variables to maximum size (32767).

CREATE OR REPLACE FUNCTION WsParameterReplace (
    p_incoming    varchar2
   ,p_max         integer
   )
   RETURN varchar2
   AUTHID CURRENT_USER
   IS
    
   -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

   -- :============================================================================
   -- DBMS Name      :   ORACLE
   -- Script Name    :   WsParameterReplace.sql
   -- Description    :   Replaces occurrences of Parameters in a string
   -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
   -- :=============================================================================

   v_return_status   integer;       -- Update result status
   v_row_count       integer;       -- General row count
   v_work            varchar2(32767);
   v_work2           varchar2(32767);
   v_parameter       varchar2(32767);
   v_spos            integer;
   v_epos            integer;
   v_qspos           integer;
   v_qepos           integer;
   v_search_value    varchar2(32767);
   v_return_value    varchar2(32767);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
BEGIN
  v_return_value := '';
  v_search_value := p_incoming;
  -- look for first $P
  v_spos := INSTR(v_search_value,'$P');
  WHILE  v_spos > 0
  LOOP
    -- look for first dbl quote
    v_qspos := 0; -- (forced removal of this check) INSTR(v_search_value,'"');

    -- Check if Quotes before or after the parameter
    IF v_qspos < v_spos
    AND v_qspos > 0
    THEN -- have double quotes somewhere before the first parameter
      -- append up to the "
      v_return_value := v_return_value || SUBSTR(v_search_value,1,v_qspos);

      -- remove up to and including the quote from the search string
      v_search_value := SUBSTR(v_search_value,v_qspos+1,LENGTH(v_search_value)-v_qspos );

      -- find terminating quote
      v_qepos := INSTR(v_search_value,'"');

      IF v_qepos > 0
      THEN
        -- append up to the "
        v_return_value := v_return_value || SUBSTR(v_search_value,1,v_qepos);

        -- remove up to and including the quote from the search string
        v_search_value := SUBSTR(v_search_value,v_qepos+1,LENGTH(v_search_value)-v_qepos );

      END IF;
      -- look for any more $P
      v_spos := INSTR(v_search_value,'$P');

    ELSE
      -- append up to the $P
      v_return_value := v_return_value || SUBSTR(v_search_value,1,v_spos-1);
      --remove up to and including the $P from the search string
      v_search_value := SUBSTR(v_search_value,v_spos+2,LENGTH(v_search_value)-v_spos-1);

      --find terminating $
      v_epos := INSTR(v_search_value,'$');

      IF v_epos = 0
      THEN
        v_spos := 0;
        v_return_value := v_return_value || '$P';
      ELSE
        -- determine the parameter name
        v_work := SUBSTR(v_search_value,1,v_epos-1);

        -- extract the parameter value
        SELECT WsParameterRead(v_work) into v_parameter FROM DUAL;

        IF v_parameter IS NULL
        THEN
          -- leave the search string alone and just append the $P to the return value
          v_return_value := v_return_value || '$P';
        ELSE 
          -- append the parameter value
          v_return_value := v_return_value || v_parameter;
  
          -- remove up to terminating $ from the search string
          v_search_value := SUBSTR(v_search_value,v_epos+1,LENGTH(v_search_value)-v_epos);
        END IF;

        -- look for any more $P
        v_spos := INSTR(v_search_value,'$P');

      END IF;
    END IF;
  END LOOP;

  -- Append rest of string
  v_return_value := v_return_value || v_search_value;

  -- If going to be too big then NULL it out to be handled on return
  IF LENGTH(v_return_value) > p_max THEN
    v_return_value := NULL;
  END IF;

  RETURN v_return_value;

EXCEPTION
    WHEN OTHERS Then
    v_return_value := '';
    Return v_return_value;  -- return null
END WsParameterReplace;

 
_PROCEDURE_ Ws_Object_Info 
-- Notes / History
--
-- JML 21/02/2008     Version 5.6.3.1
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION Ws_Object_Info
  ( p_sequence        IN  integer
  , p_job_name        IN  varchar2
  , p_task_name       IN  varchar2
  , p_job_id          IN  integer
  , p_task_id         IN  integer
  , p_obj_key         IN  integer
  , p_obj_name        IN  varchar2
  , p_info_type       IN  varchar2
  , p_return_code     OUT varchar2
  , p_return_msg      OUT varchar2
  , p_result          OUT integer
  )
RETURN VARCHAR2
AUTHID CURRENT_USER
IS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Oracle
  -- Script Name  : Ws_Object_Info
  -- Description  : Returns requested information regarding an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants
  --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

  --=====================================================
  -- Variables
  --=====================================================
  v_msgtext                  VARCHAR2(1024);  -- Text for audit_trail
  v_set                      INTEGER;         -- commit set
  v_analyze_flag             INTEGER;         -- analyze flag
  v_step                     INTEGER;         -- step number
  v_update_count             INTEGER;         -- no of records updated
  v_insert_count             INTEGER;         -- no of records inserted
  v_count                    INTEGER;         -- General counter
  v_result                   INTEGER;         -- return code

  v_obj_count                INTEGER;
  v_obj_key                  INTEGER;
  v_obj_name                 VARCHAR2(64);
  v_obj_type                 INTEGER;
  v_tablespace               VARCHAR2(64);
  v_short_name               VARCHAR2(64);
  v_info_type                VARCHAR2(64);
  v_value                    VARCHAR2(4000);

BEGIN

  v_step := 100;

  IF ( p_obj_key IS NOT NULL AND p_obj_name IS NOT NULL ) THEN

    p_return_code := 'E';
    p_return_msg := 'Unable to get info as a maximum of one of p_obj_key and p_obj_name can be specified.';
    p_result := -2;
    v_value := '';

    RETURN v_value;

  END IF;

  v_step := 200;

  IF ( p_obj_key IS NOT NULL ) THEN

    v_step := 300;

    SELECT COUNT(*)
         , MAX(oo_name)
         , MAX(oo_type_key)
    INTO   v_obj_count
         , v_obj_name
         , v_obj_type
    FROM   ws_obj_object
    WHERE  oo_obj_key = p_obj_key
    ;

    v_step := 400;

    v_obj_key := p_obj_key;

  ELSIF ( TRIM(p_obj_name) IS NOT NULL ) THEN

    v_step := 500;

    SELECT COUNT(*)
         , MAX(oo_obj_key)
         , MAX(oo_type_key)
    INTO   v_obj_count
         , v_obj_key
         , v_obj_type
    FROM   ws_obj_object
    WHERE  LOWER(oo_name) = LOWER(p_obj_name)
    ;

    v_step := 600;

    v_obj_name := p_obj_name;

  ELSE

    v_step := 700;

    p_return_code := 'E';
    p_return_msg := 'Unable to check for object existance, either p_obj_key or p_obj_name must be specified.';
    p_result := -2;
    v_value := '';

    RETURN v_value;

  END IF;

  v_step := 800;

  IF ( v_obj_count = 1 ) THEN

    v_step := 900;

    IF ( UPPER(p_info_type) IN ('DATABASE','TABLESPACE','FILEGROUP','SHORTNAME') ) THEN

      v_step := 1000;

      v_info_type := p_info_type;

      v_step := 1100;

      IF ( v_obj_type = v_ws_obj_load ) THEN

        v_step := 1200;

        SELECT lt_tablespace
             , lt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_load_tab
        WHERE  lt_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_dim ) THEN

        v_step := 1300;

        SELECT dt_tablespace
             , dt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_dim_tab
        WHERE  dt_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_view ) THEN

        v_step := 1400;

        SELECT vt_tablespace
             , vt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_view_tab
        WHERE  vt_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_fact ) THEN

        v_step := 1500;

        SELECT ft_tablespace
             , ft_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_fact_tab
        WHERE  ft_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_stage ) THEN

        v_step := 1600;

        SELECT st_tablespace
             , st_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_stage_tab
        WHERE  st_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_agg ) THEN

        v_step := 1700;

        SELECT at_tablespace
             , at_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_agg_tab
        WHERE  at_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_index ) THEN

        v_step := 1800;

        SELECT ih_tablespace
             , ih_index_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_index_header
        WHERE  ih_index_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_join ) THEN

        v_step := 1900;

        SELECT jt_tablespace
             , jt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_join_tab
        WHERE  jt_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_export ) THEN

        v_step := 2000;

        SELECT et_tablespace
             , et_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_export_tab
        WHERE  et_obj_key = v_obj_key
        ;

      ELSIF (( v_obj_type = v_ws_obj_retro ) OR ( v_obj_type = v_ws_obj_retro_copy )) THEN

        v_step := 2100;

        SELECT rt_tablespace
             , rt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_retro_tab
        WHERE  rt_obj_key = v_obj_key
        ;

      ELSIF ( v_obj_type = v_ws_obj_ods ) THEN

        v_step := 2000;

        SELECT ot_tablespace
             , ot_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_ods_tab
        WHERE  ot_obj_key = v_obj_key
        ;

      ELSIF v_obj_type = v_ws_obj_normal
      OR v_obj_type = v_ws_obj_hub
      OR v_obj_type = v_ws_obj_satellite
      OR v_obj_type = v_ws_obj_link
      OR v_obj_type = v_ws_obj_custom1
      OR v_obj_type = v_ws_obj_custom2
      THEN

        v_step := 2000;

        SELECT nt_tablespace
             , nt_short_name
        INTO   v_tablespace
             , v_short_name
        FROM   ws_normal_tab
        WHERE  nt_obj_key = v_obj_key
        ;

      ELSE

        v_step := 2200;

        p_return_code := 'E';
        p_return_msg := 'Unable to find object''s database: unsupported object type.';
        p_result := -2;
        v_value := '';

        RETURN v_value;

      END IF;

      v_step := 2300;

      IF ( UPPER(p_info_type) = 'SHORTNAME' ) THEN

        v_step := 2400;

        v_value := v_short_name;

        v_step := 2500;

        p_return_code := 'S';
        p_return_msg := 'Object ' || v_obj_name || ' (object key ' || TO_CHAR(v_obj_key) || ') is an object type ' || TO_CHAR(v_obj_type) || ' with a short name of ' || v_value;
        p_result := 1;

      ELSE

        v_step := 2600;

        v_value := v_tablespace;

        v_step := 2700;

        p_return_code := 'S';
        p_return_msg := 'Object ' || v_obj_name || ' (object key ' || TO_CHAR(v_obj_key) || ') is an object type ' || TO_CHAR(v_obj_type) || ' located in database ' || v_value;
        p_result := 1;

      END IF;

      v_step := 2800;

    ELSIF ( UPPER(p_info_type) = 'NAME' ) THEN

      v_step := 2900;

      v_value := v_obj_name;

      v_step := 3000;

      p_return_code := 'S';
      p_return_msg := 'Object with key ' || TO_CHAR(v_obj_key) || ' is called: ' || v_value;
      p_result := 1;

    ELSIF ( UPPER(p_info_type) = 'KEY' ) THEN

      v_step := 3100;

      v_value := TO_CHAR(v_obj_key);

      v_step := 3200;

      p_return_code := 'S';
      p_return_msg := 'Object ' || v_obj_name || ' has a key of: ' || TO_CHAR(v_obj_key);
      p_result := 1;

    ELSIF ( UPPER(p_info_type) = 'TYPE' ) THEN

      v_step := 3300;

      SELECT ot_description
      INTO  v_value
      FROM   ws_obj_type
      WHERE  ot_type_key = v_obj_type
      ;

      v_step := 3400;

      p_return_code := 'S';
      p_return_msg := 'Object ' || v_obj_name || ' (object key ' || TO_CHAR(v_obj_key) || ') is an object type ' || v_value;
      p_result := 1;

    ELSE

      v_step := 3500;

      v_info_type := p_info_type;
      p_return_code := 'E';
	p_return_msg := 'Object ' || v_obj_name || ' (object key ' || TO_CHAR(v_obj_key) || ') is an object type ' || TO_CHAR(v_obj_type) || ' located in tablespace ' || v_value;
      p_result := -2;
      v_value := '';

      RETURN v_value;

    END IF;

  ELSE

    v_step := 3600;

    p_return_code := 'E';

    IF ( TRIM(p_obj_name) IS NOT NULL ) THEN

      p_return_msg := 'The object ' || p_obj_name || ' does not exists.';

    ELSE

      p_return_msg := 'The object with key ' || TO_CHAR(p_obj_key) || ' does not exists.';

    END IF;

    p_result := -2;
    v_value := '';

  END IF;

  v_step := 3700;

  RETURN v_value;

EXCEPTION
  --=================================================================
  -- Unhandled Exception. Return with Fatal Error
  --=================================================================
  WHEN OTHERS THEN
    v_msgtext := SUBSTR('Unhandled Exception in Ws_Object_Info. '||
        ' Step ' || TO_CHAR(v_step) ||
        '   SQL Error Code: ' || SQLCODE || ' - ' || SQLERRM,1,1023);
    v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence
                          , v_MsgText, SQLCODE, SQLERRM, p_task_id, p_job_id);
    p_return_code := 'F';
    p_return_msg := v_msgtext;
    p_result := -2;
    v_value := '';

    RETURN v_value;

END Ws_Object_Info;
 
_PROCEDURE_ Ws_Act_Analyze 
-- Notes / History
--
-- WMR 22/01/2002  Version 1.0.0
-- WMR 05/04/2002  Version 1.0.7    Added for all indexed columns to analyze
-- WMR 27/09/2004  Version 4.1.0.9  Changed to just one analyze
-- WMR 24/06/2005  Version 4.1.2.11 include the schema name in the analyze if flag set
-- WMR 17/02/2006  Version 5.0.0.2  Look up command to run from ws_table_attributes
-- WMR 07/03/2006  Version 5.0.1.1  Put a begin / End around the ws_table_attributes lookup
-- AP  24/11/2014  Version 6.8.1.2  Schema Support
-- KH  22/10/2015  Version 6.8.4.4  Statement increased to > 4000
-- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_analyze
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_percent     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_act_analyze
    -- Description    :    Analyze a table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(4200);
--    v_stmt2           varchar2(256);
    v_cursor          number;
    v_schema_flag     integer := 0;
    v_dss_schema      varchar2(64);
    v_satellite_ind   varchar2(1);

    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_index_name      varchar2(64);
    v_index_with_schema varchar2(150);


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN


    v_step := 5;
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      IF p_obj_type = v_ws_obj_index THEN
        v_step := 110;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
                  ,ih_index_name
        INTO       v_table_schema
                  ,v_table_name
                  ,v_index_name
        FROM       ws_index_header
        LEFT JOIN  ws_obj_object
        ON         ws_obj_object.oo_obj_key = ih_obj_key
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      UPPER(ws_index_header.ih_index_name) = UPPER(p_task_name)
        ;
      else
        v_step := 120;
        v_index_name := '';
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      UPPER(ws_obj_object.oo_name) = UPPER(p_task_name)
        ;
      END IF;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found name:' || p_task_name;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_index_with_schema := v_table_with_schema || v_index_name;
    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 10;
    --=====================================================
    -- Handle either an Index or a Table
    --=====================================================
    If p_obj_type = v_ws_obj_index Then

        If p_percent = 100 Then
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_9 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$INDEX$',p_task_name);
            ELSE
              v_stmt := 'analyze index '||v_index_with_schema;
              v_stmt := v_stmt||' compute statistics';
            END IF;
        Else
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_10 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$INDEX$',p_task_name);
            ELSE
              v_stmt := 'analyze index '||v_index_with_schema;
              v_stmt := v_stmt||' estimate statistics sample '||
                          p_percent || ' percent';
            END IF;
        End If;
        p_return_msg := 'Index '||p_task_name||' analyzed';

        -- Execute the analyze
        v_step := 90;
        Execute Immediate v_stmt;
        v_step := 92;
   Else
        --=====================================================
        -- Table
        --=====================================================

        If p_percent = 100 Then
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_5 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$TABLE$',p_task_name);
            ELSE
              v_stmt := 'analyze table '||v_table_with_schema ;
              v_stmt := v_stmt||' compute statistics';
            END IF;
        Else
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_6 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$TABLE$',p_task_name);
            ELSE
              v_stmt := 'analyze table '||v_table_with_schema ;
              v_stmt := v_stmt||' estimate statistics sample '||
                          p_percent || ' percent';
            END IF;
        End If;
        p_return_msg := 'Table '||p_task_name||' analyzed ';

        -- Execute the analyze
        v_step := 94;
        Execute Immediate v_stmt;
        v_step := 96;



    End If;

    v_MsgText := substr(v_stmt,1,1023);
    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                  v_MsgText,NULL,NULL, p_task_id, p_job_id);

    p_status_code := 1;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_analyze. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        v_MsgText := substr(v_stmt,1,1023);
        v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_analyze step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_analyze;
 
_PROCEDURE_ Ws_Act_Build 
-- Notes / History
--
-- WMR 30/08/2001 Ver 0.3.0.6  Added support for Primary Keys
-- WMR 21/01/2002 Ver 1.0.0.0  Added support for Partitioned indexes
-- WMR 20/03/2002 Ver 1.0.0.6  Added support for Parallel Index builds
-- WMR 02/12/2002 ver 1.2.1.5  Fixed missing K in index build. Added PctUsed
-- WMR 24/12/2003 Ver 4.1.0.0  Added support for compressed indexes
-- WMR 17/04/2004 Ver 4.1.0.8  Added support for compute statistics during index build
-- WMR 18/05/2004 Ver 4.1.0.8  Added support fro buffer pool options
-- WMR 25/05/2004 Ver 4.1.0.8  Added support for pctfree column and function indexes
-- WMR 23/07/2004 Ver 4.1.0.8  Added support p_parameter being passed in
-- WMR 24/06/2005 Ver 4.1.2.11 Include the schema name in the create if flag set
-- WMR 05/07/2005 Ver 4.1.2.13 Changed user_tab_partitions to all_tab_partitions
-- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to all out messages
--                             Add call to wswrkerror for each index as built
-- AP  19/06/2009 Ver 6.0.4.1  Include parallel and nologging where missed
--                             Also added missing buffer pool settings
-- JML 22/09/2009 Ver 6.0.5.1  Several varchars changed to 32k to accommodate
--                             larger partitioned tables.
-- AP  30/05/2014 Ver 6.8.0.1  Include invisible option
-- HM  15/08/2014 Ver 6.8.1.2  Added Schema support
-- BC  14/08/2015 Ver 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  03/10/2017 Ver 8.1.1.0  Added support for Source Mapping
-- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_build
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_parameter   IN  varchar2,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_build
    -- Description    : Build any indexes due for rebuild
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_obj_source_mapping    constant number := 69;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText                  varchar2(1024); -- Text in audit_trail
    v_step                     integer := 0;   -- return code
    v_result                   integer := 0;   -- return code
    v_stmt                     varchar2(32000);
    v_count                    integer := 0;
    v_columns                  varchar2(32000);
    v_col_number               integer := 0;
    v_index_key                integer := 0;
    v_day                      integer := 0;
    v_day_name                 varchar2(3);
    v_month_end                integer := 0;
    v_month                    integer := 0;
    v_tommorrow_month          integer := 0;
    v_part_count               integer := 0;
    v_row                      integer := 0;
    v_pctfree                  integer := 0;
    v_pctinc                   integer := 0;
    v_no_tablespace            integer := 0;
    v_primary_key              integer := 0;
    v_epos                     integer := 0;
    v_spos                     integer := 0;
    v_fix                      varchar2(32000);
    v_function                 varchar2(32000);
    v_user_tablespace          varchar2(32000);
    v_schema_flag              integer := 0;
    v_satellite_ind            varchar2(1);
    v_dss_schema               varchar2(64);
    v_stats_include            varchar2(1);
    v_index_done               integer;        -- used to flag if action successful
    v_msg_result               integer := 0;   -- return code
    v_table_schema             varchar2(64);
    v_table_name               varchar2(64);
    v_table_with_schema        varchar2(150);
    v_index_name               varchar2(64);
    v_index_with_schema        varchar2(150);

    --=====================================================
    -- Cursor for all indexes
    --=====================================================
    Cursor c_Index is
          Select * from ws_index_header
          Where ih_obj_key = p_obj_key
          And ih_active = 'Y';

    --=====================================================
    -- Cursor for specified index
    --=====================================================
    Cursor c_IndexOnly is
          Select * from ws_index_header
          Where ih_index_key = p_obj_key;

    --=====================================================
    -- Cursor for index columns
    --=====================================================
    Cursor c_IndCol is
          Select ic_column, ic_foreign_table, ic_foreign_column
          from ws_index_col
          Where ic_index_key = v_index_key
          Order by ic_column_no;

    --=====================================================
    -- Cursor for partitions when schema must be used
    --=====================================================
    Cursor c_AllPartitionEx is
          Select partition_name
          from all_tab_partitions
          Where table_name = upper(v_table_name)
          And table_owner = upper(v_table_schema)
          Order by partition_position;

BEGIN

    v_step := 100;
    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';

    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      IF p_obj_type = v_ws_obj_index THEN
        v_step := 110;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
                  ,ih_index_name
        INTO       v_table_schema
                  ,v_table_name
                  ,v_index_name
        FROM       ws_index_header
        LEFT JOIN  ws_obj_object
        ON         ws_obj_object.oo_obj_key = ih_obj_key
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_index_header.ih_index_key = p_obj_key
        ;
      ELSIF p_obj_type = v_ws_obj_source_mapping THEN
        v_step := 115;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        LEFT JOIN  ws_source_mapping_tab
        ON         ws_source_mapping_tab.smt_parent_obj_key = ws_obj_object.oo_obj_key
        WHERE      ws_source_mapping_tab.smt_source_mapping_key = p_obj_key
        ;
      ELSE
        v_step := 120;
        v_index_name := '';
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_obj_object.oo_obj_key = p_obj_key
        ;
      END IF;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_index_with_schema := v_table_with_schema || v_index_name;
    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;
    --=====================================================
    -- See if a specific tablespace was specified and if
    -- so use that tablespace
    --=====================================================
    v_user_tablespace := NULL;
    If p_parameter is not null Then
      v_spos := INSTR(UPPER(p_parameter),'TABLESPACE=');
      IF v_spos > 0 THEN
        v_epos := INSTR(p_parameter,';',v_spos);
        IF v_epos > 0 THEN
          v_user_tablespace := SUBSTR(p_parameter,v_spos+11,v_epos-(v_spos+11));
        ELSE
          v_user_tablespace := SUBSTR(p_parameter,v_spos+11);
        END IF;
      END IF;
    End If;

    v_step := 300;
    --=====================================================
    -- If this is an index task then just build that index
    -- Otherwise we have a table so build all required indexes
    --=====================================================
    If p_obj_type = v_ws_obj_index Then
        --=====================================================
        -- Loop through all the indexes looking for what to build
        --=====================================================
        FOR v_IndRec in c_IndexOnly LOOP
            v_step := 400;
            v_no_tablespace := 0;
            v_primary_key := 0;

            --=====================================================
            -- First drop the index in case that step was not run
            -- Execute the drop
            --=====================================================
            v_step := 500;
            If v_IndRec.ih_partition_type is NULL Then
               v_part_count := 0;
            Else
               Select count(1) into v_part_count
               from all_tab_partitions
               Where table_owner = upper(v_table_schema)
               And table_name = upper(v_table_name);
            End If;

            v_step := 600;
            If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
                v_stmt := 'alter table ' ||v_table_with_schema;
                v_stmt := v_stmt ||' drop constraint '||v_index_name;
            Else
                v_stmt := 'drop index ' || v_index_with_schema;
            End If;
            v_step := 700;
            BEGIN
                v_index_done := 1;
                Execute Immediate v_stmt;
            EXCEPTION
                WHEN OTHERS THEN
                    v_index_done := 0;
                    If SQLCODE <> -1418 And SQLCODE <> -2443 Then
                        v_MsgText := 'Unhandled Exception in ws_act_build. '|| v_ws_pro_version || ' Step ' ||v_step;
                        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                        p_return_msg := 'Unhandled Exception in ws_act_build '|| v_ws_pro_version ||' step ' ||v_step;
                        p_status_code := -3;
                        v_result := -3;
                    End If;
            END;

            --=====================================================
            -- Put detail message
            --=====================================================
            v_step := 800;
            IF v_index_done = 1 THEN

              v_step := 900;

              v_MsgText := 'Index ' || v_index_with_schema || ' dropped';

              v_msg_result := WsWrkError(
                 'I'
              ,  p_job_name
              ,  p_task_name
              ,  p_sequence
              ,  v_MsgText
              ,  NULL
              ,  NULL
              ,  p_task_id
              ,  p_job_id
              ,  NULL);
            END IF;

            --=====================================================
            -- Create the rebuild command
            --=====================================================
            v_step := 1000;
            If v_IndRec.ih_unique = 'Y'
            And v_IndRec.ih_key_type = 'A'
            And v_part_count = 0 Then
                v_stmt := 'Alter Table ' ||v_table_with_schema;
                v_stmt := v_stmt||' Add Constraint '||v_index_name;
                v_stmt := v_stmt||' Primary Key (';
                v_primary_key := 1;
            Else
                v_stmt := 'Create ';
                If v_IndRec.ih_unique = 'Y' then
                     v_stmt := v_stmt||'Unique ';
                End If;
                If v_IndRec.ih_index_type = 'B' Then
                     v_stmt := v_stmt||'Bitmap ';
                End If;
                v_stmt := v_stmt||'Index ' || v_index_with_schema ||' on ';

                v_stmt := v_stmt||v_table_with_schema ||'(';
            End If;

            -- Now add in all the columns
            v_index_key := v_IndRec.ih_index_key;
            v_columns := '';
            v_col_number := 0;
            FOR v_ColRec in c_IndCol LOOP

                v_col_number := v_col_number + 1;
                If v_col_number > 1 Then
                    v_columns := v_columns||',';
                End If;
                v_columns := v_columns||v_ColRec.ic_column;
            END LOOP;

            --=====================================================
            -- If no columns See if this is a function index
            --=====================================================
            If v_columns = '' OR v_columns is NULL THEN
                v_epos := Instr(v_IndRec.ih_index_options,'function_index=');
                If v_epos > 0 Then
                  v_spos := to_number(substr(v_IndRec.ih_index_options,v_epos+15,4));
                  If v_spos > 0 Then
                    v_columns := substr(v_IndRec.ih_index_options,v_epos+20,v_spos);
                  End If;
                End If;
            End if;

            v_stmt := v_stmt||v_columns||')';
            If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                        And v_part_count = 0 Then
                If  v_user_tablespace is not null
                Or  v_IndRec.ih_tablespace is not null Then
                    v_stmt := v_stmt||' Using Index ';
                Else
                    v_no_tablespace := 1;
                End If;
            Else
                v_stmt := v_stmt||' NOLOGGING';

                If nvl(v_IndRec.ih_parallel,0) > 0 Then
                    If  nvl(v_IndRec.ih_parallel,0) > 1 Then
                        v_stmt := v_stmt||' Parallel '|| v_IndRec.ih_parallel;
                    Else
                        v_stmt := v_stmt||' Parallel ';
                    End If;
                End If;
            End If;

            If v_user_tablespace is not null Then
                 v_stmt := v_stmt||' Tablespace '||v_user_tablespace;
            ElsIf v_IndRec.ih_tablespace is not null Then
                 v_stmt := v_stmt||' Tablespace '||v_IndRec.ih_tablespace;
            End If;

            --RED_3620 test for invisible
            v_spos := Instr(v_IndRec.ih_index_options,'invisible=TRUE;');
            If v_spos > 0 Then
               v_stmt := v_stmt||' INVISIBLE ';
            End If;

            -- If we are a primary key and we do not have a tablespace
            -- then we cannot add any of the following
            If v_primary_key = 1 And v_no_tablespace = 1 Then
              NULL;
            Else

            -- see if this is a compute statistics for this index
            v_stats_include := 'N';
            v_spos := Instr(v_IndRec.ih_index_options,'compute_stats;');
            If v_spos > 0 Then
                v_stmt := v_stmt||' Compute Statistics ';
                v_stats_include := 'Y';
            End If;

             -- see if this is a compressed index
            v_spos := Instr(v_IndRec.ih_index_options,'compressed=');
            If v_spos > 0 Then
                v_fix := substr(v_IndRec.ih_index_options,v_spos+11);
                If substr(v_fix,1,1) = ';' Then
                  v_stmt := v_stmt||' Compress ';
                ElsIf substr(v_fix,1,3) <> '-1;' Then
                  v_spos := Instr(v_fix,';');
                  v_stmt := v_stmt||' Compress '||substr(v_fix,1,v_spos-1);
                End If;
            End If;

            If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
              v_pctfree := TRUNC(NVL(v_IndRec.ih_pct_increase,0)/1000,0);
              v_stmt := v_stmt||' PctFree '||v_pctfree;
            Else
              v_stmt := v_stmt||' PctFree '||NVL(v_IndRec.ih_pct_free,0);
            End If;

            v_stmt := v_stmt||' Storage (';
            If v_IndRec.ih_initial_kb+v_IndRec.ih_next_kb <> 0 Then
              v_stmt := v_stmt||' Initial '||v_IndRec.ih_initial_kb||'K';
              v_stmt := v_stmt||' Next '||v_IndRec.ih_next_kb||'K';
            End If;
            If v_IndRec.ih_min_extents+v_IndRec.ih_max_extents <> 0 Then
              v_stmt := v_stmt||' Minextents '||v_IndRec.ih_min_extents;
              v_stmt := v_stmt||' Maxextents '||v_IndRec.ih_max_extents;
            End If;
            If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
              v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
              v_pctinc := v_pctinc - ( TRUNC(v_pctinc/1000,0) *1000);
            Else
              v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
            End If;
            v_stmt := v_stmt||' Pctincrease '||v_pctinc;

            If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
                v_stmt:= v_stmt||' Buffer_Pool Keep';
            ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
                v_stmt:= v_stmt||' Buffer_Pool Recycle';
            ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
                v_stmt:= v_stmt||' Buffer_Pool Default';
            End If;

            v_stmt:= v_stmt||')';
           END If;

            --====================================================================
            -- PARTITION . If partitioned then add the partitions and local if set
            --====================================================================

            If v_part_count > 0 Then
                v_step := 1100;
                If v_IndRec.ih_partition_type = 'L'
                Or v_IndRec.ih_partition_type is NULL Then
                    v_stmt := v_stmt||' LOCAL ';
                End If;

                v_stmt := v_stmt||' ( ';

             -- now get all the partitions
                v_row := 0;
                v_step := 1200;

                FOR v_PartRec in c_AllPartitionEx LOOP
                    v_row := v_row + 1;
                    v_stmt := v_stmt||' Partition '||v_PartRec.partition_name;
                    If v_row < v_part_count Then
                        v_stmt := v_stmt||',';
                    End if;
                END LOOP;

                v_stmt := v_stmt||')';
            End If;

            --=====================================================
            -- Rebuild the index
            --=====================================================
            v_step := 1300;
            Execute Immediate v_stmt;

            --=====================================================
            -- If Parallel primary key then apply that now
            --=====================================================
            v_step := 1400;
            If  v_primary_key = 1
            THEN
                v_stmt := 'Alter INDEX '||v_index_with_schema ;

                IF nvl(v_IndRec.ih_parallel,0) > 0
                THEN
                  v_stmt := v_stmt||' Parallel ';
                  If nvl(v_IndRec.ih_parallel,0) > 1 Then
                     v_stmt := v_stmt|| v_IndRec.ih_parallel;
                  End If;
                else
                  v_stmt := v_stmt||' NOPARALLEL ';
                End If;

              v_stmt := v_stmt||' NOLOGGING ';

              If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
                v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Keep )';
              ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
                v_stmt:= v_stmt||' STORAGE (  Buffer_Pool Recycle ) ';
              ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
                v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Default ) ';
              End If;

              v_step := 1500;

              Execute Immediate v_stmt;
            End If;

            --=====================================================
            -- Put detail message
            --=====================================================
            v_step := 1600;

            v_MsgText := 'Index ' || v_index_with_schema || ' rebuilt';
            IF v_stats_include = 'Y' THEN
              v_MsgText := v_MsgText || ' including stats';
            END IF;

            v_msg_result := WsWrkError(
               'I'
            ,  p_job_name
            ,  p_task_name
            ,  p_sequence
            ,  v_MsgText
            ,  NULL
            ,  NULL
            ,  p_task_id
            ,  p_job_id
            ,  NULL);


            v_count := v_count + 1;
        END LOOP;
    Else
        --=====================================================
        -- Get the day of the week, and if at start or end of month
        --=====================================================
        select to_char(sysdate,'DY'), to_number(to_char(sysdate,'DD')),
                to_number(to_char(sysdate,'MM')), to_number(to_char(sysdate+1,'MM'))
        into v_day_name, v_day, v_month, v_tommorrow_month
        from dual;

        If v_month <> v_tommorrow_month Then
            v_month_end := 1;
        Else
            v_month_end := 0;
        End If;

        --=====================================================
        -- Loop through all the indexes looking for what to build
        --=====================================================
        FOR v_IndRec in c_Index LOOP
            If upper(v_IndRec.ih_pre_drop_flag) = 'Y'
            Or upper(v_IndRec.ih_rebuild_freq) = 'DAILY'
            Or upper(substr(v_IndRec.ih_rebuild_freq,1,3)) = upper(v_day_name)
            Or (upper(v_IndRec.ih_rebuild_freq) = 'END MONTH' And v_month_end = 1)
            Or (upper(v_IndRec.ih_rebuild_freq) = 'START MONTH' And v_day = 1)
            Then
                v_step := 1700;
                v_no_tablespace := 0;
                v_primary_key := 0;

                v_index_name := v_IndRec.ih_index_name;

                v_index_with_schema := TRIM(v_table_schema);
                IF TRIM(v_index_with_schema) IS NOT NULL THEN
                   v_index_with_schema := v_index_with_schema ||'.';
                END IF;

                v_index_with_schema := v_index_with_schema || v_index_name;

                --=====================================================
                -- First drop the index in case that step was not run
                -- Execute the drop
                --=====================================================
                v_step := 1800;
                If v_IndRec.ih_partition_type is NULL Then
                   v_part_count := 0;
                Else
                   Select count(1) into v_part_count
                   from all_tab_partitions
                   Where table_owner = upper(v_table_schema)
                   And table_name = upper(v_table_name);
                End If;
                v_step := 1900;
                If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
                    v_stmt := 'alter table '||v_table_with_schema ||
                              ' drop constraint '||v_index_name;
                Else
                    v_stmt := 'drop index '||v_index_with_schema;
                End If;
                v_step := 2000;
                BEGIN
                    v_index_done := 1;
                    Execute Immediate v_stmt;
                EXCEPTION
                    WHEN OTHERS THEN
                        v_index_done := 0;
                        If SQLCODE <> -1418 And SQLCODE <> -2443 Then
                            v_MsgText := 'Unhandled Exception in ws_act_build '|| v_ws_pro_version || ' Step ' ||v_step;
                            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                            p_return_msg := 'Unhandled Exception in ws_act_build ' || v_ws_pro_version || ' step ' ||v_step;
                            p_status_code := -3;
                            v_result := -3;
                        End If;
                END;

                --=====================================================
                -- Put detail message
                --=====================================================
                v_step := 2100;
                IF v_index_done = 1 THEN

                  v_step := 2200;

                  v_MsgText := 'Index ' || v_index_with_schema || ' dropped';

                  v_msg_result := WsWrkError(
                     'I'
                  ,  p_job_name
                  ,  p_task_name
                  ,  p_sequence
                  ,  v_MsgText
                  ,  NULL
                  ,  NULL
                  ,  p_task_id
                  ,  p_job_id
                  ,  NULL);
                END IF;

                --=====================================================
                -- Create the rebuild command
                --=====================================================
                v_step := 2300;
                If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                            And v_part_count = 0 Then
                v_stmt := 'Alter Table ';
                    v_stmt := 'Alter Table '    || v_table_with_schema
                           ||' Add Constraint ' || v_index_name
                           ||' Primary Key (';
                    v_primary_key := 1;
                Else
                    v_stmt := 'Create ';
                    If v_IndRec.ih_unique = 'Y' then
                         v_stmt := v_stmt||'Unique ';
                    End If;
                    If v_IndRec.ih_index_type = 'B' Then
                         v_stmt := v_stmt||'Bitmap ';
                    End If;
                    v_stmt := v_stmt||'Index '|| v_index_with_schema
                                    ||' on ' || v_table_with_schema
                                    ||'(';
                End If;

                -- Now add in all the columns
                v_index_key := v_IndRec.ih_index_key;
                v_columns := '';
                v_col_number := 0;
                FOR v_ColRec in c_IndCol LOOP

                    v_col_number := v_col_number + 1;
                    If v_col_number > 1 Then
                        v_columns := v_columns||',';
                    End If;
                    v_columns := v_columns||v_ColRec.ic_column;
                END LOOP;

                --=====================================================
                -- If no columns See if this is a function index
                --=====================================================
                If v_columns = '' OR v_columns is NULL THEN
                    v_epos := Instr(v_IndRec.ih_index_options,'function_index=');
                    If v_epos > 0 Then
                      v_spos := to_number(substr(v_IndRec.ih_index_options,v_epos+15,4));
                      If v_spos > 0 Then
                        v_columns := substr(v_IndRec.ih_index_options,v_epos+20,v_spos);
                      End If;
                    End If;
                End if;

                v_stmt := v_stmt||v_columns||')';
                If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                            And v_part_count = 0 Then
                    If  v_user_tablespace is not null
                    Or  v_IndRec.ih_tablespace is not null Then
                        v_stmt := v_stmt||' Using Index ';
                    Else
                        v_no_tablespace := 1;
                    End If;

                Else
                    v_stmt := v_stmt||' NOLOGGING';

                    If nvl(v_IndRec.ih_parallel,0) > 0 Then
                        If  nvl(v_IndRec.ih_parallel,0) > 1 Then
                            v_stmt := v_stmt||' Parallel '|| v_IndRec.ih_parallel;
                Else
                            v_stmt := v_stmt||' Parallel ';
                        End If;
                    End If;
                End If;

                If v_user_tablespace is not null Then
                     v_stmt := v_stmt||' Tablespace '||v_user_tablespace;
                ElsIf v_IndRec.ih_tablespace is not null Then
                     v_stmt := v_stmt||' Tablespace '||v_IndRec.ih_tablespace;
                End If;

                --RED_3620 test for invisible
                v_spos := Instr(v_IndRec.ih_index_options,'invisible=TRUE;');
                If v_spos > 0 Then
                   v_stmt := v_stmt||' INVISIBLE ';
                End If;

                -- If we are a primary key and we do not have a tablespace
                -- then we cannot add any of the following
                If v_primary_key = 1 And v_no_tablespace = 1 Then
                  NULL;
                Else

                  -- see if this is a compute statistics for this index
                  v_stats_include := 'N';
                  v_spos := Instr(v_IndRec.ih_index_options,'compute_stats;');
                  If v_spos > 0 Then
                      v_stmt := v_stmt||' Compute Statistics ';
                      v_stats_include := 'Y';
                  End If;

                   -- see if this is a compressed index
                  v_spos := Instr(v_IndRec.ih_index_options,'compressed=');
                  If v_spos > 0 Then
                      v_fix := substr(v_IndRec.ih_index_options,v_spos+11);
                      If substr(v_fix,1,1) = ';' Then
                        v_stmt := v_stmt||' Compress ';
                      ElsIf substr(v_fix,1,3) <> '-1;' Then
                        v_spos := Instr(v_fix,';');
                        v_stmt := v_stmt||' Compress '||substr(v_fix,1,v_spos-1);
                      End If;
                  End If;

                  If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
                    v_pctfree := TRUNC(NVL(v_IndRec.ih_pct_increase,0)/1000,0);
                    v_stmt := v_stmt||' PctFree '||v_pctfree;
                  Else
                    v_stmt := v_stmt||' PctFree '||NVL(v_IndRec.ih_pct_free,0);
                  End If;

                  v_stmt := v_stmt||' Storage (';

                  If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
                    v_stmt:= v_stmt||' Buffer_Pool Keep ';
                  ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
                    v_stmt:= v_stmt||' Buffer_Pool Recycle ';
                  ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
                    v_stmt:= v_stmt||' Buffer_Pool Default ';
                  End If;

                  If v_IndRec.ih_initial_kb+v_IndRec.ih_next_kb <> 0 Then
                       v_stmt := v_stmt||' Initial '||v_IndRec.ih_initial_kb||'K';
                       v_stmt := v_stmt||' Next '||v_IndRec.ih_next_kb||'K';
                  End If;
                  If v_IndRec.ih_min_extents+v_IndRec.ih_max_extents <> 0 Then
                       v_stmt := v_stmt||' Minextents '||v_IndRec.ih_min_extents;
                       v_stmt := v_stmt||' Maxextents '||v_IndRec.ih_max_extents;
                  End If;
                  If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
                    v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
                    v_pctinc := v_pctinc - ( TRUNC(v_pctinc/1000,0) *1000);
                  Else
                    v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
                  End If;
                  v_stmt := v_stmt||' Pctincrease '||v_pctinc||')';
                End If;

                --====================================================================
                -- PARTITION . If partitioned then add the partitions and local if set
                --====================================================================

                If v_part_count > 0 Then
                    v_step := 2400;
                    If v_IndRec.ih_partition_type = 'L'
                    Or v_IndRec.ih_partition_type is NULL Then
                        v_stmt := v_stmt||' LOCAL ';
                    End If;

                    v_stmt := v_stmt||' ( ';

                     -- now get all the partitions
                    v_row := 0;
                    v_step := 2500;

                    FOR v_PartRec in c_AllPartitionEx LOOP
                        v_row := v_row + 1;
                        v_stmt := v_stmt||' Partition '||v_PartRec.partition_name;
                        If v_row < v_part_count Then
                            v_stmt := v_stmt||',';
                        End if;
                    END LOOP;

                    v_stmt := v_stmt||')';
                End If;

                --=====================================================
                -- Rebuild the index
                --=====================================================
                v_step := 2600;
                Execute Immediate v_stmt;

                --=====================================================
                -- If Parallel primary key then apply that now
                --=====================================================
                v_step := 2700;
                If  v_primary_key = 1
                THEN
                    v_stmt := 'Alter INDEX '||v_index_with_schema;

                    IF nvl(v_IndRec.ih_parallel,0) > 0
                    THEN
                      v_stmt := v_stmt||' Parallel ';
                      If nvl(v_IndRec.ih_parallel,0) > 1 Then
                         v_stmt := v_stmt|| v_IndRec.ih_parallel;
                      End If;
                    else
                      v_stmt := v_stmt||' NOPARALLEL ';
                    End If;

                  v_stmt := v_stmt||' NOLOGGING ';

                  If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
                    v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Keep )';
                  ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
                    v_stmt:= v_stmt||' STORAGE (  Buffer_Pool Recycle ) ';
                  ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
                    v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Default ) ';
                  End If;


                  v_step := 2800;

                  Execute Immediate v_stmt;
                End If;

                --=====================================================
                -- Put detail message
                --=====================================================
                v_step := 2900;

                v_MsgText := 'Index ' || v_index_with_schema || ' rebuilt';
                IF v_stats_include = 'Y' THEN
                  v_MsgText := v_MsgText || ' including stats';
                END IF;

                v_msg_result := WsWrkError(
                   'I'
                ,  p_job_name
                ,  p_task_name
                ,  p_sequence
                ,  v_MsgText
                ,  NULL
                ,  NULL
                ,  p_task_id
                ,  p_job_id
                ,  NULL);

                IF p_action = v_ws_act_build THEN
                  v_MsgText := 'Index rebuilt '||v_index_with_schema;
                  v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                         v_MsgText,NULL,NULL, p_task_id, p_job_id);
                END IF;

                v_count := v_count + 1;
            End If;
        END LOOP;
    End If;

    v_step := 3000;
    -- tell them how many indexes we rebuilt
    If v_count = 0 Then
       p_return_msg := 'No indexes rebuilt';
    ElsIf v_count = 1 Then
       p_return_msg := v_count||' index rebuilt';
    Else
       p_return_msg := v_count||' indexes rebuilt';
    End If;
    p_status_code := 1;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_build '|| v_ws_pro_version ||
                ' Index '||v_index_name||' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        v_MsgText := substr(v_stmt,1,1023);
        v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_build (index build) '|| v_ws_pro_version ||' '||
            v_index_name||' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_build;
 
_PROCEDURE_ Ws_Act_Build_all 
-- Notes / History
--
-- WMR 30/08/2001 Ver 0.3.0.6  Added support for Primary Keys
-- WMR 21/01/2002 Ver 1.0.0.0  Added support for Partitioned indexes
-- WMR 20/03/2002 Ver 1.0.6.0  Added support for Parallel index builds
-- WMR 02/12/2002 Ver 1.2.1.5  Fixed missing K on extents and added support for pct free
-- WMR 24/12/2003 Ver 4.1.0.0  Added support for compressed indexes
-- WMR 17/04/2004 Ver 4.1.0.0  Added support for compute statistics in index create
-- WMR 15/05/2004 Ver 4.1.0.8  Added support for buffer pool options
-- WMR 25/05/2004 Ver 4.1.0.8  Added support for pctfree column and function indexes
-- WMR 23/07/2004 Ver 4.1.0.8  Added support p_parameter being passed in
-- WMR 24/06/2005 Ver 4.1.2.11 Include the schema name in the create if flag set
-- WMR 05/07/2005 Ver 4.1.2.13 Changed user_tab_partitions to all_tab_partitions
-- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to all out messages
--                             Add call to wswrkerror for each index as built
-- AP  19/06/2006 Ver 6.0.4.1  Include parallel and nologging where missed
--                             Also added missing buffer pool settings
-- JML 22/09/2009 Ver 6.0.5.1  Several varchars changed to 32k to accommodate
--                             larger partitioned tables.
-- AP  30/05/2014 Ver 6.8.0.1  Include invisible option
-- HM  15/08/2014 Ver 6.8.1.2  Added Schema support
-- BC  14/08/2015 Ver 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_build_all
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_parameter   IN  varchar2,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_build_all
    -- Description    : Build all indexes associated with an object
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(32000);
    v_count           integer := 0;
    v_columns         varchar2(32000);
    v_col_number      integer := 0;
    v_index_key       integer := 0;
    v_part_count      integer := 0;
    v_row             integer := 0;
    v_pctfree         integer := 0;
    v_pctinc          integer := 0;
    v_no_tablespace   integer := 0;
    v_primary_key     integer := 0;
    v_epos            integer := 0;
    v_spos            integer := 0;
    v_fix             varchar2(32000);
    v_user_tablespace varchar2(32000);
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_stats_include   varchar2(1);
    v_index_done      integer;        -- used to flag if action successful
    v_msg_result      integer := 0;   -- return code
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_index_name      varchar2(64);
    v_index_with_schema varchar2(150);

    --=====================================================
    -- Cursor for all indexes
    --=====================================================
    Cursor c_Index is
          Select * from ws_index_header
          Where ih_obj_key = p_obj_key
          And ih_active = 'Y';

    --=====================================================
    -- Cursor for index columns
    --=====================================================
    Cursor c_IndCol is
          Select ic_column, ic_foreign_table, ic_foreign_column
          from ws_index_col
          Where ic_index_key = v_index_key
          Order by ic_column_no;

    --=====================================================
    -- Cursor for partitions when schema must be used
    --=====================================================
    Cursor c_AllPartitionEx is
          Select partition_name
          from all_tab_partitions
          Where table_name = upper(v_table_name)
          And table_owner = upper(v_table_schema)
          Order by partition_position;

BEGIN

    v_step := 100;
    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      v_step := 120;
      v_index_name := '';
      SELECT     NVL(dt_schema, '')
                ,oo_name
      INTO       v_table_schema
                ,v_table_name
      FROM       ws_obj_object
      LEFT JOIN  ws_dbc_target
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = p_obj_key
      ;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;
    --=====================================================
    -- See if a specific tablespace was specified and if
    -- so use that tablespace
    --=====================================================
    v_user_tablespace := NULL;
    If p_parameter is not null Then
      v_spos := INSTR(UPPER(p_parameter),'TABLESPACE=');
      IF v_spos > 0 THEN
        v_epos := INSTR(p_parameter,';',v_spos);
        IF v_epos > 0 THEN
          v_user_tablespace := SUBSTR(p_parameter,v_spos+11,v_epos-(v_spos+11));
        ELSE
          v_user_tablespace := SUBSTR(p_parameter,v_spos+11);
        END IF;
      END IF;
    End If;


    v_step := 300;
    --=====================================================
    -- Loop through all the indexes looking for what to build
    --=====================================================
    FOR v_IndRec in c_Index LOOP
        v_step := 400;
        v_no_tablespace := 0;
        v_primary_key := 0;

        v_index_name := v_IndRec.ih_index_name;

        v_index_with_schema := TRIM(v_table_schema);
        IF TRIM(v_index_with_schema) IS NOT NULL THEN
           v_index_with_schema := v_index_with_schema ||'.';
        END IF;

        v_index_with_schema := v_index_with_schema || v_index_name;

        --=====================================================
        -- First drop the index in case that step was not run
        -- Execute the drop
        --=====================================================
        v_step := 500;

        If v_IndRec.ih_partition_type is NULL Then
           v_part_count := 0;
        Else
           Select count(1) into v_part_count
           from all_tab_partitions
           Where table_owner = upper(v_table_schema)
           And table_name = upper(v_table_name);
        End If;

        v_step := 600;
        If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
            v_stmt := 'alter table ' || v_table_with_schema
                       || ' drop constraint '||v_index_name;
        Else
            v_stmt := 'drop index ' || v_index_with_schema;
        End If;
        v_step := 700;
        BEGIN
            v_index_done := 1;
            Execute Immediate v_stmt;
        EXCEPTION
            WHEN OTHERS THEN
                v_index_done := 0;
                If SQLCODE <> -1418 And SQLCODE <> -2443 Then
                    v_MsgText := 'Unhandled Exception in ws_act_build_all '||v_ws_pro_version ||
                            ' Step ' ||v_step;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_build_all '||v_ws_pro_version || ' step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;
        --=====================================================
        -- Put detail message
        --=====================================================
        v_step := 800;
        IF v_index_done = 1 THEN
          v_step := 900;
          v_MsgText := 'Index ' || v_index_with_schema || ' dropped';

          v_msg_result := WsWrkError(
             'I'
          ,  p_job_name
          ,  p_task_name
          ,  p_sequence
          ,  v_MsgText
          ,  NULL
          ,  NULL
          ,  p_task_id
          ,  p_job_id
          ,  NULL);
        END IF;

        --=====================================================
        -- Create the rebuild command
        --=====================================================
        v_step := 1000;
        If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
            v_stmt := 'Alter Table ' ||v_table_with_schema
                      ||' Add Constraint ' || v_index_name
                      ||' Primary Key (';
            v_primary_key := 1;
        Else
            v_stmt := 'Create ';
            If v_IndRec.ih_unique = 'Y' then
                 v_stmt := v_stmt||'Unique ';
            End If;
            If v_IndRec.ih_index_type = 'B' Then
                 v_stmt := v_stmt||'Bitmap ';
            End If;
            v_stmt := v_stmt||'Index ' || v_index_with_schema
                            ||' on ' || v_table_with_schema
                            ||'(';
        End If;

        -- Now add in all the columns
        v_index_key := v_IndRec.ih_index_key;
        v_columns := '';
        v_col_number := 0;
        FOR v_ColRec in c_IndCol LOOP
            v_col_number := v_col_number + 1;
            If v_col_number > 1 Then
                v_columns := v_columns||',';
            End If;
            v_columns := v_columns||v_ColRec.ic_column;
        END LOOP;

        --=====================================================
        -- If no columns See if this is a function index
        --=====================================================
        If v_columns = '' OR v_columns IS NULL THEN
            v_epos := Instr(v_IndRec.ih_index_options,'function_index=');
            If v_epos > 0 Then
              v_spos := to_number(substr(v_IndRec.ih_index_options,v_epos+15,4));
              If v_spos > 0 Then
                v_columns := substr(v_IndRec.ih_index_options,v_epos+20,v_spos);
              End If;
            End If;
        End if;


        v_stmt := v_stmt||v_columns||')';

        If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
            If  v_user_tablespace is not null
            Or  v_IndRec.ih_tablespace is not null Then
                v_stmt := v_stmt||' Using Index ';
            Else
                v_no_tablespace := 1;
            End If;

        Else
            v_stmt := v_stmt||' NOLOGGING';

            If nvl(v_IndRec.ih_parallel,0) > 0 Then
                If  nvl(v_IndRec.ih_parallel,0) > 1 Then
                    v_stmt := v_stmt||' Parallel '|| v_IndRec.ih_parallel;
        Else
                    v_stmt := v_stmt||' Parallel ';
                End If;
            End If;
        End If;

        --RED_3620 test for invisible
        v_spos := Instr(v_IndRec.ih_index_options,'invisible=TRUE;');
        If v_spos > 0 Then
           v_stmt := v_stmt||' INVISIBLE ';
        End If;

        -- If we are a primary key and we do not have a tablespace
        -- then we cannot add any of the following
        If v_primary_key = 1 And v_no_tablespace = 1 Then
          NULL;
        Else
          If v_user_tablespace is not null Then
               v_stmt := v_stmt||' Tablespace '||v_user_tablespace;
          ElsIf v_IndRec.ih_tablespace is not null Then
               v_stmt := v_stmt||' Tablespace '||v_IndRec.ih_tablespace;
          End If;

          -- see if this is a compute statistics for this index
          v_stats_include  := 'N';

          v_spos := Instr(v_IndRec.ih_index_options,'compute_stats;');
          If v_spos > 0 Then
              v_stmt := v_stmt||' Compute Statistics ';
              v_stats_include := 'Y';
          End If;

           -- see if this is a compressed index
          v_spos := Instr(v_IndRec.ih_index_options,'compressed=');
          If v_spos > 0 Then
              v_fix := substr(v_IndRec.ih_index_options,v_spos+11);
              If substr(v_fix,1,1) = ';' Then
                v_stmt := v_stmt||' Compress ';
              ElsIf substr(v_fix,1,3) <> '-1;' Then
                v_spos := Instr(v_fix,';');
                v_stmt := v_stmt||' Compress '||substr(v_fix,1,v_spos-1);
              End If;
          End If;


          If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
            v_pctfree := TRUNC(NVL(v_IndRec.ih_pct_increase,0)/1000,0);
            v_stmt := v_stmt||' PctFree '||v_pctfree;
          Else
            v_stmt := v_stmt||' PctFree '||NVL(v_IndRec.ih_pct_free,0);
          End If;

          v_stmt := v_stmt||' Storage (';
          If v_IndRec.ih_initial_kb+v_IndRec.ih_next_kb <> 0 Then
               v_stmt := v_stmt||' Initial '||v_IndRec.ih_initial_kb||'K';
               v_stmt := v_stmt||' Next '||v_IndRec.ih_next_kb||'K';
          End If;
          If v_IndRec.ih_min_extents+v_IndRec.ih_max_extents <> 0 Then
               v_stmt := v_stmt||' Minextents '||v_IndRec.ih_min_extents;
               v_stmt := v_stmt||' Maxextents '||v_IndRec.ih_max_extents;
          End If;

          If NVL(v_IndRec.ih_pct_increase,0) > 1000 Then
            v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
            v_pctinc := v_pctinc - ( TRUNC(v_pctinc/1000,0) *1000);
          Else
            v_pctinc := NVL(v_IndRec.ih_pct_increase,0);
          End If;
          v_stmt := v_stmt||' Pctincrease '||v_pctinc;

          If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
            v_stmt:= v_stmt||' Buffer_Pool Keep';
          ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
            v_stmt:= v_stmt||' Buffer_Pool Recycle';
          ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
            v_stmt:= v_stmt||' Buffer_Pool Default';
          End If;

          v_stmt:= v_stmt||')';
        End If;

        --====================================================================
        -- PARTITION . If partitioned then add the partitions and local if set
        --====================================================================
        If v_part_count > 0 Then
            v_step := 1100;

            If v_IndRec.ih_partition_type = 'L'
            Or v_IndRec.ih_partition_type is NULL Then
                v_stmt := v_stmt||' LOCAL ';
            End If;
            v_stmt := v_stmt||' ( ';

            -- now get all the partitions
            v_row := 0;
            v_step := 1200;

            FOR v_PartRec in c_AllPartitionEx LOOP
                v_row := v_row + 1;
                v_stmt := v_stmt||' Partition '||v_PartRec.partition_name;
                If v_row < v_part_count Then
                   v_stmt := v_stmt||',';
                End if;
            END LOOP;
            v_stmt := v_stmt||')';
        End If;

        --=====================================================
        -- Rebuild the index
        --=====================================================
        v_step := 1300;
        Execute Immediate v_stmt;
        v_count := v_count + 1;

        --=====================================================
        -- If Parallel primary key then apply that now
        --=====================================================
        v_step := 1400;
        If  v_primary_key = 1
        THEN
            v_stmt := 'Alter INDEX ' || v_index_with_schema;

            IF nvl(v_IndRec.ih_parallel,0) > 0
            THEN
              v_stmt := v_stmt||' Parallel ';
              If nvl(v_IndRec.ih_parallel,0) > 1 Then
                 v_stmt := v_stmt || v_IndRec.ih_parallel;
              End If;
            else
              v_stmt := v_stmt||' NOPARALLEL ';
            End If;

          v_stmt := v_stmt||' NOLOGGING ';

          If upper(v_IndRec.ih_buffer_pool_ind) = 'K' Then
            v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Keep )';
          ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'R' Then
            v_stmt:= v_stmt||' STORAGE (  Buffer_Pool Recycle ) ';
          ElsIf upper(v_IndRec.ih_buffer_pool_ind) = 'D' Then
            v_stmt:= v_stmt||' STORAGE ( Buffer_Pool Default ) ';
          End If;

          v_step := 1500;

          Execute Immediate v_stmt;
        End If;

        --=====================================================
        -- Put detail message
        --=====================================================
        v_step := 1600;

        v_MsgText := 'Index ' || v_table_with_schema || ' rebuilt';
        IF v_stats_include = 'Y' THEN
          v_MsgText := v_MsgText || ' including stats';
        END IF;

        v_msg_result := WsWrkError(
           'I'
        ,  p_job_name
        ,  p_task_name
        ,  p_sequence
        ,  v_MsgText
        ,  NULL
        ,  NULL
        ,  p_task_id
        ,  p_job_id
        ,  NULL);

    END LOOP;

    v_step := 1700;
    -- tell them how many indexes we rebuilt
    If v_count = 0 Then
       p_return_msg := 'No indexes rebuilt';
    ElsIf v_count = 1 Then
       p_return_msg := v_count||' index rebuilt';
    Else
       p_return_msg := v_count||' indexes rebuilt';
    End If;
    p_status_code := 1;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_build_all '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        If v_step = 40 Then
            v_MsgText := substr(v_stmt,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_stmt) > 1023 Then
                v_MsgText := substr(v_stmt,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
        End If;
        p_return_msg := 'Unhandled Exception in ws_act_build_all ' || v_ws_pro_version ||' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_build_all;
 
_PROCEDURE_ Ws_Act_Create 
-- Notes / History
--
-- WMR 22/01/2002     Version 1.0.0
-- WMR 23/03/2004     Version 4.1.0.8  added support for transformations in dim views
-- WMR 10/02/2005     Version 4.1.1.3  added support for user views and version in errors
-- WMR 24/06/2005     Version 4.1.2.11 include the schema name in the create if flag set
-- WMR 06/04/2006     Version 5.6.0.0  Add support for Retrofit copies
-- AP  30/10/2007     Version 5.6.2.1  Add support for load table post fix and not logging
-- AP  31/01/2008     Version 5.6.3.1  Added parameter substitution for view creates
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
-- AP  24/09/2008     Version 6.0.1.1  Added Default column value handling
-- AP  31/12/2008     Version 6.0.2.3  Added support for Views
-- AP  15/04/2009     Version 6.0.4.1  No longer add quotes for default,
--                                     and ensure not null after default
-- HM  07/07/2014     Version 6.8.1.1  Added Override DDL
-- HM  15/08/2014     Version 6.8.1.2  Added Schema support
-- AP  16/10/2014     Version 6.8.1.2  Support DISTINCT on views.
-- RS  14/11/2014     Version 6.8.1.2  Fixed issue with table create
-- BC  14/08/2015     Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- RS  04/09/2015     Version 6.8.4.3  Fixed issue with from clause in view generation
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- RS  03/10/2016     Version 6.8.6.2  Added support for multiple statements in DDL override
-- RS  02/11/2016     Version 6.8.6.3  RED-7375: Fixed issue with user defined views
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_create
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_create
    -- Description    : Create a Table or View
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_cursor          number;
    v_create          varchar2(4000);
    v_create2         varchar2(4000);
    v_create3         varchar2(4000);
    v_create4         varchar2(4000);
    v_create5         varchar2(4000);
    v_create_all      varchar2(32000);
    v_as              varchar2(2000);
    v_row             integer := 0;
    v_user_view       integer := 0;
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_spos            integer;

    v_LoadRec         ws_load_tab%ROWTYPE;
    v_DimRec          ws_dim_tab%ROWTYPE;
    v_ViewRec         ws_view_tab%ROWTYPE;
    v_FactRec         ws_fact_tab%ROWTYPE;
    v_StageRec        ws_stage_tab%ROWTYPE;
    v_AggRec          ws_agg_tab%ROWTYPE;
    v_RetroRec        ws_retro_tab%ROWTYPE;
    v_OdsRec          ws_ods_tab%ROWTYPE;
    v_NormalRec       ws_normal_tab%ROWTYPE;

    v_text1           varchar2(4000);
    v_text2           varchar2(4000);
    v_text3           varchar2(4000);
    v_text4           varchar2(4000);
    v_text5           varchar2(4000);
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_tablespace      varchar2(64);
    v_ddl_override    varchar2(32000);

    v_start_location  integer := 1;
    v_end_location    integer;
    v_statement       varchar2(32000);
    v_delimiter       varchar2(4000);

    --=====================================================
    -- Cursor for all columns in the tables
    --=====================================================
    Cursor c_Load is
          Select * from ws_load_col
          Where lc_obj_key = p_obj_key
          Order by lc_order;

    Cursor c_Dim is
          Select * from ws_dim_col
          Where dc_obj_key = p_obj_key
          Order by dc_order;

    Cursor c_View is
          Select * from ws_view_col
          Where vc_obj_key = p_obj_key
          Order by vc_order;

    Cursor c_Fact is
          Select * from ws_fact_col
          Where fc_obj_key = p_obj_key
          Order by fc_order;

    Cursor c_Stage is
          Select * from ws_stage_col
          Where sc_obj_key = p_obj_key
          Order by sc_order;

    Cursor c_Agg is
          Select * from ws_agg_col
          Where ac_obj_key = p_obj_key
          Order by ac_order;

    Cursor c_Retro is
          Select * from ws_retro_col
          Where rc_obj_key = p_obj_key
          Order by rc_order;

    Cursor c_Ods is
          Select * from ws_ods_col
          Where oc_obj_key = p_obj_key
          Order by oc_order;

    Cursor c_Normal is
          Select * from ws_normal_col
          Where nc_obj_key = p_obj_key
          Order by nc_order;

    --=====================================================
    -- Cursor for source tables if a dimension view
    --=====================================================
    Cursor c_Tables is
          Select distinct dc_src_table
          from ws_dim_col
          Where dc_obj_key = p_obj_key;
    --=====================================================
    -- Cursor for source tables if a view
    --=====================================================
    Cursor c_ViewTables is
          Select distinct vc_src_table
          from ws_view_col
          Where vc_obj_key = p_obj_key;

    --=====================================================
    -- MAIN
    --=====================================================
BEGIN
    v_step := 100;
    v_create2 := '';
    v_create3 := '';
    v_create4 := '';
    v_create5 := '';

    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      SELECT     NVL(dt_schema, '')
                ,oo_name
      INTO       v_table_schema
                ,v_table_name
      FROM       ws_obj_object
      LEFT JOIN  ws_dbc_target
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = p_obj_key
      ;
      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 110;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 120;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 130;

    v_table_schema := TRIM(v_table_schema);
    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;

  --=====================================================
  -- DDL Override
  --=====================================================
  -- RED_4237
  BEGIN
    v_step := 140;
    SELECT NVL(ta_text_1, '')
         , NVL(ta_text_2, '')
         , NVL(ta_text_3, '')
         , NVL(ta_text_4, '')
         , NVL(ta_text_5, '')
      INTO v_text1
         , v_text2
         , v_text3
         , v_text4
         , v_text5
    FROM ws_table_attributes
    WHERE ta_obj_key = p_obj_key
      AND ta_type = 'D'
    ;

   EXCEPTION WHEN NO_DATA_FOUND THEN
      v_text1 := '';
      v_text2 := '';
      v_text3 := '';
      v_text4 := '';
      v_text5 := '';
   END;

  -- Oracle treats empty strings as NULL: http://www.techonthenet.com/oracle/questions/empty_null.php
  IF TRIM(v_text1) IS NOT NULL THEN
    v_step := 200;

    IF p_obj_type = v_ws_obj_load THEN
      SELECT * INTO v_LoadRec FROM ws_load_tab WHERE lt_obj_key = p_obj_key;
      v_tablespace := v_LoadRec.lt_tablespace;
    ELSIF p_obj_type = v_ws_obj_stage THEN
      SELECT * INTO v_StageRec FROM ws_stage_tab WHERE st_obj_key = p_obj_key;
      v_tablespace := v_StageRec.st_tablespace;
    ELSIF p_obj_type = v_ws_obj_ods THEN
      SELECT * INTO v_OdsRec FROM ws_ods_tab WHERE ot_obj_key = p_obj_key;
      v_tablespace := v_OdsRec.ot_tablespace;
    ELSIF p_obj_type = v_ws_obj_normal
    OR p_obj_type = v_ws_obj_hub
    OR p_obj_type = v_ws_obj_satellite
    OR p_obj_type = v_ws_obj_link
    OR p_obj_type = v_ws_obj_custom1
    OR p_obj_type = v_ws_obj_custom2
    THEN
      SELECT * INTO v_NormalRec FROM ws_normal_tab WHERE nt_obj_key = p_obj_key;
      v_tablespace := v_NormalRec.nt_tablespace;
    ELSIF p_obj_type = v_ws_obj_dim THEN
      SELECT * INTO v_DimRec FROM ws_dim_tab WHERE dt_obj_key = p_obj_key;
      v_tablespace := v_DimRec.dt_tablespace;
    ELSIF p_obj_type = v_ws_obj_fact THEN
      SELECT * INTO v_FactRec FROM ws_fact_tab WHERE ft_obj_key = p_obj_key;
      v_tablespace := v_FactRec.ft_tablespace;
    ELSIF p_obj_type = v_ws_obj_agg THEN
      SELECT * INTO v_AggRec FROM ws_agg_tab WHERE at_obj_key = p_obj_key;
      v_tablespace := v_AggRec.at_tablespace;
    ELSE
      v_tablespace := '';
    END IF;

    v_table_name := TRIM(v_table_name);
    v_tablespace := TRIM(v_tablespace);

    v_ddl_override := v_text1 || v_text2 || v_text3 || v_text4 || v_text5;
    v_ddl_override := REPLACE(v_ddl_override, '$TABLE$', v_table_name);
    v_ddl_override := REPLACE(v_ddl_override, '$INDEX$', v_table_name);
    v_ddl_override := REPLACE(v_ddl_override, '$OBJECT$', v_table_with_schema);
    v_ddl_override := REPLACE(v_ddl_override, '$SCHEMA$', v_table_schema);
    v_ddl_override := REPLACE(v_ddl_override, '$TABLESPACE$', v_tablespace);
    v_ddl_override := WsParameterReplace(v_ddl_override, 32000);

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SELECT COALESCE(LENGTH(v_ddl_override),0) INTO v_end_location FROM DUAL;

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT COALESCE(ta_text_3, '<EOS>') INTO v_delimiter FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

    -- Loop through the override statement and execute each statement individually
    WHILE v_end_location > 0
    LOOP
       SELECT INSTR(v_ddl_override,v_delimiter, v_start_location) INTO v_end_location FROM DUAL;
       SELECT CASE
              WHEN v_end_location > 0
              THEN SUBSTR(v_ddl_override,v_start_location,v_end_location -v_start_location)
              ELSE SUBSTR(v_ddl_override,v_start_location)
              END  INTO v_statement FROM DUAL;

       IF TRIM(TRANSLATE(v_statement, chr(10) || chr(13) || chr(09), '   ')) IS NOT NULL Then
            BEGIN
              EXECUTE IMMEDIATE v_statement;
              p_return_msg := 'Table created using DDL Override '|| v_table_with_schema;
              p_status_code := 1;
              v_result := 1;
              EXCEPTION
                WHEN OTHERS THEN
                  If SQLCODE = -955 THEN
                    v_MsgText := 'DDL Override: Table already exists. Drop table first if you wish to re-create';
                  ELSE
                    v_MsgText := 'Unhandled exception using DDL Override in ws_act_create cursor step '|| v_step;
                  END IF;

                  v_result := WsWrkAudit( 'E', p_job_name, p_task_name, p_sequence
                                        , v_MsgText, SQLCODE, SQLERRM, p_task_id, p_job_id
                                        );

                  p_return_msg := v_MsgText;
                  p_status_code := -2;
                  v_result := -2;

                  RETURN v_result;
            END;
        END IF;

        SELECT v_end_location + LENGTH(v_delimiter) INTO v_start_location  FROM DUAL;
    END LOOP;

    RETURN v_result;
  END IF;

  --=====================================================
    -- Handle all the table types
    --=====================================================
    --=====================================================
    -- L O A D
    --=====================================================
    If p_obj_type = v_ws_obj_load Then
        select * into v_LoadRec
        from ws_load_tab where lt_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table ' || v_table_with_schema ||'(';

        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Load LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.lc_col_name||' '||v_ColRec.lc_data_type;

            IF  LENGTH(TRIM(v_ColRec.lc_default_value)) > 0
            AND v_ColRec.lc_default_value IS NOT NULL
            THEN
--                v_ColRec.lc_default_value := '''' || v_ColRec.lc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.lc_default_value;
            END IF;

            If v_ColRec.lc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL ';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_LoadRec.lt_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_LoadRec.lt_tablespace;
        End If;

        v_step := 300;

      v_Create := v_Create||'  PctFree ';
      If v_LoadRec.lt_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_LoadRec.lt_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_LoadRec.lt_initial_kb + v_LoadRec.lt_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_LoadRec.lt_initial_kb||'K';
            v_Create := v_Create||' Next '||v_LoadRec.lt_next_kb||'K';
        End If;

        If v_LoadRec.lt_min_extents + v_LoadRec.lt_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_LoadRec.lt_min_extents;
            v_Create := v_Create||' Maxextents '||v_LoadRec.lt_max_extents;
        End If;

        v_step := 400;
      If v_LoadRec.lt_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_LoadRec.lt_pct_increase - (TRUNC(v_LoadRec.lt_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_LoadRec.lt_pct_increase||' )';
        End If;

        If v_LoadRec.lt_post_fix IS NOT NULL Then
          v_Create := v_Create||' '||v_LoadRec.lt_post_fix;
        End If;

        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 500;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 600;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 700;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 800;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;

        p_return_msg := 'Table created ' || v_table_with_schema;

        IF v_LoadRec.lt_post_fix IS NULL
        OR instr(v_LoadRec.lt_post_fix,'logging') = 0 Then
          --=====================================================
          -- Alter the table for No Logging
          --=====================================================
          v_Create := 'Alter Table '|| v_table_with_schema ||' NoLogging';

          --=====================================================
          -- Execute the alter statement
          --=====================================================
          BEGIN
              v_step := 900;
              v_cursor := DBMS_SQL.OPEN_CURSOR;
              v_step := 1000;
              DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
              v_step := 1100;
              v_result := DBMS_SQL.EXECUTE(v_cursor);
              v_step := 1200;
              COMMIT;
              DBMS_SQL.CLOSE_CURSOR(v_cursor);
          EXCEPTION WHEN OTHERS THEN
              v_MsgText := substr(v_create,1,1023);
              v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                            v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              If length(v_create) > 1023 Then
                  v_MsgText := substr(v_create,-1023,1023);
                  v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              End If;
              v_MsgText := 'Unhandled exception in create / alter';
              v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              p_return_msg := 'Unhandled exception in create';
              p_status_code := -2;
              v_result := -2;
              RETURN v_result;
          END;
          p_return_msg := p_return_msg||' Nologging';
        End if;

        p_status_code := 1;

        v_result := 1;

    --=====================================================
    -- D I M E N S I O N
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_dim Then
        select * into v_DimRec
        from ws_dim_tab where dt_obj_key = p_obj_key;
        --=====================================================
        -- D I M E N S I O N    T A B L E  create
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||'(';
        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Dim LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.dc_col_name||' '||v_ColRec.dc_data_type;

            IF  LENGTH(TRIM(v_ColRec.dc_default_value)) > 0
            AND v_ColRec.dc_default_value IS NOT NULL
            THEN
--                v_ColRec.dc_default_value := '''' || v_ColRec.dc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.dc_default_value;
            END IF;

            If v_ColRec.dc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;


        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_DimRec.dt_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_DimRec.dt_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_DimRec.dt_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_DimRec.dt_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_DimRec.dt_initial_kb + v_DimRec.dt_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_DimRec.dt_initial_kb||'K';
            v_Create := v_Create||' Next '||v_DimRec.dt_next_kb||'K';
        End If;

        If v_DimRec.dt_min_extents + v_DimRec.dt_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_DimRec.dt_min_extents;
            v_Create := v_Create||' Maxextents '||v_DimRec.dt_max_extents;
        End If;

      If v_DimRec.dt_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_DimRec.dt_pct_increase - (TRUNC(v_DimRec.dt_pct_increase/1000)*1000));
        Else
          v_Create := v_Create||' Pctincrease '||v_DimRec.dt_pct_increase;
        End If;

      If upper(v_DimRec.dt_buffer_pool_ind) = 'K' Then
          v_Create := v_Create||' Buffer_Pool Keep';
      ElsIf upper(v_DimRec.dt_buffer_pool_ind) = 'R' Then
          v_Create := v_Create||' Buffer_Pool Recycle';
      ElsIf upper(v_DimRec.dt_buffer_pool_ind) = 'D' Then
          v_Create := v_Create||' Buffer_Pool Default';
        End If;

        v_Create := v_Create||')';
        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 1300;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 1400;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 1500;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 1600;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in ws_act_create cursor step '||v_step;
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;

    --=====================================================
    -- D I M E N S I O N     V I E W
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_dim_view Then
        select * into v_DimRec
        from ws_dim_tab where dt_obj_key = p_obj_key;
        --=====================================================
        -- D I M E N S I O N    V I E W
        --=====================================================
        v_step := 1700;
        IF v_DimRec.dt_type_ind = 'U' THEN
          IF UPPER(SUBSTR(v_DimRec.dt_gen_spec,1,6)) = 'CREATE' THEN
            v_user_view := 1;
          END IF;
        END IF;

        IF v_user_view = 1 THEN
          v_step := 1800;
          v_create5 := v_DimRec.dt_gen_spec;
          v_create4 := v_DimRec.dt_where;
          v_create3 := v_DimRec.dt_attributes;
          v_create2 := v_DimRec.dt_post_fix;
          v_create := v_DimRec.dt_view_where;
        ELSE
          v_step := 1900;
          v_As := '';
          v_Create := 'Create or replace view '|| v_table_with_schema ||' (';

          -- Loop through all the columns adding them to the create
          --
          For v_ColRec in c_Dim LOOP
              v_step := 2000;
              v_row := v_row + 1;
              If v_row > 1 Then
                  v_Create := v_Create||',';
                  v_As := v_As||',';
              End If;
              -- If we have nearly filled this statement then use another
              If length(v_create) > 3500 Then
                If  v_create5 IS NULL Then
                    v_create5 := v_create;
                    v_create := '';
                ElsIf  v_create4 IS NULL Then
                    v_create4 := v_create;
                    v_create := '';
                ElsIf  v_create3 IS NULL Then
                    v_create3 := v_create;
                    v_create := '';
                ElsIf  v_create2 IS NULL Then
                    v_create2 := v_create;
                    v_create := '';
                Else
                    v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                    v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,NULL,NULL, p_task_id, p_job_id);
                    p_return_msg := 'Create statement too long';
                    p_status_code := -2;
                    RETURN -2;
                End If;
              End If;
              v_Create := v_Create||v_ColRec.dc_col_name;
              If v_ColRec.dc_src_table is not null Then
                  If v_ColRec.dc_transform_code is not null Then
                    v_As := v_As||v_ColRec.dc_transform_code;
                  Else
                    v_As := v_As||v_ColRec.dc_src_table||'.'||v_ColRec.dc_src_column;
                  End If;
              Else
                  If v_ColRec.dc_transform_code is not null Then
                    v_As := v_As||v_ColRec.dc_transform_code;
                  Else
                    v_As := v_As||v_ColRec.dc_src_column;
                  End If;
              End If;

          END LOOP;

          IF v_DimRec.dt_type_ind = 'U' THEN -- User view select
            v_step := 2100;
            v_Create := v_Create||') As ';
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_DimRec.dt_gen_spec;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_DimRec.dt_where;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_DimRec.dt_attributes;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_DimRec.dt_post_fix;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_DimRec.dt_view_where;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;


          ELSE
            v_step := 2200;
            If instr(UPPER(NVL(v_DimRec.dt_attributes,'')),'DISTINCT~;') = 0 Then
              v_Create := v_Create||') As Select '||v_As;
            Else
              v_Create := v_Create||') As Select DISTINCT '||v_As;
            End If;

            -- Check the user specified a from clause
            -- Note empty strings assigned to Varchar2 are treated as NULL in Oracle (http://docs.oracle.com/cd/B28359_01/server.111/b28286/sql_elements005.htm)
            IF instr(UPPER(LTRIM(NVL(v_DimRec.dt_view_where,'DUMMY'))), 'FROM ') <> 1 Then
               v_Create := v_Create||' From ';
               v_row := 0;
               For v_TabRec in c_Tables LOOP
                   v_row := v_row + 1;
                   If v_row > 1 Then
                       v_Create := v_Create||',';
                   End If;
                   if v_table_schema is not null Then
                       v_Create := v_Create||v_table_schema||'.';
                   ElsIf v_schema_flag = 1 Then
                       v_Create := v_Create||v_dss_schema||'.';
                   End If;
                   v_Create := v_Create||v_TabRec.dc_src_table;

               END LOOP;
            End If;

            If v_DimRec.dt_view_where is not null Then
                v_Create := v_Create||' '||v_DimRec.dt_view_where;
            End If;
          END IF; -- END of normal column list
        END IF; -- end of normal view create

        --=====================================================
        -- Replace any $P parameters
        --=====================================================
        BEGIN
          v_step := 2300;
          SELECT WsParameterReplace(v_create,4000) into v_create FROM DUAL;
          v_step := 2400;
          SELECT WsParameterReplace(v_create2,4000) into v_create2 FROM DUAL;
          v_step := 2500;
          SELECT WsParameterReplace(v_create3,4000) into v_create3 FROM DUAL;
          v_step := 2600;
          SELECT WsParameterReplace(v_create4,4000) into v_create4 FROM DUAL;
          v_step := 2700;
          SELECT WsParameterReplace(v_create5,4000) into v_create5 FROM DUAL;
          EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Failure replacing parameter: Step ' ||v_step;
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        END;

        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 2800;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 2900;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 3000;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 3100;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in create';
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'View created ' || v_table_with_schema;
        v_result := 1;

    --=====================================================
    -- V I E W
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_view Then
        select * into v_ViewRec
        from ws_view_tab where vt_obj_key = p_obj_key;

        v_step := 3200;
        IF v_ViewRec.vt_type_ind = 'U' THEN


          v_spos := INSTR(NVL(UPPER(v_ViewRec.vt_gen_spec),''),'~ENDGEN~;');
          IF v_spos <> 0 THEN
            IF LENGTH(NVL(v_ViewRec.vt_gen_spec,'')) > v_spos +10 THEN
              v_ViewRec.vt_gen_spec := SUBSTR(v_ViewRec.vt_gen_spec,v_spos +9);
            ELSE
              v_ViewRec.vt_gen_spec := '';
            END IF;
          END IF;

          v_spos := INSTR(NVL(UPPER(v_ViewRec.vt_where),''),'~ENDWHERE~;');
          IF v_spos <> 0 THEN
            IF LENGTH(NVL(v_ViewRec.vt_where,'')) > v_spos +12 THEN
              v_ViewRec.vt_where := SUBSTR(NVL(v_ViewRec.vt_where,''),v_spos +11);
            ELSE
              v_ViewRec.vt_where := '';
            END IF;
          END IF;


          IF UPPER(SUBSTR(v_ViewRec.vt_gen_spec,1,6)) = 'CREATE' THEN
            v_user_view := 1;
          END IF;
        END IF;

        IF v_user_view = 1 THEN
          v_step := 3300;
          v_create5 := v_ViewRec.vt_gen_spec;
          v_create4 := v_ViewRec.vt_where;
          v_create3 := v_ViewRec.vt_attributes;
          v_create2 := v_ViewRec.vt_post_fix;
          v_create := v_ViewRec.vt_view_where;
        ELSE
          v_step := 3400;
          v_As := '';
          v_Create := 'Create or replace view '|| v_table_with_schema ||' (';

          -- Loop through all the columns adding them to the create
          --
          For v_ColRec in c_View LOOP
              v_step := 3500;
              v_row := v_row + 1;
              If v_row > 1 Then
                  v_Create := v_Create||',';
                  v_As := v_As||',';
              End If;
              -- If we have nearly filled this statement then use another
              If length(v_create) > 3500 Then
                If  v_create5 IS NULL Then
                    v_create5 := v_create;
                    v_create := '';
                ElsIf  v_create4 IS NULL Then
                    v_create4 := v_create;
                    v_create := '';
                ElsIf  v_create3 IS NULL Then
                    v_create3 := v_create;
                    v_create := '';
                ElsIf  v_create2 IS NULL Then
                    v_create2 := v_create;
                    v_create := '';
                Else
                    v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                    v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,NULL,NULL, p_task_id, p_job_id);
                    p_return_msg := 'Create statement too long';
                    p_status_code := -2;
                    RETURN -2;
                End If;
              End If;
              v_Create := v_Create||v_ColRec.vc_col_name;
              If v_ColRec.vc_src_table is not null Then
                  If v_ColRec.vc_transform_code is not null Then
                    v_As := v_As||v_ColRec.vc_transform_code;
                  Else
                    v_As := v_As||v_ColRec.vc_src_table||'.'||v_ColRec.vc_src_column;
                  End If;
              Else
                  If v_ColRec.vc_transform_code is not null Then
                    v_As := v_As||v_ColRec.vc_transform_code;
                  Else
                    v_As := v_As||v_ColRec.vc_src_column;
                  End If;
              End If;

          END LOOP;

          IF v_ViewRec.vt_type_ind = 'U' THEN -- User view select
            v_step := 3600;
            v_Create := v_Create||') As ';
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_ViewRec.vt_gen_spec;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_ViewRec.vt_where;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_ViewRec.vt_attributes;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_ViewRec.vt_post_fix;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create || v_ViewRec.vt_view_where;
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;


          ELSE
            v_step := 3700;

            If instr(UPPER(NVL(v_ViewRec.vt_attributes,'')),'DISTINCT~;') = 0 Then
              v_Create := v_Create||') As Select '||v_As;
            Else
              v_Create := v_Create||') As Select DISTINCT '||v_As;
            End If;

            -- Check the user specified a from clause
            -- Note empty strings assigned to Varchar2 are treated as NULL in Oracle (http://docs.oracle.com/cd/B28359_01/server.111/b28286/sql_elements005.htm)
            IF instr(UPPER(LTRIM(NVL(v_ViewRec.vt_view_where,'DUMMY'))), 'FROM ') <> 1 Then
               v_Create := v_Create||' From ';
               v_row := 0;
               For v_ViewTabRec in c_ViewTables LOOP
                   v_row := v_row + 1;
                   If v_row > 1 Then
                       v_Create := v_Create||',';
                   End If;
                   if v_table_schema is not null Then
                       v_Create := v_Create||v_table_schema||'.';
                   ElsIf v_schema_flag = 1 Then
                       v_Create := v_Create||v_dss_schema||'.';
                   End If;
                   v_Create := v_Create||v_ViewTabRec.vc_src_table;

               END LOOP;
            End If;

            If v_ViewRec.vt_view_where is not null Then
                v_Create := v_Create||' '||v_ViewRec.vt_view_where;
            End If;
          END IF; -- END of normal column list
        END IF; -- end of normal view create

        --=====================================================
        -- Replace any $P parameters
        --=====================================================
        BEGIN
          v_step := 3800;
          SELECT WsParameterReplace(v_create,4000) into v_create FROM DUAL;
          v_step := 3900;
          SELECT WsParameterReplace(v_create2,4000) into v_create2 FROM DUAL;
          v_step := 4000;
          SELECT WsParameterReplace(v_create3,4000) into v_create3 FROM DUAL;
          v_step := 4100;
          SELECT WsParameterReplace(v_create4,4000) into v_create4 FROM DUAL;
          v_step := 4200;
          SELECT WsParameterReplace(v_create5,4000) into v_create5 FROM DUAL;
          EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Failure replacing parameter: Step ' ||v_step;
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        END;

        SELECT v_create5||v_create4||v_create3||v_create2||v_create into v_create_all FROM DUAL;

        v_create_all := REPLACE(v_create_all, '$TABLE$', v_table_name);
        v_create_all := REPLACE(v_create_all, '$OBJECT$', v_table_with_schema);
        v_create_all := REPLACE(v_create_all, '$SCHEMA$', v_table_schema);
        v_create_all := REPLACE(v_create_all, '$TABLESPACE$', v_tablespace);

        -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
        -- Get the initial end location of the statement
        SELECT COALESCE(LENGTH(v_create_all),0) INTO v_end_location FROM DUAL;

        -- Get the end-of-statement indicator, defaults to <EOS>
        SELECT COALESCE(ta_text_3, '<EOS>') INTO v_delimiter FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

        -- Loop through the override statement and execute each statement individually
        WHILE v_end_location > 0
        LOOP
           SELECT INSTR(v_create_all,v_delimiter, v_start_location) INTO v_end_location FROM DUAL;
           SELECT CASE
                  WHEN v_end_location > 0
                  THEN SUBSTR(v_create_all,v_start_location,v_end_location -v_start_location)
                  ELSE SUBSTR(v_create_all,v_start_location)
                  END  INTO v_statement FROM DUAL;

            --=====================================================
            -- Execute the create statement
            --=====================================================
            IF TRIM(TRANSLATE(v_statement, chr(10) || chr(13) || chr(09), ' ')) IS NOT NULL Then
                BEGIN
                    v_step := 4300;
                    v_cursor := DBMS_SQL.OPEN_CURSOR;
                    v_step := 4400;
                    DBMS_SQL.PARSE(v_cursor, v_statement, 1);
                    v_step := 4500;
                    v_result := DBMS_SQL.EXECUTE(v_cursor);
                    v_step := 4600;
                    COMMIT;
                    DBMS_SQL.CLOSE_CURSOR(v_cursor);
                EXCEPTION WHEN OTHERS THEN
                    v_MsgText := substr(v_create,1,1023);
                    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    If length(v_create) > 1023 Then
                        v_MsgText := substr(v_create,-1023,1023);
                        v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    End If;
                    If SQLCODE = -1031 Then
                        v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                        v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    End If;
                    If SQLCODE = -955 Then
                        v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                        p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
                    Else
                        v_MsgText := 'Unhandled exception in create';
                        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                        p_return_msg := 'Unhandled exception in create';
                    End If;
                    p_status_code := -2;
                    v_result := -2;
                    RETURN v_result;
                END;
            END IF;

            SELECT v_end_location + LENGTH(v_delimiter) INTO v_start_location  FROM DUAL;
        END LOOP;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'View created ' || v_table_with_schema;
        v_result := 1;

    --=====================================================
    -- F A C T
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_fact Or p_obj_type = v_ws_obj_fact_kpi Then
        select * into v_FactRec
        from ws_fact_tab where ft_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Fact LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.fc_col_name||' '||v_ColRec.fc_data_type;

            IF  LENGTH(TRIM(v_ColRec.fc_default_value)) > 0
            AND v_ColRec.fc_default_value IS NOT NULL
            THEN
--                v_ColRec.fc_default_value := '''' || v_ColRec.fc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.fc_default_value;
            END IF;

            If v_ColRec.fc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL ';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_FactRec.ft_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_FactRec.ft_tablespace;
        End If;

        v_Create := v_Create||'  PctFree ';
        If v_FactRec.ft_pct_increase > 1000 Then
          v_Create := v_Create||TRUNC(v_FactRec.ft_pct_increase/1000);
        Else
          v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_FactRec.ft_initial_kb + v_FactRec.ft_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_FactRec.ft_initial_kb||'K';
            v_Create := v_Create||' Next '||v_FactRec.ft_next_kb||'K';
        End If;

        If v_FactRec.ft_min_extents + v_FactRec.ft_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_FactRec.ft_min_extents;
            v_Create := v_Create||' Maxextents '||v_FactRec.ft_max_extents;
        End If;

        If v_FactRec.ft_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_FactRec.ft_pct_increase - (TRUNC(v_FactRec.ft_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_FactRec.ft_pct_increase||' )';
        End If;

        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 4700;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 4800;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 4900;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 5000;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;

    --=====================================================
    -- S T A G E
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_stage Then
        select * into v_StageRec
        from ws_stage_tab where st_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Stage LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.sc_col_name||' '||v_ColRec.sc_data_type;

            IF  LENGTH(TRIM(v_ColRec.sc_default_value)) > 0
            AND v_ColRec.sc_default_value IS NOT NULL
            THEN
--                v_ColRec.sc_default_value := '''' || v_ColRec.sc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.sc_default_value;
            END IF;

            If v_ColRec.sc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_StageRec.st_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_StageRec.st_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_StageRec.st_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_StageRec.st_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_StageRec.st_initial_kb + v_StageRec.st_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_StageRec.st_initial_kb||'K';
            v_Create := v_Create||' Next '||v_StageRec.st_next_kb||'K';
        End If;

        If v_StageRec.st_min_extents + v_StageRec.st_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_StageRec.st_min_extents;
            v_Create := v_Create||' Maxextents '||v_StageRec.st_max_extents;
        End If;

           If v_StageRec.st_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_StageRec.st_pct_increase - (TRUNC(v_StageRec.st_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_StageRec.st_pct_increase||' )';
        End If;


        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 5100;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 5200;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 5300;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 5400;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;
    --=====================================================
    -- A G G R E G A T E
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_agg Then
        select * into v_AggRec
        from ws_agg_tab where at_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Agg LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.ac_col_name||' '||v_ColRec.ac_data_type;

            IF  LENGTH(TRIM(v_ColRec.ac_default_value)) > 0
            AND v_ColRec.ac_default_value IS NOT NULL
            THEN
--                v_ColRec.ac_default_value := '''' || v_ColRec.ac_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.ac_default_value;
            END IF;

            If v_ColRec.ac_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_AggRec.at_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_AggRec.at_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_AggRec.at_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_AggRec.at_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_AggRec.at_initial_kb + v_AggRec.at_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_AggRec.at_initial_kb||'K';
            v_Create := v_Create||' Next '||v_AggRec.at_next_kb||'K';
        End If;

        If v_AggRec.at_min_extents + v_AggRec.at_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_AggRec.at_min_extents;
            v_Create := v_Create||' Maxextents '||v_AggRec.at_max_extents;
        End If;

      If v_AggRec.at_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_AggRec.at_pct_increase - (TRUNC(v_AggRec.at_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_AggRec.at_pct_increase||' )';
        End If;


        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 5500;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 5600;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 5700;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 5800;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;

    --=====================================================
    -- R E T R O      C O P Y
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_retro_copy Then
        select * into v_RetroRec
        from ws_retro_tab where rt_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Retro LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.rc_col_name||' '||v_ColRec.rc_data_type;

            IF  LENGTH(TRIM(v_ColRec.rc_default_value)) > 0
            AND v_ColRec.rc_default_value IS NOT NULL
            THEN
--                v_ColRec.rc_default_value := '''' || v_ColRec.rc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.rc_default_value;
            END IF;

            If v_ColRec.rc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_RetroRec.rt_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_RetroRec.rt_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_RetroRec.rt_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_RetroRec.rt_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_RetroRec.rt_initial_kb + v_RetroRec.rt_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_RetroRec.rt_initial_kb||'K';
            v_Create := v_Create||' Next '||v_RetroRec.rt_next_kb||'K';
        End If;

        If v_RetroRec.rt_min_extents + v_RetroRec.rt_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_RetroRec.rt_min_extents;
            v_Create := v_Create||' Maxextents '||v_RetroRec.rt_max_extents;
        End If;

      If v_RetroRec.rt_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_RetroRec.rt_pct_increase - (TRUNC(v_RetroRec.rt_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_RetroRec.rt_pct_increase||' )';
        End If;


        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 5900;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 6000;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 6100;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 6200;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;


    --=====================================================
    -- O D S
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_ods Then
        select * into v_OdsRec
        from ws_ods_tab
        where ot_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Ods LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.oc_col_name||' '||v_ColRec.oc_data_type;

            IF  LENGTH(TRIM(v_ColRec.oc_default_value)) > 0
            AND v_ColRec.oc_default_value IS NOT NULL
            THEN
--                v_ColRec.oc_default_value := '''' || v_ColRec.oc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.oc_default_value;
            END IF;

            If v_ColRec.oc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_OdsRec.ot_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_OdsRec.ot_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_OdsRec.ot_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_OdsRec.ot_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_OdsRec.ot_initial_kb + v_OdsRec.ot_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_OdsRec.ot_initial_kb||'K';
            v_Create := v_Create||' Next '||v_OdsRec.ot_next_kb||'K';
        End If;

        If v_OdsRec.ot_min_extents + v_OdsRec.ot_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_OdsRec.ot_min_extents;
            v_Create := v_Create||' Maxextents '||v_OdsRec.ot_max_extents;
        End If;

      If v_OdsRec.ot_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_OdsRec.ot_pct_increase - (TRUNC(v_OdsRec.ot_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_OdsRec.ot_pct_increase||' )';
        End If;


        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 6300;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 6400;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 6500;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 6600;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;


    --=====================================================
    -- N O R M A L
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_normal
    OR p_obj_type = v_ws_obj_hub
    OR p_obj_type = v_ws_obj_satellite
    OR p_obj_type = v_ws_obj_link
    OR p_obj_type = v_ws_obj_custom1
    OR p_obj_type = v_ws_obj_custom2
    Then
        select * into v_NormalRec
        from ws_normal_tab
        where nt_obj_key = p_obj_key;
        --=====================================================
        -- Build the create string
        --=====================================================
        v_Create := 'Create table '|| v_table_with_schema ||' (';
        v_row := 0;

        -- Loop through all the columns adding them to the create
        --
        For v_ColRec in c_Normal LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
                v_Create := v_Create||',';
            End If;
            -- If we have nearly filled this statement then use another
            If length(v_create) > 3500 Then
              If  v_create5 IS NULL Then
                  v_create5 := v_create;
                  v_create := '';
              ElsIf  v_create4 IS NULL Then
                  v_create4 := v_create;
                  v_create := '';
              ElsIf  v_create3 IS NULL Then
                  v_create3 := v_create;
                  v_create := '';
              ElsIf  v_create2 IS NULL Then
                  v_create2 := v_create;
                  v_create := '';
              Else
                  v_MsgText := 'Object create statement is more than 17500 bytes long. Unable to handle';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                    v_MsgText,NULL,NULL, p_task_id, p_job_id);
                  p_return_msg := 'Create statement too long';
                  p_status_code := -2;
                  RETURN -2;
              End If;
            End If;

            v_Create := v_Create||v_ColRec.nc_col_name||' '||v_ColRec.nc_data_type;

            IF  LENGTH(TRIM(v_ColRec.nc_default_value)) > 0
            AND v_ColRec.nc_default_value IS NOT NULL
            THEN
--                v_ColRec.nc_default_value := '''' || v_ColRec.nc_default_value || '''';
                v_Create := v_Create||' DEFAULT ';
                v_Create := v_Create|| v_ColRec.nc_default_value;
            END IF;

            If v_ColRec.nc_nulls_flag = 'N' Then
                v_Create := v_Create||' NOT NULL';
            End If;

        END LOOP;
        -- Add the rest of the create statement
        --
        v_Create := v_Create||')';
        If v_NormalRec.nt_tablespace is not null Then
            v_Create := v_Create||' Tablespace '||v_NormalRec.nt_tablespace;
        End If;

      v_Create := v_Create||'  PctFree ';
      If v_NormalRec.nt_pct_increase > 1000 Then
        v_Create := v_Create||TRUNC(v_NormalRec.nt_pct_increase/1000);
        Else
        v_Create := v_Create||'0';
        End If;

        v_Create := v_Create||' Storage (';

        If v_NormalRec.nt_initial_kb + v_NormalRec.nt_next_kb <> 0 Then
            v_Create := v_Create||' Initial '||v_NormalRec.nt_initial_kb||'K';
            v_Create := v_Create||' Next '||v_NormalRec.nt_next_kb||'K';
        End If;

        If v_NormalRec.nt_min_extents + v_NormalRec.nt_max_extents <> 0 Then
            v_Create := v_Create||' Minextents '||v_NormalRec.nt_min_extents;
            v_Create := v_Create||' Maxextents '||v_NormalRec.nt_max_extents;
        End If;

      If v_NormalRec.nt_pct_increase > 1000 Then
          v_Create := v_Create||' Pctincrease '||
            (v_NormalRec.nt_pct_increase - (TRUNC(v_NormalRec.nt_pct_increase/1000)*1000))||' )';
        Else
          v_Create := v_Create||' Pctincrease '||v_NormalRec.nt_pct_increase||' )';
        End If;


        --=====================================================
        -- Execute the create statement
        --=====================================================
        BEGIN
            v_step := 6700;
            v_cursor := DBMS_SQL.OPEN_CURSOR;
            v_step := 6800;
            DBMS_SQL.PARSE(v_cursor, v_create5||v_create4||v_create3||v_create2||v_create, 1);
            v_step := 6900;
            v_result := DBMS_SQL.EXECUTE(v_cursor);
            v_step := 7000;
            COMMIT;
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := substr(v_create,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            If length(v_create) > 1023 Then
                v_MsgText := substr(v_create,-1023,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -1031 Then
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            End If;
            If SQLCODE = -955 Then
                v_MsgText := 'Table already exists. Drop it first if you wish to re-create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Table already exists. Drop it first if you wish to re-create';
            Else
                v_MsgText := 'Unhandled exception in create';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                p_return_msg := 'Unhandled exception in ws_act_create cursor step '||v_step;
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        COMMIT;
        p_status_code := 1;
        p_return_msg := 'Table created ' || v_table_with_schema;
        v_result := 1;


    --=====================================================
    -- U N S U P P O R T E D
    --=====================================================
    Else
        v_MsgText := 'Unsupported object type '||p_obj_type;
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                          v_MsgText,NULL,NULL, p_task_id, p_job_id);
        p_return_msg := 'Unsupported object type '||p_obj_type;
        p_status_code := -2;
        RETURN -2;
    End If;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_create. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_create step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_create;
 
_PROCEDURE_ Ws_Act_Dbms_Stats 
-- Notes / History
--
-- WMR 22/01/2002  Version 1.0.0
-- WMR 05/04/2002  Version 1.0.7    Added for all indexed columns to analyze
-- KH  22/12/2003  Version 4.1.0    Added use of dbms stats
-- WMR 24/06/2005  Version 4.1.2.11 include the schema name in the stats if flag set
-- WMR 17/02/2006  Version 5.0.0.2  Look up command to run from ws_table_attributes
-- WMR 23/02/2006  Version 5.0.0.2  Fix to use BEGIN / END construct to call dbms_stats dynamically
-- WMR 07/03/2006  Version 5.0.1.1  Put a begin/End around the ws-table_attributes lookup
-- AP  24/11/2014  Version 6.8.1.2  Schema Support
-- KH  22/10/2015  Version 6.8.4.4  Statement increased to > 4000
-- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_dbms_stats
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_percent     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_act_dbms_stats
    -- Description         :    Analyze a table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_stmt            varchar2(4200); -- statement text
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_cursor          number;
    v_schema          varchar2(100);  -- schema name
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_index_name      varchar2(64);
    v_index_with_schema varchar2(150);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      IF p_obj_type = v_ws_obj_index THEN
        v_step := 110;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
                  ,ih_index_name
        INTO       v_table_schema
                  ,v_table_name
                  ,v_index_name
        FROM       ws_index_header
        LEFT JOIN  ws_obj_object
        ON         ws_obj_object.oo_obj_key = ih_obj_key
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
         WHERE      UPPER(ws_index_header.ih_index_name) = UPPER(p_task_name)
        ;
      else
        v_step := 120;
        v_index_name := '';
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      UPPER(ws_obj_object.oo_name) = UPPER(p_task_name)
        ;
      END IF;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found Name:' || p_task_name;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_index_with_schema := v_table_with_schema || v_index_name;
    v_table_with_schema := v_table_with_schema || v_table_name;


    --=====================================================
    -- Handle either an Index or a Table
    --=====================================================
    If p_obj_type = v_ws_obj_index Then
        v_step := 100;

        If p_percent = 100 Then
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_11 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$INDEX$',p_task_name);
            ELSE
              v_stmt := 'BEGIN dbms_stats.gather_index_stats(ownname=>'''||v_table_schema||''', indname=>'''||
              p_task_name||'''); END;';
            END IF;

        Else
            v_stmt := NULL;
            BEGIN
              SELECT ta_text_12 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
            EXCEPTION WHEN OTHERS THEN
              v_stmt := NULL;
            END;
            IF TRIM(v_stmt) IS NOT NULL THEN
              v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
              v_stmt := REPLACE(v_stmt,'$INDEX$',p_task_name);
            ELSE
               v_stmt := 'BEGIN dbms_stats.gather_index_stats(ownname=>'''||v_table_schema||
               ''', indname=>'''||p_task_name||''', estimate_percent=>'''||p_percent||'''); END;';
            END IF;
        End If;
        p_return_msg := 'Index '||p_task_name||' statistics gathered';

         -- Execute the statement
        v_step := 110;
        Execute Immediate v_stmt;
        v_step := 112;
   Else
        --=====================================================
        -- Table
        --=====================================================
        If p_percent = 100 Then

         v_step := 120;
         v_stmt := NULL;
          BEGIN
            SELECT ta_text_7 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
          EXCEPTION WHEN OTHERS THEN
            v_stmt := NULL;
          END;
          IF TRIM(v_stmt) IS NOT NULL THEN
            v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
            v_stmt := REPLACE(v_stmt,'$TABLE$',p_task_name);
          ELSE
            v_stmt := 'BEGIN dbms_stats.gather_table_stats(ownname=>'''||v_table_schema||
            ''', tabname=>'''||p_task_name||''', cascade=>TRUE); END;';
          END IF;

        Else
          v_stmt := NULL;
          BEGIN
            SELECT ta_text_8 into v_stmt FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'S';
          EXCEPTION WHEN OTHERS THEN
            v_stmt := NULL;
          END;
          IF TRIM(v_stmt) IS NOT NULL THEN
            v_stmt := REPLACE(v_stmt,'$SCHEMA$',v_table_schema);
            v_stmt := REPLACE(v_stmt,'$TABLE$',p_task_name);
          ELSE
            v_stmt := 'BEGIN dbms_stats.gather_table_stats(ownname=>'''||v_table_schema||''',tabname=>'''||
            p_task_name||''',estimate_percent=>'''||p_percent||''',cascade=>TRUE); END;';
          END IF;
        End If;
        p_return_msg := 'Table '||p_task_name||' statistics gathered ';

         -- Execute the statement
        v_step := 130;
        Execute Immediate v_stmt;
        v_step := 132;
    End If;

    v_step := 140;

    p_status_code := 1;

    v_MsgText := substr(v_stmt,1,1023);
    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                  v_MsgText,NULL,NULL, p_task_id, p_job_id);

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_dbms_stats. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        v_MsgText := substr(v_stmt,1,1023);
        v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_dbms_stats step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_dbms_stats;
 
_PROCEDURE_ Ws_Act_Drop 
-- Notes / History
--
-- WMR 22/01/2002     Version 1.0.0
-- WMR 10/02/2005     Version 4.1.1.3  added support for user views and version in errors
-- WMR 24/06/2005     Version 4.1.2.11 include the schema name in the create if flag set
-- AP  01/08/2006     Version 5.5.0.5  Add Version Number as constant to all out messages
--                                     Add call to wswrkerror for each index as drop/built
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
-- AP  13/12/2008     Version 6.0.2.3  Added support for View
-- HM  15/08/2014     Version 6.8.1.2  Added Schema support
-- AP  16/06/2015     Version 6.8.4.1  Added missing PURGE keyword for table drops
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_drop
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_drop
    -- Description    : Drop a table or Index
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(1024);
    v_cursor          number;
    v_IndRec          ws_index_header%ROWTYPE;
    v_part_count      integer := 0;
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_index_done      integer;       -- used to flag successful drop
    v_msg_result      integer := 0;  -- return code
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_index_name      varchar2(64);
    v_index_with_schema varchar2(150);

BEGIN

    v_step := 100;
    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';

    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      IF p_obj_type = v_ws_obj_index THEN
        v_step := 110;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
                  ,ih_index_name
        INTO       v_table_schema
                  ,v_table_name
                  ,v_index_name
        FROM       ws_index_header
        LEFT JOIN  ws_obj_object
        ON         ws_obj_object.oo_obj_key = ih_obj_key
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_index_header.ih_index_key = p_obj_key
        ;
      else
        v_step := 120;
        v_index_name := '';
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_obj_object.oo_obj_key = p_obj_key
        ;
      END IF;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_index_with_schema := v_table_with_schema || v_index_name;
    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;
    --=====================================================
    -- Handle either an Index, Table or View
    --=====================================================
    If p_obj_type = v_ws_obj_index Then

        BEGIN
            v_step := 300;
            Select * into v_IndRec from ws_index_header where ih_index_key = p_obj_key;
            v_step := 400;

            If v_IndRec.ih_partition_type is NULL Then
               v_part_count := 0;
            Else
               Select count(1) into v_part_count
               from all_tab_partitions
               Where table_owner = upper(v_table_schema)
               And   table_name  = upper(v_table_name);
            End If;

            v_step := 500;
            If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                        And v_part_count = 0 Then
                v_stmt := 'alter table '|| v_table_with_schema ||
                          ' drop constraint '||v_index_name;
            Else
                v_stmt := 'drop index '||v_index_with_schema;
            End If;
            v_step := 600;

            v_index_done := 1;
            Execute Immediate v_stmt;
            p_status_code := 1;
            p_return_msg := 'Index '||v_index_with_schema||' dropped';
        EXCEPTION
            WHEN OTHERS THEN
                v_index_done := 0;
                If SQLCODE = -1418 OR SQLCODE = -942 Then
                    p_return_msg := 'Index to be dropped does not exist';
                    p_status_code := -1;
                    v_result := -1;
                Else
                    v_MsgText := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version ||
                            ' Step ' ||v_step||' Object ' ||p_obj_key;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version || ' step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;
        --=====================================================
        -- Put detail message
        --=====================================================
        v_step := 700;
        IF v_index_done = 1 THEN

          v_step := 800;
          v_MsgText := 'Index ' || v_index_with_schema || ' dropped';
          v_msg_result := WsWrkError(
             'I'
          ,  p_job_name
          ,  p_task_name
          ,  p_sequence
          ,  v_MsgText
          ,  NULL
          ,  NULL
          ,  p_task_id
          ,  p_job_id
          ,  NULL);

        END IF;

    ElsIf p_obj_type = v_ws_obj_dim_view
    OR    p_obj_type = v_ws_obj_view Then

        v_stmt := 'drop view '|| v_table_with_schema;
        v_step := 900;
        BEGIN
            Execute Immediate v_stmt;
            p_status_code := 1;
            p_return_msg := 'View '|| v_table_with_schema ||' dropped';
        EXCEPTION
            WHEN OTHERS THEN
                If SQLCODE = -1418 OR SQLCODE = -942 Then
                    p_return_msg := 'View to be dropped does not exist';
                    p_status_code := -1;
                    v_result := -1;
                Else
                    v_MsgText := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version ||
                            ' Step ' ||v_step;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version || ' step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;
    Else
        --=====================================================
        -- Table. But if an agg need to drop the materialized view
        --=====================================================
        If p_obj_type = v_ws_obj_agg Then
          v_stmt := 'drop materialized view '|| v_table_with_schema;
          v_step := 1000;
          BEGIN
            Execute Immediate v_stmt;
            p_status_code := 1;
            p_return_msg := 'Materialized view '|| v_table_with_schema||' dropped';
          EXCEPTION
            WHEN OTHERS THEN
            p_status_code := -1;
          END;
        End If;

        --=====================================================
        -- Now drop the Table
        --=====================================================
        v_stmt := 'DROP TABLE '|| v_table_with_schema || ' PURGE';
        v_step := 1100;
        BEGIN
            Execute Immediate v_stmt;
            p_status_code := 1;
            p_return_msg := 'Table '|| v_table_with_schema ||' dropped';
        EXCEPTION
            WHEN OTHERS THEN
                If SQLCODE = -1418 OR SQLCODE = -942 Then
                    p_return_msg := 'Table to be dropped does not exist';
                    p_status_code := -1;
                    v_result := -1;
                Else
                    v_MsgText := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version ||
                            ' Step ' ||v_step;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version || ' step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;
    End If;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_drop '|| v_ws_pro_version || ' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_drop;
 
_PROCEDURE_ Ws_Act_Drop_All 
-- Notes / History
--
-- WMR 30/08/2001 Ver 0.3.0.6  Added support for Primary Keys
-- WMR 21/01/2002 Ver 1.0.0.0  Added support for Partitioned indexes
-- WMR 24/06/2005 Ver 4.1.2.11 include the schema name in the drop if flag set
-- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to all out messages
--                             Add call to wswrkerror for each index as drop/built
--                             Correct message count number
-- HM  15/08/2014 Ver 6.8.1.2  Added Schema support
-- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_drop_all
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_drop_all
    -- Description    : Drop all indexes associated with an object
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(1024);
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_index_done      integer;       -- used to flag successful drop
    v_msg_result      integer := 0;  -- return code
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);
    v_index_name      varchar2(64);
    v_index_with_schema varchar2(150);

    --=====================================================
    -- Cursor for all indexes
    --=====================================================
    Cursor c_Index is
    Select * from ws_index_header
    Where ih_obj_key = p_obj_key;

BEGIN

    v_step := 100;
    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';

    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      IF p_obj_type = v_ws_obj_index THEN
        v_step := 110;
        SELECT     NVL(dt_schema, '')
                  ,oo_name
                  ,ih_index_name
        INTO       v_table_schema
                  ,v_table_name
                  ,v_index_name
        FROM       ws_index_header
        LEFT JOIN  ws_obj_object
        ON         ws_obj_object.oo_obj_key = ih_obj_key
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_index_header.ih_index_key = p_obj_key
        ;
      else
        v_step := 120;
        v_index_name := '';
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_obj_object.oo_obj_key = p_obj_key
        ;
      END IF;

      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;

    --=====================================================
    -- Loop through all the indexes to drop
    -- May not be any
    --=====================================================
    p_status_code := 1;
    p_return_msg := '';
    FOR v_IndRec in c_Index LOOP
        v_step := 300;

    v_index_name := v_IndRec.ih_index_name;
        v_index_with_schema := TRIM(v_table_schema);
        IF TRIM(v_index_with_schema) IS NOT NULL THEN
           v_index_with_schema := v_index_with_schema ||'.';
        END IF;
        v_index_with_schema := v_index_with_schema || v_index_name;

        v_step := 350;
        If v_IndRec.ih_partition_type is NULL Then
           v_part_count := 0;
        else
           Select count(1) into v_part_count
           from all_tab_partitions
           Where table_owner = upper(v_table_schema)
           And   table_name  = upper(v_table_name);
        End If;

        v_step := 400;
        If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
            v_stmt := 'alter table '||v_table_with_schema ||
                      ' drop constraint '||v_index_name;
        Else
            v_stmt := 'drop index '||v_index_with_schema;
        End If;

        -- Execute the drop
        v_step := 500;
        BEGIN
            v_index_done := 1;
            Execute Immediate v_stmt;

        EXCEPTION
            WHEN OTHERS THEN
                If SQLCODE = -2443 Then
                    v_stmt := 'drop index '||v_index_with_schema ;
                    BEGIN
                        Execute Immediate v_stmt;
                    EXCEPTION
                        WHEN OTHERS THEN
                            v_index_done := 0;
                            v_MsgText := 'Index '||v_index_with_schema ||' does not exist';
                            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                              v_MsgText,NULL,NULL, p_task_id, p_job_id);
                    END;
                ElsIf SQLCODE = -1418 OR SQLCODE = -942 Then
                    v_index_done := 0;
                    v_MsgText := 'Index '||v_index_with_schema ||' does not exist';
                    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,NULL,NULL, p_task_id, p_job_id);
                Else
                    v_index_done := 0;
                    v_MsgText := 'Unhandled Exception in ws_act_drop_all '|| v_ws_pro_version ||
                            ' Step ' ||v_step;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_drop_all step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;
        --=====================================================
        -- Put detail message
        --=====================================================
        v_step := 600;
        IF v_index_done = 1 THEN

          v_count := v_count + 1;
          v_step := 700;
          v_MsgText := 'Index ' || v_index_with_schema  || ' dropped';

          v_msg_result := WsWrkError(
             'I'
          ,  p_job_name
          ,  p_task_name
          ,  p_sequence
          ,  v_MsgText
          ,  NULL
          ,  NULL
          ,  p_task_id
          ,  p_job_id
          ,  NULL);

        END IF;

        v_step := 800;
    END LOOP;

    v_step := 900;
    -- tell them how many indexes we dropped
    If v_count = 0 Then
       p_return_msg := 'No indexes to drop'||p_return_msg;
    ElsIf v_count = 1 Then
       p_return_msg := v_count||' index dropped'||p_return_msg;
    Else
       p_return_msg := v_count||' indexes dropped'||p_return_msg;
    End If;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_drop_all '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_drop_all '|| v_ws_pro_version || ' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_drop_all;
 
_PROCEDURE_ Ws_Act_Execute 
-- Notes / History
--
-- WMR 22/01/2002   Version 1.0.0
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_execute
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_act_execute
    -- Description    :    Execute a function or procedure
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText                  varchar2(1024); -- Text in audit_trail
    v_step                     integer := 0;   -- return code
    v_result                   integer := 0;   -- return code
    v_stmt                     varchar2(1024);
    v_cursor                   number;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_step := 12;
    -- Build up our execute statement for the procedure
    v_stmt := 'BEGIN '|| p_task_name
     || '(:p1, :p2, :p3, :p4, :p5, :p6, :p7); END;';
    v_step := 14;
    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
    v_step := 20;

    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', p_sequence);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p2', p_job_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p3', p_task_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p4', p_job_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p5', p_task_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p6', p_return_msg,1024);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p7', p_status_code);
    v_step := 30;

    --=====================================================
    -- Call the procedure
    --=====================================================
    BEGIN
        v_step := 39;
        v_result := DBMS_SQL.EXECUTE(v_cursor);
        v_step := 40;
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p6', p_return_msg);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p7', p_status_code);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
        p_return_msg := 'Unhandled Exception in call to ' ||p_task_name;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
              p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_status_code := -3;
    END;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_execute. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_execute step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_execute;
 
_PROCEDURE_ Ws_Act_Host_Script 
-- Notes / History
--
-- WMR 22/01/2002 Ver 1.0.0
-- WMR 08/04/2002 Ver 1.0.7    Added trailing nullcols to windows load
-- WMR 29/12/2003 Ver 4.1.0    Added support for non present script
-- WMR 13/02/2004 Ver 4.1.0.7  Added support for XML loads
-- WMR 16/05/2004 Ver 4.1.0.8  Added support for wildcard in file name, fixed width
--                                 0 length positional columns
-- WMR 23/05/2004 Ver 4.1.0.8  Added support for optional enclosed by and direct path
-- WMR 13/06/2004 Ver 4.1.0.8  Added handling of wild card and spaces in path name
-- WMR 13/06/2004 Ver 4.1.0.8  Added support for comments in the transform
-- WMR 27/06/2004 Ver 4.1.0.8  Added support for compress on rename
-- WMR 22/07/2004 Ver 4.1.0.8  Handle wild card trigger file renames
-- JML 24/08/2004 Ver 4.1.0.8  Fixed bug in trigger files.   Changed:
--                                    let NOW_HH="$NOW_MM * 60" '||chr(10));
--                                    to:
--                                    let NOW_MM="$NOW_MM * 60" '||chr(10));
-- JML 25/08/2004 Ver 4.1.0.8  Changed if -r test to cater for wildcards, as double
--                                   quotes make wild cards literal.
-- WMR 10/09/2004 Ver 4.1.0.8  Added support for WHEN in SQL*Loader loads
-- WMR 10/09/2004 Ver 4.1.0.8  Added support for Parameters in file/trigger path and name
-- WMR 12/10/2004 Ver 4.1.1.2  Added support for Parameters in file/trigger rename path,name
-- WMR 27/10/2004 Ver 4.1.1.2  Fixed problem whereby after transformation where included in file load
-- WMR 17/02/2005 Ver 4.1.1.3  Move a trigger file before the load file on a rename. Add version
-- WMR 18/02/2005 Ver 4.1.1.3  Add support for row_file_name in single column load text files
-- WMR 13/03/2006 Ver 5.0.1.4  Clean out the script header and line files in case child job restart
-- WMR 09/06/2006 Ver 5.0.1.6  Moved the script file clean out to the start of the procedure
-- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to all out messages
--                             Added call to WsParameterReplace for param substitution of
--                                   script lines
-- JML 17/04/2007 Ver 5.6.0.0  Support for Export Objects Added.
-- JML 11/07/2007 Ver 5.6.1.1  Added support for ASCII delimiters in exports.
--                             Added support for where clause in exports.
--                             Added support for sqlplus SET in exports.
-- AP  09/10/2008 Ver 5.5.0.5  Pipe date parts thru bc to remove lead 0
-- AP  26/01/2009 Ver 6.0.2.3  Changed export head lines to ensure dont exceed 256 char on task_scr_line
-- MXU 05/03/2014 Ver 6.7.4.1  RED_2771:Trim CR or LF in transform code to fix file load error in the windows scheduler
-- AP  29/05/2014 Ver 6.8.0.1  Support characterset for sqlloader
-- MXU 13/08/2014 Ver 6.8.1.2  RED_3923:Correct the hard coded message "Export of fact_orders Completed"
-- HM  19/08/2014 Ver 6.8.1.2  Added Schema support.
-- HM  20/10/2014 Ver 6.8.1.2  Fix "Export Completed" message.
-- HM  22/10/2014 Ver 6.8.1.2  RED_3853:Unix file based load: ensure correct login when TWO_TASK defined.
-- HM  28/10/2014 Ver 6.8.1.2  RED_3924:Add OSERROR and SQLERROR handling.
-- MXU 23/10/2014 Ver 6.8.1.2  RED_2257:Add CONSTANT_FILE_NAME to protect back slashes
-- HM  05/11/2014 Ver 6.8.1.2  RED_4207:Fix export when using single quotes to enclose record values.
-- HM  10/11/2014 Ver 6.8.1.2  RED_3853:Insert WSL_SID for script loads.
-- KH  26/11/2014 Ver 6.8.1.2  RED_4296:Removed question mark in comment.
-- HM  27/11/2014 Ver 6.8.1.2  RED_4302:Finish "enclose-by" fix started in RED_4207.
-- RS  08/12/2014 Ver 6.8.1.3  RED_4349 Masked password in call of sqlldr to allow special characters
-- RS  05/01/2015 Ver 6.8.2.1  RED_4373: Remove plain user/password for file exports
-- RS  31/03/2015 Ver 6.8.3.3  RED_4820: Redirection of sqlldr stdout to log-file
-- HM  13/04/2015 Ver 6.8.3.3  RED_4650: Fix work directory for Hadoop scheduler
-- TA  17/04/2015 Ver 6.8.3.3  RED_4816: Use Script Shell configuration from connection
-- BC  14/08/2015 Ver 6.8.4.3  RED_5520: Replaced occurrences of the != SQL operator with <>
-- HM  04/03/2016 Ver 6.8.5.3  RED_6416: Add export object source schema look up
-- HM  21/03/2016 Ver 6.8.5.4  RED_6199: Fix export when using single quotes, double quotes and backslash to
--                                       enclose record values.
-- HM  16/06/2016 Ver 6.8.6.1  RED_4934: Inject JOB_NAME and TASK_NAME into the script.
-- BC  29/08/2016 Ver 6.8.6.2  RED-7032: Script based loads from Database/ODBC connections return host information for script connection
-- BC  18/11/2016 Ver 6.8.6.3  RED-7329: Initialise new environment variables for Script-based loads and exports.
-- BC  18/01/2017 Ver 6.8.7.1  RED-3545: Change the value for wtsh_load_type to indicate a Powershell script.
-- BC  27/03/2017 Ver 6.8.7.1  RED-7778: Fix to set WSL_LOAD_SCHEMA and WSL_EXP_SCHEMA only if not already set in execution environment.
-- BC  07/04/2017 Ver 6.8.8.0  RED-8076: Fix to set WSL_LOAD_SCHEMA and WSL_EXP_SCHEMA in PowerShell syntax if executing a PowerShell script.
-- KH  04/05/2018 Ver 8.2.1.0  RED-9436: Oracle Client 12.2 is adding row count to stdout, sqlldr stdout goes to null.
-- BC  11/06/2018 Ver 8.2.1.0  RED-9530: Fixed WSL_LOAD_SCHEMA and WSL_EXP_SCHEMA to be correctly formatted with a trailing dot.
--                                       Also fixed WSL_LOAD_FULLNAME and WSL_EXP_FULLNAME to be correctly formatted.
-- TA  23/11/2018 Ver 8.3.1.0  RED-9975: Support arbitrary script interpreters for Unix scripts
-- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_host_script
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ===============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_host_script
    -- Description    : Handles a host script, file or script based load
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- ===============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    v_ws_script_execute        constant varchar2(1) := 'S';
    v_ws_load_script           constant varchar2(1) := 'L';
    v_ws_load_file             constant varchar2(1) := 'F';
    v_ws_load_xml              constant varchar2(1) := 'X';

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText                  varchar2(1024); -- Text in audit_trail
    v_step                     integer := 0;   -- return code
    v_result                   integer := 0;   -- return code
    v_stmt                     varchar2(4000);
    v_file_charset             varchar2(256);
    v_create                   varchar2(4000);
    v_rec_delimiter            varchar2(256);
    v_rec_options              varchar2(256);
    v_rec_when                 varchar2(256);
    v_rec_enclosed             varchar2(256);
    v_count                    integer := 0;
    v_view                     integer := 0;
    v_cursor                   number;
    v_row_count                integer := 0;
    v_source_con_type          varchar2(1);
    v_connect_key              integer := 0;
    v_script_key               integer := 0;
    v_load_key                 integer := 0;
    v_script_type              varchar2(1);
    v_load_type                varchar2(1);
    v_host_type                varchar2(1);
    v_line_no                  integer := 0;
    v_min_line_no              integer := 0;
    v_col_count                integer := 0;
    v_row                      integer := 0;
    v_fix                      varchar2(256);
    v_script                   varchar2(512);
    v_lookfor                  varchar2(512);
    v_work_dir                 varchar2(256);
    v_file_path                varchar2(1024);
    v_trig_path                varchar2(1024);
    v_compress_path            varchar2(1024);
    v_file_rename              varchar2(256);
    v_trig_rename              varchar2(256);
    v_file_repath              varchar2(256);
    v_trig_repath              varchar2(256);
    v_skip                     varchar2(12);
    v_pos                      integer := 0;
    v_cpos                     integer := 0;
    v_epos                     integer := 0;
    v_spos                     integer := 0;
    v_action                   varchar2(10);
    v_rename                   varchar2(512);
    v_command                  varchar2(256);
    v_new_command              varchar2(256);
    v_current_date             date;
    v_work                     varchar2(4000);
    v_work2                    varchar2(4000);
    v_work3                    varchar2(4000);
    v_shell                    varchar2(24);
    v_file_seq                 integer := 0;
    v_wild                     integer := 0;
    v_t1pos                    integer := 0;
    v_t2pos                    integer := 0;
    v_compress                 integer := 0;
    v_rowseq                   integer := 0;
    v_rowname                  integer := 0;
    v_first_time               integer;
    v_nlength                  integer;
    v_src_table                varchar2(64);
    v_line                     varchar2(256);
    v_protector                varchar2(10);
    v_file_slash               varchar2(10);
    v_str_quote                varchar2(10);
    v_enclosed_by              varchar2(10);
    v_table_schema             varchar2(64);
    v_dc_attributes            varchar2(4000);
    v_att_slice                varchar2(4000);
    v_att_pos                  integer;
    v_att_len                  integer;
    v_load_table_schema        varchar2(64);
    v_load_table_db            varchar2(64);
    v_load_table_fullname      varchar2(194);
    v_load_target_dsn          varchar2(64);
    v_load_target_server       varchar2(64);
    v_load_target_dbport       varchar2(64);
    v_load_target_dbid         varchar2(64);
    v_load_source_dsn          varchar2(64);
    v_load_source_server       varchar2(64);
    v_load_source_dbport       varchar2(64);
    v_load_source_dbid         varchar2(64);
    v_load_source_db           varchar2(64);
    v_load_source_schema       varchar2(64);
    v_exp_source_table         varchar2(64);
    v_exp_source_schema        varchar2(64);
    v_exp_source_db            varchar2(64);
    v_exp_source_fullname      varchar2(194);
    v_exp_source_dsn           varchar2(64);
    v_exp_source_server        varchar2(64);
    v_exp_source_dbport        varchar2(64);
    v_exp_source_dbid          varchar2(64);
    v_meta_dsn                 varchar2(64);
    v_meta_server              varchar2(64);
    v_meta_dbid                varchar2(64);
    v_meta_db                  varchar2(64);
    v_meta_schema              varchar2(65);
    v_param_obj_name           varchar2(64);

    v_LoadRec         ws_load_tab%ROWTYPE;
    v_ExpRec          ws_export_tab%ROWTYPE;
    v_ConnectRec      ws_dbc_connect%ROWTYPE;
    v_ScriptRec       ws_scr_header%ROWTYPE;
    v_ParameterRec    dss_parameter%ROWTYPE;

    --=====================================================
    -- Cursor for all columns in the load table (parsed)
    --=====================================================
    Cursor c_LoadCol is
          Select lc_col_name, lc_data_type, lc_transform_code, lc_src_column,
          lc_transform_type
          From ws_load_col
          Where lc_obj_key = p_obj_key
          and lc_src_column like 'COL%'
          Order by lc_order;

    --=====================================================
    -- Cursor for all columns in the export object (parsed)
    --=====================================================
    Cursor c_ExpCol is
          Select ec_col_name, ec_data_type, ec_transform_code, ec_src_column,
          ec_transform_type, ec_src_table, ec_display_name
          From ws_export_col
          Where ec_obj_key = p_obj_key
          Order by ec_order;

    --=====================================================
    -- Cursor for all column names in the load table
    --=====================================================
    Cursor c_LoadAll is
          Select lc_col_name
          From ws_load_col
          Where lc_obj_key = p_obj_key;

BEGIN

    v_step := 100;

    -- Clean out the script file in case a restart on a child job
    Delete from ws_wrk_task_scr_line
    where wtsl_task_key = p_task_id
    and   wtsl_job_key  = p_job_id
    and   wtsl_sequence = p_sequence;

    Delete from ws_wrk_task_scr_hdr
    where wtsh_task_key = p_task_id
    and   wtsh_job_key  = p_job_id
    and   wtsh_sequence = p_sequence;

    v_step := 101;

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      SELECT     NVL(dt_schema, '')
      INTO       v_table_schema
      FROM       ws_dbc_target
      INNER JOIN ws_obj_object
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = p_obj_key
      ;
      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_table_schema := '';
    END;

    v_step := 102;

    --=====================================================
    -- Handle:
    -- (1) a straight script execution where we are just
    -- passed the script object
    -- (2) a script based load where we are passed the
    -- the load object and then can lookup the script obj
    -- (3) a file based load where we have to build up
    -- the script to be used.
    --=====================================================

    v_script_key := 0;

    If p_obj_type = v_ws_obj_script Then
        v_script_key := p_obj_key;
        v_script_type := v_ws_script_execute;
    ElsIf p_obj_type = v_ws_obj_load Then
        select * into v_LoadRec
        from ws_load_tab
        where lt_obj_key = p_obj_key;

        BEGIN
            select dc_type into v_source_con_type
            from ws_dbc_connect
            where dc_obj_key = v_LoadRec.lt_connect_key;
        EXCEPTION WHEN NO_DATA_FOUND THEN
            v_source_con_type := '';
        END;

        v_step := 200;
        v_load_type := v_LoadRec.lt_type;
        If v_LoadRec.lt_type = 'S' Then
            v_script_key := v_LoadRec.lt_script_key;
            v_script_type := v_ws_load_script;
            v_load_type := '';
        ElsIf v_LoadRec.lt_type = 'F' Then
            v_script_key := 0;
            v_script_type := v_ws_load_file;
        ElsIf v_LoadRec.lt_type = 'X' Then
            v_script_key := 0;
            v_script_type := v_ws_load_xml;
        Else
            p_return_msg := 'Unsupported host script method. Not a File, XML or Script Load. Load Type is ' ||
                            v_LoadRec.lt_type;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        End If;

        -- If a file load then replace any parameters in the file name
        If v_LoadRec.lt_type = 'F' Then
          v_step := 210;
          -- lt_file_name
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_file_name,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_file_name,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_file_name,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_file_name) Then
                  v_work2 := Substr(v_LoadRec.lt_file_name,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_file_name := Substr(v_LoadRec.lt_file_name,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_file_path
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_file_path,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_file_path,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_file_path,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_file_path) Then
                  v_work2 := Substr(v_LoadRec.lt_file_path,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_file_path := Substr(v_LoadRec.lt_file_path,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_trig_name
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_trig_name,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_trig_name,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_trig_name,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_trig_name) Then
                  v_work2 := Substr(v_LoadRec.lt_trig_name,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_trig_name := Substr(v_LoadRec.lt_trig_name,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_trig_path
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_trig_path,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_trig_path,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_trig_path,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_trig_path) Then
                  v_work2 := Substr(v_LoadRec.lt_trig_path,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_trig_path := Substr(v_LoadRec.lt_trig_path,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;


          -- lt_file_name_rename
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_file_name_rename,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_file_name_rename,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_file_name_rename,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_file_name_rename) Then
                  v_work2 := Substr(v_LoadRec.lt_file_name_rename,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_file_name_rename := Substr(v_LoadRec.lt_file_name_rename,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_file_path_rename
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_file_path_rename,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_file_path_rename,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_file_path_rename,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_file_path_rename) Then
                  v_work2 := Substr(v_LoadRec.lt_file_path_rename,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_file_path_rename := Substr(v_LoadRec.lt_file_path_rename,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_trig_name_rename
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_trig_name_rename,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_trig_name_rename,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_trig_name_rename,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_trig_name_rename) Then
                  v_work2 := Substr(v_LoadRec.lt_trig_name_rename,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_trig_name_rename := Substr(v_LoadRec.lt_trig_name_rename,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- lt_trig_path_rename
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_LoadRec.lt_trig_path_rename,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_LoadRec.lt_trig_path_rename,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_loadRec.lt_trig_path_rename,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_LoadRec.lt_trig_path_rename) Then
                  v_work2 := Substr(v_LoadRec.lt_trig_path_rename,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_LoadRec.lt_trig_path_rename := Substr(v_LoadRec.lt_trig_path_rename,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

        End If;

        If v_LoadRec.lt_type = 'S' Then

          v_load_table_schema := trim(NVL(v_table_schema,''));
          If v_load_table_schema IS NOT NULL Then
              v_load_table_schema := v_load_table_schema||'.';
          End If;

          v_load_table_db := '';

          v_load_table_fullname := coalesce(trim(v_load_table_db),'');
          If v_load_table_fullname IS NOT NULL Then
            v_load_table_fullname := v_load_table_fullname||'.';
          End If;
          If v_load_table_schema IS NOT NULL Then
            v_load_table_fullname := v_load_table_fullname||v_load_table_schema;
          End If;
          v_load_table_fullname := v_load_table_fullname||v_LoadRec.lt_table_name;

          BEGIN
            SELECT dc_odbc_source
                 , dc_database_id
                 , dc_attributes
            INTO   v_load_target_dsn
                 , v_load_target_dbid
                 , v_dc_attributes
            FROM   ws_obj_object
            LEFT JOIN ws_dbc_target
            ON oo_target_key = dt_target_key
            LEFT JOIN ws_dbc_connect
            ON (oo_target_key <> 0 AND dt_connect_key = dc_obj_key) OR (oo_target_key = 0 AND dc_attributes LIKE '%DataWarehouse;%')
            WHERE  oo_obj_key = p_obj_key;
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              v_load_target_dsn := '';
              v_load_target_dbid := '';
              v_dc_attributes := NULL;
            WHEN TOO_MANY_ROWS THEN
              v_MsgText := 'Multiple rows found for load storage connection, job: '|| p_job_name ||'.';
              v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                     v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              RETURN -2;
          END;

          If v_dc_attributes IS NOT NULL Then
            v_att_pos := instr(v_dc_attributes, 'DBServer~=');
            If v_att_pos <> 0 Then
              v_att_slice := substr(v_dc_attributes, v_att_pos + 10);
              v_att_pos := instr(v_att_slice, ';');
              If v_att_pos <> 0 Then
                v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                v_load_target_server := substr(v_att_slice, v_att_pos + 1, v_att_len);
              End If;
            End If;

            v_att_pos := instr(v_dc_attributes, 'DBPort~=');
            If v_att_pos <> 0 Then
              v_att_slice := substr(v_dc_attributes, v_att_pos + 8);
              v_att_pos := instr(v_att_slice, ';');
              If v_att_pos <> 0 Then
                v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                v_load_target_dbport := substr(v_att_slice, v_att_pos + 1, v_att_len);
              End If;
            End If;
          End If;

          If v_source_con_type = 'D' OR v_source_con_type = 'O' OR v_source_con_type = 'Z' Then
            BEGIN
              SELECT lt_source_schema
              INTO   v_load_source_schema
              FROM   ws_load_tab
              WHERE  lt_obj_key = p_obj_key;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                v_load_source_schema := '';
              WHEN TOO_MANY_ROWS THEN
                v_MsgText := 'Multiple rows found for load table source schema, job: '|| p_job_name ||'.';
                v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                       v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                RETURN -2;
            END;

            BEGIN
              SELECT dc_odbc_source
                   , dc_database_id
                   , dc_attributes
              INTO   v_load_source_dsn
                   , v_load_source_dbid
                   , v_dc_attributes
              FROM   ws_dbc_connect
              WHERE  dc_obj_key = v_LoadRec.lt_connect_key;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                v_load_source_dsn := '';
                v_load_source_dbid := '';
                v_dc_attributes := NULL;
              WHEN TOO_MANY_ROWS THEN
                v_MsgText := 'Multiple rows found for load table source connection, job: '|| p_job_name ||'.';
                v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                       v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                RETURN -2;
            END;

            If v_dc_attributes IS NOT NULL Then
              v_att_pos := instr(v_dc_attributes, 'DBServer~=');
              If v_att_pos <> 0 Then
                v_att_slice := substr(v_dc_attributes, v_att_pos + 10);
                v_att_pos := instr(v_att_slice, ';');
                If v_att_pos <> 0 Then
                  v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                  v_load_source_server := substr(v_att_slice, v_att_pos + 1, v_att_len);
                End If;
              End If;

              v_att_pos := instr(v_dc_attributes, 'DBPort~=');
              If v_att_pos <> 0 Then
                v_att_slice := substr(v_dc_attributes, v_att_pos + 8);
                v_att_pos := instr(v_att_slice, ';');
                If v_att_pos <> 0 Then
                  v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                  v_load_source_dbport := substr(v_att_slice, v_att_pos + 1, v_att_len);
                End If;
              End If;
            End If;

            v_load_source_db := '';
          End If;

          v_param_obj_name := v_LoadRec.lt_table_name;
        End If;

    ElsIf p_obj_type = v_ws_obj_export Then
        select * into v_ExpRec
        from ws_export_tab
        where et_obj_key = p_obj_key;

        v_step := 200;
        v_load_type := v_ExpRec.et_type;
        If v_ExpRec.et_type = 'S' Then
            v_script_key := v_ExpRec.et_script_key;
            v_script_type := v_ws_load_script;
            v_load_type := '';
        ElsIf v_ExpRec.et_type = 'F' Then
            v_script_key := 0;
            v_script_type := v_ws_load_file;
        Else
            p_return_msg := 'Unsupported host script method. Not a File or Script Export. Export Type is ' ||
                            v_ExpRec.et_type;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        End If;

        -- Convert et_file_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
        v_work := UPPER(v_ExpRec.et_file_delimiter);
        IF ( INSTR(v_work,'CHAR(') > 0 ) THEN
            v_work := REPLACE(v_work,'CHAR(',NULL);
            IF ( INSTR(v_work,')') > 0 ) THEN
                v_work := REPLACE(v_work,')',NULL);
                BEGIN
                    v_work := CHR(v_work);
                    v_ExpRec.et_file_delimiter := v_work;
                EXCEPTION
                    WHEN OTHERS THEN
                        NULL;
                END;
            END IF;
        END IF;

        -- Convert et_trig_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
        v_work := UPPER(v_ExpRec.et_trig_delimiter);
        IF ( INSTR(v_work,'CHAR(') > 0 ) THEN
            v_work := REPLACE(v_work,'CHAR(',NULL);
            IF ( INSTR(v_work,')') > 0 ) THEN
                v_work := REPLACE(v_work,')',NULL);
                BEGIN
                    v_work := CHR(v_work);
                    v_ExpRec.et_trig_delimiter := v_work;
                EXCEPTION
                    WHEN OTHERS THEN
                        NULL;
                END;
            END IF;
        END IF;

        -- If a file export then replace any parameters in the file name
        If v_ExpRec.et_type = 'F' Then
          v_step := 210;
          -- et_file_name
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_ExpRec.et_file_name,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_ExpRec.et_file_name,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_ExpRec.et_file_name,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_ExpRec.et_file_name) Then
                  v_work2 := Substr(v_ExpRec.et_file_name,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_ExpRec.et_file_name := Substr(v_ExpRec.et_file_name,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- et_file_path
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_ExpRec.et_file_path,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_ExpRec.et_file_path,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_ExpRec.et_file_path,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_ExpRec.et_file_path) Then
                  v_work2 := Substr(v_ExpRec.et_file_path,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_ExpRec.et_file_path := Substr(v_ExpRec.et_file_path,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- et_trig_name
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_ExpRec.et_trig_name,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_ExpRec.et_trig_name,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_ExpRec.et_trig_name,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_ExpRec.et_trig_name) Then
                  v_work2 := Substr(v_ExpRec.et_trig_name,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_ExpRec.et_trig_name := Substr(v_ExpRec.et_trig_name,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          -- et_trig_path
          v_cpos := 1;
          While v_cpos > 0 Loop
            v_step := 220;
            v_cpos := Instr(v_ExpRec.et_trig_path,'$P');
            If v_cpos > 0 Then
              v_step := 230;
              v_epos := Instr(v_ExpRec.et_trig_path,'$',v_cpos+2);
              If v_epos > v_cpos Then
                v_step := 240;
                v_work := WsParameterRead(substr(v_ExpRec.et_trig_path,v_cpos+2,(v_epos-v_cpos)-2));
                If v_epos+1 <= LENGTH(v_ExpRec.et_trig_path) Then
                  v_work2 := Substr(v_ExpRec.et_trig_path,v_epos+1,9999);
                Else
                  v_work2 := '';
                End If;
                v_step := 260;
                v_ExpRec.et_trig_path := Substr(v_ExpRec.et_trig_path,1,v_cpos-1)||v_work||v_work2;
              Else
                v_cpos := -1;
              End If;
            End If;
          End Loop;

          v_step := 220;
          -- look up export source object schema from ws_dbc_target
          BEGIN
            SELECT NVL(ws_dbc_target.dt_schema, '')
            INTO v_table_schema
            FROM ws_obj_object
            LEFT OUTER JOIN ws_dbc_target ON ws_obj_object.oo_target_key = ws_dbc_target.dt_target_key
            LEFT OUTER JOIN ws_dbc_connect ON ws_dbc_connect.dc_obj_key = ws_dbc_target.dt_connect_key
            WHERE UPPER(ws_obj_object.oo_name) IN (
                SELECT DISTINCT UPPER(ec_src_table)
                FROM ws_export_col
                WHERE ec_obj_key = p_obj_key
              );
            v_table_schema := TRIM(v_table_schema);

          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              v_table_schema := '';

            WHEN TOO_MANY_ROWS THEN
              v_MsgText := 'Multiple sources found for export source, job: '|| p_job_name ||'.';
              v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                     v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              RETURN -2;
          END;
        End If;

        If v_ExpRec.et_type = 'S' Then

          BEGIN
            SELECT MAX(ec_src_table)
            INTO   v_exp_source_table
            FROM   ws_export_col
            WHERE  ec_obj_key = p_obj_key;
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              v_exp_source_table := '';
            WHEN TOO_MANY_ROWS THEN
              v_MsgText := 'Multiple rows found for export table name, job: '|| p_job_name ||'.';
              v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                     v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              RETURN -2;
          END;

          If trim(NVL(v_exp_source_table,'')) = '' Then
            v_MsgText := 'Unable to determine export table, job: '|| p_job_name ||'.';
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                   v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            RETURN -2;
          End If;

          v_exp_source_schema := trim(NVL(v_table_schema,''));
          If v_exp_source_schema IS NOT NULL Then
            v_exp_source_schema := v_exp_source_schema||'.';
          End If;

          v_exp_source_db := '';

          v_exp_source_fullname := coalesce(trim(v_exp_source_db),'');
          If v_exp_source_fullname IS NOT NULL Then
            v_exp_source_fullname := v_exp_source_fullname||'.';
          End If;
          If v_exp_source_schema IS NOT NULL Then
            v_exp_source_fullname := v_exp_source_fullname||v_exp_source_schema;
          End If;
          v_exp_source_fullname := v_exp_source_fullname||v_exp_source_table;

          BEGIN
            SELECT dc_odbc_source
                 , dc_database_id
                 , dc_attributes
            INTO   v_exp_source_dsn
                 , v_exp_source_dbid
                 , v_dc_attributes
            FROM   ws_obj_object
            LEFT JOIN ws_dbc_target
            ON oo_target_key = dt_target_key
            LEFT JOIN ws_dbc_connect
            ON (oo_target_key <> 0 AND dt_connect_key = dc_obj_key) OR (oo_target_key = 0 AND dc_attributes LIKE '%DataWarehouse;%')
            WHERE  oo_name = v_exp_source_table;
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              v_exp_source_dsn := '';
              v_exp_source_dbid := '';
              v_dc_attributes := NULL;
            WHEN TOO_MANY_ROWS THEN
              v_MsgText := 'Multiple rows found for export table storage connection, job: '|| p_job_name ||'.';
              v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                     v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
              RETURN -2;
          END;

          If v_dc_attributes IS NOT NULL Then
            v_att_pos := instr(v_dc_attributes, 'DBServer~=');
            If v_att_pos <> 0 Then
              v_att_slice := substr(v_dc_attributes, v_att_pos + 10);
              v_att_pos := instr(v_att_slice, ';');
              If v_att_pos <> 0 Then
                v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                v_exp_source_server := substr(v_att_slice, v_att_pos + 1, v_att_len);
              End If;
            End If;

            v_att_pos := instr(v_dc_attributes, 'DBPort~=');
            If v_att_pos <> 0 Then
              v_att_slice := substr(v_dc_attributes, v_att_pos + 8);
              v_att_pos := instr(v_att_slice, ';');
              If v_att_pos <> 0 Then
                v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
                v_exp_source_dbport := substr(v_att_slice, v_att_pos + 1, v_att_len);
              End If;
            End If;
          End If;

          v_param_obj_name := v_ExpRec.et_table_name;
        End If;

    Else
        p_return_msg := 'Unsupported host script method. Not a script or a file load or export. Type is ' ||
                        p_obj_type;
        p_status_code := -2;
        v_result := -2;
        RETURN v_result;
    End If;

    If (p_obj_type = v_ws_obj_load And v_LoadRec.lt_type = 'S')
    Or (p_obj_type = v_ws_obj_export And v_ExpRec.et_type = 'S')
    Then
      BEGIN
        SELECT dc_odbc_source
             , dc_database_id
             , dc_attributes
        INTO   v_meta_dsn
             , v_meta_dbid
             , v_dc_attributes
        FROM   ws_dbc_connect
        WHERE  dc_attributes LIKE '%DataWarehouse;%';
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_meta_dsn := '';
          v_meta_dbid := '';
          v_dc_attributes := NULL;
        WHEN TOO_MANY_ROWS THEN
          v_MsgText := 'Multiple rows found for load table storage connection, job: '|| p_job_name ||'.';
          v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                 v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
          RETURN -2;
      END;

      If v_dc_attributes IS NOT NULL Then
        v_att_pos := instr(v_dc_attributes, 'DBServer~=');
        If v_att_pos <> 0 Then
          v_att_slice := substr(v_dc_attributes, v_att_pos + 10);
          v_att_pos := instr(v_att_slice, ';');
          If v_att_pos <> 0 Then
            v_att_len := to_number(substr(v_att_slice, 1, v_att_pos - 1));
            v_meta_server := substr(v_att_slice, v_att_pos + 1, v_att_len);
          End If;
        End If;
      End If;

      v_meta_db := '';
      v_meta_schema := '';
    End If;

    v_step := 300;

    --=====================================================
    -- If a script key then copy over the script
    --=====================================================
    If v_script_type = v_ws_script_execute
    Or v_script_type = v_ws_load_script Then

        v_step := 400;
        -- Get the Connection key
        select * into v_ScriptRec
        from ws_scr_header
        where sh_obj_key = v_script_key;

        If v_script_type = v_ws_script_execute Then
            v_connect_key := v_ScriptRec.sh_connect_key;
            v_load_key := 0;
        ElsIf p_obj_type = v_ws_obj_load Then
            If v_source_con_type = 'D' Or v_source_con_type = 'O' OR v_source_con_type = 'Z' Then
                v_connect_key := v_ScriptRec.sh_connect_key;
            Else
                v_connect_key := v_LoadRec.lt_connect_key;
            End If;
            v_load_key := p_obj_key;
        Else
            v_connect_key := v_ExpRec.et_connect_key;
            v_load_key := p_obj_key;
        End If;

        -- Change the value for wtsh_load_type to indicate a Powershell script
        If v_ScriptRec.sh_type = 'P' Then
          v_load_type := 'P';
        End If;

        --=====================================================
        -- Get the work directory from the connection
        -- If no Connection then we have a problem
        --=====================================================
        v_step := 500;
        If v_connect_key > 0 Then
            select * into v_ConnectRec
            from ws_dbc_connect
            where dc_obj_key = v_connect_key;
        Else
            If v_script_type = v_ws_script_execute Then
                p_return_msg := 'No connection defined. Unable to execute script';
            Else
                p_return_msg := 'No connection defined. Unable to perform load';
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        End If;

        --=====================================================
        -- Build up the work directory for Unix and Windows
        --=====================================================
        v_step := 600;
        If v_ConnectRec.dc_type = 'U' OR v_ConnectRec.dc_type = 'H' Then
            v_work_dir := v_ConnectRec.dc_work_dir;
            If substr(v_work_dir,-1,1) <> '/' Then
                v_work_dir := v_work_dir || '/';
            End If;
        Else
            v_work_dir := v_ConnectRec.dc_work_dir;
            If substr(v_work_dir,-1,1) <> '\' Then
              v_work_dir := v_work_dir || '\';
            End If;
        End If;

        -- Copy over the script
        v_line_no := 1;

        SELECT MIN(sl_line_no)
        INTO v_min_line_no
        FROM ws_scr_line
        WHERE sl_obj_key = v_script_key;

        SELECT sl_line
        INTO v_line
        FROM ws_scr_line
        WHERE sl_obj_key = v_script_key
        AND sl_line_no = v_min_line_no;

        IF v_ConnectRec.dc_type = 'W' AND lower(substr(trim(v_line), 1, 5)) = '@echo'
        THEN
          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            NVL(WsParameterReplace(v_line,4000),v_line)
            );
          v_line_no := v_line_no + 1;

          -- Prevent this line from being inserted again later.
          v_min_line_no := v_min_line_no + 1;
        END IF;

        IF v_ConnectRec.dc_type = 'U' OR v_ConnectRec.dc_type = 'H' THEN

          -- Use the shell configured in the connection, otherwise guess
          -- based on the name of the connection
          v_shell := null;
          v_cpos := instr(v_ConnectRec.dc_attributes, 'ScriptShell~='); -- ScriptShell~=LENGTH;VALUE;
          If v_cpos <> 0 Then
              v_cpos := v_cpos + 13;
              v_epos := instr(v_ConnectRec.dc_attributes, ';', v_cpos);
              If v_epos <> 0 Then
                  v_work := substr(v_ConnectRec.dc_attributes, v_cpos, v_epos-v_cpos);
                  v_nlength := to_number(v_work);
                  If v_nlength > 0 Then
                      v_shell := '#!' || substr(v_ConnectRec.dc_attributes, v_epos+1, v_nlength);
                  End If;
              End If;
          End If;
          If v_shell is null Then
              If instr(upper(v_ConnectRec.dc_name),'LINUX') > 0 Then
                  v_shell := '#!/bin/sh';
              Else
                  v_shell := '#!/bin/ksh';
              End If;
          End If;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            v_shell||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'set -a'||chr(10) -- automatically export assigned variables
            );
          v_line_no := v_line_no + 1;

          IF v_ConnectRec.dc_database_id IS NOT NULL THEN
            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'WSL_SID='''||replace(trim(v_ConnectRec.dc_database_id),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;
          END IF;

          IF p_job_name IS NOT NULL THEN
            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'JOB_NAME='''||replace(trim(p_job_name),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;
          END IF;

          IF p_task_name IS NOT NULL THEN
            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'TASK_NAME='''||replace(trim(p_task_name),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;
          END IF;

          IF p_obj_type = v_ws_obj_export THEN

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'EXP_NAME='''||replace(coalesce(trim(v_ExpRec.et_table_name),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'EXP_FULLNAME='''||replace(coalesce(trim(v_exp_source_fullname),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'EXP_TABLE='''||replace(coalesce(trim(v_exp_source_table),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'EXP_SCHEMA='''||replace(coalesce(trim(v_exp_source_schema),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'EXP_DB='''||replace(coalesce(trim(v_exp_source_db),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'SRC_DSN='''||replace(coalesce(trim(v_exp_source_dsn),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'SRC_SERVER='''||replace(coalesce(trim(v_exp_source_server),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'SRC_DBPORT='''||replace(coalesce(trim(v_exp_source_dbport),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'SRC_DBID='''||replace(coalesce(trim(v_exp_source_dbid),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

          ELSIF p_obj_type = v_ws_obj_load THEN

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'LOAD_FULLNAME='''||replace(coalesce(trim(v_load_table_fullname),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'LOAD_TABLE='''||replace(coalesce(trim(v_LoadRec.lt_table_name),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'LOAD_SCHEMA='''||replace(coalesce(trim(v_load_table_schema),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'LOAD_DB='''||replace(coalesce(trim(v_load_table_db),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'TGT_DSN='''||replace(coalesce(trim(v_load_target_dsn),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'TGT_SERVER='''||replace(coalesce(trim(v_load_target_server),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'TGT_DBPORT='''||replace(coalesce(trim(v_load_target_dbport),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            INSERT INTO ws_wrk_task_scr_line (
              wtsl_task_key,
              wtsl_job_key,
              wtsl_sequence,
              wtsl_line_no,
              wtsl_line
              )
            VALUES (
              p_task_id,
              p_job_id,
              p_sequence,
              v_line_no,
              'TGT_DBID='''||replace(coalesce(trim(v_load_target_dbid),''),'''','''\''''')||''''||chr(10)
              );
            v_line_no := v_line_no + 1;

            IF v_source_con_type = 'D' OR v_source_con_type = 'O' OR v_source_con_type = 'Z' THEN
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_DSN='''||replace(coalesce(trim(v_load_source_dsn),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;

              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_SERVER='''||replace(coalesce(trim(v_load_source_server),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;

              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_DBPORT='''||replace(coalesce(trim(v_load_source_dbport),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;

              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_DBID='''||replace(coalesce(trim(v_load_source_dbid),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;

              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_DB='''||replace(coalesce(trim(v_load_source_db),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;

              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'SRC_SCHEMA='''||replace(coalesce(trim(v_load_source_schema),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;
            END IF;

          END IF;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'META_DSN=${META_DSN-'''||replace(coalesce(trim(v_meta_dsn),''),'''','''\''''')||'''}'||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'META_SERVER=${META_SERVER-'''||replace(coalesce(trim(v_meta_server),''),'''','''\''''')||'''}'||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'META_DBID=${META_DBID-${ORACLE_SID-'''||replace(coalesce(trim(v_meta_dbid),''),'''','''\''''')||'''}}'||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'META_DB=${META_DB-'''||replace(coalesce(trim(v_meta_db),''),'''','''\''''')||'''}'||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'META_SCHEMA=${META_SCHEMA-$(test "${DSS_USER+X}" && echo "${DSS_USER:+${DSS_USER}.}" || echo '''||replace(coalesce(trim(v_meta_schema),''),'''','''\''''')||''')}'||chr(10)
            );
          v_line_no := v_line_no + 1;

          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'WORKDIR='''||replace(coalesce(trim(v_work_dir),''),'''','''\''''')||''''||chr(10)
            );
          v_line_no := v_line_no + 1;

          If v_param_obj_name IS NOT NULL Then
            FOR v_ParameterRec in (
                SELECT *
                FROM dss_parameter
                WHERE UPPER(dss_parameter_name) LIKE UPPER(v_param_obj_name||'%')
                ORDER BY dss_parameter_name
                )
            LOOP
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'PARAM'||substr(v_ParameterRec.dss_parameter_name,length(v_param_obj_name)+1)||'='''||replace(coalesce(trim(v_ParameterRec.dss_parameter_value),''),'''','''\''''')||''''||chr(10)
                );
              v_line_no := v_line_no + 1;
            END LOOP;
          End If;

          -- Write a line to delimit the environment variable setting code from the body of the script
          INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
          )
          VALUES (
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no,
            'exit 1 # ~~WSL_CUT_HERE~~'||chr(10)
          );
          v_line_no := v_line_no + 1;

        ELSE

          IF p_obj_type = v_ws_obj_export THEN

            If v_load_type = 'P' Then
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'if (-not (Test-Path "env:WSL_EXP_SCHEMA")) { ${env:WSL_EXP_SCHEMA} = '''||coalesce(trim(v_exp_source_schema),'')||''' }'||chr(10)
                );
            Else
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'if not defined WSL_EXP_SCHEMA SET WSL_EXP_SCHEMA='||coalesce(trim(v_exp_source_schema),'')||chr(10)
                );
            End If;
            v_line_no := v_line_no + 1;

          ELSIF p_obj_type = v_ws_obj_load THEN

            If v_load_type = 'P' Then
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'if (-not (Test-Path "env:WSL_LOAD_SCHEMA")) { ${env:WSL_LOAD_SCHEMA} = '''||coalesce(trim(v_load_table_schema),'')||''' }'||chr(10)
                );
            Else
              INSERT INTO ws_wrk_task_scr_line (
                wtsl_task_key,
                wtsl_job_key,
                wtsl_sequence,
                wtsl_line_no,
                wtsl_line
                )
              VALUES (
                p_task_id,
                p_job_id,
                p_sequence,
                v_line_no,
                'if not defined WSL_LOAD_SCHEMA SET WSL_LOAD_SCHEMA='||coalesce(trim(v_load_table_schema),'')||chr(10)
                );
            End If;
            v_line_no := v_line_no + 1;

          END IF;

        END IF;

        -- Insert all the remaining lines into the script.
        INSERT INTO ws_wrk_task_scr_line (
            wtsl_task_key,
            wtsl_job_key,
            wtsl_sequence,
            wtsl_line_no,
            wtsl_line
            )
        SELECT
            p_task_id,
            p_job_id,
            p_sequence,
            v_line_no + (sl_line_no - v_min_line_no),
            NVL(WsParameterReplace(sl_line,4000),sl_line)
        FROM ws_scr_line
        WHERE sl_obj_key = v_script_key
        AND sl_line_no >= v_min_line_no;

        --=====================================================
        -- Write out the task script header
        --=====================================================
        v_step := 800;
        Insert into ws_wrk_task_scr_hdr (
            wtsh_task_key,
            wtsh_job_key,
            wtsh_name,
            wtsh_sequence,
            wtsh_host_type,
            wtsh_script_type,
            wtsh_load_type,
            wtsh_work_dir,
            wtsh_connect_key,
            wtsh_load_key,
            wtsh_script_key
        ) values (
            p_task_id,
            p_job_id,
            p_task_name,
            p_sequence,
            v_ConnectRec.dc_type,
            v_script_type,
            v_load_type,
            v_work_dir,
            v_connect_key,
            v_load_key,
            v_script_key
        );
        COMMIT;


    --=====================================================
    -- XML File based Load. Build the script header
    --=====================================================
    ElsIf v_script_type = v_ws_load_xml Then
        v_step := 1900;
        v_connect_key := v_LoadRec.lt_connect_key;
        v_load_key := p_obj_key;
        v_script_key := 0;

        --=====================================================
        -- Get the work directory from the connection
        -- If no Connection then we have a problem
        --=====================================================
        v_step := 11000;
        If v_connect_key > 0 Then
            select * into v_ConnectRec
            from ws_dbc_connect
            where dc_obj_key = v_connect_key;
        Else
            If v_script_type = v_ws_script_execute Then
                p_return_msg := 'No connection defined. Unable to execute script';
            Else
                p_return_msg := 'No connection defined. Unable to perform load';
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        End If;

        v_step := 11100;
        --=====================================================
        -- Unix XML load not supported
        --=====================================================
        If v_ConnectRec.dc_type = 'U' Then

            v_step := 11200;
            p_return_msg := 'Unix based XML loads are not supported';
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;

        --=====================================================
        -- Windows XMLfile based load. Build a script header
        --=====================================================
        ElsIf v_ConnectRec.dc_type = 'W' Then

            -- Create a unique name for the ctrl files and log files
            v_work_dir := v_ConnectRec.dc_work_dir;
            If substr(v_work_dir,-1,1) <> '\' Then
                v_work_dir := v_work_dir || '\';
            End If;

            --=====================================================
            -- Write out the task script header
            --=====================================================
            Insert into ws_wrk_task_scr_hdr (
                wtsh_task_key,
                wtsh_job_key,
                wtsh_name,
                wtsh_sequence,
                wtsh_host_type,
                wtsh_script_type,
                wtsh_load_type,
                wtsh_work_dir,
                wtsh_connect_key,
                wtsh_load_key,
                wtsh_script_key
            ) values (
                p_task_id,
                p_job_id,
                p_task_name,
                p_sequence,
                v_ConnectRec.dc_type,
                v_script_type,
                v_load_type,
                v_work_dir,
                v_connect_key,
                v_load_key,
                v_script_key
            );
            COMMIT;
        End If;

-- XXXXXXXXXXX

    --=====================================================
    -- File based Load. Build the script below once we work
    -- out if a Unix or Windows connection
    --=====================================================
    ElsIf p_obj_type = v_ws_obj_load Then
        v_step := 900;
        v_connect_key := v_LoadRec.lt_connect_key;
        v_load_key := p_obj_key;
        v_script_key := 0;

        --=====================================================
        -- Get the work directory from the connection
        -- If no Connection then we have a problem
        --=====================================================
        v_step := 1000;
        If v_connect_key > 0 Then
            select * into v_ConnectRec
            from ws_dbc_connect
            where dc_obj_key = v_connect_key;
        Else
            If v_script_type = v_ws_script_execute Then
                p_return_msg := 'No connection defined. Unable to execute script';
            Else
                p_return_msg := 'No connection defined. Unable to perform load';
            End If;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        End If;

        --=====================================================
        -- See if we have a record delimiter in the load_option field
        --=====================================================
        v_step := 1099;
        v_rec_delimiter := '';
        v_rec_enclosed := '';
        v_rec_options := '';
        v_file_charset := '';
        v_rec_when := '';
        If v_LoadRec.lt_load_options IS NOT NULL Then
          v_epos := Instr(v_LoadRec.lt_load_options,'REC_DELIM=');
          If v_epos > 0 Then
            v_spos := to_number(substr(v_LoadRec.lt_load_options,v_epos+10,4));
            If v_spos > 0 Then
              v_rec_delimiter := substr(v_LoadRec.lt_load_options,v_epos+15,v_spos);
            End If;
          End If;
          v_epos := Instr(v_LoadRec.lt_load_options,'ENCLOSED=');
          If v_epos > 0 Then
            v_spos := to_number(substr(v_LoadRec.lt_load_options,v_epos+9,4));
            If v_spos > 0 Then
              v_rec_enclosed := substr(v_LoadRec.lt_load_options,v_epos+14,v_spos);
            End If;
          End If;
          v_epos := Instr(v_LoadRec.lt_load_options,'OPTIONS=');
          If v_epos > 0 Then
            v_spos := to_number(substr(v_LoadRec.lt_load_options,v_epos+8,4));
            If v_spos > 0 Then
              v_rec_options := substr(v_LoadRec.lt_load_options,v_epos+13,v_spos);
            End If;
          End If;

          v_epos := Instr(v_LoadRec.lt_load_options,'CHARSET=');
          If v_epos > 0 Then
            v_spos := to_number(substr(v_LoadRec.lt_load_options,v_epos+8,4));
            If v_spos > 0 Then
              v_file_charset := substr(v_LoadRec.lt_load_options,v_epos+13,v_spos);
            End If;
          End If;

          v_epos := Instr(v_LoadRec.lt_load_options,'COMPRESS_ON_RENAME;');
          If v_epos > 0 Then
            v_compress := 1;
          End If;

          If v_rec_options IS NOT NULL Then
            v_work := UPPER(v_rec_options);
            v_epos := Instr(v_work,'WHEN');
            If v_epos > 0 Then
              v_rec_when := replace(substr(v_rec_options,v_epos,9999),'>','^>');
              v_rec_options := substr(v_rec_options,1,v_epos-1);
            End If;
          End If;
        Else
          v_rec_enclosed := '"';
        End If;

        v_step := 1100;
        --=====================================================
        -- U N I X                 U N I X
        --=====================================================
        --=====================================================
        -- Unix file based load. Build a UNIX script
        --=====================================================
        If v_ConnectRec.dc_type = 'U' Then

            v_step := 1200;
            -- add a slash to any directory if required
            v_work_dir := v_ConnectRec.dc_work_dir;
            If substr(v_work_dir,-1,1) <> '/' Then
                v_work_dir := v_work_dir || '/';
            End If;

            If v_LoadRec.lt_file_path is not NULL Then
                If substr(v_LoadRec.lt_file_path,-1,1) <> '/' Then
                    v_file_path := v_LoadRec.lt_file_path || '/';
                Else
                    v_file_path := v_LoadRec.lt_file_path;
                End If;
            Else
                v_file_path := '';
            End If;

            If v_LoadRec.lt_trig_path is not NULL Then
                If substr(v_LoadRec.lt_trig_path,-1,1) <> '/' Then
                    v_trig_path := v_LoadRec.lt_trig_path || '/';
                Else
                    v_trig_path := v_LoadRec.lt_trig_path;
                End If;
            Else
                v_trig_path := '';
            End If;


            -- Create a unique name for the ctrl files and log files
            v_script := v_work_dir||'wsl'||p_sequence||'j'||p_job_id||'t'||p_task_id;
            If v_LoadRec.lt_file_header_line = 'Y' Then
                v_skip := 'skip=1 ';
            Else
                v_skip := ' ';
            End If;


            -- If we have a trigger then use that as the lookup file
            -- otherwise use the actual file
            If v_LoadRec.lt_trig_name is not NULL Then
                v_lookfor := v_trig_path||v_LoadRec.lt_trig_name;
            Else
                v_lookfor := v_file_path||v_LoadRec.lt_file_name;
            End If;

            -- Use the shell configured in the connection, otherwise guess
            -- based on the name of the connection
            v_shell := null;
            v_cpos := instr(v_ConnectRec.dc_attributes, 'ScriptShell~='); -- ScriptShell~=LENGTH;VALUE;
            If v_cpos <> 0 Then
                v_cpos := v_cpos + 13;
                v_epos := instr(v_ConnectRec.dc_attributes, ';', v_cpos);
                If v_epos <> 0 Then
                    v_work := substr(v_ConnectRec.dc_attributes, v_cpos, v_epos-v_cpos);
                    v_nlength := to_number(v_work);
                    If v_nlength > 0 Then
                        v_shell := '#!' || substr(v_ConnectRec.dc_attributes, v_epos+1, v_nlength);
                    End If;
                End If;
            End If;
            If v_shell is null Then
                If instr(upper(v_ConnectRec.dc_name),'LINUX') > 0 Then
                    v_shell := '#!/bin/sh';
                Else
                    v_shell := '#!/bin/ksh';
                End If;
            End If;

            -- Create the script
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_shell||chr(10));

            -- Do the waiting
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'WAITSECS='||v_LoadRec.lt_file_wait|| chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if [ "$WAITSECS" -gt "0" ] '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'then'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  NOW_HH=`date +%H | bc`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  NOW_MM=`date +%M | bc`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  NOW_SS=`date +%S | bc`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  let NOW_HH="$NOW_HH * 3600"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  let NOW_MM="$NOW_MM * 60"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  let NOW_TIME="$NOW_HH + $NOW_MM + $NOW_SS"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  let TILL_TIME="$NOW_TIME + $WAITSECS"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  let START_TIME="$NOW_TIME"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  while [ "$NOW_TIME" -lt "$TILL_TIME" ]'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  do '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
--                '    if [ -r '||v_lookfor||' ]'||chr(10));
                '    if [ `ls "'||v_LoadRec.lt_trig_path||'" | grep "'||
                v_LoadRec.lt_trig_name||'" | wc -l` -gt "0" ]'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    then '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      let NOW_TIME="$TILL_TIME"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    else '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      sleep 30 '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      NOW_HH=`date +%H | bc` '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      NOW_MM=`date +%M | bc` '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      NOW_SS=`date +%S | bc` '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      let NOW_HH="$NOW_HH * 3600" '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      let NOW_MM="$NOW_MM * 60" '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      let NOW_TIME="$NOW_HH + $NOW_MM + $NOW_SS" '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      if [ "$NOW_TIME" -lt "$START_TIME" ] '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      then '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '        let NOW_TIME="$NOW_TIME + 86400" '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '      fi '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    fi '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  done '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'fi '||chr(10));

            -- check that the file exists
            -- use a loop in case of wild cards
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'FLIST=`find '||v_lookfor||' -print`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if [ "$FLIST" = "" ]'||chr(10));
            --v_line_no := v_line_no + 1;
            --Insert into ws_wrk_task_scr_line (wtsl_task_key,
            --    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            --Values (p_task_id, p_job_id, p_sequence,v_line_no,
            --    'if [ ! -r "'||v_lookfor||'" ]'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'then'||chr(10));

            If upper(v_LoadRec.lt_wait_action) = 'S' Then
                v_action := '1';
            ElsIf upper(v_LoadRec.lt_wait_action) = 'E' Then
                v_action := '-2';
            ElsIf upper(v_LoadRec.lt_wait_action) = 'F' Then
                v_action := '-3';
            Else
                v_action := '-1';
            End If;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  echo "'||v_action||'"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  echo "File '||v_lookfor||' was not found. No load"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  exit'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'fi'||chr(10));


            -- Get the first trigger file name
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'for ACTFILE in $FLIST'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'do'||chr(10));

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  TRIG_ACTFILE=$ACTFILE'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  break'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'done'||chr(10));

            -- SID
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if [ -z "$ORACLE_SID" ]'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'then'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  SID=@'||v_ConnectRec.dc_database_id||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'else'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  SID=@$ORACLE_SID'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'fi'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'export SID'||chr(10));

            -- handle the trigger parameters
            If v_LoadRec.lt_trig_name is not NULL And
                v_LoadRec.lt_trig_prefix is not NULL Then

                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'sqlplus -s <<EOF >/dev/null'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			v_ConnectRec.dc_admin_userid||'/'||v_ConnectRec.dc_admin_pwd||'${SID}'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set sqlprompt "";'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set heading off;'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set pagesize 0'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set linesize 256'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set trimspool on'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'set echo off;'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'update dss_parameter set dss_parameter_value = NULL'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'where dss_parameter_name like '''||v_LoadRec.lt_trig_prefix||'_%'''||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'exit;'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'EOF'||CHR(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'if [ "$'||chr(63)||'" -ne "0" ]'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'then'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'   echo "-1"'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'   echo "Parameter clear Sqlplus returned a non standard return code of $'||chr(63)||'"'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'fi'||chr(10));

                    -- NOW LOADUP THE PARAMETERS
                    If v_LoadRec.lt_trig_delimiter is NULL Then
                        v_fix := '\012';
                    Else
                        v_fix := v_LoadRec.lt_trig_delimiter;
                    End If;
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
                        'cat $TRIG_ACTFILE | tr "'||v_fix||
 --          	            'cat '||v_trig_path||v_LoadRec.lt_trig_name||' | tr "'||v_fix||
                                            '" "\012" >'||v_script||'.trg'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'TRIGNO=`cat '||v_script||'.trg'||' | wc -l | tr -d " "`'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'if [ "$TRIGNO" != "0" ] '||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
         			'then'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'  ROWNUM=0'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'  while [ "$ROWNUM" -lt "$TRIGNO" ]'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'  do'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    let ROWNUM="$ROWNUM+1"'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    TRIG_NO="'||v_LoadRec.lt_trig_prefix||'_$ROWNUM"'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    TRIG_MSG=`cat '||v_script||'.trg | head -$ROWNUM | tail -1 | sed "s/''/''''/g"`'
                                  ||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    sqlplus -s <<EOF1 >/dev/null'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    '||v_ConnectRec.dc_admin_userid||'/'||v_ConnectRec.dc_admin_pwd||'${SID}'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    variable x number;'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    exec :x := WsParameterWrite(''$TRIG_NO'',''$TRIG_MSG'',''load of '||
                            v_file_path||v_LoadRec.lt_file_name||''')'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'    exit;'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'EOF1'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'  done'||chr(10));
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
        			'fi'||chr(10));

            End If;  -- End of trigger processing

            -- Load the data using sqlldr

            -- SETUP the Loop in case of wildcards
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'FLIST=`find '||v_file_path||v_LoadRec.lt_file_name||' -print`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'for ACTFILE in $FLIST'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'do'||chr(10));

            -- if options specified then add them
            If v_rec_options is NOT NULL Then
              v_line_no := v_line_no + 1;
              v_fix := 'echo "'||replace(v_rec_options,'"','\"')||'" >'||v_script||'.ctl'||chr(10);
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);

              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo "load data" >>'||v_script||'.ctl'||chr(10));
            Else
              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo "load data" >'||v_script||'.ctl'||chr(10));
            End If;

            -- if charset specified then add them
            If v_file_charset is NOT NULL Then
              v_line_no := v_line_no + 1;
              v_fix := 'echo "CHARACTERSET '||v_file_charset||'" >>'||v_script||'.ctl'||chr(10);
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);
            End If;

            -- see if we have a fixed length record
            v_line_no := v_line_no + 1;
            v_fix := 'echo "infile ''$ACTFILE'' ';
            If substr(v_rec_delimiter,1,4) = 'FIX ' Then
              v_fix := v_fix || '\"' || v_rec_delimiter || '\"';
            End If;
            v_fix := v_fix || '" >>'||v_script||'.ctl'||chr(10);
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);


            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo "badfile '''||v_script||'.bad''" >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;
            IF v_table_schema IS NOT NULL THEN
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo "into table '||v_table_schema||'.'||v_LoadRec.lt_table_name||'" >>'||v_script||'.ctl'||chr(10));
            ELSE
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo "into table '||v_LoadRec.lt_table_name||'" >>'||v_script||'.ctl'||chr(10));
            END IF;

            If v_rec_when is NOT NULL Then
              v_line_no := v_line_no + 1;
              v_fix := 'echo "'||v_rec_when||'" >>'||v_script||'.ctl'||chr(10);
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);
            End If;

            If v_LoadRec.lt_file_delimiter is Not NULL Then
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo "fields terminated by \"'||v_LoadRec.lt_file_delimiter||'\"" >>'
                        ||v_script||'.ctl'||chr(10));

                If v_rec_enclosed is NOT NULL Then
                  v_line_no := v_line_no + 1;
                  v_fix := 'echo "optionally enclosed by '''||replace(v_rec_enclosed,'"','\"')||'''" >>'||v_script||'.ctl'||chr(10);
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);
                End If;
--                v_line_no := v_line_no + 1;
--                Insert into ws_wrk_task_scr_line (wtsl_task_key,
--                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
--                Values (p_task_id, p_job_id, p_sequence,v_line_no,
--                    'echo "optionally enclosed by ''\"''" >>'||v_script||'.ctl'||chr(10));
            End If;

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo "trailing nullcols" >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo "(" >>'||v_script||'.ctl'||chr(10));

            --**************************************************************************************
            -- See if a parsed file or single column
            -- If a parsed file then get all the columns
            --**************************************************************************************
            If v_LoadRec.lt_file_parsed = 'Y' Then
                Select count(1) into v_col_count
                From ws_load_col Where lc_obj_key = p_obj_key
                And lc_src_column like 'COL%';
                v_row := 0;
                v_pos := 1;
                FOR v_ColRec in c_LoadCol LOOP
                    v_fix := '';

                    -- see if this is width based and if so add the width to the column
                    v_epos := Instr(v_ColRec.lc_src_column,'_width_');
                    If v_epos > 0 Then
                        v_spos := to_number(substr(v_ColRec.lc_src_column,v_epos+7));
                        If v_spos > 0 Then
                          v_spos := v_spos-1+v_pos;
                          v_fix := v_fix||' position('||v_pos||':'||v_spos||')';
                          v_pos := v_spos+1;
                        End If;
                    End If;


                    IF v_ColRec.lc_transform_code is not Null
                    AND UPPER(v_ColRec.lc_transform_type) <> 'A' Then
                      v_work := v_ColRec.lc_transform_code;
                      -- Get rid of any comments in the transform
                      v_t1pos := Instr(v_work,CHR(45)||CHR(45));
                      WHILE v_t1pos > 0 LOOP
                        v_t2pos := Instr(v_work,CHR(10),v_t1pos);
                        IF v_t2pos > 0 THEN
                          v_work2 := SUBSTR(v_work,1,v_t1pos-1);
                          v_work := v_work2||SUBSTR(v_work,v_t2pos+1,9999);
                        ELSE
                          v_work := SUBSTR(v_work,1,v_t1pos-1);
                        END IF;
                        v_t1pos := Instr(v_work,CHR(45)||CHR(45));
                      END LOOP;
                      v_work := replace(replace(v_work,CHR(13),''),CHR(10),''); -- RED_2771
                      v_work := LTRIM(RTRIM(v_work));
                      v_work := substr(replace(v_work,'%FILE_NAME%','$ACTFILE'),1,255);
                      v_fix := v_fix||' '||replace(v_work,'"','\"');
                    Else
                        v_fix := v_fix||'';
                    End If;
                    v_row := v_row + 1;
                    If v_col_count = v_row Then
                        v_fix := v_fix||'';
                    Else
                        v_fix := v_fix||',';
                    End If;
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
                                'echo "'||v_ColRec.lc_col_name||v_fix||'">>'||v_script||'.ctl'||chr(10));
                END LOOP;
                v_pos := 0;
                v_spos := 0;
                v_epos := 0;
            Else -- single column load

                -- first see what columns we have
                v_rowseq := 0;
                v_rowname := 0;
                FOR v_ColRec in c_LoadAll LOOP
                    IF LOWER(v_ColRec.lc_col_name) = 'row_number' Then
                      v_rowseq := 1;
                    End If;
                    IF LOWER(v_ColRec.lc_col_name) = 'row_file_name' Then
                      v_rowname := 1;
                    End If;
                END LOOP;

                IF v_rowseq = 1 Then
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  "row_number sequence(1,1)," >>'||v_script||'.ctl'||chr(10));
                END IF;
                IF v_rowname = 1 THEN
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  "row_data char(4000)," >>'||v_script||'.ctl'||chr(10));
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  "row_file_name constant ''$ACTFILE''" >>'||v_script||'.ctl'||chr(10));
                ELSE
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  "row_data char(4000)" >>'||v_script||'.ctl'||chr(10));
                END IF;
            End If;

            -- Build the rest of the script
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo ")" >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;

            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'sqlldr userid='||v_ConnectRec.dc_admin_userid||'/\"'||v_ConnectRec.dc_admin_pwd||'\"'
                                ||'${SID} control='||v_script
                                ||'.ctl '||v_skip||'silent=HEADER,FEEDBACK log='||v_script||'.log >> '||v_script||'.log'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'retcode=`echo $'||chr(63)||'` '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'rows=`cat '||v_script||'.log | grep Rows | grep success`'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'case "$retcode" in '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '0) echo "1"; '||chr(10));
            v_line_no := v_line_no + 1;
            IF v_table_schema IS NOT NULL THEN
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  '    echo "'||v_table_schema||'.'||v_LoadRec.lt_table_name||' completed. $rows"'||chr(10));
            ELSE
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  '    echo "'||v_LoadRec.lt_table_name||' completed. $rows"'||chr(10));
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '  ;; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '2) echo "-1"; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    echo "Not all rows loaded. $rows. see error trail" ;'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    cat '||v_script||'.log | grep Rows'||chr(10));
            v_line_no := v_line_no + 1;

            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    cat '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    ;; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '1) echo "-2"; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    echo "SQL*Loader execution exited with EX_FAIL, see error trail";'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    cat '||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '     ;; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '3) echo "-3"; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    echo "SQL*Loader execution encountered a fatal error" '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    cat '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    ;; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '*) echo "-3";'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    echo "SQL*Loader unknown return code"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    cat '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '    ;; '||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'esac '||chr(10));

            v_step := 1300;

            -- Do any renames required
            If v_LoadRec.lt_trig_name_rename is not NULL Or
                v_LoadRec.lt_trig_path_rename is not NULL Or
                v_LoadRec.lt_file_name_rename is not NULL Or
                v_LoadRec.lt_file_path_rename is not NULL Then

                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
        		'if [ "$retcode" -eq "0" -o "$retcode" -eq "2" ]'||chr(10));
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
        		'then'||chr(10));

                v_step := 2300;
                If v_LoadRec.lt_trig_name_rename is not NULL Or
                    v_LoadRec.lt_trig_path_rename is not NULL Then

--                    If v_LoadRec.lt_trig_name_rename is NULL Then
--                        v_trig_rename := v_LoadRec.lt_trig_name;
--                    Else
                        v_trig_rename := v_LoadRec.lt_trig_name_rename;
--                    End If;
                    If v_LoadRec.lt_trig_path_rename is NULL Then
                        v_trig_repath := v_LoadRec.lt_trig_path;
                    Else
                        v_trig_repath := v_LoadRec.lt_trig_path_rename;
                    End If;


                    v_step := 2400;
                    -- find a matching pair of $ signs in the rename file name
                    -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
                    v_rename := '';
                    v_spos := instr(v_trig_rename,'$',1,1);
                    If v_spos <> 0 Then
                        v_epos := instr(v_trig_rename,'$',1,2);
                        If v_epos <> 0 Then
                            v_command := substr(v_trig_rename,v_spos+1,v_epos-v_spos-1);
                            If upper(v_command) = 'SEQUENCE' Then
                                If v_file_seq = 0 Then
                                    BEGIN
                                        Select ws_file_seq.NextVal into v_file_seq from dual;
                                        v_rename := '  REFILE='||v_file_seq;
                                        v_trig_rename := v_trig_rename||'$REFILE';
                                    EXCEPTION WHEN OTHERS THEN
                                        v_rename := '  REFILE=`date +%Y%m%d%H%M%S`';
                                        v_trig_rename := v_trig_rename||'$REFILE';
                                        v_file_seq := 0;
                                    END;
                                Else
                                    v_rename := '  REFILE=`date +%Y%m%d%H%M%S`';
                                    v_trig_rename := v_trig_rename||'$REFILE';
                                End If;
                            Else
                                v_step := 2500;
                                If instr(v_command,'YYYY') <> 0 Then
                                    v_rename := v_rename||'%Y';
                                End If;
                                If instr(v_command,'MM') <> 0 Then
                                    v_rename := v_rename||'%m';
                                End If;
                                If instr(v_command,'DD') <> 0 Then
                                    v_rename := v_rename||'%d';
                                End If;
                                If instr(v_command,'HH') <> 0 Then
                                    v_rename := v_rename||'%H';
                                End If;
                                If instr(v_command,'MI') <> 0 Then
                                    v_rename := v_rename||'%M';
                                End If;
                                If instr(v_command,'SS') <> 0 Then
                                    v_rename := v_rename||'%S';
                                End If;

                                If v_rename is not NULL Then
                                    v_step := 2600;
                                    v_work := '';
                                    v_rename := '  REFILE=`date +'||v_rename||'`';
                                    v_step := 2700;
                                    If v_spos > 1 Then
                                        v_work := substr(v_trig_rename,1,v_spos-1);
                                    End If;
                                    v_step := 2800;
                                    v_work := v_work||'$REFILE';
                                    v_step := 2900;
                                    If v_epos < length(v_trig_rename) Then
                                       v_work := v_work||substr(v_trig_rename,v_epos+1,length(v_trig_rename)-v_epos);
                                    End If;
                                    v_trig_rename := v_work;
                                End If;

                            End If;
                        End If; -- end of epos found
                    End If; -- end of spos found
                If v_rename is not NULL Then
                    v_step := 3000;
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_rename||chr(10));
                End If;

                v_step := 3100;
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    '  mv $TRIG_ACTFILE '||v_trig_repath||v_trig_rename||chr(10));
--                  '  mv '||v_trig_path||v_LoadRec.lt_trig_name||
--                  ' '||v_trig_repath||v_trig_rename||chr(10));
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    '  echo "$TRIG_ACTFILE renamed to '||v_trig_repath||v_trig_rename||'"'||chr(10));
--                  '  echo "'||v_trig_path||v_LoadRec.lt_trig_name||
--                  ' renamed to '||v_trig_repath||v_trig_rename||'"'||chr(10));

                End If; -- end of trigger rename


                v_step := 1400;
                If v_LoadRec.lt_file_name_rename is not NULL Or
                    v_LoadRec.lt_file_path_rename is not NULL Then

                    -- wont work if a wild card in the file name
--                    If v_LoadRec.lt_file_name_rename is NULL Then
--                        v_file_rename := v_LoadRec.lt_file_name;
--                    Else
                        v_file_rename := v_LoadRec.lt_file_name_rename;
--                    End If;
                    If v_LoadRec.lt_file_path_rename is NULL Then
                        v_file_repath := v_LoadRec.lt_file_path;
                    Else
                      v_file_repath := v_LoadRec.lt_file_path_rename;
                    End If;

                    v_step := 1500;
                    -- find a matching pair of $ signs in the rename file name
                    -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
                    v_rename := '';
                    v_spos := instr(v_file_rename,'$',1,1);
                    If v_spos <> 0 Then
                        v_epos := instr(v_file_rename,'$',1,2);
                        If v_epos <> 0 Then
                            v_command := substr(v_file_rename,v_spos+1,v_epos-v_spos-1);
                            If upper(v_command) = 'SEQUENCE' Then
                                BEGIN
                                    Select ws_file_seq.NextVal into v_file_seq from dual;
                                    v_rename := '  REFILE='||v_file_seq;
                                    v_file_rename := v_file_rename||'$REFILE';
                                EXCEPTION WHEN OTHERS THEN
                                    v_rename := '  REFILE=`date +%Y%m%d%H%M%S`';
                                    v_file_rename := v_file_rename||'$REFILE';
                                    v_file_seq := 0;
                                END;
                            Else
                                v_step := 1600;
                                If instr(v_command,'YYYY') <> 0 Then
                                    v_rename := v_rename||'%Y';
                                End If;
                                If instr(v_command,'MM') <> 0 Then
                                    v_rename := v_rename||'%m';
                                End If;
                                If instr(v_command,'DD') <> 0 Then
                                    v_rename := v_rename||'%d';
                                End If;
                                If instr(v_command,'HH') <> 0 Then
                                    v_rename := v_rename||'%H';
                                End If;
                                If instr(v_command,'MI') <> 0 Then
                                    v_rename := v_rename||'%M';
                                End If;
                                If instr(v_command,'SS') <> 0 Then
                                    v_rename := v_rename||'%S';
                                End If;

                                If v_rename is not NULL Then
                                    v_step := 1700;
                                    v_work := '';
                                    v_rename := '  REFILE=`date +'||v_rename||'`';
                                    v_step := 1800;
                                    If v_spos > 1 Then
                                        v_work := substr(v_file_rename,1,v_spos-1);
                                    End If;
                                    v_step := 1900;
                                    v_work := v_work||'$REFILE';
                                    v_step := 2000;
                                    If v_epos < length(v_file_rename) Then
                                       v_work := v_work||substr(v_file_rename,v_epos+1,length(v_file_rename)-v_epos);
                                    End If;
                                    v_file_rename := v_work;
                                End If;

                            End If;
                        End If; -- end of epos found
                    End If; -- end of spos found
                If v_rename is not NULL Then
                    v_step := 2100;
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_rename||chr(10));
                End If;

                v_step := 2200;
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    '  mv $ACTFILE '||v_file_repath||v_file_rename||chr(10));
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    '  echo "$ACTFILE renamed to '||v_file_repath||v_file_rename||'"'||chr(10));


                -- If compress set then compress the file
                If v_compress = 1 THEN

                  IF v_file_rename IS NOT NULL THEN
                    v_work := v_file_rename;
                  ELSE
                    v_work := v_LoadRec.lt_file_name;
                  END IF;
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                      '  compress '||v_file_repath||v_work||chr(10));
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                      '  echo "compressed '||v_file_repath||v_work||'"'||chr(10));
                End IF;

--                '  echo "'||v_file_path||v_LoadRec.lt_file_name||
--                '  mv '||v_file_path||v_LoadRec.lt_file_name||

                End If; -- end of file rename



                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'fi'||chr(10));
            End If; -- end of renames


            -- only process one file at this stage
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'break'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'done'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));

            --=====================================================
            -- Write out the task script header
            --=====================================================
            Insert into ws_wrk_task_scr_hdr (
                wtsh_task_key,
                wtsh_job_key,
                wtsh_name,
                wtsh_sequence,
                wtsh_host_type,
                wtsh_script_type,
                wtsh_load_type,
                wtsh_work_dir,
                wtsh_connect_key,
                wtsh_load_key,
                wtsh_script_key
            ) values (
                p_task_id,
                p_job_id,
                p_task_name,
                p_sequence,
                v_ConnectRec.dc_type,
                v_script_type,
                v_load_type,
                v_work_dir,
                v_connect_key,
                v_load_key,
                v_script_key
            );
            COMMIT;

        --=====================================================
        -- W I N D O W S                      W I N D O W S
        --=====================================================
        --=====================================================
        -- Windows file based load. Build a windows script
        --=====================================================
        ElsIf v_ConnectRec.dc_type = 'W' Then

            -- Create a unique name for the ctrl files and log files
            v_work_dir := v_ConnectRec.dc_work_dir;
            If substr(v_work_dir,-1,1) <> '\' Then
                v_work_dir := v_work_dir || '\';
            End If;
            v_script := v_work_dir||'wsl'||p_sequence||'j'||p_job_id||'t'||p_task_id;
            If v_LoadRec.lt_file_header_line = 'Y' Then
                v_skip := 'skip=1 ';
            Else
                v_skip := ' ';
            End If;

            -- see  if wild cards in the file name
            v_epos := Instr(v_LoadRec.lt_file_path||v_LoadRec.lt_file_name,'*');
            If v_epos > 0 Then
              v_wild := 1;
            End If;
            v_epos := Instr(v_LoadRec.lt_file_path||v_LoadRec.lt_file_name,CHR(63));
            If v_epos > 0 Then
              v_wild := 1;
            End If;

            -- Create the script
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                '@echo off'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'setlocal enabledelayedexpansion'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'setlocal enableextensions'||chr(10));

            -- SETUP the Loop in case of wildcards
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET /A RESULT_CODE = 1'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET RESULT_MSG=Load Completed'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET FILE_NAME=NO_MORE_FILES'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET LOAD_FILE="'||v_LoadRec.lt_file_path||v_LoadRec.lt_file_name||'"'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'for %%A in (%LOAD_FILE%) do if "!FILE_NAME!"=="NO_MORE_FILES" SET FILE_NAME=%%A'||chr(10));
           v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if "!FILE_NAME!"==NO_MORE_FILES goto LABEL_EXIT'||chr(10));

            If v_LoadRec.lt_file_parsed is NULL OR v_LoadRec.lt_file_parsed <> 'Y' Then -- RED_2257
              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'SET CONSTANT_FILE_NAME=%FILE_NAME:\=\\%'||chr(10));
            End If;

            -- if options specified then add them
            If v_rec_options is NOT NULL Then
              v_line_no := v_line_no + 1;
              v_fix := 'echo '||v_rec_options||' >'||v_script||'.ctl'||chr(10);
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);

              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo load data >>'||v_script||'.ctl'||chr(10));
            Else
              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo load data >'||v_script||'.ctl'||chr(10));
              v_line_no := v_line_no + 1;
            End If;

            -- if charset specified then add them
            If v_file_charset is NOT NULL Then
              v_line_no := v_line_no + 1;
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo CHARACTERSET ' || v_file_charset || ' >>'||v_script||'.ctl'||chr(10));
              v_line_no := v_line_no + 1;
            End If;

            -- see if we have a fixed length record
            -- If a wild card in the file name then we wont have quote delimiters
            -- any more
            If v_wild = 1 THEN
              v_fix := 'echo infile ''%FILE_NAME%'' ';
            Else
              v_fix := 'echo infile %FILE_NAME% ';
            End If;
            If substr(v_rec_delimiter,1,4) = 'FIX ' Then
              v_fix := v_fix || '"' || v_rec_delimiter || '"';
            End If;
            v_fix := v_fix || ' >>'||v_script||'.ctl'||chr(10);
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo badfile '''||v_script||'.bad'' >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;
            IF v_table_schema IS NOT NULL THEN
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo append into table '||v_table_schema||'.'||v_LoadRec.lt_table_name||' >>'||v_script||'.ctl'||chr(10));
            ELSE
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,
                  'echo append into table '||v_LoadRec.lt_table_name||' >>'||v_script||'.ctl'||chr(10));
            END IF;

             -- if when statement then add it
            If v_rec_when is NOT NULL Then
              v_line_no := v_line_no + 1;
              v_fix := 'echo '||v_rec_when ||' >>'||v_script||'.ctl'||chr(10);
              Insert into ws_wrk_task_scr_line (wtsl_task_key,
                  wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
              Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);
            End If;

            If v_LoadRec.lt_file_delimiter is Not NULL Then
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo fields terminated by "'||v_LoadRec.lt_file_delimiter||'" >>'||v_script||'.ctl'||chr(10));
                If v_rec_enclosed is NOT NULL Then
                  v_line_no := v_line_no + 1;
                  v_fix := 'echo optionally enclosed by '''||replace(v_rec_enclosed,'"','^"')||''' >>'||v_script||'.ctl'||chr(10);
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,v_fix);
                End If;
--                v_line_no := v_line_no + 1;
--                Insert into ws_wrk_task_scr_line (wtsl_task_key,
--                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
--                Values (p_task_id, p_job_id, p_sequence,v_line_no,
--                    'echo optionally enclosed by ''^"'' >>'||v_script||'.ctl'||chr(10));
            End If;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo trailing nullcols >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo ( >>'||v_script||'.ctl'||chr(10));

            --**************************************************************************************
            -- See if a parsed file or single column
            -- If a parsed file then get all the columns
            --**************************************************************************************
            If v_LoadRec.lt_file_parsed = 'Y' Then
                Select count(1) into v_col_count
                From ws_load_col Where lc_obj_key = p_obj_key
                And lc_src_column like 'COL%';
                v_row := 0;
                v_pos := 1;
                FOR v_ColRec in c_LoadCol LOOP
                    v_fix := '';

                    -- see if this is width based and if so add the width to the column
                    v_epos := Instr(v_ColRec.lc_src_column,'_width_');
                    If v_epos > 0 Then
                        v_spos := to_number(substr(v_ColRec.lc_src_column,v_epos+7));
                        If v_spos > 0 Then
                          v_spos := v_spos-1+v_pos;
                          v_fix := v_fix||' position('||v_pos||':'||v_spos||')';
                          v_pos := v_spos+1;
                        End If;
                    End If;


                    If v_ColRec.lc_transform_code is not Null
                    AND UPPER(v_ColRec.lc_transform_type) <> 'A' Then
                      v_work := v_ColRec.lc_transform_code;
                      -- Get rid of any comments in the transform
                      v_t1pos := Instr(v_work,CHR(45)||CHR(45));
                      WHILE v_t1pos > 0 LOOP
                        v_t2pos := Instr(v_work,CHR(10),v_t1pos);
                        IF v_t2pos > 0 THEN
                          v_work2 := SUBSTR(v_work,1,v_t1pos-1);
                          v_work := v_work2||SUBSTR(v_work,v_t2pos+1,9999);
                        ELSE
                          v_work := SUBSTR(v_work,1,v_t1pos-1);
                        END IF;
                        v_t1pos := Instr(v_work,CHR(45)||CHR(45));
                      END LOOP;
                      v_work := replace(replace(v_work,CHR(13),''),CHR(10),''); -- RED_2771
                      v_work := LTRIM(RTRIM(v_work));
                      v_fix := v_fix||' '||substr(v_work,1,255);
                    Else
                        v_fix := v_fix||'';
                    End If;
                    v_row := v_row + 1;
                    If v_col_count = v_row Then
                        v_fix := v_fix||'';
                    Else
                        v_fix := v_fix||',';
                    End If;
                    v_line_no := v_line_no + 1;
                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
                                'echo '||v_ColRec.lc_col_name||v_fix||'>>'||v_script||'.ctl'||chr(10));
                END LOOP;
            Else -- single column load

                -- first see what columns we have
                v_rowseq := 0;
                v_rowname := 0;
                FOR v_ColRec in c_LoadAll LOOP
                    IF LOWER(v_ColRec.lc_col_name) = 'row_number' Then
                      v_rowseq := 1;
                    End If;
                    IF LOWER(v_ColRec.lc_col_name) = 'row_file_name' Then
                      v_rowname := 1;
                    End If;
                END LOOP;

                IF v_rowseq = 1 Then
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  row_number sequence(1,1), >>'||v_script||'.ctl'||chr(10));
                END IF;
                IF v_rowname = 1 THEN
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  row_data char(4000), >>'||v_script||'.ctl'||chr(10));
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  row_file_name constant %CONSTANT_FILE_NAME% >>'||v_script||'.ctl'||chr(10)); -- RED_2257
                ELSE
                  v_line_no := v_line_no + 1;
                  Insert into ws_wrk_task_scr_line (wtsl_task_key,
                      wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                  Values (p_task_id, p_job_id, p_sequence,v_line_no,
                          'echo  row_data char(4000) >>'||v_script||'.ctl'||chr(10));
                END IF;

            End If;

            -- Complete the script
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo ) >>'||v_script||'.ctl'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'sqlldr userid=%WSL_USER%/\"!WSL_PWD!\"' -- RED_4372
                                ||'@'||v_ConnectRec.dc_database_id||' > NUL control='||v_script
                                ||'.ctl '||v_skip||'silent=HEADER,FEEDBACK log='||v_script||'.log'||chr(10));

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if %errorlevel% GTR 2 goto answerbad'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'if %errorlevel% LSS 0 goto answerbad'||chr(10));

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'goto answer%errorlevel%'||chr(10));


            --SUCCESS
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':answer0'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'type '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_CODE%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_MSG%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));

            -- WARNING
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':answer2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET /A RESULT_CODE=-1'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'SET RESULT_MSG=WARNING: Not all rows loaded. See error trail'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'type '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_CODE%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_MSG%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));

            --ERROR
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':answer1'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo -2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo SQL*Loader execution exited with EX_FAIL, see error trail'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'type '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));
            --FATAL
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':answer3'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo -3'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo SQL*Loader execution encountered a fatal error'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'type '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));
            --FATAL
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':answerbad'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo -3'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
               wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo SQL*Loader execution encountered an unexpected fatal error'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'type '||v_script||'.log >' || Chr(38) || '2'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));

            -- END OF LOOP
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                ':LABEL_EXIT'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_CODE%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo %RESULT_MSG%'||chr(10));
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'exit'||chr(10));

            --=====================================================
            -- Write out the task script header
            --=====================================================
            Insert into ws_wrk_task_scr_hdr (
                wtsh_task_key,
                wtsh_job_key,
                wtsh_name,
                wtsh_sequence,
                wtsh_host_type,
                wtsh_script_type,
                wtsh_load_type,
                wtsh_work_dir,
                wtsh_connect_key,
                wtsh_load_key,
                wtsh_script_key
            ) values (
                p_task_id,
                p_job_id,
                p_task_name,
                p_sequence,
                v_ConnectRec.dc_type,
                v_script_type,
                v_load_type,
                v_work_dir,
                v_connect_key,
                v_load_key,
                v_script_key
            );
            COMMIT;
        End If;


    --=====================================================
    -- File based Export. Build the script below once we work
    -- out if a Unix or Windows connection
    --=====================================================
    ELSE

        v_step := 900;
        v_connect_key := v_ExpRec.et_connect_key;
        v_load_key := p_obj_key;
        v_script_key := 0;

        --=====================================================
        -- Get the work directory from the connection
        -- If no Connection then we have a problem
        --=====================================================
        v_step := 1000;

        IF v_connect_key > 0 THEN
            SELECT *
            INTO   v_ConnectRec
            FROM   ws_dbc_connect
            WHERE  dc_obj_key = v_connect_key;
        ELSE
            IF v_script_type = v_ws_script_execute THEN
                p_return_msg := 'No connection defined. Unable to execute script';
            ELSE
                p_return_msg := 'No connection defined. Unable to perform load';
            END IF;
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END IF;

        v_step := 1100;
        --=====================================================
        -- Set Unix/DOS Differences variables
        --=====================================================
        v_enclosed_by := v_ExpRec.et_enclosed_by;
        IF v_ConnectRec.dc_type = 'U' THEN

            v_protector := '';
            v_file_slash := '/';
            v_str_quote := '"';
            IF TRIM(v_enclosed_by) = v_str_quote THEN
              v_enclosed_by := '\"';
            END IF;

        ELSIF v_ConnectRec.dc_type = 'W' THEN

            v_protector := '^';
            v_file_slash := '\';
            v_str_quote := '';

        END IF;

        --=====================================================
        -- File based export. Builds a UNIX or DOS script
        --=====================================================

        -- Create a unique name for the ctrl files and log files
        v_work_dir := v_ConnectRec.dc_work_dir;

        IF SUBSTR(v_work_dir,-1,1) <> v_file_slash THEN
            v_work_dir := v_work_dir || v_file_slash;
        END IF;

        v_script := v_work_dir||'wsl'||p_sequence||'j'||p_job_id||'t'||p_task_id;

        IF v_ExpRec.et_file_path IS NOT NULL THEN
            IF SUBSTR(v_ExpRec.et_file_path,-1,1) <> v_file_slash THEN
                v_file_path := v_ExpRec.et_file_path || v_file_slash;
            ELSE
                v_file_path := v_ExpRec.et_file_path;
            END IF;
        ELSE
            v_file_path := '';
        END IF;

        -- loop on a matching pair of $ signs in the file name
        -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
        v_spos := INSTR(v_ExpRec.et_file_name,'$',1);
        WHILE v_spos <> 0 LOOP
            v_epos := INSTR(v_ExpRec.et_file_name,'$',v_spos+1);
            IF v_epos <> 0 THEN
                v_command := SUBSTR(v_ExpRec.et_file_name,v_spos+1,v_epos-v_spos-1);
                v_new_command := v_command;
                IF INSTR('SEQUENCE',v_new_command) <> 0 THEN
                    v_new_command := REPLACE(v_new_command,'SEQUENCE',TO_CHAR(p_sequence));
                ELSE
                    v_current_date := SYSDATE;
                    IF INSTR(v_new_command,'YYYY') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'YYYY',TO_CHAR(v_current_date,'YYYY'));
                    ELSIF INSTR(v_new_command,'YY') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'YY',TO_CHAR(v_current_date,'YY'));
                    END IF;
                    IF INSTR(v_new_command,'MM') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'MM',TO_CHAR(v_current_date,'MM'));
                    END IF;
                    IF INSTR(v_new_command,'DD') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'DD',TO_CHAR(v_current_date,'DD'));
                    END IF;
                    IF INSTR(v_new_command,'HH') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'HH',TO_CHAR(v_current_date,'HH'));
                    END IF;
                    IF INSTR(v_new_command,'MI') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'MI',TO_CHAR(v_current_date,'MI'));
                    END IF;
                    IF INSTR(v_new_command,'SS') <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'SS',TO_CHAR(v_current_date,'SS'));
                    END IF;
                END IF;
                IF NVL(v_new_command,' ') <> ' ' THEN
                    v_ExpRec.et_file_name := REPLACE(v_ExpRec.et_file_name,'$'||v_command||'$',v_new_command);
                END IF;
            END IF; -- END of epos found
            IF ((NVL(v_new_command,' ') <> ' ') AND (v_epos <> 0)) THEN
                v_spos := INSTR(v_ExpRec.et_file_name,'$',1);
            ELSE
                v_spos := 0;
            END IF;
        END LOOP; -- END of spos while

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := '@echo off';
        ELSE
            -- Use the shell configured in the connection, otherwise guess
            -- based on the name of the connection
            v_shell := null;
            v_cpos := instr(v_ConnectRec.dc_attributes, 'ScriptShell~='); -- ScriptShell~=LENGTH;VALUE;
            If v_cpos <> 0 Then
                v_cpos := v_cpos + 13;
                v_epos := instr(v_ConnectRec.dc_attributes, ';', v_cpos);
                If v_epos <> 0 Then
                    v_work := substr(v_ConnectRec.dc_attributes, v_cpos, v_epos-v_cpos);
                    v_nlength := to_number(v_work);
                    If v_nlength > 0 Then
                        v_shell := '#!' || substr(v_ConnectRec.dc_attributes, v_epos+1, v_nlength);
                    End If;
                End If;
            End If;
            If v_shell is null Then
                If instr(upper(v_ConnectRec.dc_name),'LINUX') > 0 Then
                  v_line := '#!/bin/sh';
                Else
                  v_line := '#!/bin/ksh';
                End If;
            Else
                v_line := v_shell;
            End If;
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        v_line := 'set pages '||v_protector||'0 ';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' > '||v_script||'.ctl'||chr(10));

        v_line := 'set lines 32767';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'set feed off';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'set term off';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'set trimspool on';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        IF ( TRIM(v_ExpRec.et_export_options) IS NOT NULL ) THEN
            v_line := TRIM(v_ExpRec.et_export_options);
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
        END IF;

        -- SID
        IF v_ConnectRec.dc_type = 'U' THEN
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'if [ -z "$ORACLE_SID" ]'||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'then'||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              '  SID=@'||v_ConnectRec.dc_database_id||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'else'||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              '  SID=@$ORACLE_SID'||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'fi'||chr(10));
          v_line_no := v_line_no + 1;
          Insert into ws_wrk_task_scr_line (wtsl_task_key,
              wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
          Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'export SID'||chr(10));
        END IF;

        v_line := 'WHENEVER OSERROR EXIT FAILURE';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'WHENEVER SQLERROR EXIT SQL.SQLCODE';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'spool ' || v_file_path || v_ExpRec.et_file_name;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        IF (( v_ExpRec.et_header_row_ind <> 'N' )
        AND ( v_ExpRec.et_header_row_ind IS NOT NULL )
        AND ( SUBSTR(v_ExpRec.et_export_format,1,1) = 'D' )) THEN

            v_work := 'SELECT ''';
            v_count := 1;
            v_first_time := 1;

            FOR v_ExpColRec in c_ExpCol LOOP

                IF ( v_first_time = 1 ) THEN
                    v_src_table := v_ExpColRec.ec_src_table;
                    v_first_time := 0;
                ELSE
                    v_work := v_work || v_protector || v_ExpRec.et_file_delimiter;
                END IF;

--                IF ( v_count = 8 ) THEN
--                    v_line := v_work || '''' ;
--                    v_line_no := v_line_no + 1;
--                    Insert into ws_wrk_task_scr_line (wtsl_task_key,
--                        wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
--                    Values (p_task_id, p_job_id, p_sequence,v_line_no,
--                        'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
--                    v_work := '            '||v_protector||'|'||v_protector||'|''';
--                    v_count := 0;
--                END IF;

                IF ( v_ExpRec.et_header_row_ind = 'B' ) THEN
                    v_work2 := v_ExpColRec.ec_display_name;
--                    v_work := v_work || v_work2;
                ELSIF ( v_ExpRec.et_header_row_ind = 'C' ) THEN
                    v_work2 := v_ExpColRec.ec_col_name;
--                    v_work := v_work || v_work2;
                END IF;

                v_work := v_work || v_work2;

                v_line := v_work || '''' ;
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
                v_work := '    '||v_protector||'|'||v_protector||'|''';

                v_count := v_count + 1;

            END LOOP;

--            IF ( v_count > 1 ) THEN
--                v_line := v_work || '''';
--               v_line_no := v_line_no + 1;
--                Insert into ws_wrk_task_scr_line (wtsl_task_key,
--                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
--                Values (p_task_id, p_job_id, p_sequence,v_line_no,
--                    'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
--            END IF;

            IF v_table_schema IS NOT NULL THEN
              v_line := 'FROM ' || v_table_schema || '.' || v_src_table;
            ELSE
              v_line := 'FROM ' || v_src_table;
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'WHERE ROWNUM='||v_protector||'1 ' ;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := ';';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        END IF;

        v_first_time := 1;

        For v_ExpColRec in c_ExpCol LOOP

            IF ( SUBSTR(v_ExpRec.et_export_format,1,1) = 'D' ) THEN

                IF ( v_first_time = 1 ) THEN
                    v_line := 'Select ';
                ELSE
                    v_line := ' '||v_protector||'|'||v_protector||'| '''||v_protector||
                              v_ExpRec.et_file_delimiter||''' '||v_protector||'|'||v_protector||'| ';
                END IF;
                v_work := TRIM(LOWER(v_ExpColRec.ec_data_type));
                IF ( TRIM(v_ExpColRec.ec_transform_code) IS NOT NULL ) THEN
                    v_line := v_line || v_ExpColRec.ec_transform_code;
                ELSIF (( SUBSTR(v_work,1,7) = 'varchar' ) Or ( SUBSTR(v_work,1,4) = 'char' )) THEN
                    IF ( TRIM(v_enclosed_by) = q'[']') THEN
                        v_line := v_line || q'['''']' || v_protector || '|' || v_protector || '|';
                    ELSIF ( TRIM(v_enclosed_by) = q'[\]') THEN
                        v_line := v_line || q'['\\']' || v_protector || '|' || v_protector || '|';
                    ELSIF ( TRIM(v_enclosed_by) IS NOT NULL ) THEN
                        v_line := v_line || '''' || v_enclosed_by || '''' || '||';
                    END IF;
                    v_line := v_line || v_ExpColRec.ec_src_column;
                    IF ( TRIM(v_enclosed_by) = q'[']' ) THEN
                        v_line := v_line || v_protector || '|' || v_protector || '|' || q'['''']';
                    ELSIF ( TRIM(v_enclosed_by) = q'[\]' ) THEN
                        v_line := v_line || v_protector || '|' || v_protector || '|' || q'['\\']';
                    ELSIF ( TRIM(v_enclosed_by) IS NOT NULL ) THEN
                        v_line := v_line || '||' || '''' || v_enclosed_by || '''';
                    END IF;
                ELSIF ( SUBSTR(v_work,1,4) = 'date' ) THEN
                    v_line := v_line || 'TO_CHAR(' || v_ExpColRec.ec_src_column || ',''YYYYMMDDhh24miss'')';
                ELSE
                    v_line := v_line || 'TO_CHAR(' || v_ExpColRec.ec_src_column || ')';
                END IF;

            ELSIF ( SUBSTR(v_ExpRec.et_export_format,1,1) = 'W' ) THEN

                v_work := TRIM(LOWER(v_ExpColRec.ec_data_type));
                IF (( SUBSTR(v_work,1,7) = 'varchar' ) Or ( SUBSTR(v_work,1,4) = 'char' )) THEN

                    v_cpos := INSTR(v_work,'(');
                    IF ( v_cpos = 0 ) THEN
                        v_work := NULL;
                    ELSE
                        v_work := SUBSTR(v_work,v_cpos+1);
                    END IF;
                    v_cpos := Instr(v_work,')');
                    IF ( v_cpos = 0 ) THEN
                        v_nLength := 0;
                    ELSE
                        v_nLength := TO_NUMBER(SUBSTR(v_work,1,v_cpos-1));
                    END IF;
                ELSIF ( SUBSTR(v_work,1,4) = 'date' ) THEN
                    v_nLength := 14;
                ELSE
                    v_nLength := 30;
                END IF;

                IF ( TRIM(v_ExpColRec.ec_transform_code) IS NOT NULL ) THEN
                    v_work2 := v_ExpColRec.ec_transform_code;
                ELSIF (( SUBSTR(v_work,1,7) = 'varchar' ) Or ( SUBSTR(v_work,1,4) = 'char' )) THEN
                    v_work2 := v_ExpColRec.ec_src_column;
                ELSIF ( SUBSTR(v_work,1,4) = 'date' ) THEN
                    v_work2 := 'TO_CHAR(' || v_ExpColRec.ec_src_column || ',''YYYYMMDDhh24miss'')';
                ELSE
                    v_work2 := 'TO_CHAR(' || v_ExpColRec.ec_src_column || ')';
                END IF;

                IF ( v_first_time = 1 ) THEN
                    v_line := 'Select ';
                ELSE
                    v_line := ' '||v_protector||'|'||v_protector||'| ';
                END IF;

                v_line := v_line || 'RPAD(NVL(' || v_work2 || ','' ''),' || TO_CHAR(v_nlength) || ','' '')';

            END IF;

            IF ( v_first_time = 1 ) THEN
                v_src_table := v_ExpColRec.ec_src_table;
                v_first_time := 0;
            END IF;

            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        END LOOP;

        IF v_table_schema IS NOT NULL THEN
          v_line := 'FROM ' || v_table_schema || '.' || v_src_table;
        ELSE
          v_line := 'FROM ' || v_src_table;
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        IF ( TRIM(v_ExpRec.et_where_clause) IS NOT NULL ) THEN
            v_line := REPLACE(REPLACE(v_ExpRec.et_where_clause,'<',v_protector||'<'),'>',v_protector||'>');
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
        END IF;

        v_line := '/';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'spool off';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        v_line := 'exit';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

        IF v_ConnectRec.dc_type = 'U' THEN
            v_line := 'RES=`sqlplus -s $DSS_USER/"$DSS_PWD"$SID <<EOF';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'set heading off';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'set echo off';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'set feedback 0';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'set pagesize 0';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'SELECT dc_admin_userid || CHR(9)|| dc_admin_pwd FROM ws_dbc_connect WHERE  dc_obj_key = ' || v_connect_key || ';';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'EOF`';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'USER=`echo "$RES" | cut -f1`';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'PWD=`echo "$RES" | cut -f2`';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            v_line := 'sqlplus $USER/"$PWD"${SID}' || ' @"' || v_script || '.ctl" > "' || v_script || '_a.aud"';
        ELSE
            v_line := 'sqlplus %WSL_USER%/"%WSL_PWD%"@' || v_ConnectRec.dc_database_id || ' @"' || v_script || '.ctl" > "' || v_script || '_a.aud"';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'SET ERRLEV=%errorlevel%';
        ELSE
            v_line := 'ERRLEV=$?';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'IF %ERRLEV% EQU 0 GOTO LABEL_OKAY';
        ELSE
            v_line := 'if [ "$ERRLEV" -ne "0" ]';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'U' THEN
            v_line := 'then';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'echo -2';
        ELSE
            v_line := '  echo -2';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'echo Export failed with return status %ERRLEV% See error log for details';
        ELSE
            v_line := '  echo Export failed with return status $ERRLEV See error log for details';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'type "' || v_script || '_a.aud" >' || Chr(38) || '2';
        ELSE
            v_line := '  cat "' || v_script || '_a.aud" >' || Chr(38) || '2';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'exit';
        ELSE
            v_line := '  exit';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := ':LABEL_OKAY';
        ELSE
            v_line := 'fi';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        -- Compress Output File
        IF (( TRIM(v_ExpRec.et_compress_ind) = 'Y' )
              And ( TRIM(v_ExpRec.et_compress_name) IS NOT NULL )) THEN

            IF v_ExpRec.et_compress_path is not NULL THEN
                IF substr(v_ExpRec.et_compress_path,-1,1) <> v_file_slash THEN
                    v_compress_path := v_ExpRec.et_compress_path || v_file_slash;
                ELSE
                    v_compress_path := v_ExpRec.et_compress_path;
                END IF;
            ELSE
                v_compress_path := '';
            END IF;

            v_line := '"' || v_compress_path || TRIM(v_ExpRec.et_compress_name) || '" '
                      || REPLACE(TRIM(v_ExpRec.et_compress_param),'$EXPFILE$',v_file_path||v_ExpRec.et_file_name)
                      || ' >> "' || v_script || '_a.aud"';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'SET ERRLEV=%errorlevel%';
            ELSE
                v_line := 'ERRLEV=$?';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'IF %ERRLEV% EQU 0 GOTO LABEL_OKAY2';
            ELSE
                v_line := 'if [ "$ERRLEV" -ne "0" ]';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
              v_line||chr(10));

            IF v_ConnectRec.dc_type = 'U' THEN
                v_line := 'then';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'echo -2';
            ELSE
                v_line := '  echo -2';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'echo Export compress failed with return status %ERRLEV% See error log for details';
            ELSE
                v_line := '  echo Export compress failed with return status $ERRLEV See error log for details';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'type "' || v_script || '_a.aud" >' || Chr(38) || '2';
            ELSE
                v_line := '  cat "' || v_script || '_a.aud" >' || Chr(38) || '2';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'exit';
            ELSE
                v_line := '  exit';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := ':LABEL_OKAY2';
            ELSE
                v_line := 'fi';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

        END IF;

        -- Use query tool to generate a trigger file
        IF (( TRIM(v_ExpRec.et_trig_name) IS NOT NULL )
        AND ( TRIM(v_ExpRec.et_trig_param_1) IS NOT NULL )) THEN

            IF v_ExpRec.et_trig_path is not NULL THEN
                IF substr(v_ExpRec.et_trig_path,-1,1) <> v_file_slash THEN
                    v_trig_path := v_ExpRec.et_trig_path || v_file_slash;
                ELSE
                    v_trig_path := v_ExpRec.et_trig_path;
                END IF;
            ELSE
                v_trig_path := '';
            END IF;

            -- loop on a matching pair of $ signs in the file name
            -- and handle a sequence, YYYY, MM, DD, HH, MI, SS
            v_spos := INSTR(v_ExpRec.et_trig_name,'$',1);
            WHILE v_spos <> 0 LOOP
                v_epos := INSTR(v_ExpRec.et_trig_name,'$',v_spos+1);
                IF v_epos <> 0 THEN
                    v_command := SUBSTR(v_ExpRec.et_trig_name,v_spos+1,v_epos-v_spos-1);
                    v_new_command := v_command;
                    IF INSTR('SEQUENCE',v_new_command) <> 0 THEN
                        v_new_command := REPLACE(v_new_command,'SEQUENCE',TO_CHAR(p_sequence));
                    ELSE
                        v_current_date := SYSDATE;
                        IF INSTR(v_new_command,'YYYY') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'YYYY',TO_CHAR(v_current_date,'YYYY'));
                        ELSIF INSTR(v_new_command,'YY') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'YY',TO_CHAR(v_current_date,'YY'));
                        END IF;
                        IF INSTR(v_new_command,'MM') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'MM',TO_CHAR(v_current_date,'MM'));
                        END IF;
                        IF INSTR(v_new_command,'DD') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'DD',TO_CHAR(v_current_date,'DD'));
                        END IF;
                        IF INSTR(v_new_command,'HH') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'HH',TO_CHAR(v_current_date,'HH'));
                        END IF;
                        IF INSTR(v_new_command,'MI') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'MI',TO_CHAR(v_current_date,'MI'));
                        END IF;
                        IF INSTR(v_new_command,'SS') <> 0 THEN
                            v_new_command := REPLACE(v_new_command,'SS',TO_CHAR(v_current_date,'SS'));
                        END IF;
                    END IF;
                    IF NVL(v_new_command,' ') <> ' ' THEN
                        v_ExpRec.et_trig_name := REPLACE(v_ExpRec.et_trig_name,'$'||v_command||'$',v_new_command);
                    END IF;
                END IF; -- END of epos found
                IF ((NVL(v_new_command,' ') <> ' ') AND (v_epos <> 0)) THEN
                    v_spos := INSTR(v_ExpRec.et_trig_name,'$',1);
                ELSE
                    v_spos := 0;
                END IF;
            END LOOP; -- END of spos while

            v_line := 'set pages '||v_protector||'0 ';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' > '||v_script||'.ctl'||chr(10));

            v_line := 'set lines 32767';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'set feed off';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'set term off';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'set trimspool on';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'WHENEVER OSERROR EXIT FAILURE';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'WHENEVER SQLERROR EXIT SQL.SQLCODE';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
              'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'spool ' || v_trig_path || v_ExpRec.et_trig_name;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            -- IF trig column 1 is populated
            IF ( SUBSTR(v_ExpRec.et_trig_param_1,1,1) = 'R' ) THEN
                v_work := 'TO_CHAR(COUNT(*))';
            ELSIF ( TRIM(v_ExpRec.et_trig_param_1) IS NOT NULL ) THEN
                v_work := 'TO_CHAR(' || v_ExpRec.et_trig_param_1 || ')';
            ELSE
                v_work := 'NULL';
            END IF;

            -- IF trig column 2 is populated
            IF ( SUBSTR(v_ExpRec.et_trig_param_2,1,1) = 'R' ) THEN
                v_work2 := 'TO_CHAR(COUNT(*))';
            ELSIF ( TRIM(v_ExpRec.et_trig_param_2) IS NOT NULL ) THEN
                v_work2 := 'TO_CHAR(' || v_ExpRec.et_trig_param_2 || ')';
            ELSE
                v_work2 := NULL;
            END IF;

            -- IF trig column 3 is populated
            IF ( SUBSTR(v_ExpRec.et_trig_param_3,1,1) = 'R' ) THEN
                v_work3 := 'TO_CHAR(COUNT(*))';
            ELSIF ( TRIM(v_ExpRec.et_trig_param_3) IS NOT NULL ) THEN
                v_work3 := 'TO_CHAR(' || v_ExpRec.et_trig_param_3 || ')';
            ELSE
                v_work3 := NULL;
            END IF;

            -- Put it all together
            v_line := 'SELECT ' || v_work;
            IF ( v_ExpRec.et_trig_delimiter IS NOT NULL ) THEN
                v_work := ' '||v_protector||'|'||v_protector||'| '''||v_protector||
                          v_ExpRec.et_trig_delimiter||''' '||v_protector||'|'||v_protector||'| ';
            ELSE
                v_work := ' '||v_protector||'|'||v_protector||'| '' '' '||v_protector||'|'||v_protector||'| ';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            IF ( v_work2 IS NOT NULL ) THEN
                v_line := v_work || v_work2;
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
            END IF;

            IF ( v_work3 IS NOT NULL ) THEN
                v_line := v_work || v_work3;
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
            END IF;

            IF v_table_schema IS NOT NULL THEN
              v_line := 'FROM ' || v_table_schema || '.' || v_src_table;
            ELSE
              v_line := 'FROM ' || v_src_table;
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            IF ( TRIM(v_ExpRec.et_where_clause) IS NOT NULL ) THEN
                v_line := REPLACE(REPLACE(v_ExpRec.et_where_clause,'<',v_protector||'<'),'>',v_protector||'>');
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                    'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));
            END IF;

            v_line := '/';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'spool off';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            v_line := 'exit';
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                'echo '||v_str_quote||v_line||v_str_quote||' >> '||v_script||'.ctl'||chr(10));

            IF v_ConnectRec.dc_type = 'U' THEN
                v_line := 'RES=`sqlplus -s $DSS_USER/"$DSS_PWD"$SID <<EOF';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'set heading off';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'set echo off';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                 v_line||chr(10));

                v_line := 'set feedback 0';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'set pagesize 0';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'SELECT dc_admin_userid || CHR(9)|| dc_admin_pwd FROM ws_dbc_connect WHERE  dc_obj_key = ' || v_connect_key || ';';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'EOF`';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'USER=`echo "$RES" | cut -f1`';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));

                v_line := 'PWD=`echo "$RES" | cut -f2`';
                v_line_no := v_line_no + 1;
                Insert into ws_wrk_task_scr_line (wtsl_task_key,
                    wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
                Values (p_task_id, p_job_id, p_sequence,v_line_no,
                   v_line||chr(10));
                v_line := 'sqlplus $USER/"$PWD"${SID}' || ' @"' || v_script || '.ctl" > "' || v_script || '_a.aud"';
            ELSE
                v_line := 'sqlplus %WSL_USER%/"%WSL_PWD%"@' || v_ConnectRec.dc_database_id || ' @"' || v_script || '.ctl" > "' || v_script || '_a.aud"';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'SET ERRLEV=%errorlevel%';
            ELSE
                v_line := 'ERRLEV=$?';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'IF %ERRLEV% EQU 0 GOTO LABEL_OKAY3';
            ELSE
                v_line := 'if [ "$ERRLEV" -ne "0" ]';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
              v_line||chr(10));

            IF v_ConnectRec.dc_type = 'U' THEN
                v_line := 'then';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'echo -2';
            ELSE
                v_line := '  echo -2';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'echo Export trigger creation failed with return status %ERRLEV% See error log for details';
            ELSE
                v_line := '  echo Export trigger creation failed with return status $ERRLEV See error log for details';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'type "' || v_script || '_a.aud" >' || Chr(38) || '2';
            ELSE
                v_line := '  cat "' || v_script || '_a.aud" >' || Chr(38) || '2';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := 'exit';
            ELSE
                v_line := '  exit';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

            IF v_ConnectRec.dc_type = 'W' THEN
                v_line := ':LABEL_OKAY3';
            ELSE
                v_line := 'fi';
            END IF;
            v_line_no := v_line_no + 1;
            Insert into ws_wrk_task_scr_line (wtsl_task_key,
                wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
            Values (p_task_id, p_job_id, p_sequence,v_line_no,
                v_line||chr(10));

        END IF;

        v_line := 'echo 1';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        v_line := 'echo Export of ';
        IF v_table_schema IS NOT NULL THEN
          v_line := v_line || v_table_schema || '.' || v_src_table;
        ELSE
          v_line := v_line || v_src_table;
        END IF;
        v_line := v_line || ' Completed';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        IF v_ConnectRec.dc_type = 'W' THEN
            v_line := 'type "' || v_script || '_a.aud"';
        ELSE
            v_line := '  cat "' || v_script || '_a.aud"';
        END IF;
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        v_line := 'exit';
        v_line_no := v_line_no + 1;
        Insert into ws_wrk_task_scr_line (wtsl_task_key,
            wtsl_job_key,wtsl_sequence,wtsl_line_no,wtsl_line)
        Values (p_task_id, p_job_id, p_sequence,v_line_no,
            v_line||chr(10));

        --=====================================================
        -- Write out the task script header
        --=====================================================
        Insert into ws_wrk_task_scr_hdr (
            wtsh_task_key,
            wtsh_job_key,
            wtsh_name,
            wtsh_sequence,
            wtsh_host_type,
            wtsh_script_type,
            wtsh_load_type,
            wtsh_work_dir,
            wtsh_connect_key,
            wtsh_load_key,
            wtsh_script_key
        ) values (
            p_task_id,
            p_job_id,
            p_task_name,
            p_sequence,
            v_ConnectRec.dc_type,
            v_script_type,
            v_load_type,
            v_work_dir,
            v_connect_key,
            v_load_key,
            v_script_key
        );
        COMMIT;

    End If;

    p_status_code := 1;
    p_return_msg := 'Script prepared';
    v_result := 1;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
      p_status_code := -3;
      If v_step = 400 Then
        If v_script_key <= 0 Then
          v_MsgText := 'Host Script not defined for load table. Please define a load script or change '||
                  'the load type. In ws_act_host_script '|| v_ws_pro_version ||
                  ' Step ' ||v_step;
        Else
          v_MsgText := 'Failed to find script in ws_act_host_script '|| v_ws_pro_version ||
                  ' Step ' ||v_step;
        End If;
      ElsIf v_step = 500 Or v_step = 1000 Then
        If v_connect_key <= 0 Then
          v_MsgText := 'Connection not defined for load table. Please define a connection. '||
                  'In ws_act_host_script '|| v_ws_pro_version ||
                  ' Step ' ||v_step;
        Else
          v_MsgText := 'Failed to find connection in ws_act_host_script '|| v_ws_pro_version ||
                  ' Step ' ||v_step;
        End If;
      Else
        v_MsgText := 'Unhandled Exception in ws_act_host_script '|| v_ws_pro_version ||
                        ' Step ' ||v_step;
      End If;
      v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                        v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
      p_return_msg := v_MsgText;
      RETURN -3;

END ws_act_host_script;
 
_PROCEDURE_ Ws_Act_Initial_Build 
-- Notes / History
--
-- WMR 24/09/2001                    Added support for aggregates
-- WMR 22/01/2002                    Version 1.0.0
-- WMR 10/05/2004                    Changed to custom.
-- WMR 06/04/2007   Version 6.0.0.0  Added support for retro copy
-- AP  09/04/2008   Version 6.0.0.0  Added support for ODS/Normal
-- AP  31/12/2008   Version 6.0.2.3  Added support for View
-- AP  28/11/2011   Version 6.5.5.1  RED_2382 Support SQLBlock
-- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  16/01/2018   Version 8.1.1.0  Added support for Source Mapping
-- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_initial_build
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_act_initial_build
    -- Description         :    Execute the build procedure associated with a table
    --
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;

    v_ws_obj_job               constant number := 50;
    v_ws_obj_source_mapping    constant number := 69;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(1024);
    v_cursor          number;
    v_procedure_key   number;
    v_procedure       varchar2(64);
    v_procedure_type  varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    --=====================================================
    -- See what table we have and get the update procedure
    --=====================================================
    BEGIN
        v_step := 100;
        v_procedure_key := 0;
        If p_obj_type = v_ws_obj_dim Then
            Select dt_build_key into v_procedure_key
            From ws_dim_tab
            Where dt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_dim_view Then
            Select dt_build_key into v_procedure_key
            From ws_dim_tab
            Where dt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_view Then
            Select vt_build_key into v_procedure_key
            From ws_view_tab
            Where vt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_fact Then
            Select ft_build_key into v_procedure_key
            From ws_fact_tab
            Where ft_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_fact_kpi Then
            Select ft_build_key into v_procedure_key
            From ws_fact_tab
            Where ft_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_stage Then
            Select st_build_key into v_procedure_key
            From ws_stage_tab
            Where st_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_agg Then
            Select at_build_key into v_procedure_key
            From ws_agg_tab
            Where at_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_retro_copy Then
            Select rt_build_key into v_procedure_key
            From ws_retro_tab
            Where rt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_ods Then
            Select ot_build_key into v_procedure_key
            From ws_ods_tab
            Where ot_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_normal
        OR p_obj_type = v_ws_obj_hub
        OR p_obj_type = v_ws_obj_satellite
        OR p_obj_type = v_ws_obj_link
        OR p_obj_type = v_ws_obj_custom1
        OR p_obj_type = v_ws_obj_custom2
        Then
            Select nt_build_key into v_procedure_key
            From ws_normal_tab
            Where nt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_source_mapping Then
            Select smt_build_key into v_procedure_key
            From ws_source_mapping_tab
            Where smt_source_mapping_key = p_obj_key;
        End If;
    EXCEPTION WHEN OTHERS THEN
        v_step := 200;
        If SQLCODE = 100 Then
            p_return_msg := 'Unable to acquire custom (build) procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_return_msg := 'Please check that a custom (build) procedure has been defined';
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        Else
            p_return_msg := 'Unable to acquire custom (build) procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        End If;
    END;

    v_step := 300;

    If v_procedure_key <= 0
    Or v_procedure_key is NULL Then
        v_MsgText := 'Custom (build) procedure not found for table '||p_task_name;
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                      v_MsgText,NULL,NULL, p_task_id, p_job_id);
        p_return_msg := 'Please check that a custom (build) procedure has been defined';
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Custom (build) procedure not found for table '||p_task_name;
        p_status_code := -2;
        v_result := -2;
        RETURN v_result;
    End If;

    --=====================================================
    -- Get the procedure name
    --=====================================================
    v_step := 400;
    SELECT ph_name, NVL(ph_type,'P')
    INTO   v_procedure, v_procedure_type
    FROM   ws_pro_header
    WHERE  ph_obj_key = v_procedure_key;

--    --=====================================================
--    -- IF SQLBLOCK then return for calling
--    --=====================================================

    v_step := 500;
    IF v_procedure_type = 'B'
    THEN
      -- run a POST SQLBLOCK by returning a result of 17
      p_status_code := 17;
      v_result := 2;
      RETURN v_result;
    END IF;

    --=====================================================
    -- Bind the columns and execute
    --=====================================================
    v_step := 600;
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_step := 700;
    -- Build up our execute statement for the procedure
    v_stmt := 'BEGIN '|| v_procedure
     || '(:p1, :p2, :p3, :p4, :p5, :p6, :p7); END;';
    v_step := 800;
    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
    v_step := 900;

    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', p_sequence);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p2', p_job_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p3', p_task_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p4', p_job_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p5', p_task_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p6', p_return_msg,1024);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p7', p_status_code);
    v_step := 1000;

    --=====================================================
    -- Call the procedure
    --=====================================================
    BEGIN
        v_step := 1100;
        v_result := DBMS_SQL.EXECUTE(v_cursor);
        v_step := 1200;
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p6', p_return_msg);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p7', p_status_code);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
        p_return_msg := 'Unhandled Exception in call to ' ||v_procedure;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
              p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_status_code := -3;
    END;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in Custom procedure routine ws_act_initial_build. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in Custom procedure routine ws_act_initial_build step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_initial_build;
 
_PROCEDURE_ Ws_Act_Load 
-- Notes / History
--
-- WMR 22/01/2002   Version 1.0.0
-- WMR 08/04/2002   Version 1.0.7    Added support for using lt_load_statement
-- WMR 01/05/2002   Version 1.0.7.6  Fixed problem with pre - load sql.
-- WMR 18/06/2002   Version 1.1.0    Added support for Non mandatory columns
-- WMR 11/12/2003   Version 4.1.0    View create needed to handle bigger views
-- WMR 13/02/2004   Version 4.1.0.7  Added support for XML loads
-- WMR 13/06/2004   Version 4.1.0.8  Allow comments in transformations
-- WMR 28/09/2004   Version 4.1.1.0  Load override statement for ODBC handled in scheduler
-- WMR 10/02/2005   Version 4.1.1.3  added support for distinct load and version in errors
-- WMR 24/06/2005   Version 4.1.2.11 include the schema name in the truncate if flag set
-- WMR 27/06/2005   Version 4.1.2.11 limit dberror message to 256 chars for pre_load sql.
-- JML 22/03/2007   Version 5.5.0.17 support for Native ODBC loads Added.
-- WMR 22/05/2007   Version 5.6.0.6  Changed result code for Odbc loads to 2 to prevent erroneous warning message
-- AP  11/02/2008   Version 5.6.3.1  Call WsParameterReplace to allow parse of all fields for parameter substitution.
--                                   Added substitution of $JOB_SEQUENCE$ with p_sequence
-- AP  12/10/2010   Version 6.5.3.1  RED-546 Do Param replace as we go to minimise risk of exceed 4000 characters during replace.
--                                   RED_1346 Better control over stmt control size
-- AP  01/12/2011   Version 6.5.5.1  RED-???? - Add support for Integration Services Loads
-- HM  15/08/2014   Version 6.8.1.2  Adding Schema support
-- AP  25/08/2014                    RED-869 - Add support for Truncate Option (e.g. REUSE STORAGE)
-- AP  03/08/2015   Version 6.8.4.2  RED-5449 - Correction for remote view create issue introduced pon 15/08/2014
-- BC  14/08/2015   Version 6.8.4.3  RED-5520: Replaced occurrences of the != SQL operator with <>
-- DLC 25/01/2016   Version 6.8.5.3  RED-3285 Changed statement from this
--                                     INSERT INTO LoadTable SELECT a, b, c FROM SourceTable
--                                   To this
--                                     INSERT INTO LoadTable (a, b, c) SELECT a, b, c FROM SourceTable
-- BC  11/02/2016   Version 6.8.5.3  Added support for BDA Server operations
-- RS  03/11/2016   Version 6.8.6.3  Added support for multi Sql-statement processing in Pre-Load operation
-- TA  05/04/2017   Version 6.9.1.0  Enabled database link loads with DSS columns in the load table
-- TA  29/08/2017   Version 8.0.1.0  Fixed database link loads with missing source columns
-- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION ws_act_load
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
RETURN INTEGER
AUTHID CURRENT_USER
IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_load
    -- Description    : Loads a load table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    -- =====================================================

    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    -- =====================================================
    -- Variables
    -- =====================================================
    v_MsgText                   varchar2(1024); -- Text in audit_trail
    v_DbText                    varchar2(1024); -- Text in audit_trail
    v_step                      integer := 0;   -- return code
    v_result                    integer := 0;   -- return code
    v_tabcol                    varchar2(512);
    v_sql                       varchar2(4000);
    v_stmt_pre_sql              varchar2(4000);
    v_stmt_insert               varchar2(4000);
    v_stmt_select               varchar2(4000);
    v_stmt_from_where           varchar2(4000);
    v_stmt_select_cols0         varchar2(4000);
    v_stmt_select_cols1         varchar2(4000);
    v_stmt_select_cols2         varchar2(4000);
    v_stmt_select_cols3         varchar2(4000);
    v_stmt_insert_cols0         varchar2(4000);
    v_stmt_insert_cols1         varchar2(4000);
    v_stmt_insert_cols2         varchar2(4000);
    v_stmt_insert_cols3         varchar2(4000);
    v_create                    varchar2(4000);
    v_count                     integer := 0;
    v_view                      integer := 0;
    v_cursor                    number;
    v_col_found                 integer := 1;
    v_row_count                 integer := 0;
    v_row                       integer := 0;
    v_len_select                integer := 0;
    v_len_insert                integer := 0;
    v_len_select_cols           integer := 0;
    v_len_insert_cols           integer := 0;
    v_len_from_where            integer := 0;
    v_len_total                 integer := 0;
    v_MissingMsg                varchar2(4000); -- Message for missing columns
    v_MissingBug                integer := 0;
    v_MissingRet                varchar2(1);
    v_where_clause              varchar2(4000);
    v_spos                      integer := 0;
    v_epos                      integer := 0;
    v_work_select               varchar2(4000);
    v_work_insert               varchar2(4000);
    v_parameter                 varchar2(4000);
    v_t1pos                     integer := 0;
    v_t2pos                     integer := 0;
    v_work2                     varchar2(4000);
    v_schema_flag               integer := 0;
    v_satellite_ind             varchar2(1);
    v_dss_schema                varchar2(64);
    v_table_schema              varchar2(64);
    v_table_name                varchar2(64);
    v_table_with_schema         varchar2(150);

    v_LoadRec       ws_load_tab%ROWTYPE;
    v_ConnectRec    ws_dbc_connect%ROWTYPE;
    v_ScriptRec     ws_scr_header%ROWTYPE;

    v_start_location            integer := 1;
    v_end_location              integer;
    v_statement                 varchar2(32000);
    v_delimiter                 varchar2(4000);

    -- =====================================================
    -- Cursor for all columns in the load table
    -- =====================================================
    CURSOR c_Load IS
        SELECT * FROM ws_load_col
        WHERE lc_obj_key = p_obj_key
        ORDER BY lc_order;

BEGIN
    -- =====================================================
    -- See if we have the flag set for including schema
    -- =====================================================

    v_step := 100;
    v_satellite_ind := '';
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
        SELECT NVL(dt_schema, ''), oo_name
        INTO v_table_schema, v_table_name
        FROM ws_obj_object
        LEFT JOIN ws_dbc_target
        ON ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE ws_obj_object.oo_obj_key = p_obj_key;

        v_table_schema := TRIM(v_table_schema);

        EXCEPTION WHEN NO_DATA_FOUND THEN
            v_MsgText := 'Object could not be found - key:' || p_obj_key;
            v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, NULL, NULL, p_task_id, p_job_id);

            p_return_msg := 'Object could not be found';
            p_status_code := -2;
        RETURN -2;
    END;

    v_step := 110;

    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN
        SELECT meta_satellite_ind, TRIM(meta_dss_schema)
        INTO v_satellite_ind, v_dss_schema
        FROM ws_meta
        WHERE rownum = 1;

        IF v_satellite_ind = 'A' THEN
            IF TRIM(v_dss_schema) IS NOT NULL THEN
                v_schema_flag := 1;
                v_table_schema := v_dss_schema;
            END IF;
        END IF;

        v_step := 120;

        -- If still not set then defaults to the current user
        IF TRIM(v_table_schema) IS NULL THEN
            SELECT USER
            INTO v_table_schema
            FROM dual;
        END IF;
    END IF;

    v_step := 130;

    v_table_schema := TRIM(v_table_schema);
    v_table_with_schema := TRIM(v_table_schema);

    IF TRIM(v_table_with_schema) IS NOT NULL THEN
        v_table_with_schema := v_table_with_schema || '.';
    END IF;

    v_step := 140;
    v_table_with_schema := v_table_with_schema || v_table_name;

    -- =====================================================
    -- First get the load table information
    -- =====================================================
    v_step := 200;
    SELECT * INTO v_LoadRec
    FROM ws_load_tab
    WHERE lt_obj_key = p_obj_key;

    -- =====================================================
    -- Handle any pre - load action
    -- =====================================================
    v_step := 300;
    IF v_LoadRec.lt_pre_action = 'T' OR v_LoadRec.lt_pre_action = 'B' THEN
        v_step := 400;
        v_stmt_insert := 'Truncate table ' || v_table_with_schema;

        IF v_LoadRec.lt_load_options IS NOT NULL THEN
            v_epos := Instr(v_LoadRec.lt_load_options, 'TruncOption~=');
            IF v_epos > 0 THEN
                v_spos := to_number(substr(v_LoadRec.lt_load_options, v_epos + 13, 3));
                IF v_spos > 0 THEN
                    v_stmt_insert := v_stmt_insert || ' ' || substr(v_LoadRec.lt_load_options, v_epos + 17, v_spos);
                END IF;
            END IF;
        END IF;

        BEGIN
            EXECUTE IMMEDIATE v_stmt_insert;
            COMMIT;

            v_MsgText := 'Truncated table ' || v_table_with_schema;
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, NULL, NULL, p_task_id, p_job_id);

            EXCEPTION WHEN OTHERS THEN COMMIT;

            v_DbText := substr(SQLERRM, 1, 1023);
            v_MsgText := 'Unhandled exception in truncate of ' || v_table_with_schema;
            v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText , p_task_id, p_job_id);

            v_MsgText := substr(v_stmt_insert, 1, 1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText , p_task_id, p_job_id);

            p_return_msg := 'Unhandled exception in truncate of ' || v_table_with_schema;
            p_status_code := -2;
            v_result := -2;

            RETURN v_result;
        END;
    END IF;

    IF v_LoadRec.lt_pre_action = 'E' OR v_LoadRec.lt_pre_action = 'B' THEN
        v_step := 500;
        v_stmt_pre_sql := rtrim(v_LoadRec.lt_pre_sql);
        v_stmt_pre_sql := replace(v_stmt_pre_sql, CHR(10), ' ');
        v_stmt_pre_sql := replace(v_stmt_pre_sql, CHR(13), ' ');
        v_stmt_pre_sql := replace(v_stmt_pre_sql, '$OBJECT$', v_table_with_schema);
        v_stmt_pre_sql := replace(v_stmt_pre_sql, '$SCHEMA$', v_table_schema);

        -- Execute the statements individually based on the end-statement-indicator in the pre-sql statement
        -- Get the initial end location of the statement
        SELECT COALESCE(LENGTH(v_stmt_pre_sql),0) INTO v_end_location FROM DUAL;

        -- Get the end-of-statement indicator, defaults to <EOS>
        SELECT COALESCE(ta_text_3, '<EOS>') INTO v_delimiter FROM ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

        -- Loop through the override statement and execute each statement individually
        WHILE v_end_location > 0
        LOOP
           SELECT INSTR(v_stmt_pre_sql,v_delimiter, v_start_location) INTO v_end_location FROM DUAL;
           SELECT CASE
                  WHEN v_end_location > 0
                  THEN SUBSTR(v_stmt_pre_sql,v_start_location,v_end_location -v_start_location)
                  ELSE SUBSTR(v_stmt_pre_sql,v_start_location)
                  END  INTO v_statement FROM DUAL;

           IF TRIM(TRANSLATE(v_statement, chr(10) || chr(13) || chr(09), '   ')) IS NOT NULL Then
                BEGIN
                  EXECUTE IMMEDIATE v_statement;

                  v_MsgText := substr('Executed pre load sql. ' || v_statement, 1, 1023);
                  v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, NULL, NULL, p_task_id, p_job_id);

                  EXCEPTION WHEN OTHERS THEN COMMIT;

                  v_DbText := substr(SQLERRM, 1, 1023);
                  v_MsgText := 'Unhandled exception in pre - load sql';
                  v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText , p_task_id, p_job_id);

                  v_MsgText := substr(v_stmt_pre_sql, 1, 1023);
                  v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText , p_task_id, p_job_id);

                  p_return_msg := 'Unhandled exception in pre - load sql';
                  p_status_code := -2;
                  v_result := -2;

                  RETURN v_result;
                END;
            END IF;

            SELECT v_end_location + LENGTH(v_delimiter) INTO v_start_location  FROM DUAL;
        END LOOP;
    END IF;

    -- =====================================================
    -- L O A D     S T A T E M E N T
    --
    -- If a load statement then it overrides the load method
    -- and we will issue that statement to perform the load
    -- =====================================================
    IF v_LoadRec.lt_load_statement IS NOT NULL AND v_LoadRec.lt_type = 'D' THEN
        -- =====================================================
        -- Load using the load statement
        -- =====================================================
        v_step := 600;
        BEGIN
            -- replace any parameters with their current values
            v_where_clause := v_LoadRec.lt_load_statement;
            v_where_clause := replace(v_where_clause , '$OBJECT$', v_table_with_schema);
            v_where_clause := replace(v_where_clause , '$SCHEMA$', v_table_schema);
            v_spos := INSTR(v_where_clause, '$P');
            WHILE  v_spos > 0 LOOP
                v_spos := INSTR(v_where_clause, '$P');
                If v_spos > 0 Then
                    v_epos := INSTR(v_where_clause, '$', v_spos + 2);
                    If v_epos = 0 Then
                        v_spos := 0;
                    Else
                        v_work_select := SUBSTR(v_where_clause, v_spos + 2, v_epos - v_spos - 2);
                        v_parameter := WsParameterRead(v_work_select);
                        v_work_select := SUBSTR(v_where_clause, v_spos, v_epos - v_spos + 1);
                        v_where_clause := REPLACE(v_where_clause, v_work_select, v_parameter);
                    END IF;
                END IF;
            END LOOP;

            v_stmt_insert := v_where_clause;
            EXECUTE IMMEDIATE v_stmt_insert;
            v_row_count := SQL%ROWCOUNT;
            COMMIT;

            -- Need to commit or rollback otherwise oracle could still be
            -- doing a db link transaction and will disallow pragma autonomous
            -- and will fail the WsWrkAudit calls
            EXCEPTION WHEN OTHERS THEN COMMIT;

            v_DbText := substr(SQLERRM, 1, 1023);
            v_MsgText := 'Unhandled exception where executing load statement';
            v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);

            v_MsgText := substr(v_LoadRec.lt_load_statement, 1, 1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);

            IF LENGTH(v_stmt_insert) > 1023 THEN
                v_MsgText := substr(v_LoadRec.lt_load_statement, - 1023, 1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);
            END IF;

            p_return_msg := 'Unhandled exception where executing load statement';
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        v_step := 700;
        p_return_msg := v_row_count || ' rows loaded (using load statement override) into ' || v_table_with_schema;

        v_step := 800;
        p_status_code := 1;
        v_result := 1;
        RETURN v_result;
    END IF;

    -- =====================================================
    -- See what type of load this is
    -- D = database Load
    -- O = Odbc based Load
    -- S = Script based load
    -- F = File based load
    -- X = XML File based load
    -- E = External load
    -- =====================================================
    IF v_LoadRec.lt_type = 'D' THEN
        -- =====================================================
        -- Get the connection information
        -- =====================================================
        BEGIN
            v_step := 900;
            SELECT * INTO v_ConnectRec
            FROM ws_dbc_connect
            WHERE dc_obj_key = v_LoadRec.lt_connect_key;

            EXCEPTION WHEN OTHERS THEN
                v_MsgText := 'Connection not found for load table. A valid connection must exist.';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, SQLERRM, p_task_id, p_job_id);

                p_return_msg := 'Connection not found for load table';
                p_status_code := -2;
            RETURN - 2;
        END;

        -- =====================================================
        -- If we have a view name then define the remote view
        -- =====================================================
        IF v_LoadRec.lt_view_name IS NOT NULL AND v_ConnectRec.dc_dblink_id IS NOT NULL THEN
            v_step := 1000;
            v_view := 1;
            v_stmt_insert := 'CREATE OR REPLACE VIEW ';

            -- If v_table_schema is not null Then
            --  v_stmt_insert := v_stmt_insert || v_table_schema || '.';
            -- ElsIf v_schema_flag = 1 Then
            IF v_schema_flag = 1 THEN
                v_stmt_insert := v_stmt_insert || v_dss_schema || '.';
            END IF;

            v_stmt_insert := v_stmt_insert || v_LoadRec.lt_view_name;
            v_stmt_insert := v_stmt_insert || ' AS SELECT ';

            v_stmt_insert_cols0 := v_LoadRec.lt_view_columns;
            v_stmt_insert_cols1 := '';

            v_stmt_from_where := ' FROM ' || v_LoadRec.lt_view_table;

            IF v_LoadRec.lt_view_where is NOT NULL THEN
                -- replace any parameters with their current values
                v_where_clause := v_LoadRec.lt_view_where;

                v_spos := INSTR(v_where_clause, '$P');
                WHILE  v_spos > 0 LOOP
                    v_spos := INSTR(v_where_clause, '$P');
                    IF v_spos > 0 THEN
                        v_epos := INSTR(v_where_clause, '$', v_spos + 2);
                        IF v_epos = 0 THEN
                            v_spos := 0;
                        ELSE
                            v_work_insert := SUBSTR(v_where_clause, v_spos + 2, v_epos - v_spos - 2);
                            v_parameter := WsParameterRead(v_work_insert);
                            v_work_insert := SUBSTR(v_where_clause, v_spos, v_epos - v_spos + 1);
                            v_where_clause := REPLACE(v_where_clause, v_work_insert, v_parameter);
                        END IF;
                    END IF;
                END LOOP;
                v_stmt_insert_cols1 := ' ' || v_where_clause;
            END IF;

            -- =====================================================
            -- Call the view create
            -- If the view create fails then we will stop the run
            -- =====================================================
            BEGIN
                v_step := 1100;
                v_len_insert := LENGTH(v_stmt_insert);

                v_step := 1200;
                v_len_insert_cols := LENGTH(v_stmt_insert_cols0 || v_stmt_insert_cols1);
                v_len_from_where := LENGTH(v_stmt_from_where);

                v_step := 1300;
                v_len_total := v_len_insert + v_len_insert_cols + v_len_from_where;

                IF v_len_total < 4000 THEN
                    v_step := 1400;
                    v_stmt_insert := v_stmt_insert || v_stmt_insert_cols0 || v_stmt_from_where || v_stmt_insert_cols1;

                    v_step := 1500;
                    v_cursor := DBMS_SQL.OPEN_CURSOR;

                    v_step := 1600;
                    v_create := 'BEGIN dss_view_create@' || v_ConnectRec.dc_dblink_id || '(:p1); END;';

                    v_step := 1700;
                    DBMS_SQL.PARSE(v_cursor, v_create, 1);

                    v_step := 1800;
                    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', v_stmt_insert, 4000);

                    v_step := 1900;
                    v_result := DBMS_SQL.EXECUTE(v_cursor);

                    v_step := 2000;
                    DBMS_SQL.CLOSE_CURSOR(v_cursor);
                ELSE
                    v_step := 2100;
                    v_stmt_insert_cols2 := 'BEGIN dss_view_create@' || v_ConnectRec.dc_dblink_id || '(''';
                    v_stmt_insert_cols3 := '''); END;';

                    v_stmt_insert_cols0 := REPLACE(v_stmt_insert_cols0, '''', '''''');
                    v_stmt_from_where := REPLACE(v_stmt_from_where, '''', '''''');
                    v_stmt_insert_cols1 := REPLACE(v_stmt_insert_cols1, '''', '''''');

                    EXECUTE IMMEDIATE v_stmt_insert_cols2 || v_stmt_insert || v_stmt_insert_cols0 ||
                        v_stmt_from_where || v_stmt_insert_cols1 || v_stmt_insert_cols3;

                END IF;

                COMMIT;

                -- Need to commit or rollback otherwise oracle will still be
                -- doing the db link transaction and will disallow pragma autonomous
                -- and will fail the WsWrkAudit calls
                EXCEPTION WHEN OTHERS THEN COMMIT;

                v_DbText := substr(SQLERRM, 1, 1023);
                v_MsgText := substr(v_stmt_insert, 1, 1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);

                IF LENGTH(v_create) > 1023 THEN
                    v_MsgText := substr(v_stmt_insert, - 1023, 1023);
                    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                    v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);
                End If;

                IF SQLCODE = -904 THEN
                    p_return_msg := 'Invalid Column name in view. View failed to create';
                    v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, p_return_msg, SQLCODE, v_DbText, p_task_id, p_job_id);

                    v_view := 0;
                    p_status_code := -2;
                    v_result := -2;
                    RETURN v_result;
                ELSE
                    p_return_msg := 'Unhandled Exception in call to dss_view_create. View failed to create. Step ' || v_step;
                    v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, p_return_msg, SQLCODE, v_DbText, p_task_id, p_job_id);

                    v_view := 0;
                    p_status_code := -2;
                    v_result := -2;
                    RETURN v_result;
                END IF;
            END;
        END IF;

        -- =====================================================
        -- Build the load statement
        -- =====================================================

        v_step := 2200;
        v_stmt_insert := 'INSERT /* + APPEND */ INTO ' || v_table_with_schema;

        IF INSTR(UPPER(v_LoadRec.lt_load_options), 'DISTINCT;') > 0 THEN
            v_stmt_select := ' SELECT DISTINCT ';
        ELSE
            v_stmt_select := ' SELECT ';
        END IF;

        v_stmt_select_cols0 := '';
        v_stmt_select_cols1 := '';
        v_stmt_select_cols2 := '';
        v_stmt_select_cols3 := '';
        v_stmt_insert_cols0 := '';
        v_stmt_insert_cols1 := '';
        v_stmt_insert_cols2 := '';
        v_stmt_insert_cols3 := '';

        IF v_view = 0 THEN
            -- Transformation or Ordinary Load
            IF NVL(v_LoadRec.lt_transform_ind, 'N') = 'Y' THEN
                -- =====================================================
                -- Transformation
                -- =====================================================
                v_stmt_select_cols0 := '';
                v_stmt_insert_cols0 := '';
                v_MissingMsg := '';

                FOR v_ColRec in c_Load LOOP
                    v_step := 2300;
                    v_row := v_row + 1;
                    IF v_row > 1 THEN
                        v_stmt_select_cols0 := v_stmt_select_cols0 || ', ';
                        v_stmt_insert_cols0 := v_stmt_insert_cols0 || ', ';

                        -- RED-546 do param replace as we go as otherwise risk issue with
                        --       param replace adding > 500 characters in one bash
                        v_step := 2400;
                        v_spos := INSTR(v_stmt_select_cols0, '$P');
                        IF v_spos > 0 THEN
                            v_step := 2500;
                            v_stmt_select_cols0 := WsParameterReplace(v_stmt_select_cols0, 4000);
                        END IF;

                        v_spos := INSTR(v_stmt_insert_cols0, '$P');
                        IF v_spos > 0 THEN
                            v_step := 2500;
                            v_stmt_insert_cols0 := WsParameterReplace(v_stmt_insert_cols0, 4000);
                        END IF;

                        -- If we have nearly filled this statement then use another
                        IF LENGTH(v_stmt_select_cols0) > 3500 THEN
                            IF  v_stmt_select_cols1 IS NULL THEN
                                v_stmt_select_cols1 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            ElsIf v_stmt_select_cols2 IS NULL THEN
                                v_stmt_select_cols2 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            ElsIf v_stmt_select_cols3 IS NULL THEN
                                v_stmt_select_cols3 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            END IF;
                        END IF;

                        -- If we have nearly filled this statement then use another
                        IF LENGTH(v_stmt_insert_cols0) > 3500 THEN
                            IF  v_stmt_insert_cols1 IS NULL THEN
                                v_stmt_insert_cols1 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            ElsIf v_stmt_insert_cols2 IS NULL THEN
                                v_stmt_insert_cols2 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            ElsIf v_stmt_insert_cols3 IS NULL THEN
                                v_stmt_insert_cols3 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            END IF;
                        END IF;
                    END IF;

                    -- If we have non mandatory columns specified then check to ensure
                    -- each column exists in the source
                    v_col_found := 1;
                    IF nvl(v_LoadRec.lt_non_mandatory_ind, 'N') = 'Y' THEN
                        BEGIN
                            IF v_ColRec.lc_src_column IS NOT NULL AND v_ColRec.lc_src_table IS NOT NULL THEN
                                IF v_LoadRec.lt_source_schema is not NULL THEN
                                    v_sql := 'SELECT COUNT(*) FROM all_tab_columns';
                                ELSE
                                    v_sql := 'SELECT COUNT(*) FROM user_tab_columns';
                                END IF;

                                IF v_ConnectRec.dc_dblink_id is NOT NULL THEN
                                    v_sql := v_sql || '@' || v_ConnectRec.dc_dblink_id;
                                END IF;

                                v_sql := v_sql || ' WHERE table_name = UPPER(''' || v_ColRec.lc_src_table || ''')';
                                v_sql := v_sql || ' AND column_name = UPPER(''' || v_ColRec.lc_src_column || ''')';

                                IF v_LoadRec.lt_source_schema is not NULL THEN
                                    v_sql := v_sql || ' AND OWNER = UPPER(''' || v_LoadRec.lt_source_schema || ''')';
                                END IF;

                                EXECUTE IMMEDIATE v_sql INTO v_count;

                                IF v_count <> 1 THEN
                                    v_col_found := 0;
                                    IF v_MissingMsg is NULL THEN
                                        v_MissingMsg := 'The following column(s) were missing from the source system: ';
                                    ELSE
                                        v_MissingMsg := v_MissingMsg || ', ';
                                    END IF;
                                    v_MissingMsg := v_MissingMsg || v_ColRec.lc_src_table || '.' ||
                                    v_ColRec.lc_src_column;
                                END IF;
                            END IF; -- End of valid column name to check
                        EXCEPTION WHEN OTHERS THEN
                            v_col_found := 1;
                            v_MissingMsg := 'Error when checking for non mandatory columns ' || SQLERRM;
                            v_MissingBug := 1;
                        END;
                    END IF; -- End of mandatory check

                    -- End of column check

                    IF nvl(v_ColRec.lc_transform_type, 'Z') = 'D' AND v_ColRec.lc_transform_code is not NULL THEN
                        v_work_select := v_ColRec.lc_transform_code;
                        v_work_insert := v_ColRec.lc_col_name;

                        -- Get rid of any comments in the transform
                        v_t1pos := Instr(v_work_select, CHR(45) || CHR(45));
                        WHILE v_t1pos > 0 LOOP
                            v_t2pos := Instr(v_work_select, CHR(10), v_t1pos);
                            IF v_t2pos > 0 THEN
                                v_work2 := SUBSTR(v_work_select, 1, v_t1pos - 1);
                                v_work_select := v_work2 || SUBSTR(v_work_select, v_t2pos + 1, 9999);
                            ELSE
                                v_work_select := SUBSTR(v_work_select, 1, v_t1pos - 1);
                            END IF;
                            v_t1pos := Instr(v_work_select, CHR(45) || CHR(45));
                        END LOOP;

                        v_work_select := LTRIM(RTRIM(v_work_select));

                        IF v_col_found = 1 THEN
                            v_step := 2600;
                        ELSE
                            v_step := 2700;
                            v_sql := v_work_select;
                            v_tabcol := v_ColRec.lc_src_table || '.' || v_ColRec.lc_src_column;
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_tabcol := Upper(v_tabcol);
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_tabcol := Lower(v_tabcol);
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_tabcol := v_ColRec.lc_src_column;
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_tabcol := Upper(v_tabcol);
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_tabcol := Lower(v_tabcol);
                            v_sql := Replace(v_sql, v_tabcol, 'NULL');
                            v_work_select := v_sql;
                        END IF;

                        -- RED-546 do param replace as we go as otherwise risk issue with
                        --       param replace adding > 500 characters in one bash
                        v_step := 2800;
                        v_spos := INSTR(v_work_select, '$P');
                        IF v_spos > 0 THEN
                            v_step := 2900;
                            v_work_select := WsParameterReplace(v_work_select, 4000);
                        END IF;

                        v_spos := INSTR(v_work_insert, '$P');
                        IF v_spos > 0 THEN
                            v_step := 2900;
                            v_work_insert := WsParameterReplace(v_work_insert, 4000);
                        END IF;

                        -- RED-1346 Check append wont blow the sizing
                        -- If we have nearly filled this statement then use another
                        IF (LENGTH(v_stmt_select_cols0) + LENGTH(v_work_select)) > 3900 THEN
                            IF  v_stmt_select_cols1 IS NULL THEN
                                v_stmt_select_cols1 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            ELSIF v_stmt_select_cols2 IS NULL THEN
                                v_stmt_select_cols2 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            ELSIF v_stmt_select_cols3 IS NULL THEN
                                v_stmt_select_cols3 := v_stmt_select_cols0;
                                v_stmt_select_cols0 := '';
                            END IF;
                        END IF;

                        IF (LENGTH(v_stmt_insert_cols0) + LENGTH(v_work_insert)) > 3900 THEN
                            IF  v_stmt_insert_cols1 IS NULL THEN
                                v_stmt_insert_cols1 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            ELSIF v_stmt_insert_cols2 IS NULL THEN
                                v_stmt_insert_cols2 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            ELSIF v_stmt_insert_cols3 IS NULL THEN
                                v_stmt_insert_cols3 := v_stmt_insert_cols0;
                                v_stmt_insert_cols0 := '';
                            END IF;
                        END IF;

                        v_step := 3000;
                        v_stmt_select_cols0 := v_stmt_select_cols0 || v_work_select;
                        v_stmt_insert_cols0 := v_stmt_insert_cols0 || v_work_insert;

                    ELSIF v_ColRec.lc_src_column is not NULL THEN
                        IF v_col_found = 1 THEN
                            If v_ColRec.lc_src_table is not NULL THEN
                                v_stmt_select_cols0 := v_stmt_select_cols0 || v_ColRec.lc_src_table || '.';
                                -- don't add v_ColRec.lc_src_table to the insert columns
                            END IF;
                            v_stmt_select_cols0 := v_stmt_select_cols0 || v_ColRec.lc_src_column;
                            v_stmt_insert_cols0 := v_stmt_insert_cols0 || v_ColRec.lc_col_name;
                        ELSE
                            v_stmt_select_cols0 := v_stmt_select_cols0 || '''''';
                            v_stmt_insert_cols0 := v_stmt_insert_cols0 || v_ColRec.lc_col_name;
                        END IF;
                    ELSE
                        v_stmt_select_cols0 := v_stmt_select_cols0 || '''''';
                        v_stmt_insert_cols0 := v_stmt_insert_cols0 || v_ColRec.lc_col_name;
                    END IF;
                END LOOP;
            ELSE
                v_stmt_select_cols0 := v_LoadRec.lt_source_columns;
                v_stmt_insert_cols0 := '';
            END IF;

            v_stmt_from_where := ' FROM ';
            v_stmt_from_where := v_stmt_from_where || v_LoadRec.lt_from_table;

            IF v_LoadRec.lt_where_clause IS NOT NULL THEN
                -- replace any parameters with their current values
                v_where_clause := v_LoadRec.lt_where_clause;
                v_spos := INSTR(v_where_clause, '$P');
                WHILE  v_spos > 0 LOOP
                    v_spos := INSTR(v_where_clause, '$P');
                    IF v_spos > 0 THEN
                        v_epos := INSTR(v_where_clause, '$', v_spos + 2);
                        IF v_epos = 0 THEN
                            v_spos := 0;
                        ELSE
                            v_work_select := SUBSTR(v_where_clause, v_spos + 2, v_epos - v_spos - 2);
                            v_parameter := WsParameterRead(v_work_select);
                            v_work_select := SUBSTR(v_where_clause, v_spos, v_epos - v_spos + 1);
                            v_where_clause := REPLACE(v_where_clause, v_work_select, v_parameter);
                        END IF;
                    END IF;
                END LOOP;
                v_stmt_from_where := v_stmt_from_where || ' ' || v_where_clause;
            END IF;
        ELSE -- v_view <> 0
            v_stmt_insert := v_stmt_insert || ' * FROM ';
            v_stmt_insert := v_stmt_insert || v_LoadRec.lt_view_name;
            v_stmt_select_cols0 := '';
            v_stmt_insert_cols0 := '';
            v_stmt_from_where := '';
            IF v_ConnectRec.dc_dblink_id IS NOT NULL THEN
                v_stmt_insert := v_stmt_insert || '@' || v_ConnectRec.dc_dblink_id;
            END IF;
        END IF;

        -- =====================================================
        -- Record any missing columns
        -- =====================================================
        IF v_MissingMsg is not NULL THEN
            v_MsgText := substr(v_MissingMsg, 1, 1023);

            IF v_LoadRec.lt_missing_col_act = 'W' THEN
                v_MissingRet := 'W';
            ELSIF v_LoadRec.lt_missing_col_act = 'E' THEN
                v_MissingRet := 'E';
            ELSE
                v_MissingRet := 'I';
            END IF;

            IF v_MissingBug = 1 THEN
                v_MissingRet := 'W';
            END IF;

            v_result := WsWrkAudit(v_MissingRet, p_job_name, p_task_name, p_sequence, v_MsgText, NULL, NULL, p_task_id, p_job_id);
        END IF;

        -- =====================================================
        -- Replace any $JOB_SEQUENCE$
        -- =====================================================

        v_step := 3100;
        v_stmt_select := REPLACE(v_stmt_select, '$JOB_SEQUENCE$', p_sequence);
        v_stmt_insert := REPLACE(v_stmt_insert, '$JOB_SEQUENCE$', p_sequence);

        v_step := 3200;
        v_stmt_from_where := REPLACE(v_stmt_from_where, '$JOB_SEQUENCE$', p_sequence);

        v_step := 3300;
        v_stmt_select_cols0 := REPLACE(v_stmt_select_cols0, '$JOB_SEQUENCE$', p_sequence);
        v_stmt_insert_cols0 := REPLACE(v_stmt_insert_cols0, '$JOB_SEQUENCE$', p_sequence);

        v_step := 3400;
        v_stmt_select_cols1 := REPLACE(v_stmt_select_cols1, '$JOB_SEQUENCE$', p_sequence);
        v_stmt_insert_cols1 := REPLACE(v_stmt_insert_cols1, '$JOB_SEQUENCE$', p_sequence);

        v_step := 3500;
        v_stmt_select_cols2 := REPLACE(v_stmt_select_cols2, '$JOB_SEQUENCE$', p_sequence);
        v_stmt_insert_cols2 := REPLACE(v_stmt_insert_cols2, '$JOB_SEQUENCE$', p_sequence);

        v_step := 3600;
        v_stmt_select_cols3 := REPLACE(v_stmt_select_cols3, '$JOB_SEQUENCE$', p_sequence);
        v_stmt_insert_cols3 := REPLACE(v_stmt_insert_cols3, '$JOB_SEQUENCE$', p_sequence);

        -- =====================================================
        -- Replace any $P parameters
        -- =====================================================

        v_step := 3700;
        v_stmt_select := WsParameterReplace(v_stmt_select, 4000);
        v_stmt_insert := WsParameterReplace(v_stmt_insert, 4000);

        v_step := 3800;
        v_stmt_from_where := WsParameterReplace(v_stmt_from_where, 4000);

        v_step := 3900;
        v_stmt_select_cols0 := WsParameterReplace(v_stmt_select_cols0, 4000);
        v_stmt_insert_cols0 := WsParameterReplace(v_stmt_insert_cols0, 4000);

        v_step := 4000;
        v_stmt_select_cols1 := WsParameterReplace(v_stmt_select_cols1, 4000);
        v_stmt_insert_cols1 := WsParameterReplace(v_stmt_insert_cols1, 4000);

        v_step := 4100;
        v_stmt_select_cols2 := WsParameterReplace(v_stmt_select_cols2, 4000);
        v_stmt_insert_cols2 := WsParameterReplace(v_stmt_insert_cols2, 4000);

        v_step := 4200;
        v_stmt_select_cols3 := WsParameterReplace(v_stmt_select_cols3, 4000);
        v_stmt_insert_cols3 := WsParameterReplace(v_stmt_insert_cols3, 4000);

        -- =====================================================
        -- Perform the Load
        -- =====================================================
        BEGIN
            v_step := 4300;
            v_len_insert := LENGTH(v_stmt_insert);
            v_len_select := LENGTH(v_stmt_select);

            v_step := 4400;
            v_len_insert_cols := LENGTH(v_stmt_insert_cols0 || v_stmt_insert_cols1 || v_stmt_insert_cols2 || v_stmt_insert_cols3);
            v_len_select_cols := LENGTH(v_stmt_select_cols0 || v_stmt_select_cols1 || v_stmt_select_cols2 || v_stmt_select_cols3);
            v_len_from_where := LENGTH(v_stmt_from_where);

            v_step := 4500;
            v_len_total := v_len_insert + v_len_select + v_len_insert_cols + v_len_select_cols + v_len_from_where;

            IF v_len_total < 4000 THEN
                v_step := 4600;
                IF NVL(v_LoadRec.lt_transform_ind, 'N') = 'Y' THEN
                    v_stmt_insert :=
                        v_stmt_insert ||
                            ' (' || v_stmt_insert_cols1 || v_stmt_insert_cols2 || v_stmt_insert_cols3 || v_stmt_insert_cols0 || ') ' ||
                        v_stmt_select ||
                            v_stmt_select_cols1 || v_stmt_select_cols2 || v_stmt_select_cols3 || v_stmt_select_cols0 ||
                        v_stmt_from_where;
                ELSE
                    v_stmt_insert :=
                        v_stmt_insert || v_stmt_select ||
                            v_stmt_select_cols1 || v_stmt_select_cols2 || v_stmt_select_cols3 || v_stmt_select_cols0 ||
                        v_stmt_from_where;
                END IF;

                v_step := 4700;
                v_cursor := DBMS_SQL.OPEN_CURSOR;

                v_step := 4800;
                DBMS_SQL.PARSE(v_cursor, v_stmt_insert, 1);

                v_step := 4900;
                v_row_count := DBMS_SQL.EXECUTE(v_cursor);

                v_step := 5000;
                DBMS_SQL.CLOSE_CURSOR(v_cursor);
            ELSE
                v_step := 5100;
                IF NVL(v_LoadRec.lt_transform_ind, 'N') = 'Y' THEN
                    EXECUTE IMMEDIATE
                        v_stmt_insert ||
                            ' (' || v_stmt_insert_cols1 || v_stmt_insert_cols2 || v_stmt_insert_cols3 || v_stmt_insert_cols0 || ') ' ||
                        v_stmt_select ||
                            v_stmt_select_cols1 || v_stmt_select_cols2 || v_stmt_select_cols3 || v_stmt_select_cols0 ||
                        v_stmt_from_where;
                ELSE
                    EXECUTE IMMEDIATE
                        v_stmt_insert || v_stmt_select ||
                            v_stmt_select_cols1 || v_stmt_select_cols2 || v_stmt_select_cols3 || v_stmt_select_cols0 ||
                        v_stmt_from_where;
                END IF;
                v_row_count := SQL%ROWCOUNT;
            END IF;

            COMMIT;

            -- Need to commit or rollback otherwise oracle will still be
            -- doing the db link transaction and will disallow pragma autonomous
            -- and will fail the WsWrkAudit calls
            EXCEPTION WHEN OTHERS THEN COMMIT;

            v_DbText := substr(SQLERRM, 1, 1023);
            v_MsgText := 'Unhandled exception in load';
            v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);

            v_MsgText := substr(v_stmt_insert, 1, 1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);

            IF LENGTH(v_stmt_insert) > 1023 THEN
                v_MsgText := substr(v_stmt_insert, - 1023, 1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);
            END IF;

            IF SQLCODE = -6550 THEN
                v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                v_MsgText, SQLCODE, v_DbText, p_task_id, p_job_id);
            END IF;

            p_return_msg := 'Unhandled exception in ws_act_load load(8.4.1.0). ' || substr(v_DbText, 1, 950);
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;

        v_step := 5200;
        p_return_msg := v_row_count || ' rows loaded into ' || v_LoadRec.lt_table_name;

        v_step := 5300;
        IF v_view = 1 THEN
            v_stmt_insert := p_return_msg || ' ( via rview ' || v_loadRec.lt_view_name || ' )';
            p_return_msg := substr(v_stmt_insert, 1, 1023);
        END IF;
        v_step := 5400;
        p_status_code := 1;
        v_result := 1;

    -- **********************************
    -- File Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'F' THEN
        v_result := ws_act_host_script(p_sequence, p_obj_type, p_action, p_obj_key, p_job_name,
            p_task_name, p_job_id, p_task_id, p_return_msg, p_status_code);

        -- If script prepared okay then indicate to our caller that we want to
        -- run a script by returning a result of 2
        IF v_result = 1 THEN
            v_result := 2;
            p_status_code := 2;
        END IF;

    -- **********************************
    -- XML File Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'X' THEN
        v_result := ws_act_host_script(p_sequence, p_obj_type, p_action, p_obj_key, p_job_name,
            p_task_name, p_job_id, p_task_id, p_return_msg, p_status_code);

        -- If script prepared okay then indicate to our caller that we want to
        -- run a script by returning a result of 2
        IF v_result = 1 THEN
            v_result := 2;
            p_status_code := 2;
        END IF;

    -- **********************************
    -- Script Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'S' THEN
        v_result := ws_act_host_script(p_sequence, p_obj_type, p_action, p_obj_key, p_job_name,
            p_task_name, p_job_id, p_task_id, p_return_msg, p_status_code);

        -- If script prepared okay then indicate to our caller that we want to
        -- run a script by returning a result of 2
        IF v_result = 1 THEN
            v_result := 2;
            p_status_code := 2;
        END IF;

    -- **********************************
    -- ODBC Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'O' THEN
        -- run an ODBC load by returning a result of 3
        v_result := 3;
        p_status_code := 2;

    -- **********************************
    -- Native ODBC Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'N' THEN
        -- run a Native ODBC load by returning a result of 12
        v_result := 12;
        p_status_code := 2;

    -- **********************************
    -- Integration Services Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'I' THEN
        -- run a SSIS load by returning a result of 14
        v_result := 14;
        p_status_code := 2;

    -- **********************************
    -- Apache Sqoop Load
    --**********************************
    ElsIf v_LoadRec.lt_type = 'A' Then
        -- run an Apache Sqoop load by returning a result of 91
        p_return_msg := 'Apache Sqoop load';
        v_result := 91;
        p_status_code := 2;

    --**********************************
    -- External Load
    -- **********************************
    ELSIF v_LoadRec.lt_type = 'E' THEN
        p_return_msg := 'Externally loaded';
        p_status_code := 1;
        v_result := 1;

    -- **********************************
    -- Unsupported Load type
    -- **********************************
    ELSE
        v_MsgText := 'Unsupported Load Type ';
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, v_MsgText, NULL, NULL, p_task_id, p_job_id);

        p_return_msg := 'Unsupport load type in ws_act_load (8.4.1.0)';
        p_status_code := -2;
        v_result := -2;
    END IF;

    COMMIT;
    RETURN v_result;

    -- Need to commit or rollback otherwise oracle will still be
    -- doing the db link transaction and will disallow pragma autonomous
    -- and will fail the WsWrkAudit calls
    EXCEPTION WHEN OTHERS THEN COMMIT;

    v_MsgText := 'Unhandled Exception in ws_act_load (8.4.1.0). ' ||  ' Step ' || v_step;
    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence, v_MsgText, SQLCODE, SUBSTR(SQLERRM, 1, 1023), p_task_id, p_job_id);

    p_return_msg := 'Unhandled Exception in ws_act_load (8.4.1.0) step ' || v_step;
    p_status_code := - 3;
    RETURN - 3;

END ws_act_load;
 
_PROCEDURE_ Ws_Act_Pre_Drop 
-- Notes / History
--
-- WMR 30/08/2001 Version 0.3.0.6  Added support for Primary Keys
-- WMR 21/01/2002 Version 1.0.0.0  Added support for Partitioned indexes
-- WMR 24/06/2005 Version 4.1.2.11 include the schema name in the drop if flag set
-- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
--                                 Add call to wswrkerror for each index as drop/built
--                                 Corrected counts for when actually indexes dropped
-- HM  15/08/2014 Version 6.8.1.2  Added Schema support
-- HM  03/10/2017 Version 8.1.1.0  Added support for Source Mapping
-- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_pre_drop
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_pre_drop
    -- Description    : Drop any indexes specified as being dropped before an update occurs
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_obj_source_mapping    constant number := 69;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText                  varchar2(1024); -- Text in audit_trail
    v_step                     integer := 0;   -- return code
    v_result                   integer := 0;   -- return code
    v_stmt                     varchar2(1024);
    v_count                    integer := 0;
    v_part_count               integer := 0;
    v_schema_flag              integer := 0;
    v_satellite_ind            varchar2(1);
    v_dss_schema               varchar2(64);
    v_index_done               integer;       -- used to flag successful drop
    v_msg_result               integer := 0;  -- return code
    v_table_schema             varchar2(64);
    v_table_name               varchar2(64);
    v_table_with_schema        varchar2(150);
    v_index_name               varchar2(64);
    v_index_with_schema        varchar2(150);

    --=====================================================
    -- Cursor for all pre_drop indexes
    --=====================================================
    Cursor c_Index is
          Select * from ws_index_header
          Where ih_obj_key = p_obj_key
          And ih_pre_drop_flag = 'Y';

BEGIN

    v_step := 100;
    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';
    v_table_schema := '';
    v_index_name := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      v_step := 120;

      IF p_obj_type = v_ws_obj_source_mapping THEN
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        LEFT JOIN  ws_source_mapping_tab
        ON         ws_source_mapping_tab.smt_parent_obj_key = ws_obj_object.oo_obj_key
        WHERE      ws_source_mapping_tab.smt_source_mapping_key = p_obj_key
        ;
      ELSE
        SELECT     NVL(dt_schema, '')
                  ,oo_name
        INTO       v_table_schema
                  ,v_table_name
        FROM       ws_obj_object
        LEFT JOIN  ws_dbc_target
        ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
        WHERE      ws_obj_object.oo_obj_key = p_obj_key
        ;
      END IF;

    v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;
    --=====================================================
    -- Loop through all the indexes to drop
    -- More than likely there will not be any
    --=====================================================
    p_status_code := 1;
    p_return_msg := '';
    FOR v_IndRec in c_Index LOOP
        v_step := 300;
        v_index_name := v_IndRec.ih_index_name;

        v_index_with_schema := TRIM(v_table_schema);
        IF TRIM(v_index_with_schema ) IS NOT NULL THEN
           v_index_with_schema  := v_index_with_schema ||'.';
        END IF;

        v_index_with_schema := v_index_with_schema || v_index_name;

        Select count(1) into v_part_count
        from   all_tab_partitions
        Where  table_owner = upper(v_table_name)
        and    table_name  = upper(v_table_schema);

        v_step := 400;
        If v_IndRec.ih_unique = 'Y' And v_IndRec.ih_key_type = 'A'
                                    And v_part_count = 0 Then
            v_stmt := 'alter table '|| v_table_with_schema ||
                      ' drop constraint '||v_index_name;
        Else
            v_stmt := 'drop index '|| v_index_with_schema;
        End If;

        v_index_done := 1;
        -- Execute the drop
        v_step := 500;
        BEGIN
            Execute Immediate v_stmt;
        EXCEPTION
            WHEN OTHERS THEN
                If SQLCODE = -2443 Then
                    v_stmt := 'drop index ' || v_index_with_schema;
                    BEGIN
                        Execute Immediate v_stmt;
                    EXCEPTION
                        WHEN OTHERS THEN
                            v_index_done := 0;
                            v_MsgText := 'Index '||v_IndRec.ih_index_name||' does not exist';
                            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                              v_MsgText,NULL,NULL, p_task_id, p_job_id);
                    END;
                ElsIf SQLCODE = -1418 Then
                    v_index_done := 0;
                    p_return_msg := ' Index '||v_index_with_schema||' does not exist';
                    p_status_code := -1;
                    v_result := -1;
                Else
                    v_index_done := 0;
                    v_MsgText := 'Unhandled Exception in ws_act_pre_drop '|| v_ws_pro_version ||
                            ' Step ' ||v_step;
                    v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_return_msg := 'Unhandled Exception in ws_act_pre_drop '|| v_ws_pro_version || ' step ' ||v_step;
                    p_status_code := -3;
                    v_result := -3;
                End If;
        END;

        --=====================================================
        -- Put detail message
        --=====================================================
        v_step := 600;
        IF v_index_done = 1 THEN

          v_step := 700;

          v_MsgText := 'Index ' || v_index_with_schema || ' dropped';

          v_msg_result := WsWrkError(
             'I'
          ,  p_job_name
          ,  p_task_name
          ,  p_sequence
          ,  v_MsgText
          ,  NULL
          ,  NULL
          ,  p_task_id
          ,  p_job_id
          ,  NULL);

          v_count := v_count + 1;
        END IF;

        v_step := 800;
    END LOOP;

    v_step := 900;
    -- tell them how many indexes we dropped
    If v_count = 0 Then
       p_return_msg := 'No indexes to drop'||p_return_msg;
    ElsIf v_count = 1 Then
       p_return_msg := v_count||' index dropped'||p_return_msg;
    Else
       p_return_msg := v_count||' indexes dropped'||p_return_msg;
    End If;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_pre_drop '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_pre_drop '|| v_ws_pro_version || ' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_pre_drop;
 
_PROCEDURE_ Ws_Act_Post_Load 
-- Notes / History
--
-- WMR 22/01/2002 Version 1.0.0
-- WMR 01/12/2004 Version 4.1.1.2 Fixed large after load transformations > 4000 bytes long
-- AP  28/11/2011 Version 6.5.5.1 RED_2382 Support SQLBlock
-- AP  19/11/2014 Version 6.8.1.2 Schema Support
-- HM  03/05/2017 Version 6.9.1.0 RED-7969 Do not update DSS_LOAD_DATE if already set
-- BC  10/05/2017 Version 6.9.1.0 RED-8195 Fix select to get DSS_LOAD_DATE name to handle no data found
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_post_load
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name       :  Oracle
    -- Script Name     :  ws_act_post_load
    -- Description     :  Execute the post load procedure associated with
    --                                a load table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(50) := 'Ws_Act_Post_Load(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText                        varchar2(1024); -- Text in audit_trail
    v_after_msg                      varchar2(1024); -- Text from an after transformation
    v_step                           integer := 0;   -- return code
    v_result                         integer := 0;   -- return code
    v_cursor                         number;
    v_procedure_key                  number;
    v_procedure                      varchar2(64);
    v_procedure_type                 varchar2(1);
    v_stmt                           varchar2(4000);
    v_stmt2                          varchar2(4000);
    v_stmt3                          varchar2(4000);
    v_stmt4                          varchar2(4000);
    v_stmt5                          varchar2(4000);
    v_row_count                      integer := 0;
    v_row                            integer := 0;
    v_len                            integer := 0;
    v_len2                           integer := 0;
    v_len3                           integer := 0;
    v_len4                           integer := 0;

    v_LoadRec                        ws_load_tab%ROWTYPE;
    v_schema_flag                    integer := 0;
    v_satellite_ind                  varchar2(1);
    v_dss_schema                     varchar2(64);
    v_table_schema                   varchar2(64);
    v_table_name                     varchar2(64);
    v_table_with_schema              varchar2(150);
    v_dss_load_date_name             varchar2(255); -- Configured name for DSS_LOAD_DATE
    v_rn_a_ld_trans_on_nw_rcs_only   integer := 0;
    v_update_where                   varchar2(255);

    --=====================================================
    -- Cursor for all columns in the load table
    --=====================================================
    Cursor c_Load is
          Select * from ws_load_col
          Where lc_obj_key = p_obj_key
          And lc_transform_type = 'A'
          And lc_transform_code is not Null
          Order by lc_order;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    p_return_msg := '';
    v_step := 100;

    -- Lookup DSS_LOAD_DATE name
    BEGIN
      SELECT NVL(mn_name, 'dss_load_date')
      INTO   v_dss_load_date_name
      FROM   ws_meta_names
      WHERE  mn_object = 'dss_load_date';
    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_dss_load_date_name := 'dss_load_date';
    END;

    v_satellite_ind := '';
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      v_step := 120;

      SELECT     NVL(dt_schema, '')
                ,oo_name
      INTO       v_table_schema
                ,v_table_name
      FROM       ws_obj_object
      LEFT JOIN  ws_dbc_target
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = p_obj_key
      ;

    v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 130;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 140;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 150;

    v_table_schema := TRIM(v_table_schema);

    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;

    v_step := 200;
    --=====================================================
    -- First get the load table information
    --=====================================================
    select * into v_LoadRec
    from ws_load_tab
    where lt_obj_key = p_obj_key;

    v_step := 250;

    --=====================================================
    -- Perform any after load transformations
    --=====================================================
    If nvl(v_LoadRec.lt_transform_ind,'N') = 'Y' Or
       nvl(v_LoadRec.lt_type,'D') in ('F','S','E') Then
        --=====================================================
        -- Transformation
        --=====================================================
        v_stmt2 := '';
        v_stmt3 := '';
        v_stmt4 := '';
        v_stmt5 := '';
        v_step := 300;

        For v_ColRec in c_Load LOOP
            v_row := v_row + 1;
            If v_row > 1 Then
               v_stmt2 := v_stmt2||',';
            End If;
            -- If we have nearly filled this statement then use another

            If length(v_stmt2) + length(v_ColRec.lc_col_name) + length(' = ') + length(v_ColRec.lc_transform_code) > 4000 Then
                If  v_stmt3 is null OR v_stmt3 = '' Then
                    v_stmt3 := v_stmt2;
                    v_stmt2 := '';
                ElsIf v_stmt4 is null OR v_stmt4 = '' Then
                    v_stmt4 := v_stmt2;
                    v_stmt2 := '';
                ElsIf v_stmt5 is null OR v_stmt5 = '' Then
                    v_stmt5 := v_stmt2;
                    v_stmt2 := '';
                Else
                    p_return_msg := 'Maximum length (20000 chars) of transformation expressions exceeded for '  + p_task_name;

                    v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence, p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
                    p_status_code := -2;
                    v_result := -2;

                    RETURN -2;
                End If;
            End If;
            v_stmt2 := v_stmt2||v_ColRec.lc_col_name||' = ';
            v_stmt2 := v_stmt2||v_ColRec.lc_transform_code;

            IF v_ColRec.lc_col_name = v_dss_load_date_name THEN
                v_rn_a_ld_trans_on_nw_rcs_only := 1;
            END IF;
        END LOOP;

        v_step := 400;

        --=====================================================
        -- See if any columns needed an after transformation
        -- If we have any then do the update
        --=====================================================
        If length(v_stmt2) > 0 Then

            --=====================================================
            -- Perform the after transformation update
            --=====================================================
            BEGIN
                v_step := 500;
                v_stmt := 'UPDATE '||v_table_with_schema||' SET ';
                v_len  := length(v_stmt);
                v_step := 600;
                v_len2 := length(v_stmt2||v_stmt3||v_stmt4||v_stmt5);

                IF v_rn_a_ld_trans_on_nw_rcs_only = 1 THEN
                  v_update_where := ' WHERE ' || v_dss_load_date_name || ' IS NULL';
                  v_len3 := length(v_update_where);
                END IF;

                v_len4 := v_len + v_len2 + v_len3;

                If v_len4 < 4000 Then
                    v_step := 700;
                    v_stmt := v_stmt||v_stmt3||v_stmt2||v_update_where;
                    v_step := 800;
                    v_cursor := DBMS_SQL.OPEN_CURSOR;
                    v_step := 900;
                    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
                    v_step := 1000;
                    v_row_count := DBMS_SQL.EXECUTE(v_cursor);
                    v_step := 1100;
                    DBMS_SQL.CLOSE_CURSOR(v_cursor);
                Else
                    v_step := 1200;
                    Execute Immediate v_stmt||v_stmt3||v_stmt4||v_stmt5||v_stmt2||v_update_where;
                    v_row_count := SQL%ROWCOUNT;
                End If;

                COMMIT;

            EXCEPTION WHEN OTHERS THEN
                v_MsgText := 'Unhandled exception in after transformation';
                v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                v_MsgText := substr(v_stmt||v_stmt2,1,1023);
                v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                If length(v_stmt) > 256 Then
                    v_MsgText := substr(v_stmt||v_stmt2,-1023,1023);
                    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                End If;
                If SQLCODE = -6550 Then
                    v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
                    v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
                End If;
                p_return_msg := 'Unhandled exception in after transformation stage of Ws_Act_Post_Load';
                p_status_code := -2;
                v_result := -2;
                RETURN v_result;
            END;
            p_return_msg := v_row_count||' rows updated for '||v_table_with_schema||' ';
            v_after_msg := p_return_msg;
        End If; -- End of we have a transformation to perform
    End If; -- End of If setup for transformations

    v_step := 1300;

    --=====================================================
    -- Get the post load procedure if it exists
    --=====================================================
    BEGIN
        v_step := 1400;
        v_procedure_key := 0;
        Select lt_procedure_key into v_procedure_key
        From ws_load_tab
        Where lt_obj_key = p_obj_key;
    EXCEPTION WHEN OTHERS THEN
        v_step := 1500;
        If SQLCODE = 100 Then
            p_return_msg := p_return_msg||'No post load procedure defined';
            p_status_code := 1;
            RETURN 1;
        Else
            p_return_msg := 'Unable to acquire update procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        End If;
    END;

    v_step := 1600;

    If v_procedure_key <= 0
    Or v_procedure_key is NULL Then
        p_return_msg := p_return_msg||'No post load procedure defined';
        p_status_code := 1;
        RETURN 1;
    End If;


    --=====================================================
    -- Get the procedure name
    --=====================================================

    SELECT ph_name, NVL(ph_type,'P')
    INTO   v_procedure, v_procedure_type
    FROM   ws_pro_header
    WHERE  ph_obj_key = v_procedure_key;

    --=====================================================
    -- IF SQLBLOCK then return for calling
    --=====================================================

    v_step := 1700;

    IF v_procedure_type = 'B'
    THEN
      -- run a POST SQLBLOCK by returning a result of 17
      p_status_code := 17;
      v_result := 2;
      RETURN v_result;
    END IF;

    --=====================================================
    -- Bind the columns and execute
    --=====================================================
    v_step := 1800;
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_step := 1900;
    -- Build up our execute statement for the procedure
    v_stmt := 'BEGIN '|| v_procedure
     || '(:p1, :p2, :p3, :p4, :p5, :p6, :p7); END;';
    v_step := 2000;
    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
    v_step := 2100;

    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', p_sequence);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p2', p_job_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p3', p_task_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p4', p_job_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p5', p_task_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p6', p_return_msg,1024);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p7', p_status_code);
    v_step := 2200;

    --=====================================================
    -- Call the procedure
    --=====================================================
    BEGIN
        v_step := 2300;
        v_result := DBMS_SQL.EXECUTE(v_cursor);
        v_step := 2400;
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p6', p_return_msg);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p7', p_status_code);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
        p_return_msg := 'Unhandled Exception in call from ws_act_post_load to ' ||v_procedure;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
              p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_status_code := -3;
    END;

    COMMIT;
    p_return_msg := substr(v_after_msg||p_return_msg,1,1023);
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_post_load '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_post_load step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_post_load;
 
_PROCEDURE_ Ws_Act_Update 
-- Notes / History
--
-- WMR 23/09/2001                   added aggregate support
-- WMR 22/01/2002  Version 1.0.0
-- WMR 06/04/2007  Version 5.6.0.0  Added support for retro copy
-- AP  09/04/2008  Version 6.0.0.0  Added support for ODS/Normal
-- AP  31/12/2008  Version 6.0.2.3  Added support for View
-- AP  28/11/2011  Version 6.5.5.1  RED_2382 Support SQLBlock
-- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  03/10/2017  Version 8.1.1.0  Added support for Source Mapping
-- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_update
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_act_update
    -- Description         :    Execute the update procedure associated with
    --                                a table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;
    v_ws_obj_source_mapping    constant number := 69;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(1024);
    v_cursor          number;
    v_procedure_key   number;
    v_procedure       varchar2(64);
    v_procedure_type  varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    --=====================================================
    -- See what table we have and get the update procedure
    --=====================================================
    BEGIN
        v_step := 100;
        v_procedure_key := 0;
        If p_obj_type = v_ws_obj_dim Then
            Select dt_update_key into v_procedure_key
            From ws_dim_tab
            Where dt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_dim_view Then
            Select dt_update_key into v_procedure_key
            From ws_dim_tab
            Where dt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_view Then
            Select vt_update_key into v_procedure_key
            From ws_view_tab
            Where vt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_fact Then
            Select ft_update_key into v_procedure_key
            From ws_fact_tab
            Where ft_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_fact_kpi Then
            Select ft_update_key into v_procedure_key
            From ws_fact_tab
            Where ft_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_stage Then
            Select st_update_key into v_procedure_key
            From ws_stage_tab
            Where st_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_agg Then
            Select at_update_key into v_procedure_key
            From ws_agg_tab
            Where at_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_retro_copy Then
            Select rt_update_key into v_procedure_key
            From ws_retro_tab
            Where rt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_ods Then
            Select ot_update_key into v_procedure_key
            From ws_ods_tab
            Where ot_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_normal
        OR p_obj_type = v_ws_obj_hub
        OR p_obj_type = v_ws_obj_satellite
        OR p_obj_type = v_ws_obj_link
        OR p_obj_type = v_ws_obj_custom1
        OR p_obj_type = v_ws_obj_custom2
        Then
            Select nt_update_key into v_procedure_key
            From ws_normal_tab
            Where nt_obj_key = p_obj_key;
        ElsIf p_obj_type = v_ws_obj_source_mapping Then
            Select smt_update_key into v_procedure_key
            From ws_source_mapping_tab
            Where smt_source_mapping_key = p_obj_key;
        End If;
    EXCEPTION WHEN OTHERS THEN
        v_step := 200;
        If SQLCODE = 100 Then
            p_return_msg := 'Unable to acquire update procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_return_msg := 'Please check that an update procedure has been defined';
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        Else
            p_return_msg := 'Unable to acquire update procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        End If;
    END;

    v_step := 300;

    If v_procedure_key <= 0
    Or v_procedure_key is NULL Then
        v_MsgText := 'Update procedure not found for table '||p_task_name;
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                      v_MsgText,NULL,NULL, p_task_id, p_job_id);
        p_return_msg := 'Please check that an update procedure has been defined';
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Update procedure not found for table '||p_task_name;
        p_status_code := -2;
        v_result := -2;
        RETURN v_result;
    End If;

    --=====================================================
    -- Get the procedure name
    --=====================================================

    v_step := 400;

    SELECT ph_name, NVL(ph_type,'P')
    INTO   v_procedure, v_procedure_type
    FROM   ws_pro_header
    WHERE  ph_obj_key = v_procedure_key;

    --=====================================================
    -- IF SQLBLOCK then return for calling
    --=====================================================

    v_step := 500;
    IF v_procedure_type = 'B'
    THEN
      -- run a UPDATE SQLBLOCK by returning a result of 16
      p_status_code := 16;
      v_result := 2;
      RETURN v_result;
    END IF;

    --=====================================================
    -- Bind the columns and execute
    --=====================================================
    v_step := 600;
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_step := 700;
    -- Build up our execute statement for the procedure
    v_stmt := 'BEGIN '|| v_procedure
     || '(:p1, :p2, :p3, :p4, :p5, :p6, :p7); END;';
    v_step := 800;
    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
    v_step := 900;

    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', p_sequence);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p2', p_job_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p3', p_task_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p4', p_job_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p5', p_task_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p6', p_return_msg,1024);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p7', p_status_code);
    v_step := 1000;

    --=====================================================
    -- Call the procedure
    --=====================================================
    BEGIN
        v_step := 1100;
        v_result := DBMS_SQL.EXECUTE(v_cursor);
        v_step := 1200;
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p6', p_return_msg);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p7', p_status_code);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
        p_return_msg := 'Unhandled Exception in call to ' ||v_procedure;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
              p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_status_code := -3;
    END;

    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_update. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_update step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_update;
 
_PROCEDURE_ Ws_Act_Truncate 
-- Notes / History
--
-- WMR 01/03/2005     Version 4.1.1.3  Added the ability to truncate tables
-- WMR 24/06/2005     Version 4.1.2.11 include the schema name in the create if flag set
-- WMR 06/04/2007     Version 5.6.0.0  Added support for retro objects
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
-- HM  15/08/2014     Version 6.8.1.2  Added Schema support
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_truncate
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      : Oracle
    -- Script Name    : ws_act_truncate
    -- Description    : Truncate a table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_cursor          number;
    v_truncate        varchar2(4000);
    v_as              varchar2(2000);
    v_row             integer := 0;
    v_user_view       integer := 0;
    v_schema_flag     integer := 0;
    v_satellite_ind   varchar2(1);
    v_dss_schema      varchar2(64);
    v_table_schema    varchar2(64);
    v_table_name      varchar2(64);
    v_table_with_schema varchar2(150);

BEGIN
    v_step := 10;

   --=====================================================
    -- Handle all the table types
    --=====================================================
    --=====================================================
    -- L O A D
    --=====================================================
    If p_obj_type = v_ws_obj_load
    --=====================================================
    -- D I M E N S I O N
    --=====================================================
    OR p_obj_type = v_ws_obj_dim
    --=====================================================
    -- F A C T
    --=====================================================
    OR p_obj_type = v_ws_obj_fact
    OR p_obj_type = v_ws_obj_fact_kpi
    --=====================================================
    -- S T A G E
    --=====================================================
    OR p_obj_type = v_ws_obj_stage
    --=====================================================
    -- A G G R E G A T E
    --=====================================================
    OR p_obj_type = v_ws_obj_agg
    --=====================================================
    -- R E T R O     C O P Y
    --=====================================================
    OR p_obj_type = v_ws_obj_retro_copy
    --=====================================================
    -- O D S
    --=====================================================
    OR p_obj_type = v_ws_obj_ods
    --=====================================================
    -- N O R M A L
    --=====================================================
    OR p_obj_type = v_ws_obj_normal
    --=====================================================
    -- H U B
    --=====================================================
    OR p_obj_type = v_ws_obj_hub
    --=====================================================
    --S A T E L L I T E
    --=====================================================
    OR p_obj_type = v_ws_obj_satellite
    --=====================================================
    -- L I N K
    --=====================================================
    OR p_obj_type = v_ws_obj_link
    --=====================================================
    -- C U S T O M 1
    --=====================================================
    OR p_obj_type = v_ws_obj_custom1
    --=====================================================
    -- C U S T O M 2
    --=====================================================
    OR p_obj_type = v_ws_obj_custom2    Then
       v_step := 20;
    --=====================================================
    -- U N S U P P O R T E D
    --=====================================================
    Else
        v_MsgText := 'Unsupported object type '||p_obj_type;
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                          v_MsgText,NULL,NULL, p_task_id, p_job_id);
        p_return_msg := 'Unsupported object type '||p_obj_type||' in Ws_Act_Truncate';
        p_status_code := -2;
        RETURN -2;
    End If;

    --=====================================================
    -- See if we have the flag set for including schema
    --=====================================================

    v_satellite_ind := '';
    v_table_schema := '';

    -- needs to look up the schema from ws_dbc_target
    BEGIN
      SELECT     NVL(dt_schema, '')
                ,oo_name
      INTO       v_table_schema
                ,v_table_name
      FROM       ws_obj_object
      LEFT JOIN  ws_dbc_target
      ON         ws_dbc_target.dt_target_key = ws_obj_object.oo_target_key
      WHERE      ws_obj_object.oo_obj_key = p_obj_key
      ;
      v_table_schema := TRIM(v_table_schema);

    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_MsgText := 'Object could not be found- key:' || p_obj_key;
      v_result  := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                                  v_MsgText,NULL,NULL, p_task_id, p_job_id);
      p_return_msg  := 'Object could not be found';
      p_status_code := -2;
      RETURN -2;
    END;

    v_step := 110;
    -- if its not present.. then look to see if use the meta_dss_schema from ws_meta where
    -- meta_satellite_ind = 'A'
    IF TRIM(v_table_schema) IS NULL THEN

      SELECT meta_satellite_ind,
             TRIM(meta_dss_schema)
      INTO   v_satellite_ind,
             v_dss_schema
      FROM   ws_meta
      WHERE  rownum = 1;

      IF v_satellite_ind = 'A' THEN
        IF TRIM(v_dss_schema) IS NOT NULL THEN
          v_schema_flag := 1;
          v_table_schema := v_dss_schema;
        END IF;
      END IF;

      v_step := 120;
      -- If still not set then defaults to the current user
      IF TRIM(v_table_schema) IS NULL THEN
         SELECT user
         INTO   v_table_schema
         FROM   dual;
      END IF;

    End If;

    v_step := 130;

    v_table_schema := TRIM(v_table_schema);
    v_table_with_schema := TRIM(v_table_schema);
    IF TRIM(v_table_with_schema) IS NOT NULL THEN
       v_table_with_schema := v_table_with_schema ||'.';
    END IF;

    v_table_with_schema := v_table_with_schema || v_table_name;
    v_step := 140;


    --=====================================================
    -- Build the truncate string
    --=====================================================
    v_truncate := 'Truncate table '||v_table_with_schema;

    --=====================================================
    -- Execute the truncate statement
    --=====================================================
    BEGIN
      v_step := 150;
      v_cursor := DBMS_SQL.OPEN_CURSOR;
      v_step := 160;
      DBMS_SQL.PARSE(v_cursor, v_truncate, 1);
      v_step := 170;
      v_result := DBMS_SQL.EXECUTE(v_cursor);
      v_step := 180;
      COMMIT;
      DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
      v_MsgText := substr(v_truncate,1,1023);
      v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
      If SQLCODE = -1031 Then
         v_MsgText := 'Jobs run under the DBMS package, so need specific privileges';
         v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
      Else
         v_MsgText := 'Unhandled exception in truncate ';
         v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
      End If;

      p_return_msg := 'Unhandled exception in ws_act_truncate cursor step '||v_step;
      p_status_code := -2;
      v_result := -2;
      RETURN v_result;
    END;

   COMMIT;

   p_status_code := 1;
   p_return_msg := 'Table truncated '||v_table_with_schema;
   v_result := 1;

   COMMIT;
   RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_truncate. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_truncate ' || v_ws_pro_version || ' step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_truncate;
 
_PROCEDURE_ Ws_Act_Export 
-- Notes / History
--
-- JML 17/04/2007   Version 5.6.0.0
-- TA  21/05/2105   Version 6.8.3.4 RED-5063 Support SSIS Export
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_export
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_act_export
    -- Description         :    Exports an export object
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

   --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_DbText          varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(4000);

    v_ExportRec       ws_export_tab%ROWTYPE;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;

    --=====================================================
    -- First get the export table information
    --=====================================================
    select * into v_ExportRec
    from ws_export_tab
    where et_obj_key = p_obj_key;

    v_step := 20;

    --=====================================================
    -- Handle any pre-export action
    --=====================================================
    If v_ExportRec.et_pre_action = 'E' Then
        v_step := 40;
        v_stmt := rtrim(v_ExportRec.et_pre_sql);
        v_stmt := replace(v_stmt,chr(10),' ');
        v_stmt := replace(v_stmt,chr(13),' ');
        BEGIN
            execute immediate v_stmt;
            COMMIT;
            v_MsgText := substr('Executed pre export sql. '||v_stmt,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_MsgText,NULL,NULL, p_task_id, p_job_id);
        EXCEPTION WHEN OTHERS THEN
            COMMIT;
            v_DbText := substr(SQLERRM,1,1023);
            v_MsgText := 'Unhandled exception in pre-export sql';
            v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, v_DbText , p_task_id, p_job_id);
            v_MsgText := substr(v_stmt,1,1023);
            v_result := WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, v_DbText , p_task_id, p_job_id);
            p_return_msg := 'Unhandled exception in pre-export sql';
            p_status_code := -2;
            v_result := -2;
            RETURN v_result;
        END;
    End If;


    --=====================================================
    -- See what type of export this is
    -- S = Script based export
    -- F = File based export
    -- I = Integration Services export
    -- E = External export
    --=====================================================
    If v_ExportRec.et_type = 'F' Then
        v_result := ws_act_host_script(p_sequence,p_obj_type,p_action, p_obj_key,
                                    p_job_name, p_task_name, p_job_id, p_task_id,
                                    p_return_msg, p_status_code);
        -- If script prepared okay then indicate to our caller that we want to
        -- run a script by returning a result of 2
        If v_result = 1 Then
            v_result := 2;
            p_status_code := 2;
        End If;

    --**********************************
    -- Script export
    --**********************************
    ElsIf v_ExportRec.et_type = 'S' Then
        v_result := ws_act_host_script(p_sequence,p_obj_type,p_action,p_obj_key,
                                    p_job_name, p_task_name, p_job_id, p_task_id,
                                    p_return_msg, p_status_code);
        -- If script prepared okay then indicate to our caller that we want to
        -- run a script by returning a result of 2
        If v_result = 1 Then
            v_result := 2;
            p_status_code := 2;
        End If;


    --**********************************
    -- Integration Services export
    --**********************************
    ElsIf v_ExportRec.et_type = 'I' Then
        p_return_msg := 'Integration Services export';
        v_result := 14;
        p_status_code := 2;


        --**********************************
    -- External export
    --**********************************
    ElsIf v_ExportRec.et_type = 'E' Then
        p_return_msg := 'Externally exported';
        p_status_code := 1;
        v_result := 1;

    --**********************************
    -- Unsupported export type
    --**********************************
    Else
        v_MsgText := 'Unsupported export Type ';
        v_result := WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                          v_MsgText,NULL, NULL, p_task_id, p_job_id);
        p_return_msg := 'Unsupport export type in ws_act_export (5.5.0.17)';
        p_status_code := -2;
        v_result := -2;
    End If;


    COMMIT;
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        -- Need to commit or rollback otherwise oracle will still be
        -- doing the db link transaction and will disallow pragma autonomous
        -- and will fail the WsWrkAudit calls
        COMMIT;
        v_MsgText := 'Unhandled Exception in ws_act_export '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SUBSTR(SQLERRM,1,1023), p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_export (5.5.0.17) step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_export;
 
_PROCEDURE_ Ws_Act_Post_Export 
-- Notes / History
--
-- JML 17/04/2007   Version 5.6.0.0
-- AP  28/11/2011   Version 6.5.5.1  RED_2382 Support SQLBlock
-- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_act_post_export
    (
    p_sequence    IN  number,
    p_obj_type    IN  number,
    p_action      IN  number,
    p_obj_key     IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_return_msg  OUT varchar2,
    p_status_code OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name 	    :	Oracle
    -- Script Name 		:	ws_act_post_export
    -- Description 		:	Execute the post export procedure associated with
    --                                a export object
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 14;

    v_ws_act_drop              constant number := 0;
    v_ws_act_create            constant number := 1;
    v_ws_act_compile           constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_after_msg       varchar2(1024); -- Text from an after transformation
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_cursor          number;
    v_procedure_key   number;
    v_procedure       varchar2(64);
    v_procedure_type  varchar2(1);
    v_stmt            varchar2(4000);
    v_stmt2           varchar2(4000);
    v_stmt3           varchar2(4000);
    v_stmt4           varchar2(4000);
    v_stmt5           varchar2(4000);
    v_row_count       integer := 0;
    v_row             integer := 0;
    v_len             integer := 0;
    v_len2            integer := 0;
    v_len3            integer := 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    p_return_msg := '';
    v_step := 100;

    --=====================================================
    -- Get the post export procedure if it exists
    --=====================================================
    BEGIN
        v_step := 200;
        v_procedure_key := 0;
        Select et_procedure_key into v_procedure_key
        From ws_export_tab
        Where et_obj_key = p_obj_key;
    EXCEPTION WHEN OTHERS THEN
        v_step := 300;
        If SQLCODE = 100 Then
            p_return_msg := p_return_msg||'No post export procedure defined';
            p_status_code := 1;
            RETURN 1;
        Else
            p_return_msg := 'Unable to acquire update procedure for ' ||p_task_name;
            v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                  p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
            p_status_code := -3;
        End If;
    END;

    v_step := 400;

    If v_procedure_key <= 0
    Or v_procedure_key is NULL Then
        p_return_msg := p_return_msg||'No post export procedure defined';
        p_status_code := 1;
        RETURN 1;
    End If;


    --=====================================================
    -- Get the procedure name
    --=====================================================
    v_step := 500;
    SELECT ph_name, NVL(ph_type,'P')
    INTO   v_procedure, v_procedure_type
    FROM   ws_pro_header
    WHERE  ph_obj_key = v_procedure_key;


    --=====================================================
    -- IF SQLBLOCK then return for calling
    --=====================================================

    v_step := 600;

    IF v_procedure_type = 'B'
    THEN
      -- run a POST SQLBLOCK by returning a result of 17
      p_status_code := 17;
      v_result := 2;
      RETURN v_result;
    END IF;

    --=====================================================
    -- Bind the columns and execute
    --=====================================================
    v_step := 700;
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_step := 800;
    -- Build up our execute statement for the procedure
    v_stmt := 'BEGIN '|| v_procedure
     || '(:p1, :p2, :p3, :p4, :p5, :p6, :p7); END;';
    v_step := 900;
    DBMS_SQL.PARSE(v_cursor, v_stmt, 1);
    v_step := 1000;

    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p1', p_sequence);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p2', p_job_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p3', p_task_name,64);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p4', p_job_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p5', p_task_id);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p6', p_return_msg,1024);
    DBMS_SQL.BIND_VARIABLE(v_cursor, ':p7', p_status_code);
    v_step := 1100;

    --=====================================================
    -- Call the procedure
    --=====================================================
    BEGIN
        v_step := 1200;
        v_result := DBMS_SQL.EXECUTE(v_cursor);
        v_step := 1300;
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p6', p_return_msg);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':p7', p_status_code);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION WHEN OTHERS THEN
        p_return_msg := 'Unhandled Exception in call from ws_act_post_export to ' ||v_procedure;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
              p_return_msg,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_status_code := -3;
    END;

    COMMIT;
    p_return_msg := substr(v_after_msg||p_return_msg,1,1023);
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_act_post_export '|| v_ws_pro_version ||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_task_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := 'Unhandled Exception in ws_act_post_export step ' ||v_step;
        p_status_code := -3;
   RETURN -3;

END ws_act_post_export;
 
_PROCEDURE_ Ws_Job_Get_Start 
  -- Notes / History
  -- CJL 2008-06-01 Version 6.0.4.1  New procedure to replace multiple repeated code
  --                                 Does NOT do any updates
  --                                 For Custom schedules, allows for StartAfter to be later than StartBefore.  i.e. exclusion period in the middle of the day.
  -- CJL 2009-06-23                  Allow job_type = 'H' (same action as for 'S')
  -- CJL 2009-07-13                  Allow for Custom 0000 to 2400.
  --                                 Replace CASE clause by IF.. ELSE, to cater for dodgy old versions of Oracle.
  -- AP  2010-07-02 Version 6.1.1.1  RED_1670 - Change start before to 2400 if 0000 irrespective of start before
  -- BC  2015-04-23 Version 6.8.3.3  RED-4549 Change the daily, weekly, monthly, and annually calculations of the new 'start after' datetime
  --                                 to calculate from the old 'start after' datetime rather than from the current datetime.
  -- HM  2019-02-13 Version 8.4.1.0  Fix comments.

CREATE OR REPLACE FUNCTION Ws_Job_Get_Start
  (
  pi_job_key       IN  number
 ,po_start_after   OUT date
 ,po_job_status    OUT varchar
 ,po_result_code   OUT number
 ,po_return_msg    OUT varchar2
  )
    RETURN integer
    AUTHID CURRENT_USER
    IS
    PRAGMA AUTONOMOUS_TRANSACTION;

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      :    ORACLE
  -- Script Name    :    Ws_Job_Get_Start
  -- Description    :    Return next valid starttime for a job
  -- Author         :    Chris Lerew
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants Declared
  --=====================================================
  v_ws_pro_version           varchar2(50) := 'Ws_Job_Get_Start (8.4.1.0)';

  --=====================================================
  -- Control variables
  --=====================================================
  SQLCODE           integer := 0;   -- sql result code
  SQLSTATE          char(5);        -- sql result state
  v_step            integer;        -- return code
  v_sql_code        integer;        -- Database error code for Audit Trail
  v_sql_state       char(5);        -- Database error state

  --=====================================================
  -- Variables
  --=====================================================
  v_job_type           char(1);
  v_start_after        date;
  v_start_hh           integer;
  v_start_mi           integer;
  v_start_day          integer;
  v_cust_sa_hh         integer;
  v_cust_sa_mm         integer;
  v_cust_sb_hh         integer;
  v_cust_sb_mm         integer;
  v_cust_min           integer;
  v_cust_days          integer;
  -- Variables for Custom schedule calculations
  v_Cust_SDate         date; -- Proposed Start, Date part only
  v_Cust_SATime        date; -- Start After  time on proposed date
  v_Cust_SBTime        date; -- Start Before time on proposed date

  v_Cust_SDayOK        integer;   -- 0 = Not scheduled on this day
  v_more               integer;

  --=====================================================
  -- MAIN
  --=====================================================
BEGIN

  v_step := 100;
  -- Set assumption for failure
  po_result_code := -3;
  po_start_after := TO_DATE('9999-12-31', 'YYYY-MM-DD');
  po_job_status  := 'H';
  po_return_msg  := v_ws_pro_version || ' Failed to determine next start for job key '
                      || TO_CHAR(NVL(pi_job_key,0) );

  v_step := 200;
  v_job_type := NULL;
  SELECT wjc_type
       , wjc_start_hour
       , wjc_start_minute
       , wjc_start_day
       , NVL(wjc_cust_sa_hh,0)
       , NVL(wjc_cust_sa_mm,0)
       , NVL(wjc_cust_sb_hh,0)
       , NVL(wjc_cust_sb_mm,0)
       , NVL(wjc_cust_min,0)
       , NVL(wjc_cust_days,0)
       , wjc_start_after
  INTO   v_job_type
       , v_start_hh
       , v_start_mi
       , v_start_day
       , v_cust_sa_hh
       , v_cust_sa_mm
       , v_cust_sb_hh
       , v_cust_sb_mm
       , v_cust_min
       , v_cust_days
       , v_start_after
  FROM   ws_wrk_job_ctrl
  WHERE wjc_job_key = pi_job_key;

  IF v_job_type IS NULL
  THEN
    po_result_code := -2;
    po_return_msg  := v_ws_pro_version || ' Failed to find job for job key '
                        || TO_CHAR(NVL(pi_job_key,0) );

    RETURN po_result_code ;
  END IF;

  -- Assume custom range 0000 to 0000 is really 0000 to 2400 (all day)
  -- RED_1670
  -- IF  v_cust_sa_hh + v_cust_sa_mm = 0
  IF v_cust_sb_hh + v_cust_sb_mm = 0
    THEN v_cust_sb_hh := 24;
  END IF;

  v_step := 300;
  po_job_status := 'W'; -- Default for most job types

  IF v_job_type IN ('H','S') THEN -- Hold, or Once and Hold Schedule.

      v_start_after := SYSDATE;
      po_job_status := 'H';

  ELSIF v_job_type = 'D' THEN -- Daily
      WHILE v_start_after < SYSDATE LOOP -- play catch up in case we got behind
		  v_start_after := TRUNC(v_start_after) + 1 + (v_start_hh/24) + (v_start_mi/1440);
      END LOOP;

  ELSIF v_job_type = 'W' THEN -- Weekly
      WHILE v_start_after < SYSDATE LOOP -- play catch up in case we got behind
		  v_start_after := TRUNC(v_start_after) + 7 + (v_start_hh/24) + (v_start_mi/1440);
      END LOOP;

  ELSIF v_job_type = 'M' THEN -- Monthly
      WHILE v_start_after < SYSDATE LOOP -- play catch up in case we got behind
		  v_start_after := ADD_MONTHS(TRUNC(v_start_after) + (v_start_hh/24) + (v_start_mi/1440),1);
      END LOOP;

  ELSIF v_job_type = 'A' THEN -- Annually
      WHILE v_start_after < SYSDATE LOOP -- play catch up in case we got behind
		  v_start_after := ADD_MONTHS(TRUNC(v_start_after) + (v_start_hh/24) + (v_start_mi/1440),12);
      END LOOP;

  ELSIF v_job_type = 'C' THEN -- Custom

      v_step := 400;
      WHILE v_start_after < SYSDATE LOOP -- play catch up in case we got behind
        v_start_after := v_start_after -- Add first 'Interval' minutes for next proposed start date and time
                           + v_cust_min/1440;
      END LOOP;

      v_more := 1;

      v_step := 500;
      WHILE v_more = 1 AND v_start_after < SYSDATE + 8 LOOP -- Must be a mistake if we get over a week out with no match.
        v_step := v_step + 1;
        v_Cust_SDate  := TRUNC(v_start_after);

        v_Cust_SATime := v_Cust_SDate + (v_cust_sa_hh/24) + (v_cust_sa_mm/1440);
        v_Cust_SBTime := v_Cust_SDate + (v_cust_sb_hh/24) + (v_cust_sb_mm/1440);

        -- Check that the proposed Day is scheduled
        v_step := 600;
        IF    TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-01','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days,  1); --Monday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-02','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days,  2); --Tuesday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-03','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days,  4); --Wednesday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-04','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days,  8); --Thurday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-05','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days, 16); --Friday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-06','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days, 32); --Saturday
        ELSIF TO_CHAR(v_start_after, 'DY') = TO_CHAR(TO_DATE('1900-01-07','YYYY-MM-DD') ,'DY') THEN v_Cust_SDayOK := BITAND(v_cust_days, 64); --Sunday
        END IF;
        -- Day not scheduled, skip to next day
        IF v_Cust_SDayOK = 0
        THEN
          v_start_after := v_Cust_SDate + 1;

        -- Exclusion period spans midnight. e.g. allow start After 2am and start Before 10pm
        ELSIF v_Cust_SATime <= v_Cust_SBTime
        THEN
          v_step := 700;
          IF v_start_after < v_Cust_SATime      -- Prior to the Start After time
          THEN                                  -- so jump directly to the Start After time and exit loop
            v_start_after := v_Cust_SATime;
            v_more := 0;
          ELSIF v_start_after > v_Cust_SBTime   -- Past the Start Before time
          THEN
            v_start_after := v_Cust_SDate + 1;  -- so skip to the next day
          ELSE
            v_more := 0;                        -- Between valid start times so exit the loop
          END IF;

        -- Exclusion period does not span midnight. e.g. allow start Before 2am and start again After 3am
        ELSE  --v_Cust_SATime > v_Cust_SBTime
          v_step := 800;
          IF  v_start_after >  v_Cust_SBTime -- In exclusion period, jump to end of it, OK, exit loop
          AND v_start_after <  v_Cust_SATime
          THEN
            v_start_after := v_Cust_SATime;
            v_more := 0;
          ELSE                                -- Not in exclusion period, OK, so exit loop
            v_more := 0;
          END IF;
        END IF;

      END LOOP;

      IF v_start_after >= SYSDATE + 8
      THEN
        v_start_after := TO_DATE('9999-12-31', 'YYYY-MM-DD');
      END IF;
  -- end of v_job_Type = 'C'ustom

  ELSE -- Unknown schedule type.
      v_step := 900;
      po_return_msg := v_ws_pro_version || ' Unknown schedule type ' || NVL(v_job_type,'Null') || ', or unknown job key ' || TO_CHAR(NVL(pi_job_key,0));
      v_start_after := TO_DATE('9999-12-31', 'YYYY-MM-DD');
      po_result_code := -2;
      po_job_status  := 'H';
      RETURN po_result_code ;
  END IF; -- of CASE job_type

  po_start_after := v_start_after;
  po_result_code := 1;
  po_return_msg  := 'New job Start time assigned';
  RETURN po_result_code ;
  --=====================================================
  -- Exceptions
  --=====================================================
  EXCEPTION
  WHEN OTHERS THEN
     po_return_msg := v_ws_pro_version
                      || ' step '             || TO_CHAR(v_step)
                      || '  Unhandled SQL Error ';
      po_start_after := TO_DATE('9999-12-31', 'YYYY-MM-DD');
      po_job_status  := 'H';
      po_result_code := -3;
    RETURN po_result_code;

END;
 
_PROCEDURE_ Ws_Job_Wait 
-- Notes / History
--
-- Return codes expected by call form bkg.sln (windows) ws_job_wait_411.sh (*nix)
-- 1 if a job to process
-- 2 is no jobs
-- 5 is do a status update
-- 9 is shutdown
-- anything else is an error
--
-- WMR 05/11/2001              change status to pending when running a job
-- WMR 22/01/2002 Ver 1.0.0
-- WMR 05/04/2002 Ver 1.0.7    check for the appropriate scheduler type
-- WMR 04/04/2003 Ver 1.2.1.7  added for update to cursors so we do
--                             not get two schedulers starting the same job. Also
--                             now record the sequence number against control record.
-- WMR 22/07/2004              Add support for job dependencies
-- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to output messages
--                             Tidy up of return values to confirm to expected e.g. had a return 0
--                             Fix where had call to wswrkaudit with result going to
--                               v_result instead of v_status
--                             removed commits from within cursor loop so can release or
--                              update multiple jobs.. e.g. when updating to failed for job
--                              dependency will now carry on
--                             corrected for restart to only release based on the job /sequence
--                              previously only on job so if had 2 occurrences in job_run would
--                              change both to pending, but would only run the one, leaving one
--                              in a pending state. This situation arrived at when job dependencies
--                              fail for the job in successive runs.
--                             change to fail-abort any of same job currently flagged as failed
--                              when failing due to parent dependency failure
-- AP 07/05/2007 Ver 5.6.0.0   Check that dependent jobs completed okay.
-- CJL 2009-07-21 Ver 6.0.4.1  Replace Schedule calcs with WS_JOB_GET_START
-- BC  14/08/2015 Ver 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- BC  30/03/2016 Ver 6.8.5.4  RED-881  Support added to execute Failure Command when job fails due
--                              to job dependency failure.
--                                      Also moved the delete of a failed Once-only Job Control record
--                              down to occur last before exiting, so that a Job Run record can be
--                              added for the failed job.
-- RS  09/08/2016 Ver 6.8.6.2  RED-5624 Changed to report first failed job in parent-job dependency
-- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_wait
    (
    v_sched_type    IN   varchar2,
    v_sched_name    IN   varchar2,
    v_job_name      OUT  varchar2,
    v_task_name     OUT  varchar2,
    v_restart_flag  OUT  varchar2,
    v_thread        OUT  number,
    v_sequence      OUT  number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name               : Oracle
    -- Script Name             : ws_job_wait
    -- Description             : Look for a job to execute
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_status          integer := 0;   -- return code
    v_thread_count    integer := 0;   -- return code
    v_unix            integer := 0;   -- UNIX scheduler flag
    v_windows         integer := 0;   -- win scheduler flag
    v_poll            integer := 0;   -- status poll request
    v_shut            integer := 0;   -- shutdown request
    v_okay            integer := 0;
    v_parent_okay     integer := 0;
    v_fail_job        integer := 0;
    v_fail_cmd        integer := 0;
    v_waited          integer := 0;
    v_job_id          integer := 0;
    v_child_job_name  varchar2(64);
    v_parent_job_name varchar2(64);

    v_start_hh        integer;
    v_start_mi        integer;
    v_start_day       integer;
    v_cust_sa_hh      integer;
    v_cust_sa_mm      integer;
    v_cust_sb_hh      integer;
    v_cust_sb_mm      integer;
    v_cust_min        integer;
    v_cust_days       integer;
    v_cust_sb         integer;
    v_cust_sa         integer;
    v_more            integer;
    v_AddDays         integer;
    v_wait_HH         integer;
    v_wait_MM         integer;
    v_cur_HH          integer;
    v_cur_MM          integer;
    v_cur_HHMM        integer;
    v_cur_day_name    varchar(3);
    v_Monday          integer;
    v_Tuesday         integer;
    v_Wednesday       integer;
    v_Thursday        integer;
    v_Friday          integer;
    v_Saturday        integer;
    v_Sunday          integer;
    v_log_keep        integer;
    v_job_count       integer := 0;

    v_start_after     date;
    v_job_status      varchar2(1);
    v_status_code     integer;

    --=====================================================
    -- Cursor for all ready jobs
    --=====================================================
    Cursor c_Job is
      select wjc_name, wjc_max_threads, wjc_job_key, wjc_sequence,
             wjc_start_after, sysdate now_time, wjc_scheduler, wjc_type,
             wjc_start_hour, wjc_start_minute,
             nvl(wjc_cust_sa_hh,0) cust_sa_hh,
             nvl(wjc_cust_sa_mm,0) cust_sa_mm,
             nvl(wjc_cust_sb_hh,0) cust_sb_hh,
             nvl(wjc_cust_sb_mm,0) cust_sb_mm,
             nvl(wjc_cust_min,0)   cust_min,
             nvl(wjc_cust_days,0)  cust_days
      from ws_wrk_job_ctrl
      where wjc_status = 'W'
      and wjc_start_after < sysdate
      order by wjc_priority, wjc_start_after
      for update; -- This provides the suitable locking and also means cant commit within loop

    --=====================================================
    -- Cursor for all restarted jobs
    --=====================================================
    Cursor c_Restart is
      Select wjr_name, wjr_max_threads, wjr_sequence, wjr_job_key,
             wjr_scheduler
      from   ws_wrk_job_run
      where  wjr_status = 'W'
      for update;-- This provides the suitable locking and also means cant commit within loop

    --=====================================================
    -- Cursor to check for dependent jobs
    --=====================================================
    Cursor c_DepJob is
      select *
      from   ws_wrk_job_dependency
      where  wjd_child_job_name = v_child_job_name;

    --=====================================================
    -- Cursor to check dependent job status
    --=====================================================
    Cursor c_JobLog is
      select (sysdate-wjl_completed)*1440 minutes, wjl_status, wjl_completed
      from   ws_wrk_job_log
      where  wjl_name = v_parent_job_name
      and    wjl_status = 'C'
      order by wjl_completed desc;

    --=====================================================
    -- Cursor for all the task control records to be added to a failed job
    --=====================================================
    Cursor c_TaskCtrl is
      Select *
      from   ws_wrk_task_ctrl
      Where  wtc_job_key = v_job_id;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
    --=====================================================
    -- See what schedulers we have available
    --=====================================================
    BEGIN
        v_step := 100;
        Select count(1)
        into v_unix
        From ws_wrk_scheduler
        Where ws_type_ind = 'U'
        And ws_stop_date is null
        And to_number(sysdate-ws_active_date) < 0.01;
    EXCEPTION WHEN OTHERS THEN
        v_unix := 0;
    END;

    BEGIN
        v_step := 200;
        Select count(1)
        into v_windows
        From ws_wrk_scheduler
        Where ws_type_ind = 'W'
        And ws_stop_date is null
        And to_number(sysdate-ws_active_date) < 0.01;
    EXCEPTION WHEN OTHERS THEN
        v_windows := 0;
    END;

    --=====================================================
    -- See if a poll or shutdown requested for this scheduler
    --=====================================================
    BEGIN
        v_step := 300;
        Select ws_poll_flag, ws_shut_flag
        Into v_poll, v_shut
        From ws_wrk_scheduler
        Where ws_name = v_sched_name;
    EXCEPTION WHEN OTHERS THEN
        v_poll := 0;
        v_shut := 0;
    END;

    --=====================================================
    -- If a shutdown or poll then the appropriate codes
    -- to tell the scheduler to action
    --=====================================================
    v_result := 2; -- default to no job to run
    If v_poll <> 0 Or v_shut <> 0 Then

        v_step := 400;
        If v_poll <> 0 Then
            v_result := 5;
        End If;

        If v_shut <> 0 Then
            v_result := 9;
            BEGIN
                v_step := 500;
                Update ws_wrk_scheduler
                set ws_shut_flag = 0
                Where ws_name = v_sched_name;
            EXCEPTION WHEN OTHERS THEN
                v_shut := 1;
            END;
        End If;

        RETURN v_result;
    End If;

    --=====================================================
    -- Loop through the ready jobs
    -- We will just take the first one
    --=====================================================
    FOR v_JobRec in c_Job LOOP

        v_step := 600;
        --=====================================================
        -- See if we match on the requested scheduler
        --=====================================================
        If ( v_JobRec.wjc_scheduler is NULL )
        Or ( v_JobRec.wjc_scheduler = v_sched_type )
        Or ( v_JobRec.wjc_scheduler = v_sched_name )
        Or ( v_JobRec.wjc_scheduler = 'WANY' And v_sched_type = 'WIN' )
        Or ( v_JobRec.wjc_scheduler = 'UANY' And v_sched_type = 'UNIX' )
        Or ( v_JobRec.wjc_scheduler = 'WANY' And v_windows = 0 )
        Or ( v_JobRec.wjc_scheduler = 'UANY' And v_unix = 0 )
        Then
            v_step := 700;
            v_job_name := v_JobRec.wjc_name;
            v_task_name := 'NO+JOB';
            v_restart_flag := 'NEW';
            v_thread := v_JobRec.wjc_max_threads;
            v_okay := 1;

            --=====================================================
            -- See if the job has any job dependencies
            --=====================================================
            v_child_job_name := v_JobRec.wjc_name;
            v_fail_job := 0;
            v_fail_cmd := 0;
            v_waited := (sysdate - v_JobRec.wjc_start_after)*1440;

            FOR v_DepRec in c_DepJob LOOP
              v_step := 800;
              v_parent_job_name := v_DepRec.wjd_parent_job_name;
              v_parent_okay := 0;

              -- Loop through the logs for the parent job.
              -- If one has finished within our lookback period then all okay.
              FOR v_LogRec in c_JobLog LOOP
                v_step := 900;
                If (sysdate - v_LogRec.wjl_completed)*1440 < v_DepRec.wjd_first_check_lag then
                  v_parent_okay := 1;
                End If;
              END LOOP;

              -- If parent not okay then see if we are past our wait time
              -- limit. If not past the limit then keep waiting
              -- If the parent is not required and past the wait limit
              -- then we will accept it as okay else fail it
              If v_parent_okay = 0 Then
                v_step := 1000;
                If v_waited > v_DepRec.wjd_wait_interval Then
                  If v_DepRec.wjd_require_parent IN ('Y','F') Then
                    v_fail_job := 1;
                    v_okay := 0;
                    If v_DepRec.wjd_require_parent = 'F' Then
                      v_fail_cmd := 1;
                    End If;
                    EXIT; -- Stop here to report the first failed parent job
                  End If;
                Else
                  v_okay := 0;
                End If;
              End If;

            END LOOP;

            --=====================================================
            -- OKAY to RUN
            --=====================================================
            If v_okay = 1 Then
              v_step := 1100;
              Select ws_job_seq.nextval
              into v_sequence
              from sys.dual;

              -- Set the job to pending if we plan to run it
              Update ws_wrk_job_ctrl
              Set wjc_status = 'P',
                  wjc_sequence = v_sequence
              Where wjc_job_key = v_JobRec.wjc_job_key;

              v_result := 1;
              COMMIT;
              RETURN v_result;
            End If;

            --=====================================================
            -- JOB needs to be FAILED
            --=====================================================
            If v_fail_job = 1 Then

              v_step := 1200;
              Select ws_job_seq.nextval
              into v_sequence
              from sys.dual;

              v_job_id := v_JobRec.wjc_job_key;

               -- Now either modify or delete the control record
               -- and if required delete the task records
               -- If it is a once only job then delete it from job control
               -- If a once and hold then set its status to Hold
               -- In all other cases work out when it will next run
               -- and put it in a wait state.
               BEGIN
                 v_step := 1300;
                 -- The delete of the Once-only Job Control record
                 -- has been moved down to occur last before exiting, so that
                 -- a Job Run record can be added for this failed job.

                 --============= New code by Chris for ws_job_starttime ===================
                 If v_JobRec.wjc_type <> 'O' Then

                   -- Retrieve the next valid starttime for this job.
                   v_result := ws_job_get_start(v_job_id, v_start_after, v_job_status, v_status_code, v_MsgText);

                   IF v_result <> 1 THEN
                     v_result := WsWrkAudit('E',v_job_name, v_task_name, v_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
                   END IF;

                   -- Set new job status and starttime.
                   -- If in error, then correct values already passed back from Ws_Job_Starttime
                   UPDATE ws_wrk_job_ctrl
                   SET    wjc_status = v_job_status
                        , wjc_start_after = v_start_after
                   WHERE  wjc_job_key = v_job_id;

                 END IF;
                 --============= End of New code by Chris for ws_job_starttime ===================
                  -- removed this commit 5.1.0.1
                  --COMMIT;
               EXCEPTION WHEN OTHERS THEN
                    v_MsgText := 'Failure to re-appoint scheduled job ' || v_job_name;
                    --Ver 5.1.0.1 change to go to v_status not v_result
                    v_status := WsWrkAudit('E',v_job_name, v_job_name, v_sequence,
                                                      v_MsgText,SQLCODE,SQLERRM,0,v_job_id);
               END;

               -- 5.1.0.1
               -- CHECK if any JOBS already flagged failed and therefore need aborting
               -- normally processed in ws_job_exec if able to run
               BEGIN
                  select count(1)
                  into v_job_count
                  from ws_wrk_job_run
                  where wjr_job_key = v_job_id
                  and wjr_status = 'F';
               EXCEPTION WHEN OTHERS THEN
                  v_job_count := 0;
               END;

               If v_job_count <> 0 THEN

                  v_MsgText := 'Job '||v_job_name||' has a previously Failed (incomplete) sequence. Now Aborted';
                  v_status := WsWrkAudit('W',v_job_name,v_task_name, v_sequence,
                                                        v_MsgText,NULL,NULL,0,0);

                  -- Update the job run record to be completed (Failed-Aborted)
                  -- and set the completion date if it is null
                  -- Move the job run record to the log record
                  BEGIN
                     update ws_wrk_job_run
                     set wjr_status = 'G'
                     where wjr_job_key = v_job_id;

                     update ws_wrk_job_run
                     set wjr_completed = sysdate
                     where wjr_job_key = v_job_id
                     and wjr_completed is NULL;

                     insert into ws_wrk_job_log
                     select *
                     from ws_wrk_job_run
                     where wjr_job_key = v_job_id;

                     delete
                     from ws_wrk_job_run
                     where wjr_job_key = v_job_id;

                  EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Ws_Job_Wait'|| v_ws_pro_version ||' Job '||v_job_name||
                                  ' failed in xfer to aborted job to ws_wrk_job_log. '||
                                  ' No Action !!!';
                     v_status := WsWrkAudit('F',v_job_name,v_task_name, v_sequence,
                                                   v_MsgText,SQLCODE,SQLERRM,0,0);
                     v_result := -1;
                     RETURN v_result;
                  END;
                   -- Move the task run records to the log record
                  BEGIN
                     insert into ws_wrk_task_log
                     select *
                     from ws_wrk_task_run
                     where wtr_job_key = v_job_id;

                     delete
                     from ws_wrk_task_run
                     where wtr_job_key = v_job_id;

                  EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Ws_Job_Wait'|| v_ws_pro_version ||' Job '||v_job_name||
                                  ' failed in xfer of aborted jobs tasks to ws_wrk_task_log. '||
                                  ' No Action !!!';
                     v_status := WsWrkAudit('F',v_job_name,v_task_name, v_sequence,
                                                v_MsgText,SQLCODE,SQLERRM,0,0);
                     v_result := -1;
                     RETURN v_result;
                  END;
               END IF; -- old failed jobs to abort

               -- Create the failure Job record
               BEGIN
                      v_step := 2200;
                      Insert into ws_wrk_job_run (
                            wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
                            wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
                            wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
                            wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
                            wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler)
                      Select
                            wjc_job_key, v_sequence, 0, 'F', sysdate,
                            sysdate, sysdate, 0,0,
                            0,0,0,0,
                            0,wjc_chkp_count,0, wjc_name, wjc_user_key,
                            wjc_max_threads,wjc_publish_okay, wjc_publish_fail, wjc_scheduler
                      from ws_wrk_job_ctrl
                      where wjc_job_key = v_job_id;
                      -- removed this commit 5.1.0.1
                      --COMMIT;
               EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Ws_Job_Wait'|| v_ws_pro_version ||' Job '||v_job_name||
                                    ' unable to create failure record in ws_wrk_job_run table. ';
                       v_status := WsWrkAudit('F',v_job_name, v_job_name, v_sequence,
                                                               v_MsgText,SQLCODE,SQLERRM,0,v_job_id);
                       v_result := -1;
                       RETURN v_result;
               END;

               -- Create All the Task records.
               -- Loop through all the tasks and add them. Initial state is Held
               FOR v_TaskCtrlRec in c_TaskCtrl LOOP
                  BEGIN
                      v_step := 2300;
                      Insert into ws_wrk_task_run (
                              wtr_task_key, wtr_job_key, wtr_sequence, wtr_restart, wtr_run_status,
                              wtr_audit_status, wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
                              wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg, wtr_type,
                              wtr_abort_level, wtr_chkp_number, wtr_name,
                              wtr_obj_type, wtr_action_type,wtr_obj_key)
                      Values (
                              v_TaskCtrlRec.wtc_task_key,v_TaskCtrlRec.wtc_job_key,v_sequence,0,'H',
                              NULL,NULL,NULL,0,0,
                              0,0,0,'Failed dependency on job '||v_parent_job_name,v_TaskCtrlRec.wtc_type,
                              v_TaskCtrlRec.wtc_abort_level,v_TaskCtrlRec.wtc_chkp_number, v_TaskCtrlRec.wtc_name,
                              v_TaskCtrlRec.wtc_obj_type, v_TaskCtrlRec.wtc_action_type, v_TaskCtrlRec.wtc_obj_key
                      );
                      -- removed this commit 5.1.0.1
                      --COMMIT;
                   EXCEPTION WHEN OTHERS THEN
                      v_MsgText := 'Ws_Job_Wait'|| v_ws_pro_version ||' Job '||v_job_name||
                                   ' failed creating records in ws_wrk_task_run table. ';
                      v_status := WsWrkAudit('F',v_job_name, v_job_name, v_sequence,
                                                             v_MsgText,SQLCODE,SQLERRM,0,v_job_id);
                      v_result := -1;
                      RETURN v_result;
                   END;

               END LOOP;

               If v_JobRec.wjc_type = 'O' Then
                   v_step := 2350;
                   delete
                   from ws_wrk_job_ctrl
                   where wjc_job_key = v_JobRec.wjc_job_key;
                   -- removed this commit 5.1.0.1
                   --COMMIT;
                   delete
                   from ws_wrk_task_ctrl
                   where wtc_job_key = v_job_id;
               End If;

               -- Provide a failure message
               v_MsgText := 'Job '||v_job_name||' failed dependency on job '||v_parent_job_name;
               v_status := WsWrkAudit('F',v_job_name, v_job_name, v_sequence,
                                                             v_MsgText,NULL,NULL,0,v_job_id);

               --5.1.0.1 Changed from a return 0 to this valid return 2. Have to have this return due to the
               -- cursor being 'for update' which you cant fetch next after doing a commit
               COMMIT;
               v_result := 2;
               If v_fail_cmd = 1 Then
                 v_result := -98;
               End If;
               RETURN v_result;
            End If;

        End If;

    END LOOP;

    -- inserted commit here 5.1.0.1 after all records updated and outside loop due to cursor mode
    COMMIT;

    v_step := 2400;
    --=====================================================
    -- Loop through any potential restart jobs
    -- We will just take the first one
    --=====================================================
    FOR v_RunRec in c_Restart LOOP

        v_step := 2500;
        --=====================================================
        -- See if we match on the requested scheduler
        --=====================================================
        If ( v_RunRec.wjr_scheduler is NULL )
        Or ( v_RunRec.wjr_scheduler = v_sched_type )
        Or ( v_RunRec.wjr_scheduler = v_sched_name )
        Or ( v_RunRec.wjr_scheduler = 'WANY' And v_sched_type = 'WIN' )
        Or ( v_RunRec.wjr_scheduler = 'UANY' And v_sched_type = 'UNIX' )
        Or ( v_RunRec.wjr_scheduler = 'WANY' And v_windows = 0 )
        Or ( v_RunRec.wjr_scheduler = 'UANY' And v_unix = 0 )
        Then
            v_step := 2600;
            Select count(1) into v_thread_count
            from ws_wrk_job_thread
            where wjt_job_key = v_RunRec.wjr_job_key
            and wjt_sequence = v_RunRec.wjr_sequence;

            if v_thread_count = 0 Then
                v_job_name := v_RunRec.wjr_name;
                v_task_name := 'NO+JOB';
                v_restart_flag := 'RESTART';
                v_thread := v_RunRec.wjr_max_threads;
                v_sequence := v_RunRec.wjr_sequence;

                v_step := 2700;
                -- Set the job to pending if we plan to run it
                Update ws_wrk_job_run
                Set wjr_status = 'P'
                Where wjr_job_key = v_RunRec.wjr_job_key
                --Ver 5.1.0.1 added sequence criteria
                AND wjr_sequence = v_RunRec.wjr_sequence;

                v_result := 1;
                COMMIT;
                RETURN v_result;
            End If;
        End If;

    END LOOP;

    COMMIT;
    RETURN v_result;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_job_wait '|| v_ws_pro_version ||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', v_job_name, v_job_name, v_sequence,
                          v_MsgText,SQLCODE, SQLERRM, 0,0);
    v_job_name := substr(sqlerrm,1,63);
    RETURN -3;

END ws_job_wait;
 
_PROCEDURE_ Ws_Job_Check 
-- Notes / History
--
-- WMR 08/03/2002 Version 1.0.0
-- WMR 23/05/2002 Version 1.0.9   Restricted checking to only Unix jobs
-- WMR 29/07/2002 Version 1.2.1   Enhanced checking to U% jobs (was UNIX%)
-- WMR 01/03/2005 Version 4.1.1.3 Ignore all child jobs
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_check
    (
    v_job_count     OUT  number,
    v_pending_count OUT  number,
    v_job_list      OUT  varchar2,
    v_name_list     OUT  varchar2,
    v_seq_list      OUT  varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_job_check
    -- Description    :    Check that jobs are running okay
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_thread_count    integer := 0;   -- return code

    --===============================================================
    -- Cursor for all running jobs
    -- Note: wjr_chkp_count contains a parent job key if a child job
    --===============================================================
    Cursor c_Running is
        Select wjr_name, wjr_max_threads, wjr_sequence, wjr_job_key
        from ws_wrk_job_run
        where wjr_status in ('P','R')
        and NVL(wjr_chkp_count,0) = 0
        and upper(wjr_scheduler) like 'U%';

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
    --=====================================================
    -- Loop through the running jobs
    --=====================================================
    v_result := 2;
    v_job_count := 0;
    v_pending_count := 0;
    v_name_list := '';
    v_seq_list := '';
    v_job_list := '';

    FOR v_RunRec in c_Running LOOP
        v_job_count := v_job_count + 1;
        If v_job_count > 1 Then
           v_name_list := v_name_list||',';
           v_job_list := v_job_list||',';
           v_seq_list := v_seq_list||',';
        End If;

        v_name_list := v_name_list||v_RunRec.wjr_name;
        v_seq_list := v_seq_list||v_RunRec.wjr_sequence;
        v_job_list := v_job_list||v_RunRec.wjr_name||'_'||v_RunRec.wjr_sequence;

    END LOOP;


    COMMIT;
    RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_job_check. '||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', 'Ws Job Check', 'Ws Job Check', 0,
                          v_MsgText,SQLCODE, SQLERRM, 0,0);
    v_job_count := 0;
    RETURN -3;

END ws_job_check;
 
_PROCEDURE_ Ws_Job_Abort 
-- Notes / History
--
-- WMR 08/03/2002 Version 1.0.0
-- WMR 28/02/2005 Version 4.1.1.3 handle jobs within jobs
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_abort
    (
    v_job_name     IN   varchar2,
    v_job_sequence IN   number,
    v_job_msg      IN   varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :    Oracle
    -- Script Name    :    ws_job_abort
    -- Description    :    Abort a job in a running state. Scheduler
    --                      can't find the job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_stmt            varchar2(1024);
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_thread_count    integer := 0;   -- return code

    v_job_id          number := 0;
    v_row_count       number := 0;
    v_rec_count       number := 0;


    --=====================================================
    -- Cursor to find all active tasks
    --=====================================================
    Cursor c_Sid is
        Select wjt_sid, wjt_serial
        From ws_wrk_job_thread
--        Where wjt_job_key = v_job_id
        Where wjt_sequence = v_job_sequence;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
     -- Get the job key for the job name. There should be one and
     -- only one key. Otherwise a fatal problem.
     BEGIN
          select wjr_job_key into v_job_id
          from ws_wrk_job_run
          where rtrim(upper(wjr_name)) = rtrim(upper(v_job_name));
          v_rec_count := 1;
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 0;
     END;
     If v_rec_count <> 1 Then
         v_MsgText := 'Job '||v_job_name||' passed invalid job name to Ws_Job_Abort. '||
                                           v_rec_count||' such records exist. No Action !!!';
         v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
         RETURN -2;
     End If;
     -- Make sure we are already running (i.e. have a job_run record)
     -- Otherwise a fatal problem.
     BEGIN
          select count(1) into v_rec_count
          from ws_wrk_job_run
          where wjr_job_key = v_job_id
          and wjr_sequence = v_job_sequence;
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 0;
     END;
     If v_rec_count <> 1 Then
         v_MsgText := 'Job '||v_job_name||' sequence '||v_job_sequence||' not running. '||
                                           'Cannot abort. No Action !!!';
         v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
        RETURN -2;
     End If;

    -- Hold any sub job tasks
    --
     BEGIN
          update ws_wrk_task_run
          set wtr_run_status = 'H'
          where wtr_job_key in
          ( select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = v_job_id
            and wjr_sequence = v_job_sequence )
          and wtr_sequence = v_job_sequence
          and wtr_run_status = 'W';
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 1;
     END;

    -- Have the job id now hold any tasks not started
    --
     BEGIN
          update ws_wrk_task_run
          set wtr_run_status = 'H'
          where wtr_job_key = v_job_id
          and wtr_sequence = v_job_sequence
          and wtr_run_status = 'W';
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 0;
     END;
     If v_rec_count <> 1 Then
         v_MsgText := 'Job '||v_job_name||' sequence '||v_job_sequence||' not running. '||
                                           'Cannot abort. No Action !!!';
         v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
        RETURN -2;
     End If;

    -- Flag any sub jobs as failed
    --
     BEGIN
          update ws_wrk_job_run
          set wjr_status = 'F'
          where wjr_job_key in
          ( select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = v_job_id
            and wjr_sequence = v_job_sequence)
          and wjr_sequence = v_job_sequence;
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 1;
     END;

    -- Flag the job as failed
    --
     BEGIN
          update ws_wrk_job_run
          set wjr_status = 'F'
          where wjr_job_key = v_job_id
          and wjr_sequence = v_job_sequence;
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 0;
     END;
     If v_rec_count <> 1 Then
         v_MsgText := 'Job '||v_job_name||' sequence '||v_job_sequence||' not running. '||
                                           'Cannot abort. No Action !!!';
         v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
        RETURN -2;
     End If;

    -- Fail any running sub job tasks
    --
     BEGIN
          update ws_wrk_task_run
          set wtr_run_status = 'F'
          where wtr_job_key in
          ( select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = v_job_id
            and wjr_sequence = v_job_sequence )
          and wtr_sequence = v_job_sequence
          and wtr_run_status = 'R';
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 1;
     END;

    -- Fail any running tasks
    --
     BEGIN
          update ws_wrk_task_run
          set wtr_run_status = 'F'
          where wtr_job_key = v_job_id
          and wtr_sequence = v_job_sequence
          and wtr_run_status = 'R';
     EXCEPTION WHEN OTHERS THEN
          v_rec_count := 0;
     END;
     If v_rec_count <> 1 Then
         v_MsgText := 'Job '||v_job_name||' sequence '||v_job_sequence||' not running. '||
                                           'Cannot abort. No Action !!!';
         v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                                   v_MsgText,NULL,NULL,0,v_job_id);
        RETURN -2;
     End If;

    -- Kill any running processes
    --
    For v_SidRec in c_Sid LOOP
        If v_SidRec.wjt_sid <> 0 And v_SidRec.wjt_serial <> 0 Then
            BEGIN
                v_stmt := 'alter system kill session '''||
                          v_SidRec.wjt_sid||','||v_SidRec.wjt_serial||'''';
                execute immediate v_stmt;
            EXCEPTION WHEN OTHERS THEN
                v_stmt := '';
            END;
        End If;
    END LOOP;

    COMMIT;
    If v_job_msg is not NULL Then
        v_result := WsWrkAudit('E',v_job_name, v_job_name, v_job_sequence,
                                                v_job_msg,NULL,NULL,0,v_job_id);
    End If;
    v_MsgText := 'Job '||v_job_name||' sequence '||v_job_sequence||
                             ' Aborted. ';
    v_result := WsWrkAudit('F',v_job_name, v_job_name, v_job_sequence,
                                            v_MsgText,NULL,NULL,0,v_job_id);
    COMMIT;
    RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_job_abort (8.4.1.0). '||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', 'Ws Job Abort', 'Ws Job Abort', 0,
                          v_MsgText,SQLCODE, SQLERRM, 0,0);
    RETURN -3;

END ws_job_abort;
 
_PROCEDURE_ Ws_Job_Clear_Logs 
-- Notes / History
--
-- WMR 16/10/2003   Version 4.1.0.4
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_clear_logs
    (
    p_sequence     IN  number,
    p_job_name     IN  varchar2,
    p_task_name    IN  varchar2,
    p_job_id       IN  number,
    p_task_id      IN  number,
    p_job_to_clean IN  varchar2,
    p_log_keep     IN  number,
    p_return_code  OUT varchar2,
    p_return_msg   OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_clear_logs
    -- Description         :    Removes a set number of log files for a job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_job_sequence    integer;
    v_job_key         integer;
    v_job_status      varchar2(1);
    v_job_count       integer := 0;
    v_del_count       integer := 0;
    v_job_status      varchar2(1);

    --=====================================================
    -- Cursor for all job logs
    --=====================================================
    Cursor c_Logs is
          Select wjl_job_key, wjl_sequence
          from ws_wrk_job_log
          Where wjl_name = p_job_to_clean
          Order by wjl_sequence desc;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

  v_step := 10;
  -- If zero specified in logs to keep then return
  If p_log_keep < 0 Then
    p_return_code := 'W';
    p_return_msg := 'Job '|| p_job_to_clean ||' negative value passed in log keep count. No action.';
    RETURN 1;
  End If;

  --***********************************************************************
  -- Loop through all the logs in descending order skip over the first
  -- n that are to be kept
  --***********************************************************************
  FOR v_LogRec in c_Logs LOOP

    v_job_count := v_job_count + 1;

    If v_job_count > p_log_keep Then

      -- Have a log to delete so move the tasks, job, audit and error info

      -- Copy the audit info to archive
      INSERT INTO wx_wrk_audit_archive (
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
      SELECT
        wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
        wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
      FROM
        ws_wrk_audit_log
      WHERE wa_job_key = v_LogRec.wjl_job_key
      AND   wa_sequence = v_LogRec.wjl_sequence;

      v_del_count := v_del_count + 1;

      -- Delete the audit info
      DELETE FROM ws_wrk_audit_log
      WHERE wa_job_key = v_LogRec.wjl_job_key
      AND   wa_sequence = v_LogRec.wjl_sequence;

      -- Copy the detail info to archive
      INSERT INTO wx_wrk_error_archive (
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action )
      SELECT
        wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
        wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
        wd_severity, wd_action
      FROM
        ws_wrk_error_log
      WHERE wd_job_key = v_LogRec.wjl_job_key
      AND   wd_sequence = v_LogRec.wjl_sequence;

      v_del_count := v_del_count + 1;

      -- Delete the detail info
      DELETE FROM ws_wrk_error_log
      WHERE wd_job_key = v_LogRec.wjl_job_key
      AND   wd_sequence = v_LogRec.wjl_sequence;

      -- Delete the task log
      DELETE FROM ws_wrk_task_log
      WHERE wtl_job_key = v_LogRec.wjl_job_key
      AND   wtl_sequence = v_LogRec.wjl_sequence;

      -- Delete the job log
      DELETE FROM ws_wrk_job_log
      WHERE wjl_job_key = v_LogRec.wjl_job_key
      AND   wjl_sequence = v_LogRec.wjl_sequence;

    End If;

  END LOOP;

  COMMIT;

  p_return_code := 'S';
  p_return_msg := 'Job ' || p_job_to_clean || ' had ' ||
                     v_del_count || ' logs removed. ';

  RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'W';
        v_MsgText := 'Unhandled Exception in ws_job_clear_logs. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_clear_logs;
 
_PROCEDURE_ Ws_Maintain_Indexes 
-- Notes / History
--
-- V1.0.0.0 WMR 22/02/2002
-- V4.1.0.8 WMR 27/06/2004 Result should be 1 if okay, not 0
-- V4.1.0.8 WMR 23/07/2004 Added support for index tablespace definition
-- V8.4.1.0 HM  13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_maintain_indexes
    (
    p_sequence    IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_table_name  IN  varchar2,
    p_parameter   IN  varchar2,
    p_index_name  IN  varchar2,
    p_option      IN  varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name 	         	:	Oracle
    -- Script Name 		:	ws_maintain_indexes
    -- Description 		:	Drop or create one or a group of indexes
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_directive         constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_return_msg      varchar2(1024);
    v_obj_type        integer;
    v_obj_key         integer;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --=====================================================
    -- See if an index name has been specified
    -- and if so look up the object key for that index
    -- otherwise Look up the object key for our table
    -- If we cant find it then we have an error
    --=====================================================

    If p_index_name is not null Then
        v_specific_index := 1;
        BEGIN
            Select oo_obj_key, oo_type_key into v_obj_key, v_obj_type
            From ws_obj_object
            Where upper(oo_name) = upper(p_index_name);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Invalid index name '|| p_index_name||
                    ' in call to Ws_Maintain_Index';
            v_result := WsWrkAudit('E', p_job_name, p_job_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            RETURN -2;
        END;
    Else
        BEGIN
            Select oo_obj_key, oo_type_key into v_obj_key, v_obj_type
            From ws_obj_object
            Where upper(oo_name) = upper(p_table_name);
        EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Invalid table name '|| p_table_name||
                    ' in call to Ws_Maintain_Index';
            v_result := WsWrkAudit('E', p_job_name, p_job_name, p_sequence,
                              v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
            RETURN -2;
        END;
    End If;



    --=====================================================
    -- Process depending on the option selected.
    -- DROP, DROP ALL, BUILD, BUILD ALL
    --=====================================================
    If upper(p_option) = 'DROP' And v_obj_type = v_ws_obj_index Then
        v_status := Ws_Act_Drop(p_sequence,
                                v_obj_type,
                                v_ws_act_drop,
                                v_obj_key,
                                p_job_name,
                                p_task_name,
                                p_job_id,
                                p_task_id,
                                v_return_msg,
                                v_status_code);
    ElsIf upper(p_option) = 'DROP ALL' Then
        v_status := Ws_Act_Drop_All(p_sequence,
                                v_obj_type,
                                v_ws_act_drop,
                                v_obj_key,
                                p_job_name,
                                p_task_name,
                                p_job_id,
                                p_task_id,
                                v_return_msg,
                                v_status_code);
    ElsIf upper(p_option) = 'PRE DROP' Then
        v_status := Ws_Act_Pre_Drop(p_sequence,
                                v_obj_type,
                                v_ws_act_drop,
                                v_obj_key,
                                p_job_name,
                                p_task_name,
                                p_job_id,
                                p_task_id,
                                v_return_msg,
                                v_status_code);
    ElsIf upper(p_option) = 'BUILD' Then
        v_status := Ws_Act_Build(p_sequence,
                                v_obj_type,
                                v_ws_act_drop,
                                v_obj_key,
                                p_job_name,
                                p_task_name,
                                p_job_id,
                                p_task_id,
                                p_parameter,
                                v_return_msg,
                                v_status_code);
    ElsIf upper(p_option) = 'BUILD ALL' Then
        v_status := Ws_Act_Build_All(p_sequence,
                                v_obj_type,
                                v_ws_act_drop,
                                v_obj_key,
                                p_job_name,
                                p_task_name,
                                p_job_id,
                                p_task_id,
                                p_parameter,
                                v_return_msg,
                                v_status_code);
    Else
        v_MsgText := 'Invalid option '|| p_option||
                ' in call to Ws_Maintain_Index. '||
                'Valid options are DROP (index specified) , DROP ALL, PRE DROP, BUILD, and BUILD ALL';
        v_result := WsWrkAudit('E', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        RETURN -2;
    End If;

    If v_status_code < 1 Then
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
                          v_return_msg,NULL,NULL, p_task_id, p_job_id);
--    Else
--        v_result := WsWrkAudit('I', p_job_name, p_job_name, p_sequence,
--                          v_return_msg,NULL,NULL, p_task_id, p_job_id);
    End If;

    COMMIT;
    RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in ws_maintain_indexes. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
       RETURN -3;

END ws_maintain_indexes;
 
_PROCEDURE_ Ws_Job_restart 
-- Notes / History
--
-- V1.0.6.0 WMR 20/03/2002
-- V6.8.4.3 BC  14/08/2015 RED-5520 Replaced occurrences of the != SQL operator with <>
-- V8.4.1.0 HM  13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_restart
    (
    p_sequence    IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_restart_job IN  varchar2,
    p_return_code OUT varchar2,
    p_return_msg  OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_restart
    -- Description         :    Restarts a scheduled job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;  -- return code
    v_result          integer := 0;  -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_msg             varchar2(4000);
    v_job_sequence    integer;
    v_job_key         integer;
    v_job_status      varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --***********************************************************************
    -- First see if the job name specified is in a failed state
    -- If not in a failed state then report if running, on hold, or not present
    --***********************************************************************
    BEGIN
        Select wjr_job_key, wjr_sequence, wjr_status
        Into v_job_key, v_job_sequence, v_job_status
        From ws_wrk_job_run
        Where wjr_name = p_restart_job;
    EXCEPTION WHEN OTHERS THEN
        v_job_key := 0;
    END;

    v_step := 20;
    --***********************************************************************
    -- If not running exit with that information
    --***********************************************************************
    If nvl(v_job_key,0) = 0 Then
        p_return_msg := 'Job '||p_restart_job||' is not in a running or Failed state. Cannot restart';
        p_return_code := 'N';
        return -1;
    End If;

    v_step := 30;
    --***********************************************************************
    -- If running then no need to restart
    --***********************************************************************
    If v_job_status = 'R' Then
        p_return_msg := 'Job '||p_restart_job||' is currently Running. Cannot restart';
        p_return_code := 'R';
        return -1;
    End If;

    v_step := 40;
    --***********************************************************************
    -- If not failed then no need to restart
    --***********************************************************************
    If v_job_status <> 'F' And v_job_status <> 'H' Then
        p_return_msg := 'Job '||p_restart_job||' is currently in state '||v_job_status||'. Cannot restart';
        p_return_code := 'U';
        return -2;
    End If;

    v_step := 50;
    --***********************************************************************
    -- First remove any threads that failed and didn't clean up
    -- the restart won't work if it thinks threads are still active
    --***********************************************************************
    BEGIN
        Delete from ws_wrk_job_thread
        Where wjt_job_key = v_job_key
        And wjt_sequence = v_job_sequence;
        Commit;
    EXCEPTION WHEN OTHERS THEN
        v_step := 51;
    END;


    v_step := 60;
    --***********************************************************************
    -- Set the flag to indicate that the job is waiting so the
    -- scheduler will restart it
    --***********************************************************************
    BEGIN
        Update ws_wrk_job_run
        Set wjr_status = 'W'
        Where wjr_job_key = v_job_key
        And wjr_sequence = v_job_sequence
        And wjr_status in ('H','F');

        Commit;

        p_return_code := 'S';
        p_return_msg := 'Job '||p_restart_job||' sequence '||v_job_sequence||' restarted.';
        RETURN 1;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to restart Job '||p_restart_job||' sequence '||v_job_sequence||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        RETURN -2;
    END;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'F';
        v_MsgText := 'Unhandled Exception in ws_job_restart. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_restart;
 
_PROCEDURE_ Ws_Sched_Status 
-- Notes / History
--
-- WMR 05/04/2002 Version 1.0.7
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_sched_status
    (
    v_action          IN varchar2,
    v_sched_type      IN varchar2,
    v_sched_name      IN varchar2,
    v_sched_host      IN varchar2,
    v_sched_msg       IN varchar2,
    v_sched_username  IN varchar2,
    v_sched_interval  IN number,
    v_sched_version   IN number,
    v_sched_job_count IN number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_sched_status
    -- Description         :    Reports a schedulers status
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_found           integer := 0;   -- return code
    v_stop_date       date;

    v_SchedRec        ws_wrk_scheduler%ROWTYPE;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    --=====================================================
    -- Read in any existing record for this scheduler.
    --=====================================================
    BEGIN
        v_step := 10;
        Select * into v_SchedRec
        From ws_wrk_scheduler
        Where ws_name = v_sched_name;

        v_found := 1;

    EXCEPTION WHEN OTHERS THEN
        v_found := 0;
    END;


    --=====================================================
    -- See what our action is
    --=====================================================
    v_step := 15;
    If v_action = 'START' Then
       v_stop_date := NULL;
    ElsIf v_Action = 'STOP' Then
       v_stop_date := sysdate;
    Else
       v_stop_date := NULL;
    End If;

    --=====================================================
    -- If the scheduler record did not exist then create it
    --=====================================================
    If v_found = 0 Then
        v_step := 20;
        Insert into ws_wrk_scheduler (
            ws_type_ind,
            ws_name,
            ws_host,
            ws_username,
            ws_start_date,
            ws_active_date,
            ws_stop_date,
            ws_stop_msg,
            ws_job_count,
            ws_interval,
            ws_version,
            ws_poll_flag,
            ws_shut_flag
            ) values (
            upper(substr(v_sched_type,1,1)),
            v_sched_name,
            v_sched_host,
            v_sched_username,
            sysdate,
            sysdate,
            v_stop_date,
            v_sched_msg,
            NULL,
            v_sched_interval,
            v_sched_version,
            0,
            0
            );
        COMMIT;
        v_result := 1;

    --=====================================================
    -- Scheduler record exists.
    -- See if we are updating the active time or are
    -- a new iteration for this scheduler
    --=====================================================
    Else
        v_step := 30;
        --=====================================================
        -- If we have a stop date or more than .01 of a day (14.4 minutes)
        -- since the last active date then assume a new version
        --=====================================================
        If v_SchedRec.ws_stop_date is NOT NULL
        Or v_SchedRec.ws_active_date < sysdate-.01 Then
            v_step := 40;
            Update ws_wrk_scheduler Set
                ws_stop_date = v_stop_date,
                ws_stop_msg = v_sched_msg,
                ws_start_date = sysdate,
                ws_active_date = sysdate,
                ws_type_ind = upper(substr(v_sched_type,1,1)),
                ws_host = v_sched_host,
                ws_username = v_sched_username,
                ws_version = v_sched_version,
                ws_job_count = 0,
                ws_interval = v_sched_interval,
                ws_poll_flag = 0,
                ws_shut_flag = 0
            Where ws_name = v_sched_name;
            COMMIT;
            v_result := 1;
        Else
           Update ws_wrk_scheduler Set
                ws_stop_date = v_stop_date,
                ws_stop_msg = v_sched_msg,
                ws_active_date = sysdate,
                ws_type_ind = upper(substr(v_sched_type,1,1)),
                ws_host = v_sched_host,
                ws_username = v_sched_username,
                ws_version = v_sched_version,
                ws_job_count = 0,
                ws_interval = v_sched_interval,
                ws_poll_flag = 0
            Where ws_name = v_sched_name;
            COMMIT;
            v_result := 1;
        End If;
    End If;

    COMMIT;
    RETURN v_result;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_sched_status. '||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', 'Ws_Sched_Status','Ws_Sched_Status', 0,
                          v_MsgText,SQLCODE, SQLERRM, 0,0);
    RETURN -3;

END ws_sched_status;
 
_PROCEDURE_ Ws_Api_Glossary 
-- Notes / History:
--
-- ============================================================================
-- Calling:
-- v_result := Ws_Api_Glossary(v_object_name, v_term, v_comments, v_option);
-- ============================================================================
-- WMR 25/06/2002  Version 1.2.0
-- HM  13/02/2019  Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION Ws_Api_Glossary (
    v_object_name      IN    varchar2,
    v_term             IN    varchar2,
    v_comments         IN    varchar2,
    v_option           IN    varchar2
    )
    RETURN varchar2
    AUTHID CURRENT_USER
    IS

    v_result           varchar2(1024);

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ============================================================================
    -- DBMS Name      :   Oracle
    -- Script Name    :   Ws_Api_Glossary.sql
    -- Description    :   Add elements to the ws_doc_glossary table
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

BEGIN
    -- =========================================================================
    -- Options are to insert or delete
    -- =========================================================================
    If upper(v_option) = 'ADD' Then
        Insert into ws_doc_glossary ( dg_object_name, dg_term, dg_comments )
        Values ( substr(v_object_name,1,64), substr(v_term,1,256),
		substr(v_comments,1,4000));
        v_result := v_object_name||' element inserted';
    ElsIf upper(v_option) = 'DELETE' Then
        Delete from ws_doc_glossary
        Where dg_object_name = substr(v_object_name,1,64)
        And dg_term = substr(v_term,1,256);
        v_result := v_object_name||' element deleted';
    Else
        v_result := 'Invalid option '||v_option||'. Valid options are ADD or DELETE';
    End If;

    Commit;

    Return v_result;

EXCEPTION
    WHEN OTHERS Then
	v_result := 'Unexpected error '||SQLERRM;
	Return v_result;
END Ws_Api_Glossary;
 
_PROCEDURE_ Ws_Sec_Maintain_User 
-- Notes / History
--
-- V1.2.1.2 WMR 25/09/2002
-- V6.8.4.3 BC  14/08/2015 RED-5520 Replaced occurrences of the != SQL operator with <>
-- V8.4.1.0 HM  13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function Ws_Sec_Maintain_User
    (
    p_option      IN  varchar2,
    p_user        IN  varchar2,
    p_role_rule   IN  varchar2,
    p_return_msg  OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    Ws_Sec_Maintain_User
    -- Description         :    Maintain security user information
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_stmt            varchar2(256);
    v_count           integer := 0;
    v_role_key        integer := 0;
    v_rule_key        integer := 0;
    v_role            varchar2(256);
    v_rule            varchar2(256);
    v_user            varchar2(256);

    --=====================================================
    -- Cursor to find all users in roles
    --=====================================================
    CURSOR c_role IS
    SELECT sr_role
    FROM ws_sec_role
    WHERE sr_role_key IN
      ( SELECT distinct sru_role_key
        FROM ws_sec_role_user
        WHERE UPPER(sru_user) = v_role
      );

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 100;
    --*****************************************************
    --   CHECK FOR INVALID OPTION
    --*****************************************************
    IF upper(p_option) = 'DROP_FROM_ALL_ROLES'
    OR upper(p_option) = 'DROP_FROM_ALL_POLICY_RULES'
    OR upper(p_option) = 'DROP_FROM_POLICY_RULE'
    OR upper(p_option) = 'ADD_TO_POLICY_RULE'
    OR upper(p_option) = 'DROP_FROM_ROLE'
    OR upper(p_option) = 'ADD_TO_ROLE' THEN
        v_step := 110;
    Else
        p_return_msg := 'Invalid option '|| p_option||
                ' in call to Ws_Sec_Maintain_User. '||
                'Valid options are DROP_FROM_ALL_ROLES, '||
                'DROP_FROM_ALL_POLICY_RULES, '||
                'DROP_FROM_ROLE, '||
                'DROP_FROM_POLICY_RULE, '||
                'ADD_TO_ROLE, '||
                'ADD_TO_POLICY_RULE';
        RETURN -2;
    End If;


    v_role := UPPER(p_role_rule);
    v_rule := UPPER(p_role_rule);
    v_user := UPPER(p_user);

    --=====================================================
    -- Check that the user is not null
    --=====================================================
    IF p_user is NULL THEN
        p_return_msg := 'Null user name' ||
                ' in call to Ws_Sec_Maintain_User. NO ACTION!!';
        RETURN -2;
    END IF;
    --=====================================================
    -- Check that the role/rule is not null unless a drop from
    -- ALL request.
    --=====================================================
    IF p_role_rule is NULL THEN
        IF upper(p_option) = 'DROP_FROM_ALL_ROLES'
        OR upper(p_option) = 'DROP_FROM_ALL_POLICY_RULES' THEN
            p_return_msg := '';
        ELSE
            p_return_msg := 'Null role or policy rule specified' ||
                    ' in call to Ws_Sec_Maintain_User. NO ACTION!!';
            RETURN -2;
        END IF;
    --=====================================================
    -- If non null role/rule then get the key for the element
    --=====================================================
    ELSE
        IF upper(p_option) = 'DROP_FROM_ROLE'
        OR upper(p_option) = 'ADD_TO_ROLE' THEN
            --=================================================
            -- Get the role key. Error if not found
            --=================================================
            BEGIN
                SELECT sr_role_key INTO v_role_key
                FROM ws_sec_role
                WHERE UPPER(sr_role) = v_role;
            EXCEPTION WHEN OTHERS THEN
                v_role_key := 0;
            END;
            IF v_role_key = 0 THEN
                p_return_msg := 'Unable to find the role specified (' ||
                        p_role_rule ||
                        ') in call to Ws_Sec_Maintain_User. NO ACTION!!';
                RETURN -2;
            END IF;
        END IF;
        IF upper(p_option) = 'DROP_FROM_POLICY_RULE'
        OR upper(p_option) = 'ADD_TO_POLICY_RULE' THEN
            --=================================================
            -- Get the policy_rule key. Error if not found
            --=================================================
            BEGIN
                SELECT sp_pol_key INTO v_rule_key
                FROM ws_sec_policy
                WHERE UPPER(sp_pol_name) = v_rule;
            EXCEPTION WHEN OTHERS THEN
                v_rule_key := 0;
            END;
            IF v_rule_key = 0 THEN
                p_return_msg := 'Unable to find the policy rule specified (' ||
                        p_role_rule ||
                        ') in call to Ws_Sec_Maintain_User. NO ACTION!!';
                RETURN -2;
            END IF;
        END IF;
        IF upper(p_option) = 'DROP_FROM_ALL_ROLES'
        OR upper(p_option) = 'DROP_FROM_ALL_POLICY_RULES' THEN
            --=================================================
            -- Should not be a role/rule specified
            --=================================================
            p_return_msg := 'Role or policy rule specified when not expected (' ||
                    p_role_rule ||
                    ') in call to Ws_Sec_Maintain_User. NO ACTION!!';
            RETURN -2;
        END IF;
    END IF;

    --=====================================================
    --=====================================================
    --=====================================================
    -- Process depending on the option selected.
    -- DROP_FROM_ALL_ROLES
    -- DROP_FROM_ALL_POLICY_RULES
    -- DROP_FROM_ROLE
    -- DROP_FROM_POLICY_RULE
    -- ADD_TO_ROLE
    -- ADD_TO_POLICY_RULE
    --=====================================================
    --=====================================================
    --=====================================================
    p_return_msg := '';
    v_result := 1;

    --*****************************************************
    --   DROP_FROM_ALL_ROLES
    --*****************************************************
    If upper(p_option) = 'DROP_FROM_ALL_ROLES' Then
        v_step := 200;

        --=================================================
        -- Look through all the roles the user is in
        --=================================================
        FOR v_Role in c_role LOOP
            --=================================================
            -- Revoke the role from the user
            --=================================================
            BEGIN
                v_stmt := 'REVOKE '||v_role.sr_role||' FROM '||p_user;
                EXECUTE IMMEDIATE v_stmt;
            EXCEPTION WHEN OTHERS THEN
                IF SQLCODE = 1951 THEN
                    p_return_msg := p_return_msg || 'User ' || p_user||
                            ' not granted role ' || p_role_rule ||'. ';
                    v_result := -1;
                ELSE
                    p_return_msg := p_return_msg ||
                        'Unexpected error when revoking role from user. Ora Error ' ||
                        SQLCODE || '. ';
                    v_result := -2;
                END IF;
            END;
        END LOOP; -- end cursor loop
        --=================================================
        -- Now delete the user from the metadata
        --=================================================
        BEGIN
            DELETE FROM ws_sec_role_user
            WHERE upper(sru_user) = v_user;
        EXCEPTION WHEN OTHERS THEN
            p_return_msg := p_return_msg ||
                'Unexpected error in removing user from roles in metadata. Ora Error ' ||
                SQLCODE || ' ';
            v_result := -2;
        END;
        --=================================================
        -- Return
        --=================================================
        return v_result;

    --*****************************************************
    --   DROP_FROM_ALL_POLICY_RULES
    --*****************************************************
    ElsIf upper(p_option) = 'DROP_FROM_ALL_POLICY_RULES' Then
        v_step := 300;

        --=================================================
        -- Delete the user from the metadata
        --=================================================
        BEGIN
            DELETE FROM ws_sec_pol_user
            WHERE upper(spu_user) = v_user;
        EXCEPTION
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error in removing user from policy rule. Ora Error ' ||
                    SQLCODE || ' ';
            v_result := -2;
        END;
        --=================================================
        -- Return
        --=================================================
        return v_result;

    --*****************************************************
    --   DROP_FROM_ROLE
    --*****************************************************
    ElsIf upper(p_option) = 'DROP_FROM_ROLE' Then
        v_step := 400;

        --=================================================
        -- First delete the user from the metadata
        --=================================================
        BEGIN
            DELETE FROM ws_sec_role_user
            WHERE sru_role_key = v_role_key
            AND upper(sru_user) = v_user;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_return_msg := 'User ' || p_user||
                    ' not found in role ' || p_role_rule || '. ';
            v_result := -1;
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error in removing user from role in metadata. Ora Error ' ||
                    SQLCODE || '. ';
            v_result := -2;
        END;
        --=================================================
        -- Now revoke the role from the user
        --=================================================
        BEGIN
            v_stmt := 'REVOKE '||p_role_rule||' FROM '||p_user;
            EXECUTE IMMEDIATE v_stmt;
        EXCEPTION WHEN OTHERS THEN
            IF SQLCODE = -1951 THEN
                p_return_msg := p_return_msg || 'User ' || p_user||
                        ' not granted role ' || p_role_rule;
                v_result := -1;
            ELSE
                p_return_msg := p_return_msg ||
                    'Unexpected error when revoking role from user. Ora Error ' ||
                    SQLCODE || ' ';
                v_result := -2;
            END IF;
        END;
        --=================================================
        -- Return
        --=================================================
        return v_result;

    --*****************************************************
    --   DROP_FROM_POLICY_RULE
    --*****************************************************
    ElsIf upper(p_option) = 'DROP_FROM_POLICY_RULE' Then
        v_step := 500;

        --=================================================
        -- First delete the user from the metadata
        --=================================================
        BEGIN
            DELETE FROM ws_sec_pol_user
            WHERE spu_pol_key = v_rule_key
            AND upper(spu_user) = v_user;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_return_msg := 'User ' || p_user||
                    ' not found in policy rule ' || p_role_rule;
            v_result := -1;
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error in removing user from policy rule. Ora Error ' ||
                    SQLCODE || ' ';
            v_result := -2;
        END;
        --=================================================
        -- Return
        --=================================================
        return v_result;

    --*****************************************************
    --   ADD_TO_ROLE
    --*****************************************************
    ElsIf upper(p_option) = 'ADD_TO_ROLE' Then
        v_step := 600;
        --=================================================
        -- First check the user is not already in the role
        --=================================================
        BEGIN
            SELECT count(1) INTO v_count
            FROM ws_sec_role_user
            WHERE sru_role_key = v_role_key
            AND upper(sru_user) = v_user;
        EXCEPTION
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error checking metadata ws_sec_role_user. No Action!!!. Ora Error ' ||
                    SQLCODE || '. ';
            v_result := -2;
            RETURN v_result;
        END;
        IF v_count <> 0 THEN
            p_return_msg := 'User ' ||p_user||' already in role '||
                p_role_rule||'. No Action!!!.';
            RETURN -1;
        END IF;

        --=================================================
        -- Add the user to the metadata
        --=================================================
        BEGIN
            INSERT INTO ws_sec_role_user
                (sru_role_key, sru_user, sru_active)
            VALUES
                (v_role_key, p_user, 'Y');
        EXCEPTION
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error inserting into ws_sec_role_user. Ora Error ' ||
                    SQLCODE || '. ';
            v_result := -2;
            RETURN v_result;
        END;

        --=================================================
        -- Now grant the role
        --=================================================
        BEGIN
            v_stmt := 'GRANT '||p_role_rule||' TO '||p_user;
            EXECUTE IMMEDIATE v_stmt;
        EXCEPTION WHEN OTHERS THEN
            p_return_msg := p_return_msg ||
                'Unexpected error when granting role to user. Ora Error ' ||
                SQLCODE || ' ';
            v_result := -2;
            RETURN v_result;
        END;
        --=================================================
        -- Return
        --=================================================
        return v_result;

    --*****************************************************
    --   ADD_TO_POLICY_RULE
    --*****************************************************
    ElsIf upper(p_option) = 'ADD_TO_POLICY_RULE' Then
        v_step := 700;
        --=================================================
        -- First check the user is not already in the rule
        --=================================================
        BEGIN
            SELECT count(1) INTO v_count
            FROM ws_sec_pol_user
            WHERE spu_pol_key = v_rule_key
            AND upper(spu_user) = v_user;
        EXCEPTION
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error checking metadata ws_sec_pol_user. No Action!!!. Ora Error ' ||
                    SQLCODE || '. ';
            v_result := -2;
            RETURN v_result;
        END;
        IF v_count <> 0 THEN
            p_return_msg := 'User ' ||p_user||' already in policy rule '||
                p_role_rule||'. No Action!!!.';
            RETURN -1;
        END IF;

        --=================================================
        -- Add the user to the metadata
        --=================================================
        BEGIN
            INSERT INTO ws_sec_pol_user
                (spu_pol_key, spu_user, spu_active)
            VALUES
                (v_rule_key, p_user, 'Y');
        EXCEPTION
        WHEN OTHERS THEN
            p_return_msg := 'Unexpected error inserting into ws_sec_pol_user. Ora Error ' ||
                    SQLCODE || '. ';
            v_result := -2;
            RETURN v_result;
        END;

        --=================================================
        -- Return
        --=================================================
        return v_result;


    --*****************************************************
    --   INVALID OPTION
    --*****************************************************
    Else
        p_return_msg := 'Invalid option '|| p_option||
                ' in call to Ws_Sec_Maintain_User. '||
                'Valid options are DROP_FROM_ALL_ROLES, '||
                'DROP_FROM_ALL_POLICY_RULES, '||
                'DROP_FROM_ROLE, '||
                'DROP_FROM_POLICY_RULE, '||
                'ADD_TO_ROLE, '||
                'ADD_TO_POLICY_RULE';
        RETURN -2;
    End If;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        v_MsgText := 'Unhandled Exception in Ws_Sec_Maintain_User. '||
                ' Step ' ||v_step;
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END Ws_Sec_Maintain_User;
 
_PROCEDURE_ Ws_Mon_Status 
-- Notes / History
--
-- Returned status is used by the underlying UNIX scripts to test that the procedure
-- worked. Should be -3, -2, -1, 1 or 2
--
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 2048 characters.

CREATE OR REPLACE function Ws_Mon_Status
    (
    p_option           IN  varchar2,
    p_host             IN  varchar2,
    p_version          IN  varchar2,
    p_os_type          IN  varchar2,
    p_back_hh          IN  number,
    p_back_mm          IN  number,
    p_log_level        IN  number,
    p_job_interval     IN  number,
    p_db_interval      IN  number,
    p_unix_scheduler   OUT number,
    p_win_scheduler    OUT number
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- ==============================================================================
    -- DBMS Name       :     Oracle
    -- Script Name     :     Ws_Mon_Status
    -- Description     :     Updates the monitor status
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- ==============================================================================

    --=====================================================
    -- Control variables used in most programs
    --=====================================================
    v_MsgText             varchar2(2048); -- Text for audit_trail
    v_step                integer := 0;   -- return code
    v_count               integer := 0;   -- General counter;
    v_return_status       integer := 0;   -- value returned by this function
    v_last_update         date;           -- date time the database monitoring parameters where last changed
    v_last_script_update  date;           -- datetime the monitoring info was last retrieved by the monitor
    v_db_mon_ind          varchar2(1);    -- indicator to show if we have database monitoring
    v_active_date         date;           -- date scheduler last active

BEGIN

    v_step :=100;

    --=====================================================
    -- Get the time the db monitoring info was last updated
    --=====================================================
    BEGIN
        SELECT NVL(wmd_last_updated,sysdate-100) INTO v_last_update
        FROM ws_wrk_mon_db;
        v_db_mon_ind := 'Y';
    EXCEPTION WHEN NO_DATA_FOUND THEN
        v_last_update := to_date('19010101','YYYYMMDD');
        v_db_mon_ind := 'N';
    WHEN OTHERS THEN
        v_MsgText := SUBSTR('Unhandled Exception in ws_mon_status reading ws_wrk_mon_db. '||
                            SQLERRM,1,2047);
        INSERT INTO ws_wrk_mon_log
        ( wml_time_stamp, wml_status, wml_message, wml_job_key,
          wml_job_name, wml_notify_ind )
        VALUES
        ( sysdate, 'F', v_MsgText, NULL,
          NULL, 'N');
        COMMIT;
        RETURN -3;
    END;

    --=====================================================
    -- Get the time the external monitor routine last
    -- refreshed its scripts and commands from the
    -- monitoring information.
    --=====================================================
    BEGIN
        SELECT NVL(wms_last_script_update,sysdate-1000) INTO v_last_script_update
        FROM ws_wrk_mon_status;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        v_last_script_update := sysdate;
    WHEN OTHERS THEN
        v_MsgText := SUBSTR('Unhandled Exception in ws_mon_status reading ws_wrk_mon_status. '||
                            SQLERRM,1,2047);
        INSERT INTO ws_wrk_mon_log
        ( wml_time_stamp, wml_status, wml_message, wml_job_key,
          wml_job_name, wml_notify_ind )
        VALUES
        ( sysdate, 'F', v_MsgText, NULL,
          NULL, 'N');
        COMMIT;
        RETURN -3;
    END;

    --=====================================================
    -- If the monitoring information has been changed then
    -- set the return status so that we pick up the new
    -- information
    --=====================================================
    IF v_last_update > v_last_script_update THEN
        v_return_status := 2;
    ELSE
        v_return_status := 1;
    END IF;

    --=====================================================
    -- Update the status table to show that we are active
    -- If a status update requested
    --=====================================================
    IF p_option = 'STATUS' THEN
        UPDATE ws_wrk_mon_status
        SET
            wms_time_stamp = sysdate,
            wms_host = p_host,
            wms_version = p_version,
            wms_os_type = p_os_type,
            wms_db_mon_ind = v_db_mon_ind,
            wms_lookback_hours = p_back_hh,
            wms_lookback_mins = p_back_mm,
            wms_log_level = p_log_level,
            wms_job_poll_interval = p_job_interval,
            wms_db_poll_interval = p_db_interval;
        IF SQL%NOTFOUND THEN
            INSERT INTO ws_wrk_mon_status (
                wms_time_stamp,
                wms_host ,
                wms_version,
                wms_os_type,
                wms_db_mon_ind,
                wms_lookback_hours,
                wms_lookback_mins,
                wms_log_level,
                wms_job_poll_interval,
                wms_db_poll_interval
             ) VALUES (
                sysdate,
                p_host,
                p_version,
                p_os_type,
                v_db_mon_ind,
                p_back_hh,
                p_back_mm,
                p_log_level,
                p_job_interval,
                p_db_interval
             );
        END IF;
    END IF; -- end of status update requested

    --=====================================================
    -- Get the scheduler status
    --=====================================================
    p_unix_scheduler := 0;
    p_win_scheduler := 0;

    --=====================================================
    -- Unix scheduler
    --=====================================================
    SELECT MAX(ws_active_date) INTO v_active_date
    FROM ws_wrk_scheduler
    WHERE ws_type_ind = 'U';

    --=====================================================
    -- If no scheduler then indicate 0
    -- If scheduler not active in the last 1 hour then
    -- it's down
    --=====================================================
    IF v_active_date IS NULL THEN
        p_unix_scheduler := 0;
    ELSIF v_active_date < sysdate-0.0417 THEN
        p_unix_scheduler := 0;
    ELSE
        p_unix_scheduler := 1;
    END IF;

    --=====================================================
    -- Windows scheduler
    --=====================================================
    SELECT MAX(ws_active_date) INTO v_active_date
    FROM ws_wrk_scheduler
    WHERE ws_type_ind = 'W';

    --=====================================================
    -- If no scheduler then indicate 0
    -- If scheduler not active in the last 1 hour then
    -- it's down
    --=====================================================
    IF v_active_date IS NULL THEN
        p_win_scheduler := 0;
    ELSIF v_active_date < sysdate-0.0417 THEN
        p_win_scheduler := 0;
    ELSE
        p_win_scheduler := 1;
    END IF;

    --=====================================================
    --All Done report the results and return.
    --=====================================================
    COMMIT;
    v_step := 200;

    RETURN v_return_status;

EXCEPTION
  --=====================================================
  -- Unhandled Exception. Return with Fatal Error
  --=====================================================
  WHEN OTHERS THEN
    v_MsgText := SUBSTR('Unhandled Exception in ws_mon_status. '||
                        ' Step ' ||v_step||' '|| SQLERRM,1,2047);
    INSERT INTO ws_wrk_mon_log
    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
      wml_job_name, wml_notify_ind )
    VALUES
    ( sysdate, 'F', v_MsgText, NULL,
      NULL, 'N');
    COMMIT;
    RETURN -3;
END Ws_Mon_Status;
 
_PROCEDURE_ Ws_Mon_Job_Check 
-- Notes / History
-- BC  14/08/2015   Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 2048 characters.

CREATE OR REPLACE function ws_mon_job_check
    (
    p_check_back_hh    IN  integer,
    p_check_back_mm    IN  integer,
    p_poll_interval    IN  integer,
    p_log_level        IN  integer,
    p_job_count        OUT integer
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name      :      Oracle
    -- Script Name    :      ws_mon_job_check
    -- Description    :      Checks for jobs that need notifications
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText             varchar2(2048); -- Text in audit_trail
    v_step                integer := 0;   -- return code
    v_result              integer := 0;   -- return code
    v_last_start_time     date;           -- time job last started
    v_last_stop_time      date;           -- time job last finished
    v_current_start_time  date;           -- time job started if running
    v_next_start_time     date;           -- time job scheduled to next start
    v_valid               integer;        -- flag to indicate a valid job
    v_running             integer;        -- flag to indicate a running job record
    v_completed           integer;        -- flag to indicate a completed job record
    v_check_hh            integer;        -- hour this check is running in
    v_check_mm            integer;        -- minutes past the hour of this check
    v_skip_check          integer;        -- flag to indicate outside check time
    v_hh_last             integer;        -- last check time (hour)
    v_mm_last             integer;        -- last check time (minute)
    v_hh_next             integer;        -- next check time (hour)
    v_mm_next             integer;        -- next check time (minute)
    v_hh_diff             integer;        -- difference (hour)
    v_mm_diff             integer;        -- difference (minute)
    v_notify_key          integer := 0;   -- key for notify records
    v_notify              integer := 0;   -- flag to indicate a notification
    v_day_of_week         integer;        -- day of the week 1-7
    v_day_of_month        integer;        -- day of the month 1-31
    v_next_day_of_month   integer;        -- tomorrow day of the month 1-31
    v_skip_day            integer;        -- flag to indicate that this day is not checked
    v_required_start      date;           -- date time we need to start by
    v_required_finish     date;           -- date time we need to finish by
    v_required_cpoint     date;           -- date time of checkpoint
    v_required_check      date;           -- date time we need to check for
    v_work                integer;
    v_work2               integer;
    v_start_hh            integer;        -- hour the job must start by
    v_start_mm            integer;        -- minute the job must start by
    v_finish_hh           integer;        -- hour the job must finish by
    v_finish_mm           integer;        -- minute the job must finish by
    v_abs_hh              integer;        -- absolute minimum start hour
    v_abs_mm              integer;        -- absolute minimum start minute
    v_abs_day             integer;        -- contains -1 if our absolute start time was yesterday
    v_abs_start           date;           -- absolute start/date time before which the job could not have started
    v_cp_hh               integer;        -- checkpoint hour
    v_cp_mm               integer;        -- checkpoint minute
    v_cp_found            integer;        -- flag to indicate a checkpoint to test
    v_check_date          date;           -- datetime of the check we are running
    v_start_date          date;           -- datetime of the must start by time.
    v_finish_date         date;           -- datetime of the must finish by time.
    v_cp_date             date;           -- datetime of the checkpoint.
    v_start_day           integer;        -- increment of days past check day
    v_finish_day          integer;        -- increment of days past check day
    v_cp_day              integer;        -- increment of days past check day
    v_prev_day            integer;        -- flag to indicate a previous day
    v_info_count          integer;        -- number of info messages to check for
    v_task_count          integer;        -- number of completed tasks to check for
    v_notify_type         varchar2(64);   -- type of notification message
    v_finish_status       varchar2(1);    -- finish status code of a job
    v_warn_count          integer;        -- number of warnings in job
    v_error_count         integer;        -- number of errors in job
    v_failed_job          integer;        -- flag to indicate that the job failed
    v_cp_script_key       integer;        -- notification script key for a checkpoint
    v_cp_param            varchar2(4000); -- notification parameter for a checkpoint

    v_CtrlRec             ws_wrk_job_ctrl%ROWTYPE;
    v_RunRec              ws_wrk_job_run%ROWTYPE;
    v_LogRec              ws_wrk_job_log%ROWTYPE;
    v_tasks_completed     integer;
    v_info_messages       integer;

    --=====================================================
    -- Cursor for all jobs to be checked
    --=====================================================
    CURSOR c_JobMon IS
        SELECT *
        FROM ws_wrk_mon_job
        WHERE NVL(wmj_start_active,'N') = 'Y'
        OR NVL(wmj_finish_active,'N') = 'Y'
        OR NVL(wmj_run_warn_active,'N') = 'Y'
        OR NVL(wmj_run_err_active,'N') = 'Y'
        OR NVL(wmj_fin_warn_active,'N') = 'Y'
        OR NVL(wmj_fin_err_active,'N') = 'Y'
        OR NVL(wmj_fin_ok_active,'N') = 'Y'
        OR NVL(wmj_cp1_active,'N') = 'Y'
        OR NVL(wmj_cp2_active,'N') = 'Y'
        OR NVL(wmj_cp3_active,'N') = 'Y'
        ;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_result := 1;
    v_check_date := sysdate;
    v_check_hh := to_number(to_char(v_check_date,'HH24'));
    v_check_mm := to_number(to_char(v_check_date,'MI'));

    --=====================================================
    -- If Debug set then log the start of this check
    --=====================================================
    IF p_log_level >= 9 THEN
        v_MsgText := 'Job Monitoring commenced at ' || LPAD(v_check_hh,2,'0')||
                    ':'||LPAD(v_check_mm,2,'0');
        INSERT INTO ws_wrk_mon_log
        ( wml_time_stamp, wml_status, wml_message, wml_notify_ind )
        VALUES
        ( sysdate, 'I', v_MsgText, 'N');
        COMMIT;
    END IF;

    --=====================================================
    -- Loop through the jobs checking each one
    -- If a notification required then insert
    -- a record into the notification table
    --=====================================================
    FOR v_MonRec in c_JobMon LOOP
        v_skip_day := 0;
        v_notify := 0;
        v_valid := 1;
        v_running := 1;
        v_completed := 1;

        --=====================================================
        -- Get the difference between our check time and the
        -- last nominal last start time for the job
        -- need to know if the nominal start time was yesterday.
        --=====================================================
        IF   v_check_hh > v_MonRec.wmj_nominal_hh
        OR (     v_check_hh = v_MonRec.wmj_nominal_hh
            AND v_check_mm  > v_MonRec.wmj_nominal_mm ) THEN
            -- ahead of the check start time, so must be today
            v_prev_day := 0;
        ELSE
            -- before the check start time, so last one was yesterday
            v_prev_day := 1;
        END IF;

        --=====================================================
        -- Work out the absolulte minimum start time for this job
        --=====================================================
        v_abs_day := 0;
        v_abs_mm := v_MonRec.wmj_nominal_mm - v_MonRec.wmj_prior_start_elapsed;
        v_abs_hh := v_MonRec.wmj_nominal_hh;
        WHILE v_abs_mm < 0 LOOP
            v_abs_hh := v_abs_hh - 1;
            v_abs_mm := v_abs_mm + 60;
        END LOOP;
        WHILE v_abs_hh < 0 LOOP
            v_abs_hh := v_abs_hh + 24;
            v_abs_day := v_abs_day - 1;
        END LOOP;
        v_abs_day := v_abs_day + v_prev_day;
        v_work := to_number(to_char(sysdate-v_abs_day,'YYYYMMDD'));
        v_work := v_work * 10000;
        v_work := v_work + ( v_abs_hh * 100 );
        v_work := v_work + v_abs_mm;
        v_abs_start := to_date(v_work,'YYYYMMDDHH24MI');

        --=====================================================
        -- Check to see if monitoring requested for this day
        --=====================================================
        v_day_of_week := to_number(to_char(sysdate-v_prev_day,'D'));
        v_day_of_month := to_number(to_char(sysdate-v_prev_day,'DD'));
        v_next_day_of_month := to_number(to_char(sysdate-v_prev_day+1,'DD'));
        IF v_day_of_week = 2 AND NVL(v_MonRec.wmj_mon,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 3 AND NVL(v_MonRec.wmj_tue,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 4 AND NVL(v_MonRec.wmj_wed,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 5 AND NVL(v_MonRec.wmj_thu,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 6 AND NVL(v_MonRec.wmj_fri,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 7 AND NVL(v_MonRec.wmj_sat,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        IF v_day_of_week = 1 AND NVL(v_MonRec.wmj_sun,'N') = 'N' THEN
            v_skip_day := 1;
            v_valid := 0;
        END IF;
        -- if the first of the month and checking on the first
        -- then re-set the flags so we proceed
        IF v_day_of_month = 1 AND NVL(v_MonRec.wmj_first_day,'Y') = 'Y' THEN
            v_skip_day := 0;
            v_valid := 1;
        END IF;
        -- if tomorrow is the the first of the month and checking for the last
        -- of the month then re-set the flags so we proceed
        IF v_next_day_of_month = 1 AND NVL(v_MonRec.wmj_last_day,'Y') = 'Y' THEN
            v_skip_day := 0;
            v_valid := 1;
        END IF;

        --=====================================================
        -- If Debug set then log the start of this job check
        --=====================================================
        IF p_log_level >= 9 THEN
            IF v_valid = 1 THEN
                v_MsgText := 'Job Monitoring of Job '|| v_MonRec.wmj_job_name||
                            ' commenced at ' || LPAD(v_check_hh,2,'0')|| ':'||LPAD(v_check_mm,2,'0');
            ELSE
                v_MsgText := 'Job Monitoring of Job '|| v_MonRec.wmj_job_name||
                            ' skipped. No checking for this day of the week.month.';
            END IF;
            INSERT INTO ws_wrk_mon_log
            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
              wml_job_name, wml_notify_ind )
            VALUES
            ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
              v_MonRec.wmj_job_name, 'N');
            COMMIT;
        END IF;

        --=====================================================
        -- Get information about this job
        -- If the job not found then issue a message and skip
        --=====================================================
        IF v_valid = 1 THEN
            BEGIN
                SELECT * INTO v_CtrlRec
                FROM ws_wrk_job_ctrl
                WHERE wjc_job_key = v_MonRec.wmj_job_key;
                v_valid := 1;
            EXCEPTION WHEN OTHERS THEN
                v_valid := 0;
                v_MsgText := 'Job ' || v_MonRec.wmj_job_name||
                            ' not found. Monitoring setup for an invalid job.';
                INSERT INTO ws_wrk_mon_log
                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                  wml_job_name, wml_notify_ind )
                VALUES
                ( sysdate, 'E', v_MsgText, v_MonRec.wmj_job_key,
                  v_MonRec.wmj_job_name, 'N');
                COMMIT;
            END;
        END IF;

        --=====================================================
        -- Get information about any running iterations of the job
        --=====================================================
        IF v_valid = 1 THEN
            BEGIN
                SELECT * INTO v_RunRec
                FROM ws_wrk_job_run
                WHERE wjr_job_key = v_MonRec.wmj_job_key;
                v_running := 1;
            EXCEPTION WHEN OTHERS THEN
                v_running := 0;
                v_RunRec.wjr_status := 'X';
            END;
            IF v_running = 1 THEN
                BEGIN
                    SELECT count(1) INTO v_tasks_completed
                    FROM ws_wrk_task_run
                    WHERE wtr_job_key = v_MonRec.wmj_job_key
                    AND wtr_run_status = 'C';
                EXCEPTION WHEN OTHERS THEN
                    v_tasks_completed := 0;
                END;
            END IF;
        END IF;

        --=====================================================
        -- Get information from the latest completed version
        --=====================================================
        IF v_valid = 1 THEN
            BEGIN
                SELECT * INTO v_LogRec
                FROM ws_wrk_job_log
                WHERE wjl_job_key = v_MonRec.wmj_job_key
                AND wjl_sequence =
                  ( SELECT max(wjl_sequence) FROM ws_wrk_job_log
                    WHERE wjl_job_key = v_MonRec.wmj_job_key );
                v_completed := 1;
            EXCEPTION WHEN OTHERS THEN
                v_completed := 0;
            END;
        END IF;

        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        -- F I N I S H    S T A T U S    C H E C K S
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --=====================================================
        -- If FINISH status checks are active check the jobs
        -- finish status.
        --=====================================================
        IF v_valid = 1
        AND (   NVL(v_MonRec.wmj_fin_ok_active,'N') = 'Y'
             OR NVL(v_MonRec.wmj_fin_warn_active,'N') = 'Y'
             OR NVL(v_MonRec.wmj_fin_err_active,'N') = 'Y' ) THEN

            v_step := 100;

            --=====================================================
            -- If we have a completed job or a running job that
            -- has failed, we will check the lookback time.
            --=====================================================
            IF v_completed = 1
            OR ( v_running = 1 AND v_RunRec.wjr_status = 'F' ) THEN

                v_failed_job := 0;
                -- get the finish time of any completed job
                IF v_completed = 1 THEN
                    v_finish_hh := to_number(to_char(v_LogRec.wjl_completed,'HH24'));
                    v_finish_mm := to_number(to_char(v_LogRec.wjl_completed,'MI'));
                    v_start_date := v_LogRec.wjl_started;
                END IF;

                -- If we have a running job that has a failed status then
                -- that is more current than the completed job so use that time
                -- and flag that we are using a failed job
                IF v_running = 1 AND v_RunRec.wjr_status = 'F' THEN
                    v_finish_hh := TO_NUMBER(TO_CHAR(NVL(v_RunRec.wjr_completed,v_RunRec.wjr_started),'HH24'));
                    v_finish_mm := TO_NUMBER(TO_CHAR(NVL(v_RunRec.wjr_completed,v_RunRec.wjr_started),'MI'));
                    v_start_date := v_RunRec.wjr_started;
                    v_failed_job := 1;
                END IF;

                --=====================================================
                -- Get the difference between our check time and the
                -- finish time
                --=====================================================
                v_prev_day := 0;
                IF   v_check_hh > v_finish_hh
                OR (     v_check_hh = v_finish_hh
                    AND v_check_mm  > v_finish_mm ) THEN
                    -- ahead of the check finish time
                    -- get the last start time (same day)
                    v_hh_last := v_check_hh - v_finish_hh;
                    v_mm_last := v_check_mm - v_finish_mm;
                    IF v_mm_last < 0 THEN
                        v_mm_last := v_mm_last + 60;
                        v_hh_last := v_hh_last - 1;
                    END IF;
                    -- get the next finish time (next day)
                    v_hh_next := 23 - v_hh_last;
                    v_mm_next := 60 - v_mm_last;
                    IF v_mm_next = 60 THEN
                        v_mm_next := 0;
                        v_hh_next := v_hh_next + 1;
                    END If;
                ELSE
                    -- before the check finish time
                    -- get the next start time (same day)
                    v_hh_next := v_finish_hh - v_check_hh;
                    v_mm_next := v_finish_mm - v_check_mm;
                    IF v_mm_next < 0 THEN
                        v_mm_next := v_mm_next + 60;
                        v_hh_next := v_hh_next - 1;
                    END IF;
                    -- get the last finish time (previous day)
                    v_prev_day := 1;
                    v_hh_last := 23 - v_hh_next;
                    v_mm_last := 60 - v_mm_next;
                    IF v_mm_last = 60 THEN
                        v_mm_last := 0;
                        v_hh_last := v_hh_last + 1;
                    END IF;

                END IF;

                --=====================================================
                -- See if we are within our check range
                --=====================================================
                v_hh_diff := v_hh_last - p_check_back_hh;
                v_mm_diff := v_mm_last - p_check_back_mm;
                IF v_mm_diff < 0 THEN
                    v_hh_diff := v_hh_diff - 1;
                    v_mm_diff := v_mm_diff + 60;
                END IF;
                IF v_hh_diff > 0
                OR (     v_hh_diff = 0
                     AND v_mm_diff > 0 ) THEN
                    v_skip_check := 1;
                ELSE
                    v_skip_check := 0;
                END IF;

                --=====================================================
                -- Make sure that this is the current job.
                -- If not the current job then do not report it
                --=====================================================
                IF v_start_date < v_abs_start THEN
                    v_skip_check := 1; -- not the latest job so skip it
                END IF; -- end of check that we are looking at the latest job

                --=====================================================
                -- If we have a check to do then perform it.
                --=====================================================
                IF v_skip_check = 0 THEN
                    v_step := 200;
                    --=====================================================
                    -- Log a message if log level 9
                    --=====================================================
                    IF p_log_level >= 9 THEN
                        v_MsgText := 'Finish status check actioned. Current time '||
                            LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                            LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||' back '||
                            LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is less than look back of '||
                            LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                        INSERT INTO ws_wrk_mon_log
                        ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                          wml_job_name, wml_notify_ind )
                        VALUES
                        ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                          v_MonRec.wmj_job_name, 'N');
                        COMMIT;
                    END IF;

                    --=====================================================
                    -- Perform the check
                    --=====================================================
                    IF v_failed_job = 0 THEN
                        v_finish_status := v_LogRec.wjl_status;
                        v_warn_count := v_LogRec.wjl_warning_count;
                        v_error_count := v_LogRec.wjl_error_count;
                    ELSE
                        v_finish_status := v_RunRec.wjr_status;
                        v_warn_count := v_RunRec.wjr_warning_count;
                        v_error_count := v_RunRec.wjr_error_count;
                    END IF;

                    v_notify := 0;
                    --=====================================================
                    -- Check if a finish error notify required
                    -- If we have finish completed and have errors that
                    -- means the job has been restarted and run to completion
                    -- we will not consider that a finish failure.
                    --=====================================================
                    IF NVL(v_MonRec.wmj_fin_err_active,'N') = 'Y'
                    AND v_error_count > NVL(v_MonRec.wmj_fin_err_count,0)
                    AND v_finish_status <> 'C' THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH_ERROR'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification of finish in error Skipped.'||
                                ' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'FINISH_ERROR',
                                wmn_script_key = v_MonRec.wmj_fin_err_script_key,
                                wmn_parameter = v_MonRec.wmj_fin_err_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'FINISH_ERROR', v_MonRec.wmj_fin_err_script_key,
                                  v_MonRec.wmj_fin_err_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification of finish with errors. '||
                                v_error_count||' errors detected.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                        v_notify := 1;
                    END IF;
                    --=====================================================
                    -- Check if a finish warning notify required
                    -- and we have not done an error notification
                    --=====================================================
                    IF NVL(v_MonRec.wmj_fin_warn_active,'N') = 'Y'
                    AND v_warn_count > NVL(v_MonRec.wmj_fin_warn_count,0)
                    AND v_notify = 0 THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH_WARNING'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification of finish with warnings Skipped.'||
                                ' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'FINISH_WARNING',
                                wmn_script_key = v_MonRec.wmj_fin_warn_script_key,
                                wmn_parameter = v_MonRec.wmj_fin_warn_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'FINISH_WARNING', v_MonRec.wmj_fin_warn_script_key,
                                  v_MonRec.wmj_fin_warn_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification of finish with warnings. '||
                                v_warn_count||' warnings produced.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                        v_notify := 1;
                    END IF;
                    --=====================================================
                    -- Check if a finish okay notify required
                    -- and we haven't had a finish error or warning notification
                    --=====================================================
                    IF NVL(v_MonRec.wmj_fin_ok_active,'N') = 'Y'
                    AND v_finish_status = 'C'
                    AND v_notify = 0 THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH_OKAY'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification of finish okay Skipped.'||
                                ' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'FINISH_OKAY',
                                wmn_script_key = v_MonRec.wmj_fin_ok_script_key,
                                wmn_parameter = v_MonRec.wmj_fin_ok_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'FINISH_OKAY', v_MonRec.wmj_fin_ok_script_key,
                                  v_MonRec.wmj_fin_ok_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification of finish okay.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                    END IF;


                ELSE -- check skipped last job too far back
                    IF p_log_level >= 9 THEN
                        v_MsgText := 'Finish status check skipped. Current time '||
                            LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                            LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||' back '||
                            LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is more than look back of '||
                            LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0')||
                            ' or this job ran before the latest iteration';
                        INSERT INTO ws_wrk_mon_log
                        ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                          wml_job_name, wml_notify_ind )
                        VALUES
                        ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                          v_MonRec.wmj_job_name, 'N');
                        COMMIT;
                    END IF;

                END IF; -- End of skip check test

            ELSE -- no completed jobs so skip the test. Log if level 9
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Finish status check found no completed or failed jobs.'||
                        ' The current time is '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||
                        ' All Okay.';
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;
            END IF; -- end of have a completed job to test




        END IF; -- END of FINISH STATUS CHECKS




        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        -- F I N I S H    B Y
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --=====================================================
        -- If FINISH time check is active check that the job
        -- finished on time today.
        --=====================================================
        IF NVL(v_MonRec.wmj_finish_active,'N') = 'Y' AND v_valid = 1 THEN
            v_step := 300;
            v_finish_mm := v_MonRec.wmj_nominal_mm + v_MonRec.wmj_finish_elapsed;
            v_finish_hh := v_MonRec.wmj_nominal_hh;
            WHILE v_finish_mm >= 60 LOOP
                v_finish_hh := v_finish_hh + 1;
                v_finish_mm := v_finish_mm - 60;
            END LOOP;
            WHILE v_finish_hh > 23 LOOP
                v_finish_hh := v_finish_hh - 24;
            END LOOP;

            --=====================================================
            -- Get the difference between our check time and the
            -- last must start by time and the next must start by time
            --=====================================================
            v_prev_day := 0;
            IF   v_check_hh > v_finish_hh
            OR (     v_check_hh = v_finish_hh
                AND v_check_mm  > v_finish_mm ) THEN
                -- ahead of the check finish time
                -- get the last start time (same day)
                v_hh_last := v_check_hh - v_finish_hh;
                v_mm_last := v_check_mm - v_finish_mm;
                IF v_mm_last < 0 THEN
                    v_mm_last := v_mm_last + 60;
                    v_hh_last := v_hh_last - 1;
                END IF;
                -- get the next finish time (next day)
                v_hh_next := 23 - v_hh_last;
                v_mm_next := 60 - v_mm_last;
                IF v_mm_next = 60 THEN
                    v_mm_next := 0;
                    v_hh_next := v_hh_next + 1;
                END If;
            ELSE
                -- before the check finish time
                -- get the next start time (same day)
                v_hh_next := v_finish_hh - v_check_hh;
                v_mm_next := v_finish_mm - v_check_mm;
                IF v_mm_next < 0 THEN
                    v_mm_next := v_mm_next + 60;
                    v_hh_next := v_hh_next - 1;
                END IF;
                -- get the last finish time (previous day)
                v_prev_day := 1;
                v_hh_last := 23 - v_hh_next;
                v_mm_last := 60 - v_mm_next;
                IF v_mm_last = 60 THEN
                    v_mm_last := 0;
                    v_hh_last := v_hh_last + 1;
                END IF;

            END IF;

            --=====================================================
            -- See if we are within our check range
            --=====================================================
            v_hh_diff := v_hh_last - p_check_back_hh;
            v_mm_diff := v_mm_last - p_check_back_mm;
            IF v_mm_diff < 0 THEN
                v_hh_diff := v_hh_diff - 1;
                v_mm_diff := v_mm_diff + 60;
            END IF;
            IF v_hh_diff > 0
            OR (     v_hh_diff = 0
                 AND v_mm_diff > 0 ) THEN
                v_skip_check := 1;
            ELSE
                v_skip_check := 0;
            END IF;

            --=====================================================
            -- work out the required start date
            --=====================================================
            v_work := to_number(to_char(v_check_date-v_prev_day,'YYYYMMDD'));
            v_work := v_work * 10000;
            v_work := v_work + ( v_finish_hh * 100 );
            v_work := v_work + v_finish_mm;
            v_finish_date := to_date(v_work,'YYYYMMDDHH24MI');

            --=====================================================
            -- If we have a check to do then perform it.
            --=====================================================
            IF v_skip_check = 0 THEN
                v_step := 400;
                --=====================================================
                -- Log a message if log level 9
                --=====================================================
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Must finish by check actioned. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is less than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;

                --=====================================================
                -- If we are running then check the finish time to ensure
                -- we haven't been running for more than 24 hours.
                -- Also check we haven't gone past the finish time.
                --=====================================================
                IF v_running = 1 THEN
                    v_step := 500;
                    -- been running since before the absolute start time
                    IF v_RunRec.wjr_started < v_abs_start THEN

                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure to finish on time Skipped.'||
                                ' Job still running previous iteration.'||' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'FINISH',
                                wmn_script_key = v_MonRec.wmj_finish_script_key,
                                wmn_parameter = v_MonRec.wmj_finish_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'FINISH', v_MonRec.wmj_finish_script_key,
                                  v_MonRec.wmj_finish_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure to finish on time.'||
                                ' Job still running previous iteration.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                    -- Running for less than 24 hours.
                    -- See if we have gone past our required finish time.
                    ELSE
                        -- past the required finish by time so notify
                        IF  v_check_date > v_finish_date THEN
                            -- About to notify, so check to see if we have already
                            -- sent a notification for this problem in our lookback
                            -- period. If we have then skip the notification
                            v_work := v_check_hh - p_check_back_hh;
                            v_work2 := v_check_mm - p_check_back_mm;
                            IF v_work2 < 0 THEN
                                v_work2 := v_work2 + 60;
                                v_work := v_work -1;
                            END IF;
                            IF v_work < 0 THEN
                                v_work2 := ((v_work+24) * 100) + v_work2;
                                v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                            ELSE
                                v_work2 := (v_work * 100) + v_work2;
                                v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                            END IF;
                            v_work := v_work * 10000;
                            v_work := v_work + v_work2;
                            v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                            IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH'
                            AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                                IF p_log_level >= 3 THEN
                                    v_MsgText := 'Notification for failure to finish on time Skipped.'||
                                    ' No running job.'||' Notification already sent at '||
                                    to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'N');
                                    COMMIT;
                                END IF;
                            ELSE
                                v_notify_key := v_notify_key + 1;
                                UPDATE ws_wrk_mon_notify SET
                                    wmn_time_stamp = sysdate,
                                    wmn_job_key = v_MonRec.wmj_job_key,
                                    wmn_job_name = v_MonRec.wmj_job_name,
                                    wmn_notify_type = 'FINISH',
                                    wmn_script_key = v_MonRec.wmj_finish_script_key,
                                    wmn_parameter = v_MonRec.wmj_finish_param
                                WHERE wmn_notify_number = v_notify_key;

                                IF SQL%NOTFOUND THEN
                                    INSERT INTO ws_wrk_mon_notify
                                    ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                      wmn_job_name, wmn_notify_type, wmn_script_key,
                                      wmn_parameter)
                                    VALUES
                                    ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'FINISH', v_MonRec.wmj_finish_script_key,
                                      v_MonRec.wmj_finish_param);
                                 END IF;
                                 COMMIT;
                                IF p_log_level >= 2 THEN
                                    v_MsgText := 'Notification for failure to finish on time.'||
                                    ' Running job, not completed on time. Started '||
                                    to_char(v_RunRec.wjr_started,'DD-MON-YYYY HH24:MI')||
                                    ' and completion required by '||
                                    LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||'. Current time '||
                                    LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'.';
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'Y');
                                    COMMIT;
                                END IF;
                                v_valid := 0; -- skip the rest of the checks
                                v_notify := 1;
                            END IF;

                        -- running but not past the required finish by time yet. so OKAY.
                        ELSE
                            IF p_log_level >= 9 THEN
                                v_MsgText := 'Must finish by check found running job. The current time is '||
                                    LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||
                                    ' which is before the required finish time of '||
                                    LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||
                                    '. Job started at '||to_char(v_RunRec.wjr_started,'DD-MON-YYYY HH24:MI')||
                                    ' which is after the minimum start of '||
                                    LPAD(v_abs_hh,2,'0')||':'||LPAD(v_abs_mm,2,'0')||
                                    ' All Okay.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        END IF;
                    END IF;
                --=====================================================
                -- If not running then if we have a completed entry
                -- check to see if it completed on time.
                --=====================================================
                ELSIF v_completed = 1 THEN
                    -- completed after the required finish time so notify
                    IF v_LogRec.wjl_completed > v_finish_date THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure to finish on time Skipped.'||
                                ' Job finished late.'||' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'FINISH',
                                wmn_script_key = v_MonRec.wmj_finish_script_key,
                                wmn_parameter = v_MonRec.wmj_finish_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'FINISH', v_MonRec.wmj_finish_script_key,
                                  v_MonRec.wmj_finish_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure to finish on time.'||
                                ' Job completed after required finish time. Started '||
                                to_char(v_LogRec.wjl_started,'DD-MON-YYYY HH24:MI')||
                                ' and completed '||
                                to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI')||
                                '. required finish time was '||
                                LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||'.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;

                    ELSE -- completed in time
                        v_step := 600;
                        -- check that we are not a previous iteration
                        IF v_LogRec.wjl_started < v_abs_start THEN
                            -- About to notify, so check to see if we have already
                            -- sent a notification for this problem in our lookback
                            -- period. If we have then skip the notification
                            v_work := v_check_hh - p_check_back_hh;
                            v_work2 := v_check_mm - p_check_back_mm;
                            IF v_work2 < 0 THEN
                                v_work2 := v_work2 + 60;
                                v_work := v_work -1;
                            END IF;
                            IF v_work < 0 THEN
                                v_work2 := ((v_work+24) * 100) + v_work2;
                                v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                            ELSE
                                v_work2 := (v_work * 100) + v_work2;
                                v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                            END IF;
                            v_work := v_work * 10000;
                            v_work := v_work + v_work2;
                            v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                            IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH'
                            AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                                IF p_log_level >= 3 THEN
                                    v_MsgText := 'Notification for failure to finish on time Skipped.'||
                                    ' Not started.'||' Notification already sent at '||
                                    to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'N');
                                    COMMIT;
                                END IF;
                            ELSE
                                v_notify_key := v_notify_key + 1;
                                UPDATE ws_wrk_mon_notify SET
                                    wmn_time_stamp = sysdate,
                                    wmn_job_key = v_MonRec.wmj_job_key,
                                    wmn_job_name = v_MonRec.wmj_job_name,
                                    wmn_notify_type = 'FINISH',
                                    wmn_script_key = v_MonRec.wmj_finish_script_key,
                                    wmn_parameter = v_MonRec.wmj_finish_param
                                WHERE wmn_notify_number = v_notify_key;

                                IF SQL%NOTFOUND THEN
                                    INSERT INTO ws_wrk_mon_notify
                                    ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                      wmn_job_name, wmn_notify_type, wmn_script_key,
                                      wmn_parameter)
                                    VALUES
                                    ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'FINISH', v_MonRec.wmj_finish_script_key,
                                      v_MonRec.wmj_finish_param);
                                 END IF;
                                 COMMIT;
                                IF p_log_level >= 2 THEN
                                    v_MsgText := 'Notification for failure to finish on time.'||
                                    ' Job not started, no running jobs. Last known finish was '||
                                    to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI')||
                                    '.';
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'Y');
                                    COMMIT;
                                END IF;
                                v_valid := 0; -- skip the rest of the checks
                                v_notify := 1;
                            END IF; -- end of notify request not run today
                        ELSE -- completed on time today
                            IF p_log_level >= 9 THEN
                                v_MsgText := 'Must finish by check found completed job. Current time is '||
                                    LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||
                                    '. Job finished at '||to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI')||
                                    ' which is before the required finish time of '||
                                    LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||
                                    ' All Okay.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        END IF; -- end of completed on time, but was it today check.
                    END IF; -- end of completed job found
                --=====================================================
                -- Not running and no completed entries therefore
                -- we haven't started so notify of a problem
                --=====================================================
                ELSE
                    -- About to notify, so check to see if we have already
                    -- sent a notification for this problem in our lookback
                    -- period. If we have then skip the notification
                    v_work := v_check_hh - p_check_back_hh;
                    v_work2 := v_check_mm - p_check_back_mm;
                    IF v_work2 < 0 THEN
                        v_work2 := v_work2 + 60;
                        v_work := v_work -1;
                    END IF;
                    IF v_work < 0 THEN
                        v_work2 := ((v_work+24) * 100) + v_work2;
                        v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                    ELSE
                        v_work2 := (v_work * 100) + v_work2;
                        v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                    END IF;
                    v_work := v_work * 10000;
                    v_work := v_work + v_work2;
                    v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                    IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'FINISH'
                    AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                        IF p_log_level >= 3 THEN
                            v_MsgText := 'Notification for failure to finish on time Skipped.'||
                            ' No running or completed jobs.'||' Notification already sent at '||
                            to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'N');
                            COMMIT;
                        END IF;
                    ELSE
                        v_notify_key := v_notify_key + 1;
                        UPDATE ws_wrk_mon_notify SET
                            wmn_time_stamp = sysdate,
                            wmn_job_key = v_MonRec.wmj_job_key,
                            wmn_job_name = v_MonRec.wmj_job_name,
                            wmn_notify_type = 'FINISH',
                            wmn_script_key = v_MonRec.wmj_finish_script_key,
                            wmn_parameter = v_MonRec.wmj_finish_param
                        WHERE wmn_notify_number = v_notify_key;

                        IF SQL%NOTFOUND THEN
                            INSERT INTO ws_wrk_mon_notify
                            ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                              wmn_job_name, wmn_notify_type, wmn_script_key,
                              wmn_parameter)
                            VALUES
                            ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'FINISH', v_MonRec.wmj_finish_script_key,
                              v_MonRec.wmj_finish_param);
                         END IF;
                         COMMIT;
                        IF p_log_level >= 2 THEN
                            v_MsgText := 'Notification for failure to finish on time. No Running or completed jobs';
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'Y');
                            COMMIT;
                        END IF;
                        v_valid := 0; -- skip the rest of the checks
                        v_notify := 1;
                    END IF;
                END IF;



            --=====================================================
            -- If Skipping the check log a message if log level 9
            --=====================================================
            ELSE
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Must finish by check skipped. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_finish_hh,2,'0')||':'||LPAD(v_finish_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is more than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;
            END IF;


        END IF; -- End of FINISH BY check

        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        -- R U N    S T A T U S    C H E C K S
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --=====================================================
        -- If RUN status checks are active check the jobs
        -- run status.
        --=====================================================
        IF v_valid = 1
        AND (   NVL(v_MonRec.wmj_run_warn_active,'N') = 'Y'
             OR NVL(v_MonRec.wmj_run_err_active,'N') = 'Y' ) THEN
            v_step := 700;

            --=====================================================
            -- If we have a completed job or a running job that
            -- has failed, we will check the lookback time.
            --=====================================================
            IF v_running = 1 THEN

                v_start_date := v_RunRec.wjr_started;
                v_skip_check := 0;
                --=====================================================
                -- Make sure that this is the current job.
                -- If not the current job then do not report it
                --=====================================================
--                IF v_start_date < v_abs_start THEN
--                    v_skip_check := 1; -- not the latest job so skip it
--                END IF; -- end of check that we are looking at the latest job

                --=====================================================
                -- If we have a check to do then perform it.
                --=====================================================
                IF v_skip_check = 0 THEN
                    v_step := 800;
                    --=====================================================
                    -- Log a message if log level 9
                    --=====================================================
                    IF p_log_level >= 9 THEN
                        v_MsgText := 'Run status check actioned. Current time '||
                            LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0');
                        INSERT INTO ws_wrk_mon_log
                        ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                          wml_job_name, wml_notify_ind )
                        VALUES
                        ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                          v_MonRec.wmj_job_name, 'N');
                        COMMIT;
                    END IF;

                    v_warn_count := v_RunRec.wjr_warning_count;
                    v_error_count := v_RunRec.wjr_error_count;

                    v_notify := 0;
                    --=====================================================
                    -- Check if a run error notify required
                    --=====================================================
                    IF NVL(v_MonRec.wmj_run_err_active,'N') = 'Y'
                    AND v_error_count > NVL(v_MonRec.wmj_run_err_count,0) THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'RUN_ERROR'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification of error during run Skipped.'||
                                ' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'RUN_ERROR',
                                wmn_script_key = v_MonRec.wmj_run_err_script_key,
                                wmn_parameter = v_MonRec.wmj_run_err_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'RUN_ERROR', v_MonRec.wmj_run_err_script_key,
                                  v_MonRec.wmj_run_err_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification of errors while running. '||
                                v_error_count||' errors detected.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                        v_notify := 1;
                    END IF;

                    --=====================================================
                    -- Check if a run warning notify required
                    -- and we have not done an error notification
                    --=====================================================
                    IF NVL(v_MonRec.wmj_run_warn_active,'N') = 'Y'
                    AND v_warn_count > NVL(v_MonRec.wmj_run_warn_count,0)
                    AND v_notify = 0 THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'RUN_WARNING'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification of running with warnings Skipped.'||
                                ' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'RUN_WARNING',
                                wmn_script_key = v_MonRec.wmj_run_warn_script_key,
                                wmn_parameter = v_MonRec.wmj_run_warn_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'RUN_WARNING', v_MonRec.wmj_run_warn_script_key,
                                  v_MonRec.wmj_run_warn_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification of running with warnings. '||
                                v_warn_count||' warnings produced.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                        v_notify := 1;
                    END IF;


                END IF; -- End of skip check test

            ELSE -- no running jobs so skip the test. Log if level 9
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Finish status check found no completed or failed jobs.'||
                        ' The current time is '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||
                        ' All Okay.';
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;
            END IF; -- end of have a completed job to test




        END IF; -- END of RUN STATUS CHECKS


        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        -- C H E C K P O I N T
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************

        --=====================================================
        -- If CHECKPOINT check is active, check that checkpoint hit
        -- We will only consider running jobs. completed or not
        -- started jobs are not considered
        --=====================================================
        IF  v_valid = 1
        AND v_running = 1
        AND (   NVL(v_MonRec.wmj_cp1_active,'N') = 'Y'
             OR NVL(v_MonRec.wmj_cp2_active,'N') = 'Y'
             OR NVL(v_MonRec.wmj_cp3_active,'N') = 'Y' ) THEN

            v_step := 900;
            v_cp_found := 0;
            v_skip_check := 0;

            --=====================================================
            -- We will use the last active checkpoint
            -- So start with 3 and if okay use that
            --=====================================================
            IF ( NVL(v_MonRec.wmj_cp3_active,'N') = 'Y' ) THEN
                --=====================================================
                -- Get the checkpoint time and see if we are within range
                --=====================================================
                v_cp_mm := v_MonRec.wmj_nominal_mm + v_MonRec.wmj_cp3_elapsed;
                v_cp_hh := v_MonRec.wmj_nominal_hh;
                WHILE v_cp_mm >= 60 LOOP
                    v_cp_hh := v_cp_hh + 1;
                    v_cp_mm := v_cp_mm - 60;
                END LOOP;
                WHILE v_cp_hh > 23 LOOP
                    v_cp_hh := v_cp_hh - 24;
                END LOOP;

                --=====================================================
                -- Get the difference between our check time and the
                -- checkpoint time
                --=====================================================
                IF   v_check_hh > v_cp_hh
                OR (     v_check_hh = v_cp_hh
                    AND v_check_mm  > v_cp_mm ) THEN
                    -- after the check point time
                    -- get the last checkpoint time
                    v_hh_last := v_check_hh - v_cp_hh;
                    v_mm_last := v_check_mm - v_cp_mm;
                    v_prev_day := 0;
                    IF v_mm_last < 0 THEN
                        v_mm_last := v_mm_last + 60;
                        v_hh_last := v_hh_last - 1;
                    END IF;
                ELSE
                    -- before the check finish time
                    -- get the next start time (same day)
                    v_hh_next := v_cp_hh - v_check_hh;
                    v_mm_next := v_cp_mm - v_check_mm;
                    IF v_mm_next < 0 THEN
                        v_mm_next := v_mm_next + 60;
                        v_hh_next := v_hh_next - 1;
                    END IF;
                    -- get the last finish time (previous day)
                    v_prev_day := 1;
                    v_hh_last := 23 - v_hh_next;
                    v_mm_last := 60 - v_mm_next;
                    IF v_mm_last = 60 THEN
                        v_mm_last := 0;
                        v_hh_last := v_hh_last + 1;
                    END IF;
                END IF;

                --=====================================================
                -- See if we are within our check range
                --=====================================================
                v_hh_diff := v_hh_last - p_check_back_hh;
                v_mm_diff := v_mm_last - p_check_back_mm;
                IF v_mm_diff < 0 THEN
                    v_hh_diff := v_hh_diff - 1;
                    v_mm_diff := v_mm_diff + 60;
                END IF;
                IF v_hh_diff > 0
                OR (     v_hh_diff = 0
                     AND v_mm_diff > 0 ) THEN
                    v_skip_check := 0;
                ELSE
                    v_skip_check := 0;
                    v_cp_found := 3;
                END IF;

            END IF; -- End of checkpoint 3 test

            --=====================================================
            -- If no checkpoint found and not skipping then try 2
            --=====================================================
            IF  NVL(v_MonRec.wmj_cp2_active,'N') = 'Y'
            AND v_cp_found = 0
            AND v_skip_check = 0 THEN
                --=====================================================
                -- Get the checkpoint time and see if we are within range
                --=====================================================
                v_cp_mm := v_MonRec.wmj_nominal_mm + v_MonRec.wmj_cp2_elapsed;
                v_cp_hh := v_MonRec.wmj_nominal_hh;
                WHILE v_cp_mm >= 60 LOOP
                    v_cp_hh := v_cp_hh + 1;
                    v_cp_mm := v_cp_mm - 60;
                END LOOP;
                WHILE v_cp_hh > 23 LOOP
                    v_cp_hh := v_cp_hh - 24;
                END LOOP;

                --=====================================================
                -- Get the difference between our check time and the
                -- checkpoint time
                --=====================================================
                IF   v_check_hh > v_cp_hh
                OR (     v_check_hh = v_cp_hh
                    AND v_check_mm  > v_cp_mm ) THEN
                    -- after the check point time
                    -- get the last checkpoint time
                    v_hh_last := v_check_hh - v_cp_hh;
                    v_mm_last := v_check_mm - v_cp_mm;
                    v_prev_day := 0;
                    IF v_mm_last < 0 THEN
                        v_mm_last := v_mm_last + 60;
                        v_hh_last := v_hh_last - 1;
                    END IF;
                ELSE
                    -- before the check finish time
                    -- get the next start time (same day)
                    v_hh_next := v_cp_hh - v_check_hh;
                    v_mm_next := v_cp_mm - v_check_mm;
                    IF v_mm_next < 0 THEN
                        v_mm_next := v_mm_next + 60;
                        v_hh_next := v_hh_next - 1;
                    END IF;
                    -- get the last finish time (previous day)
                    v_prev_day := 1;
                    v_hh_last := 23 - v_hh_next;
                    v_mm_last := 60 - v_mm_next;
                    IF v_mm_last = 60 THEN
                        v_mm_last := 0;
                        v_hh_last := v_hh_last + 1;
                    END IF;
                END IF;

                --=====================================================
                -- See if we are within our check range
                --=====================================================
                v_hh_diff := v_hh_last - p_check_back_hh;
                v_mm_diff := v_mm_last - p_check_back_mm;
                IF v_mm_diff < 0 THEN
                    v_hh_diff := v_hh_diff - 1;
                    v_mm_diff := v_mm_diff + 60;
                END IF;
                IF v_hh_diff > 0
                OR (     v_hh_diff = 0
                     AND v_mm_diff > 0 ) THEN
                    v_skip_check := 0;
                ELSE
                    v_skip_check := 0;
                    v_cp_found := 2;
                END IF;
            END IF; -- End of checkpoint 2 test

            --=====================================================
            -- If no checkpoint found and not skipping then try 1
            --=====================================================
            IF  NVL(v_MonRec.wmj_cp1_active,'N') = 'Y'
            AND v_cp_found = 0
            AND v_skip_check = 0 THEN
                --=====================================================
                -- Get the checkpoint time and see if we are within range
                --=====================================================
                v_cp_mm := v_MonRec.wmj_nominal_mm + v_MonRec.wmj_cp1_elapsed;
                v_cp_hh := v_MonRec.wmj_nominal_hh;
                WHILE v_cp_mm >= 60 LOOP
                    v_cp_hh := v_cp_hh + 1;
                    v_cp_mm := v_cp_mm - 60;
                END LOOP;
                WHILE v_cp_hh > 23 LOOP
                    v_cp_hh := v_cp_hh - 24;
                END LOOP;

                --=====================================================
                -- Get the difference between our check time and the
                -- checkpoint time
                --=====================================================
                IF   v_check_hh > v_cp_hh
                OR (     v_check_hh = v_cp_hh
                    AND v_check_mm  > v_cp_mm ) THEN
                    -- after the check point time
                    -- get the last checkpoint time
                    v_hh_last := v_check_hh - v_cp_hh;
                    v_mm_last := v_check_mm - v_cp_mm;
                    v_prev_day := 0;
                    IF v_mm_last < 0 THEN
                        v_mm_last := v_mm_last + 60;
                        v_hh_last := v_hh_last - 1;
                    END IF;
                ELSE
                    -- before the check finish time
                    -- get the next start time (same day)
                    v_hh_next := v_cp_hh - v_check_hh;
                    v_mm_next := v_cp_mm - v_check_mm;
                    IF v_mm_next < 0 THEN
                        v_mm_next := v_mm_next + 60;
                        v_hh_next := v_hh_next - 1;
                    END IF;
                    -- get the last finish time (previous day)
                    v_prev_day := 1;
                    v_hh_last := 23 - v_hh_next;
                    v_mm_last := 60 - v_mm_next;
                    IF v_mm_last = 60 THEN
                        v_mm_last := 0;
                        v_hh_last := v_hh_last + 1;
                    END IF;
                END IF;

                --=====================================================
                -- See if we are within our check range
                --=====================================================
                v_hh_diff := v_hh_last - p_check_back_hh;
                v_mm_diff := v_mm_last - p_check_back_mm;
                IF v_mm_diff < 0 THEN
                    v_hh_diff := v_hh_diff - 1;
                    v_mm_diff := v_mm_diff + 60;
                END IF;
                IF v_hh_diff > 0
                OR (     v_hh_diff = 0
                     AND v_mm_diff > 0 ) THEN
                    v_skip_check := 1; -- no more to test
                ELSE
                    v_skip_check := 0;
                    v_cp_found := 1;
                END IF;
            END IF; -- End of checkpoint 1 test

            --=====================================================
            -- If we have an active checkpoint then process it
            --=====================================================
            IF v_cp_found <> 0 THEN
                --=====================================================
                -- work out the required checkpoint date
                --=====================================================
                v_work := to_number(to_char(v_check_date-v_prev_day,'YYYYMMDD'));
                v_work := v_work * 10000;
                v_work := v_work + ( v_cp_hh * 100 );
                v_work := v_work + v_cp_mm;
                v_cp_date := to_date(v_work,'YYYYMMDDHH24MI');

                --=====================================================
                -- In range for the checkpoint so see if we meet
                -- The checkpoint criteria
                -- First get the criteria for the appropriate checkpoint
                --=====================================================
                IF v_cp_found = 1 THEN
                    v_task_count := v_MonRec.wmj_cp1_task_count;
                    v_info_count := v_MonRec.wmj_cp1_info_count;
                    v_cp_script_key := v_MonRec.wmj_cp1_script_key;
                    v_cp_param := v_MonRec.wmj_cp1_param;
                ELSIF v_cp_found = 2 THEN
                    v_task_count := v_MonRec.wmj_cp2_task_count;
                    v_info_count := v_MonRec.wmj_cp2_info_count;
                    v_cp_script_key := v_MonRec.wmj_cp2_script_key;
                    v_cp_param := v_MonRec.wmj_cp2_param;
                ELSE
                    v_task_count := v_MonRec.wmj_cp3_task_count;
                    v_info_count := v_MonRec.wmj_cp3_info_count;
                    v_cp_script_key := v_MonRec.wmj_cp3_script_key;
                    v_cp_param := v_MonRec.wmj_cp3_param;
                END IF;

                v_notify_type := 'CHECKPOINT'||to_char(v_cp_found);
                v_info_messages := NVL(v_RunRec.wjr_okay_count,0) + NVL(v_RunRec.wjr_info_count,0);

                --=====================================================
                -- Log a message if log level 9
                --=====================================================
                IF p_log_level >= 9 THEN
                    v_MsgText := lower(v_notify_type)||' actioned. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_cp_hh,2,'0')||':'||LPAD(v_cp_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is less than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;

                --=====================================================
                -- If task count not set to zero then check the number
                -- of completed tasks
                --=====================================================
                IF v_task_count > 0 THEN
                    -- If fewer than the required number of tasks have
                    -- completed then page
                    IF v_tasks_completed < v_task_count THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = v_notify_type
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure of '||v_notify_type||
                                ' Skipped. Found only '||v_tasks_completed||' completed tasks, checkpoint required '||
                                v_task_count||'. Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = v_notify_type,
                                wmn_script_key = v_cp_script_key,
                                wmn_parameter = v_cp_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, v_notify_type, v_cp_script_key,
                                  v_cp_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure of '||v_notify_type||
                                '. Found only '||v_tasks_completed||' completed tasks, checkpoint required '||
                                v_task_count||'.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                    --=====================================================
                    -- If Skipping the check (found enough) log a message if log level 9
                    --=====================================================
                    ELSE
                        IF p_log_level >= 9 THEN
                            v_MsgText := 'Checkpoint check '||v_notify_type||
                            '. Found  '||v_tasks_completed||' completed tasks, checkpoint required '||
                            v_task_count||'. All Okay. ';
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'N');
                            COMMIT;
                        END IF;
                    END IF; -- end of not enough tasks
                END IF; -- End of completed task check

                --=====================================================
                -- If info count not set to zero then check the number
                -- of completed tasks, unless we have already notified
                --=====================================================
                IF v_info_count > 0 AND v_valid = 1 THEN
                    -- If we have fewer than the required number of info
                    -- messages then page
                    IF v_info_messages < v_info_count THEN

                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = v_notify_type
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure of '||v_notify_type||
                                ' Skipped. Found only '||v_info_messages||
                                ' okay and info messages, checkpoint required '||
                                v_info_count||'. Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = v_notify_type,
                                wmn_script_key = v_cp_script_key,
                                wmn_parameter = v_cp_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, v_notify_type, v_cp_script_key,
                                  v_cp_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure of '||v_notify_type||
                                '. Found only '||v_info_messages||
                                ' okay and info messages, checkpoint required '||
                                v_info_count||'.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;
                    --=====================================================
                    -- If Skipping the check (found enough) log a message if log level 9
                    --=====================================================
                    ELSE
                        IF p_log_level >= 9 THEN
                            v_MsgText := 'Checkpoint check '||v_notify_type||
                            '. Found  '||v_info_messages||
                            ' okay and info messages, checkpoint required '||
                            v_info_count||'. All Okay. ';
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'N');
                            COMMIT;
                        END IF;
                    END IF; -- end of not enough messages
                END IF; -- End of information message count check

            -- No checkpoints to be checked so if logging level 9 tell them we skipped
            ELSE
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Checkpoint checks skipped. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_cp_hh,2,'0')||':'||LPAD(v_cp_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is more than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;
            END IF; -- End of a checkpoint to be checked
        END IF; -- ENd of checkpoint checks

        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        -- S T A R T
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --*************************************************************************************************
        --=====================================================
        -- If START time check is active check that the job
        -- started on time.
        --=====================================================
        IF NVL(v_MonRec.wmj_start_active,'N') = 'Y' AND v_valid = 1 THEN
            v_step := 1000;
            v_skip_check := 0;

            v_start_mm := v_MonRec.wmj_nominal_mm + v_MonRec.wmj_start_elapsed;
            v_start_hh := v_MonRec.wmj_nominal_hh;
            WHILE v_start_mm >= 60 LOOP
                v_start_hh := v_start_hh + 1;
                v_start_mm := v_start_mm - 60;
            END LOOP;
            WHILE v_start_hh > 23 LOOP
                v_start_hh := v_start_hh - 24;
            END LOOP;


            --=====================================================
            -- Get the difference between our check time and the
            -- last must start by time and the next must start by time
            --=====================================================
            v_prev_day := 0;
            IF   v_check_hh > v_start_hh
            OR (     v_check_hh = v_start_hh
                AND v_check_mm  > v_start_mm ) THEN
                -- ahead of the check start time
                -- get the last start time (same day)
                v_hh_last := v_check_hh - v_start_hh;
                v_mm_last := v_check_mm - v_start_mm;
                IF v_mm_last < 0 THEN
                    v_mm_last := v_mm_last + 60;
                    v_hh_last := v_hh_last - 1;
                END IF;
                -- get the next start time (next day)
                v_hh_next := 23 - v_hh_last;
                v_mm_next := 60 - v_mm_last;
                IF v_mm_next = 60 THEN
                    v_mm_next := 0;
                    v_hh_next := v_hh_next + 1;
                END If;
            ELSE
                -- before the check start time
                -- get the next start time (same day)
                v_hh_next := v_start_hh - v_check_hh;
                v_mm_next := v_start_mm - v_check_mm;
                IF v_mm_next < 0 THEN
                    v_mm_next := v_mm_next + 60;
                    v_hh_next := v_hh_next - 1;
                END IF;
                -- get the last start time (previous day)
                v_prev_day := 1;
                v_hh_last := 23 - v_hh_next;
                v_mm_last := 60 - v_mm_next;
                IF v_mm_last = 60 THEN
                    v_mm_last := 0;
                    v_hh_last := v_hh_last + 1;
                END If;

            END IF;

            --=====================================================
            -- See if we are within our check range
            --=====================================================
            v_hh_diff := v_hh_last - p_check_back_hh;
            v_mm_diff := v_mm_last - p_check_back_mm;
            IF v_mm_diff < 0 THEN
                v_hh_diff := v_hh_diff - 1;
                v_mm_diff := v_mm_diff + 60;
            END IF;
            IF v_hh_diff > 0
            OR (     v_hh_diff = 0
                 AND v_mm_diff > 0 ) THEN
                v_skip_check := 1;
            ELSE
                v_skip_check := 0;
            END IF;

            --=====================================================
            -- work out the required start date
            --=====================================================
            v_work := to_number(to_char(v_check_date-v_prev_day,'YYYYMMDD'));
            v_work := v_work * 10000;
            v_work := v_work + ( v_start_hh * 100 );
            v_work := v_work + v_start_mm;
            v_start_date := to_date(v_work,'YYYYMMDDHH24MI');

            --=====================================================
            -- If we have a check to do then perform it.
            --=====================================================
            IF v_skip_check = 0 THEN
                v_step := 1100;
                --=====================================================
                -- Log a message if log level 9
                --=====================================================
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Must start by check actioned. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is less than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;

                --=====================================================
                -- If we are running then check the start time to ensure
                -- this is not an old iteration
                --=====================================================
                IF v_running = 1 THEN
                    v_step := 1200;

                    -- Started after required start time
                    IF v_RunRec.wjr_started > v_start_date THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'START'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure to start on time Skipped.'||
                                ' Job started late.'||' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'START',
                                wmn_script_key = v_MonRec.wmj_start_script_key,
                                wmn_parameter = v_MonRec.wmj_start_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'START', v_MonRec.wmj_start_script_key,
                                  v_MonRec.wmj_start_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure to start on time.'||
                                ' Job started late at ' ||
                                to_char(v_RunRec.wjr_started,'DD-MON-YYYY HH24:MI')||
                                '. Start was required by '||
                                LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF; -- end of prior notification test

                    -- Ensure that this is a current iteration
                    -- i.e. that it didn't start before the absolute start time
                    ELSIF v_RunRec.wjr_started < v_abs_start THEN

                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'START'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure to start on time Skipped.'||
                                ' Job running previous iteration.'||' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'START',
                                wmn_script_key = v_MonRec.wmj_start_script_key,
                                wmn_parameter = v_MonRec.wmj_start_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'START', v_MonRec.wmj_start_script_key,
                                  v_MonRec.wmj_start_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure to start on time.'||
                                ' Job still running prior invocation which started at ' ||
                                to_char(v_RunRec.wjr_started,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;

                    ELSE
                        IF p_log_level >= 9 THEN
                            v_MsgText := 'Must start by check found running job. '||
                                'Job started at '||to_char(v_RunRec.wjr_started,'DD-MON-YYYY HH24:MI')||
                                ' which is before the required start of '||
                                LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0')||
                                ' and after the absolute minimum start of '||
                                LPAD(v_abs_hh,2,'0')||':'||LPAD(v_abs_mm,2,'0')||
                                ' All Okay.';
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'N');
                            COMMIT;
                        END IF;
                    END IF;
                --=====================================================
                -- If not running then if we have a completed entry
                -- check to see if it started after the absolute min start
                -- time. If prior to that then an earlier version.
                --=====================================================
                ELSIF v_completed = 1 THEN
                    v_step := 1300;
                    -- Ensure not a previous iteration
                    IF v_LogRec.wjl_started < v_abs_start THEN
                        -- About to notify, so check to see if we have already
                        -- sent a notification for this problem in our lookback
                        -- period. If we have then skip the notification
                        v_work := v_check_hh - p_check_back_hh;
                        v_work2 := v_check_mm - p_check_back_mm;
                        IF v_work2 < 0 THEN
                            v_work2 := v_work2 + 60;
                            v_work := v_work -1;
                        END IF;
                        IF v_work < 0 THEN
                            v_work2 := ((v_work+24) * 100) + v_work2;
                            v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                        ELSE
                            v_work2 := (v_work * 100) + v_work2;
                            v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                        END IF;
                        v_work := v_work * 10000;
                        v_work := v_work + v_work2;
                        v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                        IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'START'
                        AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                            IF p_log_level >= 3 THEN
                                v_MsgText := 'Notification for failure to start on time Skipped.'||
                                ' No running job.'||' Notification already sent at '||
                                to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        ELSE
                            v_notify_key := v_notify_key + 1;
                            UPDATE ws_wrk_mon_notify SET
                                wmn_time_stamp = sysdate,
                                wmn_job_key = v_MonRec.wmj_job_key,
                                wmn_job_name = v_MonRec.wmj_job_name,
                                wmn_notify_type = 'START',
                                wmn_script_key = v_MonRec.wmj_start_script_key,
                                wmn_parameter = v_MonRec.wmj_start_param
                            WHERE wmn_notify_number = v_notify_key;

                            IF SQL%NOTFOUND THEN
                                INSERT INTO ws_wrk_mon_notify
                                ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                  wmn_job_name, wmn_notify_type, wmn_script_key,
                                  wmn_parameter)
                                VALUES
                                ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'START', v_MonRec.wmj_start_script_key,
                                  v_MonRec.wmj_start_param);
                             END IF;
                             COMMIT;
                            IF p_log_level >= 2 THEN
                                v_MsgText := 'Notification for failure to start on time.'||
                                ' No running jobs and previous job started '||
                                to_char(v_LogRec.wjl_started,'DD-MON-YYYY HH24:MI')||
                                ' and completed '||
                                to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI');
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'Y');
                                COMMIT;
                            END IF;
                            v_valid := 0; -- skip the rest of the checks
                            v_notify := 1;
                        END IF;

                    ELSE -- current iteration, now check to see if started on time

                        IF v_LogRec.wjl_started > v_start_date THEN
                            -- About to notify, so check to see if we have already
                            -- sent a notification for this problem in our lookback
                            -- period. If we have then skip the notification
                            v_work := v_check_hh - p_check_back_hh;
                            v_work2 := v_check_mm - p_check_back_mm;
                            IF v_work2 < 0 THEN
                                v_work2 := v_work2 + 60;
                                v_work := v_work -1;
                            END IF;
                            IF v_work < 0 THEN
                                v_work2 := ((v_work+24) * 100) + v_work2;
                                v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                            ELSE
                                v_work2 := (v_work * 100) + v_work2;
                                v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                            END IF;
                            v_work := v_work * 10000;
                            v_work := v_work + v_work2;
                            v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                            IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'START'
                            AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                                IF p_log_level >= 3 THEN
                                    v_MsgText := 'Notification for failure to start on time Skipped.'||
                                    ' Started late.'||' Notification already sent at '||
                                    to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'N');
                                    COMMIT;
                                END IF;
                            ELSE
                                v_notify_key := v_notify_key + 1;
                                UPDATE ws_wrk_mon_notify SET
                                    wmn_time_stamp = sysdate,
                                    wmn_job_key = v_MonRec.wmj_job_key,
                                    wmn_job_name = v_MonRec.wmj_job_name,
                                    wmn_notify_type = 'START',
                                    wmn_script_key = v_MonRec.wmj_start_script_key,
                                    wmn_parameter = v_MonRec.wmj_start_param
                                WHERE wmn_notify_number = v_notify_key;

                                IF SQL%NOTFOUND THEN
                                    INSERT INTO ws_wrk_mon_notify
                                    ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                                      wmn_job_name, wmn_notify_type, wmn_script_key,
                                      wmn_parameter)
                                    VALUES
                                    ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'START', v_MonRec.wmj_start_script_key,
                                      v_MonRec.wmj_start_param);
                                 END IF;
                                 COMMIT;
                                IF p_log_level >= 2 THEN
                                    v_MsgText := 'Notification for failure to start on time.'||
                                    ' Job started late at '||
                                    to_char(v_LogRec.wjl_started,'DD-MON-YYYY HH24:MI')||
                                    ' and completed '||
                                    to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI')||
                                    '. Start was required by '||
                                    LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0');
                                    INSERT INTO ws_wrk_mon_log
                                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                      wml_job_name, wml_notify_ind )
                                    VALUES
                                    ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                                      v_MonRec.wmj_job_name, 'Y');
                                    COMMIT;
                                END IF;
                                v_valid := 0; -- skip the rest of the checks
                                v_notify := 1;
                            END IF;

                        ELSE -- all okay
                            IF p_log_level >= 9 THEN
                                v_MsgText := 'Must start by check found completed job. '||
                                    'Job started at '||to_char(v_LogRec.wjl_started,'DD-MON-YYYY HH24:MI')||
                                    ' and completed '||
                                    to_char(v_LogRec.wjl_completed,'DD-MON-YYYY HH24:MI')||
                                    ' which is before the must start by time of '||
                                    LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0')||
                                    '. All Okay.';
                                INSERT INTO ws_wrk_mon_log
                                ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                                  wml_job_name, wml_notify_ind )
                                VALUES
                                ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                                  v_MonRec.wmj_job_name, 'N');
                                COMMIT;
                            END IF;
                        END IF; -- end of did it start on time
                    END IF; -- end of completed job
                --=====================================================
                -- Not running and no completed entries therefore
                -- we haven't started so notify of a problem
                --=====================================================
                ELSE
                    -- About to notify, so check to see if we have already
                    -- sent a notification for this problem in our lookback
                    -- period. If we have then skip the notification
                    v_work := v_check_hh - p_check_back_hh;
                    v_work2 := v_check_mm - p_check_back_mm;
                    IF v_work2 < 0 THEN
                        v_work2 := v_work2 + 60;
                        v_work := v_work -1;
                    END IF;
                    IF v_work < 0 THEN
                        v_work2 := ((v_work+24) * 100) + v_work2;
                        v_work := to_number(to_char(sysdate-1,'YYYYMMDD'));
                    ELSE
                        v_work2 := (v_work * 100) + v_work2;
                        v_work := to_number(to_char(sysdate,'YYYYMMDD'));
                    END IF;
                    v_work := v_work * 10000;
                    v_work := v_work + v_work2;
                    v_required_check := to_date(v_work,'YYYYMMDDHH24MI');


                    IF  NVL(v_MonRec.wmj_last_notify_type,'XX') = 'START'
                    AND NVL(v_MonRec.wmj_last_notify_date,sysdate-10) > v_required_check THEN
                        IF p_log_level >= 3 THEN
                            v_MsgText := 'Notification for failure to start on time Skipped.'||
                            ' No running or completed jobs.'||' Notification already sent at '||
                            to_char(v_MonRec.wmj_last_notify_date,'DD-MON-YYYY HH24:MI');
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'N');
                            COMMIT;
                        END IF;
                    ELSE
                        v_notify_key := v_notify_key + 1;
                        UPDATE ws_wrk_mon_notify SET
                            wmn_time_stamp = sysdate,
                            wmn_job_key = v_MonRec.wmj_job_key,
                            wmn_job_name = v_MonRec.wmj_job_name,
                            wmn_notify_type = 'START',
                            wmn_script_key = v_MonRec.wmj_start_script_key,
                            wmn_parameter = v_MonRec.wmj_start_param
                        WHERE wmn_notify_number = v_notify_key;

                        IF SQL%NOTFOUND THEN
                            INSERT INTO ws_wrk_mon_notify
                            ( wmn_notify_number, wmn_time_stamp, wmn_job_key,
                              wmn_job_name, wmn_notify_type, wmn_script_key,
                              wmn_parameter)
                            VALUES
                            ( v_notify_key, sysdate, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'START', v_MonRec.wmj_start_script_key,
                              v_MonRec.wmj_start_param);
                         END IF;
                         COMMIT;
                        IF p_log_level >= 2 THEN
                            v_MsgText := 'Notification for failure to start on time. No Running or completed jobs';
                            INSERT INTO ws_wrk_mon_log
                            ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                              wml_job_name, wml_notify_ind )
                            VALUES
                            ( sysdate, 'W', v_MsgText, v_MonRec.wmj_job_key,
                              v_MonRec.wmj_job_name, 'Y');
                            COMMIT;
                        END IF;
                        v_valid := 0; -- skip the rest of the checks
                        v_notify := 1;
                    END IF;
                END IF;



            --=====================================================
            -- If Skipping the check log a message if log level 9
            --=====================================================
            ELSE
                IF p_log_level >= 9 THEN
                    v_MsgText := 'Must start by check skipped. Current time '||
                        LPAD(v_check_hh,2,'0')||':'||LPAD(v_check_mm,2,'0')||'. Check was for '||
                        LPAD(v_start_hh,2,'0')||':'||LPAD(v_start_mm,2,'0')||' back '||
                        LPAD(v_hh_last,2,'0')||':'||LPAD(v_mm_last,2,'0')||' which is more than look back of '||
                        LPAD(p_check_back_hh,2,'0')||':'||LPAD(p_check_back_mm,2,'0');
                    INSERT INTO ws_wrk_mon_log
                    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
                      wml_job_name, wml_notify_ind )
                    VALUES
                    ( sysdate, 'I', v_MsgText, v_MonRec.wmj_job_key,
                      v_MonRec.wmj_job_name, 'N');
                    COMMIT;
                END IF;
            END IF;


        END IF; -- End of Start Check




    --**************************************************************************************************************
    -- END OF CHECKS
    --**************************************************************************************************************

    END LOOP; -- End of Jobs to check


    COMMIT;
    -- Maximum of 9 notifies
    IF v_notify_key > 9 THEN
        v_notify_key := 9;
    END IF;
    p_job_count := v_notify_key;
    RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_mon_job_check. '||
                ' Step ' ||v_step;
    INSERT INTO ws_wrk_mon_log
    ( wml_time_stamp, wml_status, wml_message, wml_job_key,
      wml_job_name, wml_notify_ind )
    VALUES
    ( sysdate, 'E', v_MsgText, NULL,
      NULL, 'N');
    COMMIT;
    p_job_count := 0;
    RETURN -3;

END ws_mon_job_check;
 
_PROCEDURE_ Ws_Job_Schedule 
-- Notes / History
--
-- V4.1.1.2 WMR  18/10/2004 Created from Ws_Job_Release
-- V8.4.1.0 HM   13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_schedule
    (
    p_sequence     IN  number,
    p_job_name     IN  varchar2,
    p_task_name    IN  varchar2,
    p_job_id       IN  number,
    p_task_id      IN  number,
    p_release_job  IN  varchar2,
    p_release_time IN  date,
    p_return_code  OUT varchar2,
    p_return_msg   OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_schedule
    -- Description         :    Releases a held or waiting job to run at a specified time
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_msg             varchar2(4000);
    v_job_sequence    integer;
    v_job_key         integer;
    v_job_status      varchar2(1);

BEGIN

    v_step := 10;
    --***********************************************************************
    -- First see if the job name specified is in a held or waiting state
    -- If not in a held or waiting state report and exit
    --***********************************************************************
    BEGIN
        Select wjc_job_key, wjc_sequence, wjc_status
        Into v_job_key, v_job_sequence, v_job_status
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_release_job));
    EXCEPTION WHEN OTHERS THEN
        v_job_key := 0;
    END;

    v_step := 20;
    --***********************************************************************
    -- If not scheduled exit with that information
    --***********************************************************************
    If nvl(v_job_key,0) = 0 Then
        p_return_msg := 'Job '||p_release_job||' is not in a holding or waiting state. Cannot reschedule';
        p_return_code := 'N';
        return -1;
    End If;

    v_step := 60;
    --***********************************************************************
    -- Set the flag to indicate that the job is waiting so the
    -- scheduler will restart it
    --***********************************************************************
    BEGIN
        Update ws_wrk_job_ctrl
        Set
          wjc_status = 'W',
          wjc_start_after = p_release_time
        Where wjc_job_key = v_job_key
        And wjc_status in ('H','W');

        Commit;

        p_return_code := 'S';
        p_return_msg := 'Job '||p_release_job||' rescheduled. It Will start at '||p_release_time;
        RETURN 1;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to reschedule Job '||p_release_job||' '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        RETURN -2;
    END;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'F';
        v_MsgText := 'Unhandled Exception in ws_job_schedule. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_schedule;
 
_PROCEDURE_ Ws_Job_Release 
-- Notes / History
--
-- V1.0.6.0 WMR 20/03/2002
-- V8.4.1.0 HM  13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_release
    (
    p_sequence    IN  number,
    p_job_name    IN  varchar2,
    p_task_name   IN  varchar2,
    p_job_id      IN  number,
    p_task_id     IN  number,
    p_release_job IN  varchar2,
    p_return_code OUT varchar2,
    p_return_msg  OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name 	         	:	Oracle
    -- Script Name 		:	ws_job_release
    -- Description 		:	Releases a held or waiting job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_msg             varchar2(4000);
    v_job_sequence    integer;
    v_job_key         integer;
    v_job_status      varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --***********************************************************************
    -- First see if the job name specified is in a held or waiting state
    -- If not in a held or waiting state report and exit
    --***********************************************************************
    BEGIN
        Select wjc_job_key, wjc_sequence, wjc_status
        Into v_job_key, v_job_sequence, v_job_status
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_release_job));
    EXCEPTION WHEN OTHERS THEN
        v_job_key := 0;
    END;

    v_step := 20;
    --***********************************************************************
    -- If not scheduled exit with that information
    --***********************************************************************
    If nvl(v_job_key,0) = 0 Then
        p_return_msg := 'Job '||p_release_job||' is not in a holding or waiting state. Cannot release';
        p_return_code := 'N';
        return -1;
    End If;

    v_step := 60;
    --***********************************************************************
    -- Set the flag to indicate that the job is waiting so the
    -- scheduler will restart it
    --***********************************************************************
    BEGIN
        Update ws_wrk_job_ctrl
        Set
          wjc_status = 'W',
          wjc_start_after = sysdate
        Where wjc_job_key = v_job_key
        And wjc_status in ('H','W');

        Commit;

        p_return_code := 'S';
        p_return_msg := 'Job '||p_release_job||' released.';
        RETURN 1;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to release Job '||p_release_job||' '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        RETURN -2;
    END;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'F';
        v_MsgText := 'Unhandled Exception in ws_job_release. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_release;
 
_PROCEDURE_ Ws_Job_Create 
-- Notes / History
--
-- WMR 23/04/2004   Version 4.1.0.8
-- KH   1/11/2018   Version 8.3.1.0 RED-9838 wtc_action_ind added to task copy row.
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.


CREATE OR REPLACE function ws_job_create
    (
    p_sequence        IN  number,
    p_job_name        IN  varchar2,
    p_task_name       IN  varchar2,
    p_job_id          IN  number,
    p_task_id         IN  number,
    p_template_job    IN  varchar2,
    p_new_job         IN  varchar2,
    p_description     IN  varchar2,
    p_state           IN  varchar2,
    p_threads         IN  number,
    p_scheduler       IN  varchar2,
    p_logs            IN  number,
    p_okay            IN  varchar2,
    p_fail            IN  varchar2,
    p_att1            IN  varchar2,
    p_att2            IN  varchar2,
    p_att3            IN  varchar2,
    p_att4            IN  varchar2,
    p_att5            IN  varchar2,
    p_att6            IN  varchar2,
    p_att7            IN  varchar2,
    p_att8            IN  varchar2,
    p_return_code     OUT varchar2,
    p_return_msg      OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_create
    -- Description         :    Releases a held or waiting job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_msg             varchar2(4000);
    v_old_key         integer;
    v_old_sequence    integer;
    v_old_status      varchar2(1);
    v_new_key         integer;
    v_new_sequence    integer;
    v_wjc_status      varchar2(1);
    v_wjc_type        varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --***********************************************************************
    -- First see if the job name specified is in a held or waiting state
    -- If not in a held or waiting state report and exit
    --***********************************************************************
    BEGIN
        Select wjc_job_key, wjc_sequence, wjc_status
        Into v_old_key, v_old_sequence, v_old_status
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_template_job));
    EXCEPTION WHEN OTHERS THEN
        v_old_key := 0;
    END;

    v_step := 20;
    --***********************************************************************
    -- If not scheduled exit with that information
    --***********************************************************************
    If nvl(v_old_key,0) = 0 Then
        p_return_msg := 'Job '||p_template_job||' is not in a holding or waiting state. Cannot create new job';
        p_return_code := 'N';
        return -1;
    End If;

    v_step := 30;
    --***********************************************************************
    -- Make sure we have no job that matches our new job name
    --***********************************************************************
    BEGIN
        Select count(*)
        Into v_count
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_new_job));
    EXCEPTION WHEN OTHERS THEN
        v_count := 1;
    END;

    IF v_count > 0 THEN
        p_return_msg := 'Job '||p_new_job||' already exists. Cannot create a new job of the same name';
        p_return_code := 'P';
        return -1;
    END IF;

    v_step := 60;
    --***********************************************************************
    -- Get the right state for the new job and the sequence
    --***********************************************************************
    IF rtrim(upper(p_state)) = 'ONCE' THEN
      v_wjc_status := 'W';
      v_wjc_type := 'O';
    ELSIF rtrim(upper(p_state)) = 'ONCE+HOLD' THEN
      v_wjc_status := 'W';
      v_wjc_type := 'S';
    ELSE
      v_wjc_status := 'H';
      v_wjc_type := 'H';
    END IF;

    SELECT ws_job_seq.nextval INTO v_new_sequence FROM dual;


    v_step := 70;
    --***********************************************************************
    -- Add the new job in a held state, so that we can add the tasks/dependencies
    --***********************************************************************
    BEGIN
        INSERT into ws_wrk_job_ctrl
        (
          wjc_job_key
        , wjc_name
        , wjc_description
        , wjc_sequence
        , wjc_group_key
        , wjc_project_key
        , wjc_status
        , wjc_last_status
        , wjc_type
        , wjc_submitted
        , wjc_first_schedule
        , wjc_start_hour
        , wjc_start_minute
        , wjc_start_day
        , wjc_user_key
        , wjc_start_after
        , wjc_started
        , wjc_completed
        , wjc_max_elapsed
        , wjc_task_elapsed
        , wjc_avg_elapsed
        , wjc_avg_count
        , wjc_publish_okay
        , wjc_publish_fail
        , wjc_task_fatal
        , wjc_task_error
        , wjc_task_warning
        , wjc_task_info
        , wjc_task_okay
        , wjc_chkp_count
        , wjc_max_threads
        , wjc_priority
        , wjc_publish_flag
        , wjc_scheduler
        , wjc_cust_sa_hh
        , wjc_cust_sa_mm
        , wjc_cust_sb_hh
        , wjc_cust_sb_mm
        , wjc_cust_min
        , wjc_cust_days
        )
        SELECT
          v_new_sequence
        , p_new_job
        , NVL(p_description,wjc_description)
        , v_new_sequence
        , wjc_group_key
        , wjc_project_key
        , 'H'
        , wjc_last_status
        , v_wjc_type
        , wjc_submitted
        , wjc_first_schedule
        , wjc_start_hour
        , wjc_start_minute
        , wjc_start_day
        , wjc_user_key
        , SYSDATE
        , wjc_started
        , wjc_completed
        , wjc_max_elapsed
        , wjc_task_elapsed
        , wjc_avg_elapsed
        , NVL(p_logs,wjc_avg_count)
        , NVL(p_okay,wjc_publish_okay)
        , NVL(p_fail,wjc_publish_fail)
        , wjc_task_fatal
        , wjc_task_error
        , wjc_task_warning
        , wjc_task_info
        , wjc_task_okay
        , wjc_chkp_count
        , NVL(p_threads,wjc_max_threads)
        , wjc_priority
        , wjc_publish_flag
        , NVL(p_scheduler,wjc_scheduler)
        , wjc_cust_sa_hh
        , wjc_cust_sa_mm
        , wjc_cust_sb_hh
        , wjc_cust_sb_mm
        , wjc_cust_min
        , wjc_cust_days
        FROM ws_wrk_job_ctrl
        Where wjc_job_key = v_old_key
        And wjc_status in ('H','W');

        --***********************************************************************
        -- Add all the tasks
        --***********************************************************************
        INSERT into ws_wrk_task_ctrl
        (
          wtc_task_key
        , wtc_job_key
        , wtc_obj_key
        , wtc_name
        , wtc_type
        , wtc_sequence
        , wtc_obj_type
        , wtc_action_type
        , wtc_order
        , wtc_order_a
        , wtc_order_b
        , wtc_order_c
        , wtc_run_status
        , wtc_audit_status
        , wtc_started
        , wtc_completed
        , wtc_avg_elapsed
        , wtc_avg_count
        , wtc_task_fatal
        , wtc_task_error
        , wtc_task_warning
        , wtc_task_info
        , wtc_task_okay
        , wtc_chkp_number
        , wtc_abort_level
        , wtc_action_ind
        )
        SELECT
          ws_task_seq.nextval
        , v_new_sequence
        , wtc_obj_key
        , wtc_name
        , wtc_type
        , v_new_sequence
        , wtc_obj_type
        , wtc_action_type
        , wtc_order
        , wtc_order_a
        , wtc_order_b
        , wtc_order_c
        , wtc_run_status
        , wtc_audit_status
        , wtc_started
        , wtc_completed
        , wtc_avg_elapsed
        , wtc_avg_count
        , wtc_task_fatal
        , wtc_task_error
        , wtc_task_warning
        , wtc_task_info
        , wtc_task_okay
        , wtc_chkp_number
        , wtc_abort_level
        , NVL(wtc_action_ind,'')
        FROM ws_wrk_task_ctrl
        Where wtc_job_key = v_old_key;

        --***********************************************************************
        -- Add all the dependencies
        --***********************************************************************
        INSERT into ws_wrk_dependency
        (
          wdp_job_key
        , wdp_parent_task_key
        , wdp_child_task_key
        )
        SELECT
          v_new_sequence,
          b_new.wtc_task_key,
          c_new.wtc_task_key
        FROM
          ws_wrk_dependency a,
          ws_wrk_task_ctrl b_old,
          ws_wrk_task_ctrl c_old,
          ws_wrk_task_ctrl b_new,
          ws_wrk_task_ctrl c_new
        WHERE a.wdp_job_key = v_old_key
        AND b_new.wtc_job_key = v_new_sequence
        AND c_new.wtc_job_key = v_new_sequence
        AND a.wdp_parent_task_key = b_old.wtc_task_key
        AND a.wdp_child_task_key = c_old.wtc_task_key
        AND b_old.wtc_order = b_new.wtc_order
        AND c_old.wtc_order = c_new.wtc_order;


        --***********************************************************************
        -- Set the job to the request state
        --***********************************************************************
        UPDATE ws_wrk_job_ctrl
        SET wjc_status = v_wjc_status
    WHERE wjc_job_key = v_new_sequence
    AND  wjc_sequence = v_new_sequence;

        Commit;

        p_return_code := 'S';
        p_return_msg := 'Job '||p_new_job||' created.';
        RETURN 1;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to create Job '||p_new_job||' '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        RETURN -2;
    END;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'F';
        v_MsgText := 'Unhandled Exception in ws_job_create. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_create;
 
_PROCEDURE_ Ws_Load_Change 
-- Notes / History
--
-- WMR  14/10/2003   Version 4.1.0.4
-- JH   04/07/2011   Version 6.5.4.1  RED-2175 SSIS loads FROM CLAUSE
-- MXU  02/04/2014   Version 6.8.1.1  RED-1242 Add source table alias
-- BC   14/08/2015   Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_load_change
  (
  p_sequence    IN  number,
  p_job_name    IN  varchar2,
  p_task_name   IN  varchar2,
  p_job_id      IN  number,
  p_task_id     IN  number,
  p_action       IN  varchar2,
  p_table       IN  varchar2,
  p_new_value   IN  varchar2,
  p_return_code OUT varchar2,
  p_return_msg  OUT varchar2
  )
  Return integer
  AUTHID CURRENT_USER
  IS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           :    Oracle
  -- Script Name         :    ws_load_change
  -- Description         :    Changes the connection or schema of a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  v_MsgText         varchar2(1024); -- Text in audit_trail
  v_step            integer := 0;  -- return code
  v_result          integer := 0;  -- return code
  v_count           integer := 0;
  v_part_count      integer := 0;
  v_specific_index  integer := 0;
  v_specific_part   integer := 0;
  v_status          number := 0;
  v_status_code     number := 0;
  v_msg             varchar2(4000);
  v_job_sequence    integer;
  v_job_key         integer;
  v_job_status      varchar2(1);
  v_action          integer := 0;
  v_load_obj_key    integer := 0;
  v_old_connect_key integer := 0;
  v_new_connect_key integer := 0;
  v_old_connect     varchar2(256);
  v_old_schema      varchar2(256);
  v_new_schema      varchar2(256);
  v_source_table    varchar2(4000);
  v_view_tables     varchar2(4000);
  v_from_tables     varchar2(4000);
  v_work            varchar2(4000);
  v_view_name       varchar2(256);
  v_old_load_type   varchar2(1);
  v_new_load_type   varchar2(1);
  v_old_transform   varchar2(1);
  v_new_transform   varchar2(1);
  v_old_dblink      varchar2(256);
  v_new_dblink      varchar2(256);
  v_old_database    varchar2(256);
  v_new_database    varchar2(256);
  v_old_host        varchar2(256);
  v_new_host        varchar2(256);
  v_old_value       varchar2(256);
  v_load_options    varchar2(4000); -- RED-2175
  v_work_schema     varchar2(256); -- RED-2175
  v_work_table      varchar2(4000); -- RED-2175
  v_work_alias      varchar2(4000); -- RED-2175
  v_encap_start     varchar2(1); -- RED-2175
  v_encap_end       varchar2(1); -- RED-2175
  v_tables          integer := 0;
  v_spos            integer := 0;
  v_cpos            integer := 0;
  v_ppos            integer := 0;
  v_bpos            integer := 0; -- RED-2175

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  v_step := 100;
  IF UPPER(p_action) = 'SCHEMA' THEN
    v_action := 1;
  ELSIF UPPER(p_action) = 'CONNECTION' THEN
    v_action := 2;
  ELSE
    p_return_code := 'E';
    p_return_msg := 'Invalid action code. Valid actions are Schema and Connection.';
    v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
      p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
    RETURN -2;
  END IF;

  --***********************************************************************
  -- Get the info for the load table
  --***********************************************************************
  v_step := 200;
  BEGIN
    SELECT
      lt_obj_key,
      lt_connect_key, lt_source_schema,
      lt_source_table, lt_view_name,
      lt_type, lt_transform_ind,
      dc_dblink_id, dc_name,
      dc_database_id, dc_host_id,
      lt_load_options -- RED-2175
    INTO
      v_load_obj_key,
      v_old_connect_key, v_old_schema,
      v_source_table, v_view_name,
      v_old_load_type, v_old_transform,
      v_old_dblink, v_old_connect,
      v_old_database, v_old_host,
      v_load_options -- RED-2175
    FROM
      ws_load_tab, ws_dbc_connect
    WHERE
      UPPER(lt_table_name) = UPPER(p_table)
    AND
      lt_connect_key = dc_obj_key (+);

  EXCEPTION WHEN OTHERS THEN
      p_return_code := 'E';
      v_msg := 'Failed to get info for load table '||p_table||' '||SQLERRM;
      p_return_msg := substr(v_msg,1,1023);
      v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
        p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
      RETURN -2;
  END;


  IF v_load_obj_key <= 0 THEN
    p_return_code := 'E';
    p_return_msg := 'Failed to find load table '||p_table;
    v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
      p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
    RETURN -2;
  END IF;

  --***********************************************************************
  -- If a connection change then get the new connect info
  --***********************************************************************
  v_step := 300;
  IF v_action = 2 THEN
    BEGIN
      SELECT
        dc_obj_key, dc_type, dc_dblink_id,
        dc_database_id, dc_host_id
      INTO
        v_new_connect_key,
        v_new_load_type, v_new_dblink,
        v_new_database, v_new_host
      FROM
        ws_dbc_connect
      WHERE
        UPPER(dc_name) = UPPER(p_new_value);

      -- RED-2175
      -- assign a default type of load if the old one is no longer valid
      IF v_new_load_type = 'U' OR v_new_load_type = 'W' THEN
          IF v_old_load_type <> 'F' AND v_old_load_type <> 'S' AND v_old_load_type <> 'E' THEN
              v_new_load_type := 'F';
          ELSE
              v_new_load_type := v_old_load_type;
          END IF;
      ELSIF v_new_load_type = 'O' THEN
          IF v_old_load_type <> 'O' AND v_old_load_type <> 'E' AND v_old_load_type <> 'I' THEN
              v_new_load_type := 'O';
          ELSE
              v_new_load_type := v_old_load_type;
          END IF;
      ELSIF v_new_load_type = 'D' THEN
          IF v_old_load_type <> 'D' AND v_old_load_type <> 'E' AND v_old_load_type <> 'I' THEN
              v_new_load_type := 'D';
          ELSE
              v_new_load_type := v_old_load_type;
          END IF;
      ELSE
          v_new_load_type := v_old_load_type;
      END IF;

      IF v_new_load_type = 'O' THEN
        v_new_transform := 'Y';
      ELSE
        v_new_transform := v_old_transform;
      END IF;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to get info for connection '||p_new_value||' '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
          p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
        RETURN -2;
    END;
  ELSE
    v_new_connect_key := v_old_connect_key;
    v_new_load_type := v_old_load_type;
    v_new_dblink := v_old_dblink;
    v_new_database := v_old_database;
    v_new_host := v_old_host;
    v_new_transform := v_old_transform;
  END IF;

  --***********************************************************************
  -- If a schema change then get ready for it
  --***********************************************************************
  v_step := 400;
  IF v_action = 1 THEN
    v_new_schema := p_new_value;
    v_old_value := v_old_schema;
  ELSE
    v_new_schema := v_old_schema;
    v_old_value := v_old_connect;
  END IF;


  --***********************************************************************
  -- If a remote view is used and we have a schema change then fix the view
  -- This logic is sourced from LoaReconnect in the med application
  --***********************************************************************
  v_step := 500;
  IF v_action = 1 THEN
    IF v_view_name IS NOT NULL THEN
       IF v_new_schema IS NOT NULL  THEN
         v_view_tables := '';
         v_work := v_source_table;
         v_cpos := INSTR(v_work,',');
         WHILE  v_cpos > 0 LOOP
           v_cpos := INSTR(v_work,',');
           IF v_cpos > 0 THEN

             v_tables := v_tables + 1;
             IF v_tables > 1 THEN
               v_view_tables := v_view_tables || ',';
             END IF;

             v_spos := INSTR(v_work,'.');
             IF v_spos < v_cpos AND v_spos > 0 THEN
               v_step := 530;
             ELSE
               v_view_tables := v_view_tables || v_new_schema || '.';
             END IF;
             v_view_tables := v_view_tables || SUBSTR(v_work,1,v_cpos-1);
             v_work := SUBSTR(v_work,v_cpos+1);
           END IF;
         END LOOP;

         IF v_work IS NOT NULL  THEN
           v_tables := v_tables + 1;
           IF v_tables > 1 THEN
             v_view_tables := v_view_tables || ',';
           END IF;

           v_spos := INSTR(v_work,'.');
           IF  v_spos > 0 THEN
             v_step := 570;
           ELSE
             v_view_tables := v_view_tables || v_new_schema || '.';
           END IF;
           v_view_tables := v_view_tables || v_work;
         END IF;
       ELSE
         v_view_tables := v_source_table;
       END IF;
    END IF;
  END IF;

  --***********************************************************************
  -- Now fix up the from tables
  -- Code logic acquired from med application in LoaReconnect
  --***********************************************************************
  v_step := 600;
  IF v_new_schema IS NOT NULL THEN
    IF v_new_load_type = 'I' THEN -- RED-2175
        v_step := 650;
        v_encap_start := '';
        v_encap_end := '';

        v_cpos := INSTR(v_load_options,'COL_ENCAP=')+10;
        IF v_cpos > 10 THEN
            v_bpos := CAST(SUBSTR(v_load_options,v_cpos,4) AS integer);
            IF v_bpos > 0 THEN
                v_cpos := v_cpos + 5;
                v_encap_start := SUBSTR(v_load_options,v_cpos,1);
                v_encap_end := SUBSTR(v_load_options,v_cpos+v_bpos-1,1);
            END IF;
        END IF;

        v_from_tables := '';
        v_work := LTRIM(v_source_table);
        v_tables := 0;

        v_cpos := INSTR(v_work,',');
        WHILE v_cpos > 0 LOOP
            v_spos := INSTR(v_work,v_encap_start);
            v_bpos := INSTR(v_work,v_encap_end,v_spos+1);

            IF v_spos <= 0 OR v_bpos <= v_spos OR v_spos >= v_cpos OR v_bpos <= v_cpos THEN
                v_cpos := v_cpos-1;
                EXIT;
            END IF;

            v_cpos := INSTR(v_work,',',v_bpos+1);
        END LOOP;

        IF v_cpos = 0 THEN
            v_cpos := LENGTH(v_work);
        END IF;

        WHILE v_cpos > 0 LOOP
            v_step := 660;
            v_work_schema := LTRIM(v_new_schema);
            v_work_table := LTRIM(SUBSTR(v_work,1,v_cpos));
            v_work_alias := '';

            IF LENGTH(v_work_table) > 0 THEN
                v_step := 670;
                v_tables := v_tables + 1;
                IF v_tables > 1 THEN
                    v_from_tables := v_from_tables || ',';
                END IF;

                v_bpos := 0;
                v_ppos := INSTR(v_work_table,'.');
                WHILE v_ppos > 0 LOOP
                    v_spos := INSTR(v_work_table,v_encap_start,v_bpos+1);
                    v_bpos := INSTR(v_work_table,v_encap_end,v_spos+1);

                    EXIT WHEN v_spos <= 0 OR v_bpos <= v_spos OR v_spos >= v_ppos OR v_bpos <= v_ppos;

                    v_ppos := INSTR(v_work_table,'.',v_bpos+1);
                END LOOP;

                IF v_ppos > 0 THEN
                    v_work_schema := SUBSTR(v_work_table,1,v_ppos-1);
                    v_work_table := SUBSTR(v_work_table,v_ppos+1,LENGTH(v_work_table)-v_ppos);
                END IF;

                v_work_schema := LTRIM(RTRIM(v_work_schema));
                v_work_table := LTRIM(RTRIM(v_work_table));

                IF LENGTH(v_work_schema) > 0 THEN
                    IF SUBSTR(v_work_schema,1,1) = v_encap_start THEN
                        v_from_tables := v_from_tables || v_work_schema || '.';
                    ELSE
                        v_from_tables := v_from_tables || v_encap_start || v_work_schema || v_encap_end || '.';
                    END IF;
                END IF;

                v_bpos := 0;
                v_ppos := INSTR(v_work_table,' ');
                WHILE v_ppos > 0 LOOP
                    v_spos := INSTR(v_work_table,v_encap_start,v_bpos+1);
                    v_bpos := INSTR(v_work_table,v_encap_end,v_spos+1);

                    EXIT WHEN v_spos <= 0 OR v_bpos <= v_spos OR v_spos >= v_ppos OR v_bpos <= v_ppos;

                    v_ppos := INSTR(v_work_table,' ',v_bpos+1);
                END LOOP;

                IF v_ppos = 0 THEN
                    v_work_alias := v_work_table;
                ELSE
                    v_work_alias := SUBSTR(v_work_table,v_ppos+1,LENGTH(v_work_table)-v_ppos);
                    v_work_table := SUBSTR(v_work_table,1,v_ppos);
                END IF;

                v_work_alias := LTRIM(RTRIM(v_work_alias));
                v_work_table := LTRIM(RTRIM(v_work_table));

                IF SUBSTR(v_work_table,1,1) = v_encap_start THEN
                    v_from_tables := v_from_tables || v_work_table || ' ';
                ELSE
                    v_from_tables := v_from_tables || v_encap_start || v_work_table || v_encap_end || ' ';
                END IF;

                IF SUBSTR(v_work_alias,1,1) = v_encap_start THEN
                    v_from_tables := v_from_tables || v_work_alias || ' ';
                ELSE
                    v_from_tables := v_from_tables || v_encap_start || v_work_alias || v_encap_end || ' ';
                END IF;
            END IF;

            v_work := SUBSTR(v_work,v_cpos+1,LENGTH(v_work)-v_cpos);
            IF LENGTH(v_work) > 1 AND LTRIM(SUBSTR(v_work,1,1)) = ',' THEN
                v_work := SUBSTR(v_work,2,LENGTH(v_work)-1);
            END IF;
            v_cpos := INSTR(v_work,',');

            WHILE v_cpos > 0 LOOP
                v_spos := INSTR(v_work,v_encap_start);
                v_bpos := INSTR(v_work,v_encap_end,v_spos+1);

                IF v_spos <= 0 OR v_spos <= 0 OR v_spos >= v_cpos OR v_bpos <= v_cpos THEN
                    v_cpos := v_cpos-1;
                    EXIT;
                END IF;

                v_cpos := INSTR(v_work,',',v_bpos+1);
            END LOOP;

            IF v_cpos = 0 THEN
                v_cpos := LENGTH(v_work);
            END IF;
        END LOOP;
    ELSE
        v_from_tables := '';
        v_work := LTRIM(v_source_table);
        v_tables := 0;
        v_cpos := INSTR(v_work,',');
        WHILE  v_cpos > 0 LOOP
          v_cpos := INSTR(v_work,',');
          IF v_cpos > 0 THEN
            v_tables := v_tables + 1;
            IF v_tables > 1 THEN
             v_from_tables := v_from_tables || ',';
            END IF;

            v_spos := INSTR(v_work,'.');
            IF v_spos < v_cpos AND v_spos > 0 THEN
             v_step := 630;
            ELSE
             v_from_tables := v_from_tables || v_new_schema || '.';
            END IF;

            IF v_new_dblink IS NOT NULL THEN
              v_ppos := INSTR(v_work,' ');
              IF v_ppos < v_cpos AND v_ppos > 0 THEN
                v_from_tables := v_from_tables || SUBSTR(v_work,1,v_ppos-1) ||
                  '@' || v_new_dblink || SUBSTR(v_work,v_ppos,v_cpos-v_ppos);
              ELSE
                v_from_tables := v_from_tables || SUBSTR(v_work,1,v_cpos-1) ||
                  '@' || v_new_dblink;
              END IF;
            ELSE
              v_from_tables := v_from_tables || SUBSTR(v_work,1,v_cpos-1);
            END IF;

            -- RED-1242: Add source table alias
            IF INSTR(RTRIM(LTRIM(SUBSTR(v_work,1,v_cpos-1))),' ') <= 0 THEN
              v_from_tables := v_from_tables || ' ' || SUBSTR(v_work,1,v_cpos-1);
            END IF;

            v_work := LTRIM(SUBSTR(v_work,v_cpos+1));

          END IF;
        END LOOP;

        IF v_work IS NOT NULL THEN
          v_tables := v_tables + 1;
          IF v_tables > 1 THEN
           v_from_tables := v_from_tables || ',';
          END IF;

          v_spos := INSTR(v_work,'.');
          IF v_spos > 0 THEN
           v_step := 670;
          ELSE
           v_from_tables := v_from_tables || v_new_schema || '.';
          END IF;

          v_cpos := LENGTH(v_work);
          IF v_new_dblink IS NOT NULL THEN
            v_ppos := INSTR(v_work,' ');
            IF v_ppos < v_cpos AND v_ppos > 0 THEN
              v_from_tables := v_from_tables || SUBSTR(v_work,1,v_ppos-1) ||
                '@' || v_new_dblink || SUBSTR(v_work,v_ppos,(v_cpos-v_ppos)+1);
            ELSE
              v_from_tables := v_from_tables || SUBSTR(v_work,1,v_cpos) ||
                '@' || v_new_dblink;
            END IF;
          ELSE
            v_from_tables := v_from_tables || v_work;
            -- RED-1242: Add source table alias
            IF INSTR(RTRIM(LTRIM(v_work)),' ') <= 0 THEN
              v_from_tables := v_from_tables || ' ' || v_work;
            END IF;
          END IF;
        END IF;
    END IF;
  ELSE
    v_from_tables := v_source_table;
    IF v_new_dblink IS NOT NULL THEN
      v_from_tables := v_from_tables || '@' || v_new_dblink;
    END IF;
  END IF;

  --***********************************************************************
  -- Update the load table
  --***********************************************************************
  v_step := 700;
  UPDATE ws_load_tab
  SET
    lt_connect_key = v_new_connect_key,
    lt_source_schema = v_new_schema,
    lt_view_table = v_view_tables,
    lt_from_table = v_from_tables,
    lt_transform_ind = v_new_transform,
    lt_type = v_new_load_type
  WHERE
    lt_obj_key = v_load_obj_key;

  COMMIT;

  p_return_code := 'S';
  p_return_msg := p_action || ' changed from '||v_old_value||' to '||p_new_value||
    ' for load table '||p_table;
  v_result := WsWrkAudit('I', p_job_name, p_job_name, p_sequence,
    p_return_msg,NULL,NULL, p_task_id, p_job_id);

  RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    p_return_code := 'F';
    v_MsgText := 'Unhandled Exception in ws_load_change. '||
            ' Step ' ||v_step;
    v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
    p_return_msg := substr(v_MsgText,1,1023);
    RETURN -3;

END ws_load_change;
 
_PROCEDURE_ Ws_Job_Exec_010 
-- Notes / History  Version 1.0.9.6
--
-- WMR 24/08/2001                   Reworked the task loop to prevent the holding open of the
--                                  TaskRun cursor, causing a Rollback too old problem
-- WMR 24/08/2001                   If a job has a previously failed Sequence then let the job go.
--                                  If it has a running Sequence then put it into Hold
-- WMR 09/11/2001                   If a restart then check job is pending. Change to ws_job_wait.
-- WMR 22/01/2002   Version 1.0.0
-- WMR 08/03/2002                   Handle change of SID when breakout to perform host script
-- WMR 05/04/2002                   Changed analyze from 1% to 3%. Handle new wj_scheduler column
-- WMR 06/04/2002                   Handle ODBC based loads.
-- WMR 09/04/2002                   Handle customer jobs in working out next scheduled time
--                                  Handle blocked jobs. Release them when a job has finished or failed
-- WMR 23/05/2002                   Additional info message and check if unable to rejoin a job
-- WMR 25/05/2002                   All job_name comparisons use upper and rtrim
-- WMR 01/10/2002                   Threads sleep for 30 seconds if no action and tasks still running
-- WMR 18/10/2002                   Invalid return status now assumed to be a failure.
-- WMR 03/10/2003   Version 4.1.0   added support for cube creation and processing
-- WMR 16/10/2003                   Check for logs to delete and call Ws_Job_Clear_Logs if required
-- WMR 31/10/2003                   Added support for cube and database specific dimension processing
-- WMR 18/11/2003                   No data found in update of final status indicates that some other
--                                  thread did the update and move. so all okay
-- WMR 19/11/2003                   If an unknown status returned then treat it as a failure, so job will fail
-- WMR 09/03/2004                   Added support for virtual cube creation and processing
-- WMR 10/05/2004                   Added support for custom procedures.
-- WMR 23/07/2004                   Added support for parameters to be passed to Ws_Act_Build and Ws_Act_Build_All
-- WMR 23/09/2004                   Changed custom scheduling to us the day name instead of number
-- BC  14/08/2015   Version 6.8.4.3 RED-5520 Replaced occurrences of the != SQL operator with <>
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE procedure ws_job_exec_010
    (
    pi_job_name        IN  varchar2,
    pi_task_name       IN  varchar2,
    pi_action          IN  varchar2,
    pi_thread          IN  number,
    pi_sequence        IN  number,
    pi_job_key         IN  number,
    pi_task_key        IN  number,
    pi_task_status     IN  number,
    pi_task_msg        IN  varchar2,
    po_result_code     OUT number,
    po_result_msg      OUT varchar2,
    po_job_key         OUT number,
    po_task_key        OUT number,
    po_task_name       OUT varchar2,
    po_action_key      OUT number,
    po_action_msg      OUT varchar2
    )
    AUTHID CURRENT_USER
    As

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_exec_010
    -- Description         :    Executes a Wherescape Job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_document          constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_user1             constant number := 18;
    v_ws_obj_user2             constant number := 19;
    v_ws_obj_user3             constant number := 20;
    v_ws_obj_user4             constant number := 21;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;


    --=====================================================
    -- Parameters to the called procedures
    --=====================================================
    p_sequence               number;
    p_job_name               varchar2(64);
    p_task_name              varchar2(64);
    p_task_id                number;
    p_job_id                 number;
    p_return_msg             varchar2(1024);
    p_status_code            number;
    p_return_msg_2           varchar2(1024);
    p_status_code_2          number;
    p_return_msg_3           varchar2(1024);
    p_status_code_3          number;

    --=====================================================
    -- Variables
    --=====================================================
    v_rec_count              number;
    v_job_count              number;
    v_task_count             number;
    v_child_key              number;
    v_run_status             varchar2(1);
    v_audit_status           varchar2(1);
    v_abort_level            number;
    v_halted                 number;
    v_okay                   number;
    v_checked                number;
    v_running_count          number;
    v_failed_count           number;
    v_halted_count           number;
    v_job_status             varchar2(1);
    v_loop_count             number;
    v_MsgText                varchar2(1024); -- Text in audit_trail
    v_OkayMsg                varchar2(256);  -- Okay result command
    v_FailMsg                varchar2(256);  -- Failure result command
    v_result                 number;
    v_status_code            varchar2(1);
    v_step                   integer := 0;   -- return code
    v_Cursor                 number;
    v_Just_done              integer := 0;
    v_idle_thread            integer := 0;
    v_start_hh               integer;
    v_start_mi               integer;
    v_start_day              integer;
    v_job_type               varchar2(1);
    v_sid                    integer;
    v_serial                 integer;
    v_process                integer;
    v_action_type            integer;
    v_obj_type               integer;
    v_obj_key                integer;
    v_task_key               integer;
    v_ctrl_sequence          integer;
    v_start_after            date;
    v_cust_sa_hh             integer;
    v_cust_sa_mm             integer;
    v_cust_sb_hh             integer;
    v_cust_sb_mm             integer;
    v_cust_min               integer;
    v_cust_days              integer;
    v_cust_sb                integer;
    v_cust_sa                integer;
    v_more                   integer;
    v_AddDays                integer;
    v_wait_HH                integer;
    v_wait_MM                integer;
    v_cur_HH                 integer;
    v_cur_MM                 integer;
    v_cur_HHMM               integer;
    v_cur_day_name           varchar(3);
    v_Monday                 integer;
    v_Tuesday                integer;
    v_Wednesday              integer;
    v_Thursday               integer;
    v_Friday                 integer;
    v_Saturday               integer;
    v_Sunday                 integer;
    v_log_keep               integer;

    --=====================================================
    -- Cursor for all the task control records to be added to task run
    --=====================================================
    Cursor c_TaskCtrl is
          Select * from ws_wrk_task_ctrl
          Where wtc_job_key = p_job_id;

    --=====================================================
    -- Cursor for all the task run records waiting to be run
    --=====================================================
    Cursor c_TaskRun is
          Select * from ws_wrk_task_run
          Where wtr_job_key = p_job_id
          And wtr_sequence = pi_sequence;

    --=====================================================
    -- Cursor for all the parent dependencies of a particular task
    --=====================================================
    Cursor c_Dependency is
          Select * from ws_wrk_dependency
          Where wdp_job_key = p_job_id
          And wdp_child_task_key = v_child_key;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    p_job_name := pi_job_name;
    p_task_name := pi_task_name;
    p_sequence := pi_sequence;
    p_job_id := 0;
    p_task_id := 0;
    po_job_key := p_job_id;
    po_task_key := p_task_id;
    po_task_name := p_task_name;
    po_result_msg := 'no result';


    --=====================================================
    --                  N E W       J O B
    --=====================================================
    -- If we are a New job then check we are not already running, under
    -- this or some other sequence number.
    -- Create the job_run and task_run records
    --=====================================================
    If upper(pi_action) = 'NEW' Then
        --=====================================================
        -- If we are thread 0 then do some checks and create the records
        --=====================================================
        If pi_thread = 0 Then

             -- Get the job key for the job name. There should be one and
             -- only one key. Otherwise a fatal problem.
             BEGIN
                  select wjc_job_key, wjc_type, wjc_start_hour, wjc_start_minute, wjc_start_day,
                         wjc_sequence, wjc_publish_fail,
                         nvl(wjc_cust_sa_hh,0), nvl(wjc_cust_sa_mm,0),
                         nvl(wjc_cust_sb_hh,0), nvl(wjc_cust_sb_mm,0),
                         nvl(wjc_cust_min,0), nvl(wjc_cust_days,0),
                         nvl(wjc_avg_count,0)
                  into p_job_id, v_job_type, v_start_hh, v_start_mi, v_start_day,
                         v_ctrl_sequence, v_FailMsg,
                         v_cust_sa_hh, v_cust_sa_mm, v_cust_sb_hh, v_cust_sb_mm,
                         v_cust_min, v_cust_days, v_log_keep
                  from ws_wrk_job_ctrl
                  where rtrim(upper(wjc_name)) = rtrim(upper(pi_job_name));
                  v_rec_count := 1;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in New Job. '||
                                                   v_rec_count||' such records exist. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             -- Setup to default for a failure if a Fail command has been provided
             If v_FailMsg is not Null Then
                 po_action_key := 2;
                 po_action_msg := v_FailMsg;
             Else
                 po_action_key := 0;
             End If;

             -- Make sure we are not already running (i.e. have a job_run record)
             -- Otherwise a fatal problem.
             BEGIN
                  select count(1) into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 0 Then
                 v_MsgText := 'Job '||pi_job_name||' already running. '||
                                                   'Cannot start a new itteration. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             -- Make sure there is no other sequence of this job running
             -- Otherwise a fatal problem.
             -- WMR 24/08/2001. Put the job on hold, if there are running sequences.
             -- WMR 24/08/2001. If failed sequences then put out a warning and proceed.
             BEGIN
                  select count(1) into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 0 Then
                 BEGIN
                      select count(1) into v_job_count
                      from ws_wrk_job_run
                      where wjr_job_key = p_job_id
                      and wjr_status = 'F';
                 EXCEPTION WHEN OTHERS THEN
                      v_job_count := 0;
                 END;
                 If v_job_count <> v_rec_count Then
                     v_MsgText := 'Job '||pi_job_name||' already has a running sequence. '||
                                                   ' Job Blocked, until current job completes.';
                     v_result := WsWrkAudit('W',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                     BEGIN
                          update ws_wrk_job_ctrl
                          set wjc_status = 'B'
                          where wjc_job_key = p_job_id
                          and wjc_sequence = v_ctrl_sequence;
                          COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                           ' failed to change state to blocked '||
                                                           'in ws_wrk_job_ctrl. No Action!!!';
                           v_result := WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                                   v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                           po_result_code := -2;
                           RETURN;
                     END;
                     po_result_code := -2;
                     RETURN;
                 Else
                     v_MsgText := 'Job '||pi_job_name||' has a previously Failed (incomplete) sequence. Now Aborted';
                     v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);

                     -- Update the job run record to be completed (Failed-Aborted)
                     -- and set the completion date if it is null
                     -- Move the job run record to the log record
                     BEGIN
                          update ws_wrk_job_run
                          set wjr_status = 'G'
                          where wjr_job_key = p_job_id;
                          COMMIT;
                          update ws_wrk_job_run
                          set wjr_completed = sysdate
                          where wjr_job_key = p_job_id
                          and wjr_completed is NULL;
                          COMMIT;
                          insert into ws_wrk_job_log
                          select * from ws_wrk_job_run
                          where wjr_job_key = p_job_id;
                          COMMIT;
                          delete from ws_wrk_job_run
                          where wjr_job_key = p_job_id;
                          COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' failed in xfer to aborted job to ws_wrk_job_log. '||
                                                           ' No Action !!!';
                         v_result := WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                                   v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                         po_result_code := -2;
                         RETURN;
                     END;

                     -- Move the task run records to the log record
                     BEGIN
                          insert into ws_wrk_task_log
                          select * from ws_wrk_task_run
                          where wtr_job_key = p_job_id;
                          COMMIT;
                             delete from ws_wrk_task_run
                          where wtr_job_key = p_job_id;
                          COMMIT;
                    EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||
                                        ' failed in xfer of aborted jobs tasks to ws_wrk_task_log. '||
                                                           ' No Action !!!';
                         v_result := WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                                                   v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                         po_result_code := -2;
                         RETURN;
                     END;

                 End If;
             End If;

            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            END;

             -- Create the Job run record
             -- Set its initial state to P for pending until we have the task_run records built
             BEGIN
                  Insert into ws_wrk_job_run (
                        wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
                        wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
                        wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
                        wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
                        wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler)
                  Select
                        wjc_job_key, pi_sequence, 0, 'P', sysdate, sysdate, NULL, 0,0,
                        0,0,0,0,0,wjc_chkp_count,0, wjc_name, wjc_user_key, wjc_max_threads,
                        wjc_publish_okay, wjc_publish_fail, wjc_scheduler
                  from ws_wrk_job_ctrl
                  where wjc_job_key = p_job_id;
                  COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to create record in ws_wrk_job_run table. '||
                                                   ' No Action !!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                   po_result_code := -2;
                   RETURN;
             END;

             -- Create All the Task records.
             -- Loop through all the tasks and add them. Initial state is Waiting.
             FOR v_TaskCtrlRec in c_TaskCtrl LOOP

                 BEGIN
                      Insert into ws_wrk_task_run (
                            wtr_task_key, wtr_job_key, wtr_sequence, wtr_restart, wtr_run_status,
                            wtr_audit_status, wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
                            wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg, wtr_type,
                            wtr_abort_level, wtr_chkp_number, wtr_name, wtr_obj_type, wtr_action_type,
                            wtr_obj_key)
                      Values (
                            v_TaskCtrlRec.wtc_task_key,
                            v_TaskCtrlRec.wtc_job_key,
                            pi_sequence,0,'W',NULL,NULL,NULL,0,0,
                            0,0,0,NULL,
                            v_TaskCtrlRec.wtc_type,
                            v_TaskCtrlRec.wtc_abort_level,
                            v_TaskCtrlRec.wtc_chkp_number, v_TaskCtrlRec.wtc_name,
                            v_TaskCtrlRec.wtc_obj_type, v_TaskCtrlRec.wtc_action_type,
                            v_TaskCtrlRec.wtc_obj_key
                      );
                      COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' failed creating records in ws_wrk_task_run table. '||
                                                   ' No Action !!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                   po_result_code := -2;
                   RETURN;
                END;

             END LOOP;


             -- All tasks added
             -- Set the job status to running so our threads can start running the tasks
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'R',
                        wjr_started = sysdate
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed to change state to running '||
                                                   'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                   po_result_code := -2;
                   RETURN;
             END;

             COMMIT;

             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Started. ';
             v_result := WsWrkAudit('B',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,0,p_job_id);

            --=====================================================
            -- Clear out any old logs for this job
            --=====================================================
            If v_log_keep > 0 Then

              -- we will create a log as part of this log, so keep 1 less
              v_log_keep := v_log_keep - 1;
              v_result := Ws_Job_Clear_Logs(p_sequence,
                                p_job_name, p_task_name, p_job_id, p_task_id,
                                p_job_name, v_log_keep,
                                v_status_code, p_return_msg);
            End If;


             -- Now either modify or delete the control record
             -- and if required delete the task records
             -- If it is a once only job then delete it from job control
             -- If a once and hold then set its status to Hold
             -- In all other cases work out when it will next run
             -- and put it in a wait state.
             BEGIN
                 If v_job_type = 'O' Then
                      delete
                      from ws_wrk_job_ctrl
                      where wjc_job_key = p_job_id;
                      COMMIT;
                      delete
                      from ws_wrk_task_ctrl
                      where wtc_job_key = p_job_id;
                 ElsIf v_job_type = 'S' Then
                     update ws_wrk_job_ctrl
                        set wjc_status = 'H',
                            wjc_start_after = sysdate
                        where wjc_job_key = p_job_id;
                 ElsIf v_job_type = 'D' Then
                       update ws_wrk_job_ctrl
                        set wjc_status = 'W',
                            wjc_start_after = trunc(sysdate) + 1 + (v_start_hh/24) + ( v_start_mi/1440)
                        where wjc_job_key = p_job_id;
                 ElsIf v_job_type = 'W' Then
                       update ws_wrk_job_ctrl
                        set wjc_status = 'W',
                            wjc_start_after = trunc(sysdate) + 7 + (v_start_hh/24) + ( v_start_mi/1440)
                        where wjc_job_key = p_job_id;
                 ElsIf v_job_type = 'M' Then
                       update ws_wrk_job_ctrl
                        set wjc_status = 'W',
                            wjc_start_after = add_months((trunc(sysdate) + (v_start_hh/24) + ( v_start_mi/1440)),1)
                        where wjc_job_key = p_job_id;
                 ElsIf v_job_type = 'A' Then
                        update ws_wrk_job_ctrl
                        set wjc_status = 'W',
                            wjc_start_after = add_months((trunc(sysdate) + (v_start_hh/24) + ( v_start_mi/1440)),12)
                        where wjc_job_key = p_job_id;
                 ElsIf v_job_type = 'C' Then
                    --
                    -- C U S T O M     date/time scheduling
                    --
                    v_More := 1;
                    v_cur_day_name := lower(substr(to_char(sysdate,'DY'),1,3));
                    v_AddDays := 0;

                    -- get the current time and add the interval to it to
                    -- get the next start time
                    v_cur_HH := to_number(to_char(sysdate,'HH24'));
                    v_cur_MM := to_number(to_char(sysdate,'MI'));
                    v_cur_MM := v_cur_MM + v_cust_min;
                    While v_cur_MM >= 60 LOOP
                        v_cur_HH := v_cur_HH + 1;
                        v_cur_MM := v_cur_MM - 60;
                    End Loop;
                    While v_cur_HH >= 24 LOOP
                        v_cur_day_name := lower(substr(to_char(sysdate+1,'DY'),1,3));
                        v_cur_HH := v_cur_HH - 24;
                    End Loop;

                    v_cur_HHMM := ( v_cur_HH * 100 ) + v_cur_MM;

                    -- init variable that will hold the minutes/hours to add
                    v_wait_HH := 0;
                    v_wait_MM := 0;

                    -- Work out the stop by (sb) and start after (sa) times
                    v_cust_sb := ( v_cust_sb_HH * 100 ) + v_cust_sb_MM;
                    v_cust_sa := ( v_cust_sa_HH * 100 ) + v_cust_sa_MM;

                    -- If a stop by time of 0 then set to 2400
                    If v_cust_sb = 0 Then
                        v_cust_sb := 2400;
                    End If;

                    -- Work out which days the job is active on
                    If v_cust_days >= 64 Then
                        v_cust_days := v_cust_days - 64;
                        v_Sunday := 1;
                    Else
                        v_Sunday := 0;
                    End If;

                    If v_cust_days >= 32 Then
                        v_cust_days := v_cust_days - 32;
                        v_Saturday := 1;
                    Else
                        v_Saturday := 0;
                    End If;

                    If v_cust_days >= 16 Then
                        v_cust_days := v_cust_days - 16;
                        v_Friday := 1;
                    Else
                        v_Friday := 0;
                    End If;

                    If v_cust_days >= 8 Then
                        v_cust_days := v_cust_days - 8;
                        v_Thursday := 1;
                    Else
                        v_Thursday := 0;
                    End If;

                    If v_cust_days >= 4 Then
                        v_cust_days := v_cust_days - 4;
                        v_Wednesday := 1;
                    Else
                        v_Wednesday := 0;
                    End If;

                    If v_cust_days >= 2 Then
                        v_cust_days := v_cust_days - 2;
                        v_Tuesday := 1;
                    Else
                        v_Tuesday := 0;
                    End If;

                    If v_cust_days >= 1 Then
                        v_cust_days := v_cust_days - 1;
                        v_Monday := 1;
                    Else
                        v_Monday := 0;
                    End If;

                    -- Loop until we have a day match that we can execute on
                    While v_More = 1 LOOP
                        If v_cur_day_name = 'sun' Then
                            If v_Sunday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'mon' Then
                            If v_Monday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'tue' Then
                            If v_Tuesday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'wed' Then
                            If v_Wednesday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'thu' Then
                            If v_Thursday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'fri' Then
                            If v_Friday = 1 Then
                                v_More := 0;
                            End If;
                        ElsIf v_cur_day_name = 'sat' Then
                            If v_Saturday = 1 Then
                                v_More := 0;
                            End If;
                        End If;

                        -- If we found a day and it is today and past the stop by
                        -- time then keep looking
                        If v_More = 0 And v_AddDays = 0 And v_cur_HHMM >= v_cust_sb Then
                            v_More := 1;
                            v_cur_HHMM := 0;
                        End If;

                        -- If no match add another day
                        If v_More = 1 Then
                            v_AddDays := v_AddDays + 1;
                            v_cur_day_name := lower(substr(to_char(sysdate+v_AddDays,'DY'),1,3));
                        End If;

                        -- If we are looping then a problem so get out of here
                        If v_AddDays > 7 Then
                            v_More := 0;
                            v_AddDays := 5000;
                        End If;

                    End Loop;
                    -- End of more days to search through

                    -- reset the current time in case it got cleared.
                    v_cur_HHMM := ( v_cur_HH * 100 ) + v_cur_MM;

                    -- See if we are past our stop by time
                    -- If past then work out the wait to the next start time
                    -- And subtract a day
                    -- If not past then If today and after the start after time then we can run
                    -- else work out any offset to the start after time.
                    If v_cur_HHMM >= v_cust_sb Then
                        v_wait_HH := 23 - v_cur_HH;
                        v_wait_MM := 60 - v_cur_MM;
                        v_wait_HH := v_wait_HH + v_cust_sa_HH;
                        v_wait_MM := v_wait_MM + v_cust_sa_MM;
                        If v_AddDays > 0 Then
                            v_AddDays := v_AddDays - 1;
                        End If;
                    Else
                        If v_cur_HHMM >= v_cust_sa And v_AddDays = 0 Then
                            v_wait_HH := 0;
                            v_wait_MM := 0;
                        Else
                            v_wait_HH := v_cust_sa_HH - v_cur_HH;
                            v_wait_MM := v_cust_sa_MM - v_cur_MM;
                        End If;
                    End If;

                    update ws_wrk_job_ctrl
                    set wjc_status = 'W',
                        wjc_start_after = sysdate + v_AddDays + (v_wait_HH/24) + (v_wait_MM/1440) + (v_cust_min/1440)
                    where wjc_job_key = p_job_id;
                Else
                     update ws_wrk_job_ctrl
                        set wjc_status = 'H',
                            wjc_start_after = sysdate
                        where wjc_job_key = p_job_id;
                 End If;
                COMMIT;
             EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Failure to re-appoint scheduled job ' || pi_job_name;
                  v_result := WsWrkAudit('E',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
             END;

        --=====================================================
        -- If we are any other thread then we can start processing once
        -- the job_run and task_run tables have been updated.
        -- We will sleep for 2 minutes just in case, to give thread 0
        -- time to compete its work
        --=====================================================
        Else
             DBMS_LOCK.SLEEP(2);

             v_loop_count := 0;


             LOOP
                  -- Make sure we are running
                  -- Otherwise wait some more then go. Wait maximum of 2 minutes
                  BEGIN
                       select wjr_status, wjr_job_key into v_run_status, p_job_id
                       from ws_wrk_job_run
                       where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
                       and wjr_sequence = pi_sequence;
                  EXCEPTION WHEN OTHERS THEN
                       v_run_status := 'P';
                  END;

                  If v_run_status = 'R' Then
                       EXIT;
                  End If;

                  v_loop_count := v_loop_count + 1;
                  If v_loop_count < 13 Then
                       DBMS_LOCK.SLEEP(10);
                  Else
                      v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                             ' Thread '||pi_thread||' failed to locate job. Terminating ...';
                      v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,0,p_job_id);
                      po_result_code := 0;
                      RETURN;
                  End If;
             END LOOP;

            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            END;

         End If;

    --=====================================================
    --                  R E S T A R T       J O B
    --=====================================================
    --=====================================================
    -- If we are a Restart job then check we are in a waiting
    -- state.
    -- Archive the _run table to the log table
    -- Reset any failed jobs, change the restart counter and proceed
    --=====================================================
    ElsIf upper(pi_action) = 'RESTART' Then
        --=====================================================
        -- If we are thread 0 then do some checks and reset any halted or
        -- failed tasks so that they will run
        --=====================================================
        If pi_thread = 0 Then

             -- Make sure we are in run tables (i.e. have a job_run record)
             -- And have a waiting state
             -- Otherwise a fatal problem.
             BEGIN
                  select wjr_status, wjr_job_key, wjr_publish_fail
                  into v_run_status, p_job_id, v_FailMsg
                  from ws_wrk_job_run
                  where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
                  and wjr_sequence = pi_sequence;

                  select count(1)
                  into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;

             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                                   'Cannot restart. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;
             -- Setup to default for a failure if a Fail command has been provided
             If v_FailMsg is not Null Then
                 po_action_key := 2;
                 po_action_msg := v_FailMsg;
             Else
                 po_action_key := 0;
             End If;
             If v_run_status <> 'P' Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not prepared for re-run. '||
                                                   'Cannot restart. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            END;


            -- Copy the job run record to the log record
             --BEGIN
             --     insert into ws_wrk_job_log
             --     select * from ws_wrk_job_run
             --     where wjr_job_key = p_job_id
             --     and wjr_sequence = pi_sequence;
             --
             --     update ws_wrk_job_log
             --     set wjl_status = F
             --     where wjl_job_key = p_job_id
             --     and wjl_sequence = pi_sequence;
             --     COMMIT;
             --EXCEPTION WHEN OTHERS THEN
             --     v_MsgText := Job ||pi_job_name|| failed in copy to ws_wrk_job_log. ||
             --                                       No Action !!!;
             --    v_result := WsWrkAudit(F,pi_job_name, pi_job_name, pi_sequence,
             --                                              v_MsgText,NULL,NULL,0,p_job_id);
             --    RETURN -2;
             --END;

             -- Copy the failed task run records to the log record
             --BEGIN
             --     insert into ws_wrk_task_log
             --     select * from ws_wrk_task_run
             --     where wtr_job_key = p_job_id
             --     and wtr_sequence = pi_sequence
             --     and wtr_run_status not in (W,C,H);
             --     COMMIT;
             --EXCEPTION WHEN OTHERS THEN
             --     v_MsgText := Job ||pi_job_name|| failed in copy of tasks to ws_wrk_task_log. ||
             --                                       No Action !!!;
             --    v_result := WsWrkAudit(F,pi_job_name, pi_job_name, pi_sequence,
             --                                              v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
             --    RETURN -2;
             --END;

             -- Set the job status to pending so our threads don't start
             -- And increment the restart counter
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'P',
             --           wjr_okay_count = 0,
             --           wjr_info_count = 0,
             --           wjr_warning_count = 0,
             --           wjr_error_count = 0,
             --           wjr_detail_count = 0,
                        wjr_restart = wjr_restart + 1
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed to change state to pending restart '||
                                                   'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             END;
             COMMIT;

             -- Loop through All the Task records.
             -- Clearing any halted or failed status
             FOR v_TaskRec in c_TaskRun LOOP

                 If v_TaskRec.wtr_run_status = 'H' OR v_TaskRec.wtr_run_status = 'F'
                 OR v_TaskRec.wtr_run_status = 'U' Then
                     BEGIN
                          Update ws_wrk_task_run set
                               wtr_restart = wtr_restart + 1,
                               wtr_started = NULL,
                               wtr_completed = NULL,
                               wtr_elapsed_hh = 0,
                               wtr_elapsed_mi = 0,
                               wtr_run_status = 'W',
                               wtr_audit_status = NULL,
                               wtr_info_count = 0,
                               wtr_warning_count = 0,
                               wtr_detail_count = 0,
                               wtr_return_msg = NULL
                           where wtr_task_key = v_TaskRec.wtr_task_key
                           and wtr_job_key = v_TaskRec.wtr_job_key
                           and wtr_sequence = v_TaskRec.wtr_sequence;
                           COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' failed resetting records in ws_wrk_task_run table. '||
                                                   ' No Action !!!';
                          v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                             po_result_code := -2;
                             RETURN;
                    END;
                 Else
                     BEGIN
                          Update ws_wrk_task_run set
                               wtr_restart = wtr_restart + 1
                           where wtr_task_key = v_TaskRec.wtr_task_key
                           and wtr_job_key = v_TaskRec.wtr_job_key
                           and wtr_sequence = v_TaskRec.wtr_sequence;
                           COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' failed resetting records in ws_wrk_task_run table. '||
                                                   ' No Action !!!';
                          v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                         po_result_code := -2;
                         RETURN;
                    END;
                 End If;

             END LOOP;

             -- Set the job status to running
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'R'
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed to change state to running '||
                                                   'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                     po_result_code := -2;
                     RETURN;
             END;
             COMMIT;

             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Restarted. ';
             v_result := WsWrkAudit('B',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,0,p_job_id);

        --=====================================================
        -- If we are not thread 0 then wait for two minutes for the okay
        --=====================================================
        Else
             -- Get the job key for the job name. There should be one and
             -- only one key. Otherwise a fatal problem.
             BEGIN
                  select wjr_job_key into p_job_id
                  from ws_wrk_job_run
                  where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name));
                  v_rec_count := 1;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in Restart. '||
                                                   v_rec_count||' such records exist. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            END;

             v_loop_count := 0;

             LOOP
                  -- Make sure we are running
                  -- Otherwise wait some more then go. Wait maximum of 2 minutes
                  BEGIN
                       select wjr_status into v_run_status
                       from ws_wrk_job_run
                       where wjr_job_key = p_job_id
                       and wjr_sequence = pi_sequence;
                  EXCEPTION WHEN OTHERS THEN
                       v_run_status := 'P';
                  END;

                  If v_run_status = 'R' Then
                       EXIT;
                  End If;

                  v_loop_count := v_loop_count + 1;
                  If v_loop_count < 13 Then
                       DBMS_LOCK.SLEEP(10);
                  Else
                      v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                             ' Thread '||pi_thread||' failed to locate job. Terminating ...';
                      v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,0,p_job_id);
                     po_result_code := 0;
                     RETURN;
                  End If;
             END LOOP;
       End If;

    --=====================================================
    --                  R E J O I N       J O B
    --=====================================================
    --=====================================================
    -- If we are a Rejoin job then  we have completed a host
    -- subtask. So check we are in a running state.
    -- Set the result status for the task we have just actioned
    -- and proceed with other tasks
    --=====================================================
    ElsIf upper(pi_action) = 'REJOIN' Then

       -- Setup our return codes
       p_status_code := pi_task_status;
       p_return_msg := pi_task_msg;
       p_task_id := pi_task_key;
       p_job_id := pi_job_key;

       --=====================================================
       -- Make sure we have a valid return status
       -- Otherwise make this a failure
       -- Update the status of the task we have completed.
       --=====================================================
       If p_status_code = 1 Then
          v_audit_status := 'S';
          v_run_status := 'C';
       ElsIf p_status_code = -1 Then
           v_audit_status := 'W';
           v_run_status := 'C';
       ElsIf p_status_code = -2 Then
           v_audit_status := 'E';
           v_run_status := 'F';
       ElsIf p_status_code = -3 Then
           v_audit_status := 'F';
           v_run_status := 'F';
       ELSE
           v_audit_status := 'U';
           v_run_status := 'U';
           p_status_code := -3;
           p_return_msg := substr('Invalid return code '||pi_task_status||
             '. Msg was '||pi_task_msg,1,970)||
             '. Expecting return code of 1,-1,-2, or -3';
       End If;

        --=====================================================
        -- Record this thread as being active
        --=====================================================
        BEGIN
            select sid,serial#
            into v_sid, v_serial
            from v$session where audsid = userenv('sessionid') ;
        EXCEPTION WHEN OTHERS THEN
            v_sid := 0;
            v_serial := 0;
        END;
        BEGIN
            Insert into ws_wrk_job_thread (
                    wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
            Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
           COMMIT;
        EXCEPTION WHEN OTHERS THEN
               v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
               v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
        END;

       -- Delete the temporary script we have created for this
       -- task to use
       BEGIN
            delete
            from ws_wrk_task_scr_line
            where wtsl_task_key = pi_task_key
            and  wtsl_job_key = pi_job_key
            and wtsl_sequence = pi_sequence;

            delete
            from ws_wrk_task_scr_hdr
            where wtsh_task_key = pi_task_key
            and  wtsh_job_key = pi_job_key
            and wtsh_sequence = pi_sequence;
            COMMIT;
       EXCEPTION WHEN OTHERS THEN
            v_rec_count := 0;
       END;

       -- Make sure we are in run tables (i.e. have a job_run record)
       -- And have a waiting state
       -- Otherwise a fatal problem.
       BEGIN
            select wjr_status, wjr_job_key, wjr_publish_fail
            into v_run_status, p_job_id, v_FailMsg
            from ws_wrk_job_run
            where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
            and wjr_sequence = pi_sequence;

            select count(1)
            into v_rec_count
            from ws_wrk_job_run
            where wjr_job_key = p_job_id
            and wjr_sequence = pi_sequence;
       EXCEPTION WHEN OTHERS THEN
            v_rec_count := 0;
       END;
       If v_rec_count <> 1 Then
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                             'Cannot rejoin. '||v_rec_count||' jobs running. No Action !!!';
           v_result := WsWrkAudit('E',pi_job_name, rtrim(p_task_name), pi_sequence,
                                                     v_MsgText,SQLCODE,SQLERRM,pi_task_key,p_job_id);

           -- See if we can work out what has happened to the job
           -- and let them know
           If v_rec_count = 0 Then
               BEGIN
                    select wjl_status, wjl_publish_fail
                    into v_run_status, v_FailMsg
                    from ws_wrk_job_log
                    where wjl_name = pi_job_name
                    and wjl_sequence = pi_sequence;
                    v_MsgText := SUBSTR('Job '||pi_job_name||' sequence '||pi_sequence||' has a log entry with status '||
                                        v_run_status||' '||v_FailMsg, 1, 1023);
                    v_result := WsWrkAudit('E',pi_job_name, rtrim(p_task_name), pi_sequence,
                                          v_MsgText,NULL,NULL,pi_task_key,p_job_id);
               EXCEPTION WHEN OTHERS THEN
                    v_rec_count := 0;
               END;
           End If;

           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, p_job_name, rtrim(p_task_name), p_sequence,
                     p_return_msg, NULL, NULL, pi_task_key, p_job_id);
           po_result_code := -2;
           RETURN;
       End If;


       -- Setup to default for a failure if a Fail command has been provided
       If v_FailMsg is not Null Then
           po_action_key := 2;
           po_action_msg := v_FailMsg;
       Else
           po_action_key := 0;
       End If;

       -- Get some info about the task we have just completed
       BEGIN
            select wtr_obj_key, wtr_obj_type, wtr_action_type
            into v_obj_key, v_obj_type, v_action_type
            from ws_wrk_task_run
            where wtr_job_key = p_job_id
            and wtr_task_key = pi_task_key
            and wtr_sequence = pi_sequence;
       EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                        ' Task ' || pi_task_name || ' not running. '||
                                             'Cannot rejoin. No Action !!!';
           v_result := WsWrkAudit('E',pi_job_name, rtrim(p_task_name), pi_sequence,
                                                     v_MsgText,NULL,NULL,pi_task_key,p_job_id);
           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, p_job_name, rtrim(p_task_name), p_sequence,
                     p_return_msg, NULL, NULL, pi_task_key, p_job_id);

           po_result_code := -2;
           RETURN;
       END;


       --=====================================================
       -- If a Load then we have just completed the load phase
       -- And now need to run any post load procedure if the
       -- load was a success
       -- If a Load and the action is a process then we need
       -- to do any index builds as well
       --=====================================================
       v_step := 2301;
       If v_obj_type = v_ws_obj_load Then
          If p_status_code >= -1 Then
              v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                    v_obj_key,
                                    p_job_name, p_task_name, p_job_id, p_task_id,
                                    p_return_msg_2, p_status_code_2);
              If p_status_code_2 = 1 Then
                 v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                      p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
              ElsIf p_status_code_2 < 1 Then
                 v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                      p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
              End If;
              If v_result >= -1 And v_action_type = v_ws_act_process Then

                 v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                         v_obj_key,
                                         p_job_name, p_task_name, p_job_id, p_task_id,'',
                                         p_return_msg_3, p_status_code_3);
                 If p_status_code_3 = 1 Then
                    v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg_3,NULL,NULL,p_task_id,p_job_id);
                 ElsIf p_status_code_3 < 1 Then
                    v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg_3,NULL,NULL,p_task_id,p_job_id);
                 End If;
              Else
                 p_status_code_2 := 1;
              End If;

              -- If our post load procedure failed and the load worked then
              -- record the post load failure
              If p_status_code_2 < p_status_code Then
                   p_status_code := p_status_code_2;
              End If;
              If p_status_code_3 < p_status_code Then
                   p_status_code := p_status_code_3;
              End If;
          End If;
       End If;

       --=====================================================
       -- Log the results in the audit trail
       --=====================================================
       v_step := 2302;
       If p_status_code = 1 Then
          v_audit_status := 'S';
          v_run_status := 'C';
       ElsIf p_status_code = -1 Then
           v_audit_status := 'W';
           v_run_status := 'C';
       ElsIf p_status_code = -2 Then
           v_audit_status := 'E';
           v_run_status := 'F';
       ElsIf p_status_code = -3 Then
           v_audit_status := 'F';
           v_run_status := 'F';
       ELSE
           v_audit_status := 'U';
           v_run_status := 'U';
           p_status_code := -3;
       End If;
       v_result := WsWrkAudit(v_audit_status, p_job_name, rtrim(p_task_name), p_sequence,
                 p_return_msg, NULL, NULL, pi_task_key, p_job_id);

       --=====================================================
       -- Update the run record to indicate our final status
       --=====================================================
       v_step := 2303;
       BEGIN
         update ws_wrk_task_run
         set wtr_run_status = v_run_status,
               wtr_audit_status = v_audit_status,
               wtr_return_msg = p_return_msg,
               wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
               wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                trunc(to_number(sysdate-wtr_started)*24,0)*60),
               wtr_completed = sysdate
         where wtr_task_key = pi_task_key
         and wtr_job_key = p_job_id;
       EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' failed in final update of ws_wrk_task_run for task id '||
                                      pi_task_key||'. Run incomplete !!!';
           v_result := WsWrkAudit('F',pi_job_name, rtrim(pi_task_name), pi_sequence,
                                              v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
           po_result_code := -2;
           RETURN;
       END;
       COMMIT;


    --=====================================================
    --                 C A N C E L       J O B
    --=====================================================
    --=====================================================
    -- If we are a Cancel job then check we are in a halted or aborted
    -- state.
    -- Archive the _run table to the log table
     --=====================================================
    ElsIf upper(pi_action) = 'CANCEL' Then
        --=====================================================
        -- If we are thread 0 then do some checks and archive
        --=====================================================
        If pi_thread = 0 Then

             -- Get the job key for the job name. There should be one and
             -- only one key. Otherwise a fatal problem.
             BEGIN
                  select wjc_job_key into p_job_id
                  from ws_wrk_job_ctrl
                  where rtrim(upper(wjc_name)) = rtrim(upper(pi_job_name));
                  v_rec_count := 1;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in Cancel. '||
                                                   v_rec_count||' such records exist. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             -- Make sure we are already running (i.e. have a job_run record)
             -- Otherwise a fatal problem.
             BEGIN
                  select count(1) into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                                   'Cannot cancel. No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,0,p_job_id);
                po_result_code := -2;
                RETURN;
             End If;

             -- Move the job run record to the log record
             BEGIN
                  insert into ws_wrk_job_log
                  select * from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  COMMIT;
                  delete from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  COMMIT;
             EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Job '||pi_job_name||' failed in xfer to ws_wrk_job_log. '||
                                                   ' No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                po_result_code := -2;
                RETURN;
             END;

             -- Move the task run records to the log record
             BEGIN
                  insert into ws_wrk_task_log
                  select * from ws_wrk_task_run
                  where wtr_job_key = p_job_id
                  and wtr_sequence = pi_sequence;
                  COMMIT;
      delete from ws_wrk_task_run
                  where wtr_job_key = p_job_id
                  and wtr_sequence = pi_sequence;
                  COMMIT;
            EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Job '||pi_job_name||' failed in xfer of tasks to ws_wrk_task_log. '||
                                                   ' No Action !!!';
                 v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                 po_result_code := -2;
                 RETURN;
             END;
             COMMIT;


             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Canceled. ';
             v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,0,p_job_id);

        --=====================================================
        -- If we are not thread 0 then wait for ten seconds and proceed.
        --=====================================================
        Else
             DBMS_LOCK.SLEEP(10);
       End If;


   -- not a New or a Restart so we have a problem
   Else
         v_MsgText := 'Job '||pi_job_name||' passed invalid option: '||
                                pi_action||'. No Action !!!';
         v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                v_MsgText,NULL,NULL,0,p_job_id);
    End If;

    --=====================================================
    --                  E X E C U T E      T A S K S
    --=====================================================
    --=====================================================
    --**********************************************************************
    -- Okay to start processing tasks. Three possible types of tasks
    -- will be handled. These Being (P)procedures, (F)functions and
    -- (C) checkpoints.
    -- Open the cursor we will use t run the tasks
    --**********************************************************************
    --=====================================================
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_task_count := 1;
    v_step := 100;

    -- While More tasks loop
    WHILE v_task_count > 0 LOOP

        v_step := 110;
        v_task_count := 0;
        v_running_count := 0;
        v_halted_count := 0;
        v_failed_count := 0;
        v_just_done := 0;
        v_idle_thread := 0;
        FOR v_TaskRec in c_TaskRun LOOP
            --=====================================================
            -- Check the status of each task
            -- If it is waiting then we will check dependencies etc.
            -- and see if it needs to be executed.
            --=====================================================
            v_step := 120;
            v_process := 0;
            If v_TaskRec.wtr_run_status = 'W' Then
                v_step := 130;
                v_task_count := 1;
                --=====================================================
                -- Check the dependencies for the task
                --=====================================================
                BEGIN
                    select count(1) into v_rec_count from ws_wrk_dependency
                    where wdp_job_key = p_job_id
                    and wdp_child_task_key = v_TaskRec.wtr_task_key;
                EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in read of ws_wrk_dependency. '||
                                                   ' Run incomplete !!!';
                   v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                   po_result_code := -2;
                   RETURN;
                END;
                -- If parent dependencies then check each to see if it has completed.
                v_child_key := v_TaskRec.wtr_task_key;
                v_halted := 0;
                v_okay := 0;
                v_checked := 0;
                v_step := 140;
                FOR v_DepRec in c_Dependency LOOP
                     -- get the parent task record from the task_run table
                     BEGIN
                        select wtr_run_status, wtr_audit_status, wtr_abort_level
                        into v_run_status, v_audit_status, v_abort_level
                        from ws_wrk_task_run
                        where wtr_job_key = p_job_id
                        and wtr_task_key = v_DepRec.wdp_parent_task_key;
                     EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in parent task read of ws_wrk_task_run. '||
                                                   ' Run incomplete !!!';
                       v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                       po_result_code := -2;
                       RETURN;
                    END;
                    v_step := 150;

                    -- Get the status for the parent task.
                    -- If the parent is waiting or running then skip the rest of the tests as we cant go
                    -- If the parent has been halted then set the flag to halt this task also.
                    -- If the parent has failed or completed check the audit status
                    -- The abort level will tell us if we should count this as a halt or an okay
                    If v_run_status = 'W' Then
                        EXIT;
                    ElsIf v_run_status = 'R' Then
                        EXIT;
                    ElsIf v_run_status = 'H' Then
                        v_halted := 1;
                        EXIT;
                    ElsIf v_run_status = 'F' Then
                        If v_abort_level = 5 Then
                            v_checked := v_checked + 1;
                        Else
                            v_halted := 1;
                            EXIT;
                        End If;
                    ElsIf v_run_status = 'U' Then
                        If v_abort_level = 5 Then
                            v_checked := v_checked + 1;
                        Else
                            v_halted := 1;
                            EXIT;
                        End If;
                    ElsIf v_run_status = 'C' Then
                        If v_abort_level <= 3 Then
                             If v_audit_status = 'W' Then
                                  v_halted := 1;
                                  EXIT;
                             Else
                                 v_checked := v_checked + 1;
                             End If;
                        Else
                             v_checked := v_checked + 1;
                        End If;
                    Else
                        EXIT;
                    End If;

                END LOOP; -- End of dependency Loop

                -- See if we passed our dependency check
                -- We either passed, need to halt the task or need to skip this task
                If v_checked = v_rec_count Then
                     v_okay := 1;
                End If;
                v_step := 160;
                --=====================================================
                -- See if the task is okay to run and a procedure if so run it
                --=====================================================
                If v_okay = 1  And  v_TaskRec.wtr_obj_type > 0 And v_TaskRec.wtr_obj_type < 20 Then
                    v_step := 170;
                    --=====================================================
                    -- Update the run record to indicate we are running.
                    -- Need to lock the record first to prevent another thread from
                    -- grabbing it, or in case another thread has already got it,
                    -- or updated it
                    --=====================================================
                   BEGIN
                      select wtr_run_status into v_run_status
                      from ws_wrk_task_run
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id
                      and wtr_sequence = pi_sequence
                      for update nowait;
                      If v_run_status = 'W' Then
                          update ws_wrk_task_run
                          set wtr_run_status = 'R',
                                wtr_thread = pi_thread,
                                wtr_started = sysdate
                          where wtr_task_key = v_TaskRec.wtr_task_key
                          and wtr_job_key = p_job_id;
                      Else
                          -- someone else got the record
                          v_okay := 0;
                       End If;
                   EXCEPTION WHEN OTHERS THEN
                      -- If a resource busy someone else has the record
                      -- so skip it
                      If SQLCODE = -54 Then
                          v_okay := 0;
                      Else
                          v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in update of ws_wrk_task_run for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                          v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                          po_result_code := -2;
                          RETURN;
                       End If;
                   END;
                   COMMIT;
                   v_step := 180;
                   -- If we still have a go, then run it
                   -- Break out of this loop and run the task by setting the v_process flag
                   If v_okay = 1 Then
                       v_process := 1;
                       p_task_id := v_TaskRec.wtr_task_key;
                       p_task_name := v_TaskRec.wtr_name;
                       v_action_type := v_TaskRec.wtr_action_type;
                       v_obj_type := v_TaskRec.wtr_obj_type;
                       v_obj_key := v_TaskRec.wtr_obj_key;
                       v_task_key := v_TaskRec.wtr_task_key;
                       Exit;
                   End if;
                --=====================================================
                -- See if OKay and A Checkpoint
                --=====================================================
                ElsIf v_okay = 1 And v_TaskRec.wtr_type = 'C' Then
                    --=====================================================
                    -- Update the run record to indicate we are running.
                    -- Need to lock the record first to prevent another thread from
                    -- grabbing it, or in case another thread has already go it,
                    -- or updated it
                    --=====================================================
                   v_step := 200;
                   BEGIN
                      select wtr_run_status into v_run_status
                      from ws_wrk_task_run
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id
                      for update nowait;
                      If v_run_status = 'W' Then
                          update ws_wrk_task_run
                          set wtr_run_status = 'R',
                                wtr_started = sysdate
                          where wtr_task_key = v_TaskRec.wtr_task_key
                          and wtr_job_key = p_job_id;
                      Else
                          -- someone else got the record
                          v_okay := 0;
                       End If;
                   EXCEPTION WHEN OTHERS THEN
                      -- If a resource busy someone else has the record
                      -- so skip it
                      If SQLCODE = -54 Then
                          v_okay := 0;
                      Else
                          v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in update of ws_wrk_task_ctrl for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                          v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                          po_result_code := -2;
                          RETURN;
                       End If;
                   END;
                   COMMIT;
                    v_step := 210;
                    -- If still okay (i.e we got the record then record the checkpoint
                    If v_okay = 1 Then
                        v_run_status := 'C';
                        v_audit_status := 'S';
                        p_task_name := 'Checkpoint';
                        p_return_msg := 'Checkpoint completed';
                        v_result := WsWrkAudit(v_audit_status, p_job_name, p_task_name, p_sequence,
                             p_return_msg, NULL, NULL, p_task_id, p_job_id);
                        If v_TaskRec.wtr_chkp_number <> 0 Then
                               v_result := WsWrkChkPoint(p_job_id, pi_sequence, v_TaskRec.wtr_chkp_number);
                        End If;
                        v_just_done := 1;
                    End If;
                End If;  -- End of task
                v_step := 220;
                --=====================================================
                -- See if the task needs a status update.
                --=====================================================
                If v_okay = 1 OR v_halted = 1 Then
                    --=====================================================
                    -- Update the run record to indicate our final status
                    -- If we have a halt then generate a message
                    --=====================================================
                    v_step := 230;
                    If v_halted = 1 Then
                         p_return_msg := 'Halted by dependency failure or halt';
                         v_run_status := 'H';
                         v_audit_status := NULL;
                    End If;
                    BEGIN
                      update ws_wrk_task_run
                      set wtr_run_status = v_run_status,
                            wtr_audit_status = v_audit_status,
                            wtr_return_msg = p_return_msg,
                            wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
                            wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                             trunc(to_number(sysdate-wtr_started)*24,0)*60),
                            wtr_completed = sysdate
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id;
                    EXCEPTION WHEN OTHERS THEN
                        v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in final update of ws_wrk_task_run for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                        v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                        po_result_code := -2;
                        RETURN;
                    END;
                    COMMIT;
                End If;  -- End of task record update
            ElsIf v_TaskRec.wtr_run_status = 'R' Then
                  v_running_count := v_running_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'H' Then
                  v_halted_count := v_halted_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'F' Then
                  v_failed_count := v_failed_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'U' Then
                  v_failed_count := v_failed_count + 1;
            End If; -- End of Waiting task if statement
            v_step := 240;
        END LOOP;  -- End of task Loop

        -- A task that we are ready to run will break out of the Task loop
        -- with the v_Process flag set, so proceed to process it.
        If v_Process = 1 Then
           v_step := 181;
           --=====================================================
           -- Work out the type of action and run the appropriate
           -- function.
           --=====================================================
           p_status_code := -3;
           p_return_msg := 'Unhandled exception in action';
           --=====================================================
           -- E X E C U T E
           --=====================================================
           If v_action_type = v_ws_act_execute then
              --=====================================================
              -- E X E C U T E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 8
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube execute';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 8;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 336;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
               --=====================================================
               -- E X E C U T E    P R O C E D U R E
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_procedure Then
                   v_result := ws_act_execute(p_sequence,v_obj_type,v_action_type,
                                                p_job_name, p_task_name, p_job_id, p_task_id,
                                                p_return_msg, p_status_code);
               --=====================================================
               -- E X E C U T E    S C R I P T
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_script Then
                   v_result := ws_act_host_script(p_sequence,v_obj_type,v_action_type,v_obj_key,
                                                p_job_name, p_task_name, p_job_id, p_task_id,
                                                p_return_msg, p_status_code);
                   -- If script build worked then skip out to process it
                   -- If it failed then the standard handling will deal with it.
                   If v_result >= -1 Then
                       po_job_key := p_job_id;
                       po_task_key := p_task_id;
                       po_task_name := p_task_name;
                       po_result_msg := 'execute script';
                       po_action_key := 0;
                       po_action_msg := 'no action';
                       po_result_code := 2;
                       RETURN;
                   End If;
               --=====================================================
               -- E X E C U T E    U N S U P P O R T E D
               --=====================================================
               Else
                  v_MsgText := 'Job '||pi_task_name||' sequence '||pi_sequence||
                                           ' could not perform action. Unsupported action '||
                                           v_action_type||' for object ' ||v_obj_type;
                  v_result := WsWrkAudit('E',pi_job_name, p_task_name, pi_sequence,
                                                   v_MsgText,NULL,NULL,p_task_id,p_job_id);
                  p_status_code  := -2;
                  p_return_msg := 'Unsupported action '||
                                   v_action_type||' for object ' ||v_obj_type;
                  v_result := 1;
           End If;
           --=====================================================
           -- L O A D
           --=====================================================
           ElsIf v_action_type = v_ws_act_load then
               v_result := ws_act_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
               If v_result >= -1 Then
                  If p_status_code = 1 Then
                     v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,p_task_id,p_job_id);
                  ElsIf p_status_code <> 2 Then
                       v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,p_task_id,p_job_id);
                  End If;
                  -- If this load requires a host script then we will have a
                  -- return value of 2
                  -- If script build worked then skip out to process it
                  -- If it failed then the standard handling will deal with it.
                  -- When we Rejoin the job any post load procedure will be run
                  If v_result = 2 Then
                      po_job_key := p_job_id;
                      po_task_key := p_task_id;
                      po_task_name := p_task_name;
                      po_result_msg := 'load table';
                      po_action_key := 0;
                      po_action_msg := 'no action';
                      po_result_code := 2;
                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 330;
                        BEGIN
                            IF p_job_id > 0 And v_sid <> 0 Then
                                Delete from ws_wrk_job_thread
                                Where wjt_job_key = p_job_id
                                And wjt_thread = pi_thread
                                And wjt_sequence = pi_sequence
                                And wjt_sid = v_sid
                                And wjt_serial = v_serial;
                            End If;
                           COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                               v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                      RETURN;
                  -- If this load requires an ODBC based load then we will have a
                  -- return value of 3
                  -- Skip out to process it
                  -- When we Rejoin the job any post load procedure will be run
                  ElsIf v_result = 3 Then
                      po_job_key := p_job_id;
                      po_task_key := p_task_id;
                      po_task_name := p_task_name;
                      po_result_msg := 'load table';
                      po_action_key := v_obj_key;
                      po_action_msg := 'no action';
                      po_result_code := 3;
                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 333;
                        BEGIN
                            IF p_job_id > 0 And v_sid <> 0 Then
                                Delete from ws_wrk_job_thread
                                Where wjt_job_key = p_job_id
                                And wjt_thread = pi_thread
                                And wjt_sequence = pi_sequence
                                And wjt_sid = v_sid
                                And wjt_serial = v_serial;
                            End If;
                           COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                               v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                      RETURN;
                  End If;
                  v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        p_job_name, p_task_name, p_job_id, p_task_id,
                                        p_return_msg_2, p_status_code_2);
                  If p_status_code_2 = 1 Then
                     v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                          p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                  ElsIf p_status_code_2 < 1 Then
                     v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                          p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                  End If;

                  -- If our post load procedure failed and the load worked then
                  -- record the post load failure
                  If p_status_code_2 < p_status_code Then
                       p_status_code := p_status_code_2;
                  End If;
               End If;
           --=====================================================
           -- U P D A T E
           --=====================================================
           ElsIf v_action_type = v_ws_act_update then
              --=====================================================
              -- U P D A T E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 9
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube update';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 9;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 336;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_result := ws_act_update(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- C R E A T E
           --=====================================================
           ElsIf v_action_type = v_ws_act_create then
               If v_obj_type = v_ws_obj_cube
               Or v_obj_type = v_ws_obj_cube_virtual Then
                  -- If this is a cube then let the scheduler handle it
                  -- return value of 4
                  -- Skip out to process it
                  po_job_key := p_job_id;
                  po_task_key := p_task_id;
                  po_task_name := p_task_name;
                  po_result_msg := 'cube create';
                  po_action_key := v_obj_key;
                  po_action_msg := 'no action';
                  po_result_code := 4;
                  --=====================================================
                  -- Remove this thread as being active
                  --=====================================================
                  v_step := 336;
                  BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                          Delete from ws_wrk_job_thread
                          Where wjt_job_key = p_job_id
                          And wjt_thread = pi_thread
                          And wjt_sequence = pi_sequence
                          And wjt_sid = v_sid
                          And wjt_serial = v_serial;
                      End If;
                     COMMIT;
                  EXCEPTION WHEN OTHERS THEN
                         v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                  END;
                  RETURN;
               Else
                  v_result := ws_act_create(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
               End If;
           --=====================================================
           -- D R O P
           --=====================================================
           ElsIf v_action_type = v_ws_act_drop then
              --=====================================================
              -- D R O P       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 10
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube drop';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 10;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 336;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_result := ws_act_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- D R O P    A L L
           --=====================================================
           ElsIf v_action_type = v_ws_act_drop_all then
               v_result := ws_act_drop_all(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- B U I L D
           --=====================================================
           ElsIf v_action_type = v_ws_act_build then
               v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,'',
                                            p_return_msg, p_status_code);
           --=====================================================
           -- B U I L D    A L L
           --=====================================================
           ElsIf v_action_type = v_ws_act_build_all then
               v_result := ws_act_build_all(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,'',
                                            p_return_msg, p_status_code);
           --=====================================================
           -- P R E   D R O P
           --=====================================================
           ElsIf v_action_type = v_ws_act_pre_drop then
               v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- A N A L Y Z E
           --=====================================================
           ElsIf v_action_type = v_ws_act_analyze then
              --=====================================================
              -- A N A L Y Z E      C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 8
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube analyze';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 8;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 336;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_result := ws_act_analyze(p_sequence,v_obj_type,v_action_type, 100,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- Q U I C K    A N A L Y Z E
           --=====================================================
           ElsIf v_action_type = v_ws_act_quick_analyze then
              --=====================================================
              -- Q U I C K    A N A L Y Z E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 9
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube quick analyze';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 9;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 336;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                v_result := ws_act_analyze(p_sequence,v_obj_type,v_action_type, 3,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- S T A T I S T I C S
           --=====================================================
           ElsIf v_action_type = v_ws_act_statistics then
               v_result := ws_act_dbms_stats(p_sequence,v_obj_type,v_action_type, 100,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- Q U I C K   S T A T S
           --=====================================================
           ElsIf v_action_type = v_ws_act_quick_statistics then
               v_result := ws_act_dbms_stats(p_sequence,v_obj_type,v_action_type, 3,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- P R O C E S S
           --=====================================================
           ElsIf v_action_type = v_ws_act_process then
               --=====================================================
               -- P R O C E S S      C U B E
               --=====================================================
               If v_obj_type = v_ws_obj_cube
               Or v_obj_type = v_ws_obj_cube_virtual Then
                  -- If this is a cube then let the scheduler handle it
                  -- return value of 5
                  -- Skip out to process it
                  po_job_key := p_job_id;
                  po_task_key := p_task_id;
                  po_task_name := p_task_name;
                  po_result_msg := 'cube process';
                  po_action_key := v_obj_key;
                  po_action_msg := 'no action';
                  po_result_code := 5;
                  --=====================================================
                  -- Remove this thread as being active
                  --=====================================================
                  v_step := 336;
                  BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                          Delete from ws_wrk_job_thread
                          Where wjt_job_key = p_job_id
                          And wjt_thread = pi_thread
                          And wjt_sequence = pi_sequence
                          And wjt_sid = v_sid
                          And wjt_serial = v_serial;
                      End If;
                     COMMIT;
                  EXCEPTION WHEN OTHERS THEN
                         v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                  END;
                  RETURN;
               End If;
               --=====================================================
               -- P R O C E S S      L O A D
               --=====================================================
               If v_obj_type = v_ws_obj_load Then
                   v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
                   If v_result >= -1 Then
                      If p_status_code = 1 Then
                          v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,p_task_id,p_job_id);
                      Else
                          v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,p_task_id,p_job_id);
                      End If;
                      v_result := ws_act_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
                      -- If this load requires a host script then we will have a
                      -- return value of 2
                      -- If script build worked then skip out to process it
                      -- If it failed then the standard handling will deal with it.
                      -- When we Rejoin the job any post load procedure will be run
                      If v_result = 2 Then
                          po_job_key := p_job_id;
                          po_task_key := p_task_id;
                          po_task_name := p_task_name;
                          po_result_msg := 'process table';
                          po_action_key := 0;
                          po_action_msg := 'no action';
                          po_result_code := 2;
                            --=====================================================
                            -- Remove this thread as being active
                            --=====================================================
                            v_step := 330;
                            BEGIN
                                IF p_job_id > 0 And v_sid <> 0 Then
                                    Delete from ws_wrk_job_thread
                                    Where wjt_job_key = p_job_id
                                    And wjt_thread = pi_thread
                                    And wjt_sequence = pi_sequence
                                    And wjt_sid = v_sid
                                    And wjt_serial = v_serial;
                                End If;
                               COMMIT;
                            EXCEPTION WHEN OTHERS THEN
                                   v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                            END;
                          RETURN;
                      -- If this load requires an ODBC load then we will have a
                      -- return value of 3
                      -- Skip out to process it
                      -- When we Rejoin the job any post load procedure will be run
                      ElsIf v_result = 3 Then
                          po_job_key := p_job_id;
                          po_task_key := p_task_id;
                          po_task_name := p_task_name;
                          po_result_msg := 'process table';
                          po_action_key := v_obj_key;
                          po_action_msg := 'no action';
                          po_result_code := 3;
                            --=====================================================
                            -- Remove this thread as being active
                            --=====================================================
                            v_step := 336;
                            BEGIN
                                IF p_job_id > 0 And v_sid <> 0 Then
                                    Delete from ws_wrk_job_thread
                                    Where wjt_job_key = p_job_id
                                    And wjt_thread = pi_thread
                                    And wjt_sequence = pi_sequence
                                    And wjt_sid = v_sid
                                    And wjt_serial = v_serial;
                                End If;
                               COMMIT;
                            EXCEPTION WHEN OTHERS THEN
                                   v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                            END;
                          RETURN;
                      End If;
                   End If;
                   If v_result >= -1 Then
                      v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg_2, p_status_code_2);
                   Else
                       p_status_code_2 := 1;
                   End If;
                   If v_result >= -1 Then
                      If p_status_code_2 = 1 Then
                          v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                      Else
                          v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                      End If;
                      v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,'',
                                            p_return_msg_3, p_status_code_3);
                      If p_status_code_3 = 1 Then
                         v_result := WsWrkAudit('I',pi_job_name, p_task_name, pi_sequence,
                                              p_return_msg_3,NULL,NULL,p_task_id,p_job_id);
                      ElsIf p_status_code_3 < 1 Then
                         v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                              p_return_msg_3,NULL,NULL,p_task_id,p_job_id);
                      End If;
                   Else
                       p_status_code_3 := 1;
                   End If;

                   -- If our index build failed and the load worked then
                   -- record the index failure
                   If p_status_code_2 < p_status_code Then
                        p_status_code := p_status_code_2;
                   End If;
                   If p_status_code_3 < p_status_code Then
                        p_status_code := p_status_code_3;
                   End If;
               --=====================================================
               -- P R O C E S S      U P D A T E
               --=====================================================
               Else
                    v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
                   If v_result >= -1 Then
                      If p_status_code = 1 Then
                          v_result := WsWrkAudit('S',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,p_task_id,p_job_id);
                      Else
                          v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,p_task_id,p_job_id);
                      End If;
                      v_result := ws_act_update(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,
                                            p_return_msg, p_status_code);
                   End If;
                   If v_result >= -1 Then
                       v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            p_job_name, p_task_name, p_job_id, p_task_id,'',
                                            p_return_msg_2, p_status_code_2);
                       If p_status_code_2 = 1 Then
                          v_result := WsWrkAudit('S',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                       ElsIf p_status_code_2 < 1 Then
                          v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
                       End If;
                   Else
                      p_status_code_2 := 1;
                   End If;

                   -- If our index build failed and the update worked then
                   -- record the index failure
                   If p_status_code_2 < p_status_code Then
                        p_status_code := p_status_code_2;
                   End If;
               End If;
           --=====================================================
           -- I N I T I A L     L O A D
           --=====================================================
           ElsIf v_action_type = v_ws_act_initial then
                v_result := ws_act_drop_all(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        p_job_name, p_task_name, p_job_id, p_task_id,
                                        p_return_msg, p_status_code);
               If v_result >= -1 Then
                  If p_status_code = 1 Then
                      v_result := WsWrkAudit('S',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,p_task_id,p_job_id);
                  Else
                      v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,p_task_id,p_job_id);
                  End If;
                  v_result := ws_act_initial_build(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        p_job_name, p_task_name, p_job_id, p_task_id,
                                        p_return_msg, p_status_code);
               End If;
               If v_result >= -1 Then
                   v_result := ws_act_build_all(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        p_job_name, p_task_name, p_job_id, p_task_id,'',
                                        p_return_msg_2, p_status_code_2);
               End If;
               If p_status_code_2 = 1 Then
                  v_result := WsWrkAudit('S',pi_job_name, p_task_name, pi_sequence,
                                       p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
               ElsIf p_status_code_2 < 1 Then
                  v_result := WsWrkAudit('W',pi_job_name, p_task_name, pi_sequence,
                                       p_return_msg_2,NULL,NULL,p_task_id,p_job_id);
               End If;

               -- If our index build failed and the initial load worked then
               -- record the index failure
               If p_status_code_2 < p_status_code Then
                    p_status_code := p_status_code_2;
               End If;
           --=====================================================
           -- C U S T O M
           --=====================================================
           ElsIf v_action_type = v_ws_act_custom then
              v_result := ws_act_initial_build(p_sequence,v_obj_type,v_action_type,
                                    v_obj_key,
                                    p_job_name, p_task_name, p_job_id, p_task_id,
                                    p_return_msg, p_status_code);
           --=====================================================
           -- C U B E   P R O C E S S    C U B E   D I M S
           --=====================================================
           ElsIf v_action_type = v_ws_act_cube_dim then
              -- If this is a cube then let the scheduler handle it
              -- return value of 6
              -- Skip out to process it
              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_msg := 'cube process cube dimensions';
              po_action_key := v_obj_key;
              po_action_msg := 'no action';
              po_result_code := 6;
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 337;
              BEGIN
                  IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                  End If;
                 COMMIT;
              EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;
           --=====================================================
           -- C U B E   P R O C E S S    D A T A B A S E   D I M S
           --=====================================================
           ElsIf v_action_type = v_ws_act_db_dim then
              -- If this is a cube then let the scheduler handle it
              -- return value of 7
              -- Skip out to process it
              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_msg := 'cube process db dimensions';
              po_action_key := v_obj_key;
              po_action_msg := 'no action';
              po_result_code := 7;
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 338;
              BEGIN
                  IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                  End If;
                 COMMIT;
              EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;
           --=====================================================
           -- U N S U P P O R T E D
           --=====================================================
           Else
              v_MsgText := 'Job '||pi_task_name||' sequence '||pi_sequence||
                                       ' could not perform action. Unsupported action '||
                                       v_action_type||' for object ' ||v_obj_type;
              v_result := WsWrkAudit('E',pi_job_name, p_task_name, pi_sequence,
                                               v_MsgText,NULL,NULL,p_task_id,p_job_id);
              p_status_code  := -2;
              p_return_msg := 'Unsupported action '||
                               v_action_type||' for object ' ||v_obj_type;
              v_result := 1;
           End If;
           COMMIT;
           v_step := 190;
           --=====================================================
           -- Check that our function worked. If not then task failed
           --=====================================================
           --If v_result = -3 Then
           --    p_status_code := -3;
           --    If ltrim(rtrim(p_return_msg)) =  Then
           --         p_return_msg := Unhandled exception in action;
           --    End If;
           --End If;

           v_just_done := 1;
           v_step := 192;
           --=====================================================
           -- Log the results in the audit trail
           --=====================================================
           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, p_job_name, p_task_name, p_sequence,
                     p_return_msg, NULL, NULL, p_task_id, p_job_id);
            --=====================================================
            -- See if the task needs a status update.
            --=====================================================
            If v_okay = 1 OR v_halted = 1 Then
                --=====================================================
                -- Update the run record to indicate our final status
                -- If we have a halt then generate a message
                --=====================================================
                v_step := 230;
                If v_halted = 1 Then
                     p_return_msg := 'Halted by dependency failure or halt';
                     v_run_status := 'H';
                     v_audit_status := NULL;
                End If;
                BEGIN
                  update ws_wrk_task_run
                  set wtr_run_status = v_run_status,
                        wtr_audit_status = v_audit_status,
                        wtr_return_msg = p_return_msg,
                        wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
                        wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                         trunc(to_number(sysdate-wtr_started)*24,0)*60),
                        wtr_completed = sysdate
                  where wtr_task_key = v_task_key
                  and wtr_job_key = p_job_id;
                EXCEPTION WHEN OTHERS THEN
                    v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                               ' failed in final update of ws_wrk_task_run for task id '||
                                               v_task_key||'. Run incomplete !!!';
                    v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
                    po_result_code := -2;
                    RETURN;
                END;
                COMMIT;
            End If;  -- End of task record update
        Else -- not processing, so must be an idle thread
           v_idle_thread := 1;
        End If; -- End of Processing of a task

        -- If just processed then sleep for 2 seconds and look for next task
        If v_just_done = 0 Then
            DBMS_LOCK.SLEEP(2);
        End If;

        -- If the thread is idle then sleep for 30 seconds.
        If v_idle_thread = 1 And v_running_count > 0 Then
            DBMS_LOCK.SLEEP(30);
        End If;

    END LOOP; -- End of While More tasks Loop

    v_step := 250;

    DBMS_SQL.CLOSE_CURSOR(v_cursor);

   --=====================================================
    --      A L L      T A S K S      D O N E
    --=====================================================
    --=====================================================
    -- Here if no more waiting tasks. If no more running tasks
    -- then all threads are finished, so update the job_run
    -- record to a completed state
    -- WMR Need to update the ctrl record and move the run records to the log tables. WMR
    --=====================================================
    po_action_key := 0;
    po_action_msg := '';
    v_step := 260;
    If v_running_count = 0 Then

      v_okay := 0;

      -- work out what the return will be
      If v_halted_count = 0 AND v_failed_count = 0 Then
           v_job_status := 'C';
           v_audit_status := 'S';
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                  ' Completed. ';
           BEGIN
              Select wjr_publish_okay into v_OkayMsg
              From ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              v_FailMsg := '';
           EXCEPTION WHEN OTHERS THEN
              v_OkayMsg := '';
              v_FailMsg := '';
           END;
      Else
           v_job_status := 'F';
           v_audit_status := 'F';
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                  ' FAILED. ';
           BEGIN
              Select wjr_publish_fail into v_FailMsg
              From ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              v_OkayMsg := '';
           EXCEPTION WHEN OTHERS THEN
              v_OkayMsg := '';
              v_FailMsg := '';
           END;
      End If;

      --=====================================================
      -- All tasks done
      -- Set the job status on the run record and job finish time
      -- Need to lock the record first to prevent another thread from
      -- grabbing it, or in case another thread has already got it,
      -- or updated it
      --=====================================================
     v_step := 270;
     BEGIN
        select wjr_status into v_run_status
        from ws_wrk_job_run
        where wjr_job_key = p_job_id
        and wjr_sequence = pi_sequence
        for update nowait;
        If v_run_status = 'R' Then
           update ws_wrk_job_run
           set wjr_status = v_job_status,
                 wjr_elapsed_hh =  trunc(to_number(sysdate-wjr_started)*24,0),
                 wjr_elapsed_mi = round(to_number(sysdate-wjr_started)*24*60,0) - (
                                                         trunc(to_number(sysdate-wjr_started)*24,0)*60),
                wjr_completed = sysdate
           where wjr_job_key = p_job_id
           and wjr_sequence = pi_sequence;
           v_okay := 1;
        Else
            -- someone else got the record
            v_okay := 0;
         End If;
     EXCEPTION WHEN OTHERS THEN
        -- If a resource busy someone else has the record
        -- so skip it
        -- If a no data found then the run record has already been
        -- changed to log so all okay
        If SQLCODE = -54 Then
            v_okay := 0;
        ElsIf SQLCODE = 100 Then
            v_okay := 0;
        Else
            v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                            ' failed to change state to completed '||
                                            'in ws_wrk_job_run.!!!';
            v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            po_result_code := -2;
            RETURN;
         End If;
     END;
     COMMIT;

     -- if we are the thread doing the update then
     -- write to the audit trail and complete the cleanup
     If v_okay = 1 Then

       If v_OkayMsg is not Null Then
           po_action_key := 1;
           po_action_msg := v_OkayMsg;
       End If;
       If v_FailMsg is not Null Then
           po_action_key := 2;
           po_action_msg := v_FailMsg;
       End If;



       v_result := WsWrkAudit(v_audit_status,pi_job_name, pi_job_name, pi_sequence,
                                                v_MsgText,NULL,NULL,0,p_job_id);


       -- Set the job status on the control record for the job and finish time.
       -- WMR need to set the status to HOLD or Waiting depending on if another run.
       v_step := 280;
       BEGIN
           update ws_wrk_job_ctrl
           set wjc_last_status = v_job_status,
                wjc_completed = sysdate
           where wjc_job_key = p_job_id;
       EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                            ' failed to change completed time for job '||
                                            'in ws_wrk_job_ctrl.!!!';
            v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
            po_result_code := -2;
            RETURN;
       END;
       COMMIT;

       v_step := 290;
       If v_job_status = 'C' Then
         -- Move the job run record to the log record
         v_step := 300;
         BEGIN
              insert into ws_wrk_job_log
              select * from ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              COMMIT;
              delete from ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              COMMIT;
         EXCEPTION WHEN OTHERS THEN
              v_MsgText := 'Job '||pi_job_name||' failed in xfer to ws_wrk_job_log. '||
                                               ' No Action !!!';
              v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
              po_result_code := -2;
              RETURN;
         END;

         -- Move the task run records to the log record
         v_step := 310;
         BEGIN
              insert into ws_wrk_task_log
              select * from ws_wrk_task_run
              where wtr_job_key = p_job_id
              and wtr_sequence = pi_sequence;
              COMMIT;
              v_step := 320;
                 delete from ws_wrk_task_run
              where wtr_job_key = p_job_id
              and wtr_sequence = pi_sequence;
              COMMIT;
         EXCEPTION WHEN OTHERS THEN
              v_MsgText := 'Job '||pi_job_name||' failed in xfer of tasks to ws_wrk_task_log. '||
                                               ' No Action !!!';
             v_result := WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
             po_result_code := -2;
             RETURN;
         END;
       End If;

       -- If this job has a blocked iteration waiting then release it
       v_step := 311;
       BEGIN
            update ws_wrk_job_ctrl
                set wjc_status = 'W'
                where wjc_job_key = p_job_id
                and wjc_status = 'B';
            COMMIT;
       EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Job '||pi_job_name||' failed to release blocked job. '||
                                             ' No Action !!!';
            v_result := WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                                     v_MsgText,SQLCODE,SQLERRM,0,p_job_id);
       END;

     End If; -- end of final thread

    End If; -- end of running count 0

    --=====================================================
    -- Remove this thread as being active
    --=====================================================
    v_step := 330;
    BEGIN
        IF p_job_id > 0 And v_sid <> 0 Then
            Delete from ws_wrk_job_thread
            Where wjt_job_key = p_job_id
            And wjt_thread = pi_thread
            And wjt_sequence = pi_sequence
            And wjt_sid = v_sid
            And wjt_serial = v_serial;
        End If;
       COMMIT;
    EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
    END;

   v_step := 340;
   COMMIT;
   po_result_code := 1;

   RETURN;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_job_execute. '||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', pi_job_name, pi_job_name, pi_sequence,
                          v_MsgText,SQLCODE, SQLERRM, 0,p_job_id);
   po_result_code := -3;
   RETURN;
END ws_job_exec_010;
 
_PROCEDURE_ Ws_Job_Exec_411 
-- Notes / History
-- WMR 24/08/2001                      Reworked the task loop to prevent the holding open of the
--                                     TaskRun cursor, causing a Rollback too old problem
-- WMR 24/08/2001                      If a job has a previously failed Sequence then let the job go.
--                                     If it has a running Sequence then put it into Hold
-- WMR 09/11/2001                      If a restart then check job is pending. Change to ws_job_wait.
-- WMR 22/01/2002     Version 1.0.0
-- WMR 08/03/2002                      Handle change of SID when breakout to perform host script
-- WMR 05/04/2002                      Changed analyze from 1% to 3%. Handle new wj_scheduler column
-- WMR 06/04/2002                      Handle ODBC based loads.
-- WMR 09/04/2002                      Handle customer jobs in working out next scheduled time
--                                     Handle blocked jobs. Release them when a job has finished or failed
-- WMR 23/05/2002                      Additional info message and check if unable to rejoin a job
-- WMR 25/05/2002                      All job_name comparisons use upper and rtrim
-- WMR 01/10/2002                      Threads sleep for 30 seconds if no action and tasks still running
-- WMR 18/10/2002                      Invalid return status now assumed to be a failure.
-- WMR 03/10/2003     Version 4.1.0    added support for cube creation and processing
-- WMR 16/10/2003                      Check for logs to delete and call Ws_Job_Clear_Logs if required
-- WMR 31/10/2003                      Added support for cube and database specific dimension processing
-- WMR 18/11/2003                      No data found in update of final status indicates that some other
--                                     thread did the update and move. so all okay
-- WMR 19/11/2003                      If an unknown status returned then treat it as a failure, so job will fail
-- WMR 09/03/2004                      Added support for virtual cube creation and processing
-- WMR 10/05/2004                      Added support for custom procedures.
-- WMR 23/07/2004                      Added support for parameters to be passed to Ws_Act_Build and Ws_Act_Build_All
-- WMR 23/09/2004                      Changed custom scheduling to us the day name instead of number
-- WMR 24/02/2005                      Added ability to call another job from a running job
-- WMR 01/03/2005                      Added Ws_Act_Truncate
-- WMR 01/03/2005                      Added check for dependency loops and fail if loop found.
-- WMR 14/03/2005                      Removed any reference to ''. Changed it to NULL
-- WMR 17/03/2005                      Put the task order into the wtr_thread field so that we can sort
--                                     waiting tasks. It will be overwritten with the thread when the
--                                     task starts,
-- WMR 18/03/2005                      Scheduler incorrectly flagging a job as having a dependency loop
-- WMR 27/05/2005                      Scheduler incorrectly flagging a job as having a dependency loop
--                                     when two threads went for the last task at the same time.
-- WMR 27/06/2005                      Removed reference to DBMS_SQL. Was unused.
-- WMR 06/07/2005                      Remove dependency flag if no tasks are waiting.
-- WMR 04/04/2006                      Changed custom job re-scheduling to prevent time creep.
-- WMR 04/04/2006                      Pre drop and build of indexes during a process are now flagged as Information
-- AP  01/08/2006     Version 5.5.0.5  Add Version Number as constant to all out messages
--                                     Change updates to be full transactions (not commits at each stage) so
--                                      don't end up with integrity issues in event of failure
--                                     Add seq to select stmt for non 0 thread tasks when selecting job key
--                                     Added ordering default to cursor c_TaskRun.. eventually want to have this
--                                      changed to use the sort order from the tasks but this reqs meta change
--                                     Added DSS parameter substitution for job fail/success message
--                                     Custom job re-scheduling was skipping a day in some cases.
-- WMR 02/11/2006     Version 5.5.0.7  Fixed a problem in dependent cursor where child jobs where present
-- JML 22/03/2007     Version 5.5.0.17 support for Native ODBC loads Added.
-- WMR 06/04/2007     Version 5.6.0.0  support for Retrofit ODBC loads Added.
-- JML 17/04/2007     Version 5.6.0.0  support for Export Objects Added.
-- WMR 08/05/2007     Version 5.6.0.4  Changed custom job re-scheduling to use v_start_after_date instead of sysdate.
-- WMR 08/05/2007     Version 5.6.0.6  Fix for retrofit odbc. Added the variable v_ws_obj_max to define the last object
-- AP  26/07/2007     Version 5.6.1.1  Reset depend loop count as soon as find a task so as to minimise risk
--                                     of erroneous dependency loop error message
-- AP  20/11/2007     Version 5.6.2.1  When deleting from ws_wrk_scr_* use parent job_key
-- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
--                                     New wtr_order column included
--                                     New override for wait for idle tasks
-- AP  10/06/2008     Version 6.0.4.1  Implement new '-99' return code for blocked job so handle nicer
--                                     Implement new '-98' return code for no active job found
-- CJL 02/08/2009                      Replace Schedule calcs with ws_job_get_start
-- AP  04/01/2010     Version 6.1.0.0  Implement OLAP objects
-- AP  07/05/2010     Version 6.1.0.2  Tidy up of test for job existence
-- AP  02/07/2010     Version 6.1.1.1  Remove select into v_start_after _hour/minute as not required
-- AP  28/11/2011     Version 6.5.5.1  RED_2382 Support SQLBlock (Return values of 16 and 17)
--                                     RED_???? Support SSIS Loads (Return Value = 14)
-- AP  23/09/2013     Version 6.7.2.0  RED-3266 - Correct support for Integration Services Loads
-- RS  01/10/2014     Version 6.8.1.2  RED_3792 - Correct missing job substitutions for blocked jobs
-- TA  21/05/2015     Version 6.8.3.4  RED-5063 Support SSIS Export
-- BC  14/08/2015     Version 6.8.4.3  RED-5520 Replaced occurrences of the != SQL operator with <>
-- BC  11/02/2016     Version 6.8.5.3  Added support for BDA Server operations
-- TA  26/02/2016     Version 6.8.5.3  Added support for BDA Server authentication
-- HM  08/03/2016     Version 6.8.5.3  Comment fixes
-- RS  21/03/2016     Version 6.8.5.3  Added support for ODBC load into Hive tables
-- TA  11/03/2016     Version 6.8.5.4  RED-5890 Added support for Database Link Loads into Hive targets
-- BC  29/03/2016     Version 6.8.5.4  Added support for MSAS Tabular table operations
-- BC  05/04/2016     Version 6.8.5.4  RED-6379 Fixed issue with child jobs when blocked
-- BC  07/04/2016     Version 6.8.5.4  Fixed execution of child BDA tasks to output task data from nested call
-- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
-- AP  22/06/2016     Version 6.8.6.2  RED-3282 Support 'disabled' tasks
-- BC  28/09/2016     Version 6.8.6.2  RED-7268 Prevent Hive script loads and exports going to BDA.
-- HM  03/10/2016     Version 6.8.6.2  RED-7055 Add support for on-the-fly template DDL evaluation
-- HM  12/10/2016     Version 6.8.6.3  RED-7193 Assign new return code for on-the-fly template DDL evaluation
-- RS  14/12/2016     Version 6.8.6.3  RED-7626 Added check if object key is a child job before looking at BDA connection
-- FS  28/03/2017     Version 6.8.8.0  RED-7898 Fixed issue with child jobs and SQLBLOCK
-- BC  10/08/2017     Version 8.0.1.0  RED-7560 Fixed to exit to caller to process actions for remote objects
-- HM  03/10/2017     Version 8.1.1.0  RED-8704 Added support for Source Mapping
-- BC  07/03/2018     Version 8.1.1.0  RED-9267 Fix check for external object when processing Source Mapping
-- AD  13/08/2018     Version 8.3.1.0  RED-9704 Fix high IO usage on scheduler query on Teradata
-- BC  10/10/2018     Version 8.3.1.0  RED-9814 Fix to prevent execution of Post-load procedures or scripts of remote objects
-- BC  10/10/2018     Version 8.3.1.0  RED-9814 Fix query to determine if there is any Hive target when multiple rows found
-- BC  19/12/2018     Version 8.3.1.0  RED-10133 Fix to not treat a child job as an external object
-- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

-- ****************************************************
-- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
-- ****************************************************
--

CREATE OR REPLACE procedure ws_job_exec_411
    (
    pi_job_name         IN  varchar2,
    pi_task_name        IN  varchar2,
    pi_action           IN  varchar2,
    pi_thread           IN  number,
    pi_sequence         IN  number,
    pi_job_key          IN  number,
    pi_task_key         IN  number,
    pi_task_status      IN  number, -- used during rejoin to pass back a tasks status
    pi_task_msg         IN  varchar2,
    pm_job_name         IN  varchar2, -- Master job name ( used in audit trail)
    pm_job_key          IN  number,   -- Master job key ( used in audit trail )
    pm_rejoin_job_keys  IN  varchar2, -- List of job keys to rejoin on.
    pm_rejoin_task_keys IN  varchar2, -- List of task keys to rejoin on.
    po_result_code      OUT number,
    po_result_msg       OUT varchar2,
    po_job_key          OUT number,
    po_task_key         OUT number,
    po_task_name        OUT varchar2,
    po_action_key       OUT number,
    po_action_msg       OUT varchar2,
    ps_job_key_list     OUT varchar2, -- ( list of jobs to pass task down to. Comma separated )
    ps_task_key_list    OUT varchar2,
    po_task_data        OUT varchar2
    )
    AUTHID CURRENT_USER
    As

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name        : Oracle
    -- Script Name      : ws_job_exec_411
    -- Description      : Executes a WhereScape Job
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Constants
    --=====================================================
    v_ws_pro_version           constant varchar2(15) := '(8.4.1.0)';
    v_ws_obj_procedure         constant number := 1;
    v_ws_obj_fact_kpi          constant number := 2;
    v_ws_obj_script            constant number := 3;
    v_ws_obj_template          constant number := 4;
    v_ws_obj_fact              constant number := 5;
    v_ws_obj_dim               constant number := 6;
    v_ws_obj_stage             constant number := 7;
    v_ws_obj_load              constant number := 8;
    v_ws_obj_agg               constant number := 9;
    v_ws_obj_index             constant number := 10;
    v_ws_obj_connect           constant number := 11;
    v_ws_obj_dim_view          constant number := 12;
    v_ws_obj_export            constant number := 13;
    v_ws_obj_cube              constant number := 15;
    v_ws_obj_cube_virtual      constant number := 16;
    v_ws_obj_report            constant number := 17;
    v_ws_obj_view              constant number := 18;
    v_ws_obj_file              constant number := 19;
    v_ws_obj_join              constant number := 20;
    v_ws_obj_retro             constant number := 21;
    v_ws_obj_retro_copy        constant number := 22;
    v_ws_obj_olap_cube         constant number := 23;
    v_ws_obj_olap_dim          constant number := 24;
    v_ws_obj_olap_role         constant number := 25;
    v_ws_obj_ods               constant number := 26;
    v_ws_obj_normal            constant number := 27;
    v_ws_obj_hub               constant number := 28;
    v_ws_obj_satellite         constant number := 29;
    v_ws_obj_link              constant number := 30;
    v_ws_obj_custom1           constant number := 31;
    v_ws_obj_custom2           constant number := 32;
    v_ws_obj_max               constant number := 32;

    v_ws_obj_job               constant number := 50;
    v_ws_obj_source_mapping    constant number := 69;

    v_ws_act_drop              constant number := 1;
    v_ws_act_create            constant number := 2;
    v_ws_act_drop_all          constant number := 3;
    v_ws_act_pre_drop          constant number := 4;
    v_ws_act_load              constant number := 5;
    v_ws_act_update            constant number := 6;
    v_ws_act_execute           constant number := 7;
    v_ws_act_process           constant number := 8;
    v_ws_act_build             constant number := 9;
    v_ws_act_build_all         constant number := 10;
    v_ws_act_analyze           constant number := 11;
    v_ws_act_quick_analyze     constant number := 12;
    v_ws_act_statistics        constant number := 13;
    v_ws_act_quick_statistics  constant number := 14;
    v_ws_act_initial           constant number := 15;
    v_ws_act_cube_dim          constant number := 16;
    v_ws_act_db_dim            constant number := 17;
    v_ws_act_custom            constant number := 18;
    v_ws_act_truncate          constant number := 19;

    v_wants_to_run             integer := 1;
    v_ws_act_disabled_once     constant char(1) := 'A';
    v_ws_act_disabled          constant char(1) := 'B';

    v_ws_create_ddl_type       constant char(1) := '3';

    --=====================================================
    -- Parameters to the called procedures
    --=====================================================
    p_sequence                 number;
    p_job_name                 varchar2(64);
    p_task_name                varchar2(64);
    p_task_id                  number;
    p_job_id                   number;
    p_return_msg               varchar2(1024);
    p_status_code              number;
    p_return_msg_2             varchar2(1024);
    p_status_code_2            number;
    p_return_msg_3             varchar2(1024);
    p_status_code_3            number;

    --=====================================================
    -- Variables
    --=====================================================
    v_rec_count                number;
    v_job_count                number;
    v_task_count               number;
    v_child_key                number;
    v_run_status               varchar2(1);
    v_audit_status             varchar2(1);
    v_abort_level              number;
    v_halted                   number;
    v_okay                     number;
    v_checked                  number;
    v_running_count            number;
    v_failed_count             number;
    v_halted_count             number;
    v_job_status               varchar2(1);
    v_loop_count               number;
    v_MsgText                  varchar2(1024); -- Text in audit_trail
    v_OkayMsg                  varchar2(256);  -- Okay result command
    v_FailMsg                  varchar2(256);  -- Failure result command
    v_result                   number;
    v_status_code              varchar2(1);
    v_step                     integer := 0;   -- return code
    v_Cursor                   number;
    v_Just_done                integer := 0;
    v_idle_thread              integer := 0;
    v_start_hh                 integer;
    v_start_mi                 integer;
    v_start_day                integer;
    v_job_type                 varchar2(1);
    v_sid                      integer;
    v_serial                   integer;
    v_process                  integer;
    v_action_type              integer;
    v_obj_type                 integer;
    v_obj_key                  integer;
    v_task_key                 integer;
    v_ctrl_sequence            integer;
    v_start_after              date;
    v_cust_sa_hh               integer;
    v_cust_sa_mm               integer;
    v_cust_sb_hh               integer;
    v_cust_sb_mm               integer;
    v_cust_min                 integer;
    v_cust_days                integer;
    v_cust_sb                  integer;
    v_cust_sa                  integer;
    v_more                     integer;
    v_AddDays                  integer;
    v_wait_HH                  integer;
    v_wait_MM                  integer;
    v_cur_HH                   integer;
    v_cur_MM                   integer;
    v_cur_HHMM                 integer;
    v_cur_day_name             varchar(3);
    v_Monday                   integer;
    v_Tuesday                  integer;
    v_Wednesday                integer;
    v_Thursday                 integer;
    v_Friday                   integer;
    v_Saturday                 integer;
    v_Sunday                   integer;
    v_log_keep                 integer;
--    v_start_after_hour         integer;
--    v_start_after_minute       integer;
    v_new_HH                   integer;
    v_new_MM                   integer;
    v_new_HHMM                 integer;
    v_increment                integer;
    v_increment_days           integer;
    v_increment_current        integer;
    v_spos                     integer;
    v_epos                     integer;
    v_work                     varchar2(4000);
    v_parameter                varchar2(4000);
--    v_start_after_date         date;
    v_idle_thread_wait         integer;-- wait interval for an idle thread
    v_retry                    integer;  -- variable to act as a boolean for retry/while loops
    v_retry_msg_count          integer;  -- counter of retries for message logging (want to try more often than report)
    v_procedure_type           varchar2(1);
    v_any_hive_targets         integer;
    v_bda_connect_key          integer;
    v_is_hive_target           integer;
    v_secret_id                integer;
    v_secret_text              varchar2(4000);
    v_task_data                varchar2(4000);
    v_is_msas_tabular_target   integer;
    v_is_template_ddl_target   integer;
    v_target_key               integer;
    v_target_db_type           integer;

    --=====================================================
    -- Variables for jobs from jobs
    --=====================================================
    v_job_result_code          integer;
    v_job_result_msg           varchar2(1024);
    v_job_job_key              integer;
    v_job_job_name             varchar2(64);
    v_job_task_key             integer;
    v_job_task_name            varchar2(64);
    v_job_key_list             varchar2(256);
    v_task_key_list            varchar2(256);
    v_job_action_key           integer;
    v_job_action_msg           varchar2(4000);
    v_integer                  integer;
    v_audit_job_id             integer;
    v_audit_task_id            integer;
    v_audit_job_name           varchar2(64);
    v_audit_task_name          varchar2(64);
    v_child_job                integer := 0;
    v_sub_job_key              integer;
    v_sub_task_key             integer;
    v_my_job_key               integer;
    v_my_task_key              integer;
    v_sub_job_name             varchar2(64);
    v_my_task_name             varchar2(64);
    v_rejoin_job_keys          varchar2(256);
    v_rejoin_task_keys         varchar2(256);
    v_cpos                     integer;
    v_pm_job_key               integer;
    v_pm_job_name              varchar2(64);
    v_restart_flag             integer := 0;
    v_run_count                integer := 0;
    v_job_action               varchar2(64);
    v_depend_loop              integer := 0;

   --=====================================================
    -- Cursor for all the task control records to be added to task run
    --=====================================================
    Cursor c_TaskCtrl is
    Select *
    from  ws_wrk_task_ctrl
    Where wtc_job_key = p_job_id;

    --=====================================================
    -- Cursor for all the task run records waiting to be run
    --=====================================================
    Cursor   c_TaskRun is
    SELECT   ws_wrk_task_run.*
    FROM     ws_wrk_task_run
    WHERE    wtr_job_key = p_job_id
    AND      wtr_sequence = pi_sequence
    ORDER BY wtr_type desc,wtr_name;

    --=====================================================
    -- Cursor for all the parent dependencies of a particular task
    --=====================================================
    Cursor c_Dependency is
    Select *
    from ws_wrk_dependency
    Where wdp_job_key = p_job_id
    And wdp_child_task_key = v_child_key;

BEGIN
    v_step := 100;

    p_job_name := pi_job_name;
    p_task_name := pi_task_name;
    p_sequence := pi_sequence;
    p_job_id := 0;
    p_task_id := 0;
    po_job_key := p_job_id;
    po_task_key := p_task_id;
    po_task_name := p_task_name;
    po_task_data := '';
    po_result_msg := 'no result';
    v_idle_thread_wait :=30;

    -- setup the default audit log variables
    v_audit_job_id := p_job_id;
    v_audit_task_id := pi_task_key;
    v_audit_job_name := pi_job_name;
    v_audit_task_name := pi_task_name;

    -- If we have a calling job then setup to use it's keys in the audit log
    IF pm_job_name IS NOT NULL THEN
      IF pm_job_name <> pi_job_name THEN
        v_audit_job_id := pm_job_key;
        v_audit_job_name := pm_job_name;
        v_audit_task_name := pi_job_name;
        v_child_job := 1;
      END IF;
      v_pm_job_key := pm_job_key;
      v_pm_job_name := pm_job_name;
    ELSE
      v_pm_job_key := p_job_id;
      v_pm_job_name := pi_job_name;
    END IF;


    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --                  N E W       J O B
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- If we are a New job then check we are not already running, under
    -- this or some other sequence number.
    -- Create the job_run and task_run records
    --=====================================================
    If upper(pi_action) = 'NEW' Then
        v_step := 200;

        --=====================================================
        -- If we are thread 0 then do some checks and create the records
        --=====================================================
        IF pi_thread = 0 Then
            v_step := 300;

            -- Get the job key for the job name. There should be one and
            -- only one key. Otherwise a fatal problem.
            BEGIN
                  SELECT wjc_job_key, wjc_type, wjc_start_hour, wjc_start_minute, wjc_start_day,
                         wjc_sequence, wjc_publish_fail,
                         nvl(wjc_cust_sa_hh,0), nvl(wjc_cust_sa_mm,0),
                         nvl(wjc_cust_sb_hh,0), nvl(wjc_cust_sb_mm,0),
                         nvl(wjc_cust_min,0), nvl(wjc_cust_days,0),
                         nvl(wjc_avg_count,0),
--                         to_number(to_char(wjc_start_after,'HH24')),
--                         to_number(to_char(wjc_start_after,'MI')),
                         wjc_start_after, NVL(wjc_idle_thread_wait ,30)
                  INTO   p_job_id, v_job_type, v_start_hh, v_start_mi, v_start_day,
                         v_ctrl_sequence, v_FailMsg,
                         v_cust_sa_hh, v_cust_sa_mm, v_cust_sb_hh, v_cust_sb_mm,
                         v_cust_min, v_cust_days, v_log_keep,
--                         v_start_after_hour,
--                         v_start_after_minute,
                         v_start_after, v_idle_thread_wait
                  FROM   ws_wrk_job_ctrl
                  WHERE  RTRIM(UPPER(wjc_name)) = RTRIM(UPPER(pi_job_name));

                  v_rec_count := 1;

            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                v_MsgText := 'No job found named:'||pi_job_name||'.';

                v_rec_count := 0;
                v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                po_result_code := -2;
                RETURN;

              WHEN TOO_MANY_ROWS THEN
                v_MsgText := 'Multiple jobs found named:'||pi_job_name||'.';

                v_rec_count := 0;
                v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                po_result_code := -2;
                RETURN;

              WHEN OTHERS THEN
                v_MsgText := 'Unhandled exception finding job:'||pi_job_name||'.';

                v_rec_count := 0;
                v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                po_result_code := -2;
                RETURN;

             END;

--             EXCEPTION WHEN OTHERS THEN
--                  v_rec_count := 0;
--             END;
--             If v_rec_count <> 1 Then
--                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in New Job. '||
--                                    v_rec_count||' such records exist. No Action !!!';
--                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
--                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
--                 po_result_code := -2;
--                 RETURN;
--             End If;

              -- If we have a parent job then setup to use it's keys in the audit log
              IF v_child_job = 0 THEN
                v_audit_job_id := p_job_id;
                v_pm_job_key := p_job_id;
              END IF;

             -- Setup to default for a failure if a Fail command has been provided
             If v_FailMsg is not Null Then
                 po_action_key := 2;
                 po_action_msg := v_FailMsg;
             Else
                 po_action_key := 0;
             End If;

             -- Make sure we are not already running (i.e. have a job_run record)
             -- Otherwise a fatal problem.
             BEGIN
                  select count(1)
                  into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 0 Then
                 v_MsgText := 'Job '||pi_job_name||' already running. '||
                              'Cannot start a new iteration. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             -- Make sure there is no other sequence of this job running
             -- Otherwise a fatal problem.
             -- WMR 24/08/2001. Put the job on hold, if there are running sequences.
             -- WMR 24/08/2001. If failed sequences then put out a warning and proceed.
             -- BC 05/04/2016  retry logic added as need to loop if blocked job being called as a child job
             v_retry := 1;
             v_retry_msg_count := 6; -- force message on first pass then will occur on every n ones
             WHILE v_retry = 1 LOOP
                 v_retry := 0;

                 BEGIN
                      select count(1)
                      into v_rec_count
                      from ws_wrk_job_run
                      where wjr_job_key = p_job_id;
                 EXCEPTION WHEN OTHERS THEN
                      v_rec_count := 0;
                 END;
                 If v_rec_count <> 0 Then
                     BEGIN
                          select count(1)
                          into v_job_count
                          from ws_wrk_job_run
                          where wjr_job_key = p_job_id
                          and wjr_status = 'F';
                     EXCEPTION WHEN OTHERS THEN
                          v_job_count := 0;
                     END;
                     If v_job_count <> v_rec_count Then
                         v_MsgText := 'Job '||pi_job_name||' already has a running sequence. '||
                                      ' Job Blocked, until current job completes.';

                         If v_child_job = 1 Then
                             v_retry := 1;
                             v_retry_msg_count := v_retry_msg_count + 1;

                             If v_retry_msg_count > 5 Then -- don't want a message on every occurrence
                                 -- Note using diff p_sequence rather than ctrl_sequ .. not sure whats with ctrl_seq
                                 v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                                       v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                                 v_retry_msg_count := 0;
                             End If;

                             DBMS_LOCK.SLEEP(10);
                         Else
                             v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                                   v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                             BEGIN
                                  update ws_wrk_job_ctrl
                                  set wjc_status = 'B'
                                  where wjc_job_key = p_job_id
                                  and wjc_sequence = v_ctrl_sequence;
                                  COMMIT;

								  --RED_3792
					             -- substitute any variables.
						 	     IF po_action_msg IS NOT NULL THEN
								   po_action_msg := REPLACE(po_action_msg,'$JOB_KEY$',NVL(v_audit_job_id,0));
								   po_action_msg := REPLACE(po_action_msg,'$JOB_SEQ$',NVL(pi_sequence,0));
								   po_action_msg := REPLACE(po_action_msg,'$JOB_THREAD$',NVL(pi_thread,-1));
								   po_action_msg := REPLACE(po_action_msg,'$JOB_NAME$',RTRIM(v_audit_job_name));
						 	     END IF;

                             EXCEPTION WHEN OTHERS THEN
                                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                ' failed to change state to blocked '||
                                                'in ws_wrk_job_ctrl. No Action!!!';
                                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                              v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                                   po_result_code := -2;
                                   RETURN;
                             END;
                             po_result_code := -99;
                             RETURN;
                         End If;
                     Else
                         v_MsgText := 'Job '||pi_job_name||' has a previously Failed (incomplete) sequence. Now Aborted';
                         v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                               v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);

                         -- Update the job run record to be completed (Failed-Aborted)
                         -- and set the completion date if it is null
                         -- Move the job run record to the log record
                         BEGIN
                              update ws_wrk_job_run
                              set wjr_status = 'G'
                              where wjr_job_key = p_job_id;
                              -- 5.1.0.1 commit removed to make full transaction
                              --COMMIT;
                              update ws_wrk_job_run
                              set wjr_completed = sysdate
                              where wjr_job_key = p_job_id
                              and wjr_completed is NULL;
                              -- 5.1.0.1 commit removed to make full transaction
                              --COMMIT;
                              insert into ws_wrk_job_log
                              select *
                              from ws_wrk_job_run
                              where wjr_job_key = p_job_id;
                              -- 5.1.0.1 commit removed to make full transaction
                              --COMMIT;
                              delete
                              from ws_wrk_job_run
                              where wjr_job_key = p_job_id;
                              -- 5.1.0.1 commit removed to make full transaction
                              --COMMIT;
                         EXCEPTION WHEN OTHERS THEN
                              v_MsgText := 'Job '||pi_job_name||' failed in xfer to aborted job to ws_wrk_job_log. '||
                                                               ' No Action !!!';
                             v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                     v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                             po_result_code := -2;
                             RETURN;
                         END;

                         -- Move the task run records to the log record
                         BEGIN
                              insert into ws_wrk_task_log
                              select *
                              from ws_wrk_task_run
                              where wtr_job_key = p_job_id;
                              -- 5.1.0.1 commit removed to make full transaction
                              --COMMIT;
                              delete
                              from ws_wrk_task_run
                              where wtr_job_key = p_job_id;
                              COMMIT;
                         EXCEPTION WHEN OTHERS THEN
                              v_MsgText := 'Job '||pi_job_name||
                                            ' failed in xfer of aborted jobs tasks to ws_wrk_task_log. '||
                                                               ' No Action !!!';
                              v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                              v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                              po_result_code := -2;
                              RETURN;
                         END;

                     End If;
                 End If;
             END LOOP; -- Loop for in case a blocked child job

            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
                -- 5.1.0.1 commit removed to make full transaction
                --COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            END;

             -- Create the Job run record
             -- Set its initial state to P for pending until we have the task_run records built
             -- NOTE: wjr_chkp_count is used to hold the parent job number
             v_integer := 0;
             IF v_child_job = 1 THEN
               v_integer := v_audit_job_id;
             END IF;

             BEGIN
                  Insert into ws_wrk_job_run (
                        wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
                        wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
                        wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
                        wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
                        wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler, wjr_idle_thread_wait)
                  Select
                        wjc_job_key, pi_sequence, 0, 'P', sysdate, sysdate, NULL, 0,0,
                        0,0,0,0,0,v_integer,0, wjc_name, wjc_user_key, wjc_max_threads,
                        wjc_publish_okay, wjc_publish_fail, wjc_scheduler, NVL(wjc_idle_thread_wait,30)
                  from ws_wrk_job_ctrl
                  where wjc_job_key = p_job_id;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to create record in ws_wrk_job_run table. '||
                                                   ' No Action !!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                          v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;
             END;

             -- Create All the Task records.
             -- Loop through all the tasks and add them. Initial state is Waiting.
             FOR v_TaskCtrlRec in c_TaskCtrl LOOP

                 BEGIN
                      Insert into ws_wrk_task_run (
                            wtr_task_key, wtr_job_key, wtr_sequence, wtr_restart, wtr_run_status,
                            wtr_audit_status, wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
                            wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg, wtr_type,
                            wtr_abort_level, wtr_chkp_number, wtr_name, wtr_obj_type, wtr_action_type,
                            wtr_obj_key, wtr_thread, wtr_order, wtr_action_ind)
                      Values (
                            v_TaskCtrlRec.wtc_task_key,
                            v_TaskCtrlRec.wtc_job_key,
                            pi_sequence,0,'W',NULL,NULL,NULL,0,0,
                            0,0,0,NULL,
                            v_TaskCtrlRec.wtc_type,
                            v_TaskCtrlRec.wtc_abort_level,
                            v_TaskCtrlRec.wtc_chkp_number, v_TaskCtrlRec.wtc_name,
                            v_TaskCtrlRec.wtc_obj_type, v_TaskCtrlRec.wtc_action_type,
                            v_TaskCtrlRec.wtc_obj_key,
                            v_TaskCtrlRec.wtc_order, -- used temporarily to sort running tasks
                            v_TaskCtrlRec.wtc_order,
                            v_TaskCtrlRec.wtc_action_ind
                      );
                      -- 5.1.0.1 commit removed to make full transaction
                      --COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' failed creating records in ws_wrk_task_run table. '||
                                ' No Action !!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                            v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;
                END;

             END LOOP;

             -- All tasks added
             -- Set the job status to running so our threads can start running the tasks
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'R',
                        wjr_started = sysdate
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                ' failed to change state to running '||
                                'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                             v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;
             END;

             COMMIT;

             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Started. ';
             v_result := WsWrkAudit('B',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);

             -- Set the task back to enabled if was set as disabled once only unless job was a once only
             IF v_job_type <> 'O' THEN
             BEGIN
               UPDATE ws_wrk_task_ctrl
               SET    wtc_action_ind = NULL
               WHERE  wtc_job_key = p_job_id
               AND    NVL(wtc_action_ind,'') = v_ws_act_disabled_once;

               EXCEPTION WHEN OTHERS THEN
                 v_MsgText := 'Job '||pi_job_name||
                                   ' failed to change task disabled once '||
                                   'in ws_wrk_task_ctrl. No Action!!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                            v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
              END;
            END IF;

            --=====================================================
            -- Clear out any old logs for this job unless a child job
            --=====================================================
            If v_log_keep > 0 AND v_child_job = 0 Then

              -- we will create a log as part of this log, so keep 1 less
              v_log_keep := v_log_keep - 1;
              v_result := Ws_Job_Clear_Logs(p_sequence,
                                p_job_name, p_task_name, p_job_id, p_task_id,
                                p_job_name, v_log_keep,
                                v_status_code, p_return_msg);
            End If;


             -- Now either modify or delete the control record
             -- and if required delete the task records
             -- If it is a once only job then delete it from job control
             -- If a once and hold then set its status to Hold
             -- In all other cases work out when it will next run
             -- and put it in a wait state.
             IF v_child_job = 0 THEN
             BEGIN

                 If v_job_type = 'O' Then
                      delete
                      from ws_wrk_job_ctrl
                      where wjc_job_key = p_job_id;
                      -- 5.1.0.1 commit removed to make full transaction
                      --COMMIT;
                      delete
                      from ws_wrk_task_ctrl
                      where wtc_job_key = p_job_id;
                 --============= New code by Chris for ws_job_starttime ===================
                 ELSE

                   -- Retrieve the next valid starttime for this job.
                   v_result := ws_job_get_start(p_job_id, v_start_after, v_job_status, v_status_code, v_msgtext);

                   IF v_result <> 1 THEN
                     v_result := WsWrkAudit('E',p_job_name, p_job_name, p_sequence,
                                                   v_MsgText,NULL,NULL,pi_task_key,pi_job_key);
                   END IF;

                   -- Set new job status and starttime.
                   -- If in error, then correct values already passed back from Ws_Job_Starttime
                   UPDATE ws_wrk_job_ctrl
                   SET    wjc_status = v_job_status
                        , wjc_start_after = v_start_after
                   WHERE  wjc_job_key = p_job_id;

                 END IF;
                 --============= End of New code by Chris for ws_job_starttime ===================

                COMMIT;
             EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Failure to re-appoint scheduled job ' || pi_job_name;
                  v_result := WsWrkAudit('E',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
             END;
             END IF; -- ENd of if not a child job

        --=====================================================
        -- If we are any other thread then we can start processing once
        -- the job_run and task_run tables have been updated.
        -- We will sleep for 2 minutes just in case, to give thread 0
        -- time to compete its work
        --=====================================================
        Else
             DBMS_LOCK.SLEEP(2);

             v_loop_count := 0;


             LOOP
                  -- Make sure we are running
                  -- Otherwise wait some more then go. Wait maximum of 2 minutes
                  BEGIN
                       select wjr_status, wjr_job_key, NVL(wjr_idle_thread_wait,30)
                       into v_run_status, p_job_id,v_idle_thread_wait
                       from ws_wrk_job_run
                       where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
                       and wjr_sequence = pi_sequence;
                  EXCEPTION WHEN OTHERS THEN
                       v_run_status := 'P';
                  END;

                  If v_run_status = 'R' Then
                       EXIT;
                  End If;

                  v_loop_count := v_loop_count + 1;
                  If v_loop_count < 13 Then
                       DBMS_LOCK.SLEEP(10);
                  Else
                      v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                             ' Thread '||pi_thread||' failed to locate job. Terminating ...';
                      v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      po_result_code := -98;
                      RETURN;
                  End If;
             END LOOP;


            -- If we are the parent job then we need the job id
            IF v_child_job = 0 THEN
              v_audit_job_id := p_job_id;
              v_pm_job_key := p_job_id;
            END IF;


            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            END;

         End If;

    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --                  R E S T A R T       J O B
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- If we are a Restart job then check we are in a waiting
    -- state.
    -- Archive the _run table to the log table
    -- Reset any failed jobs, change the restart counter and proceed
    --=====================================================
    ElsIf upper(pi_action) = 'RESTART' Then
        v_restart_flag := 1;
        --=====================================================
        -- If we are thread 0 then do some checks and reset any halted or
        -- failed tasks so that they will run
        --=====================================================
        If pi_thread = 0
        AND v_child_job = 0 Then

             -- Make sure we are in run tables (i.e. have a job_run record)
             -- And have a waiting state
             -- Otherwise a fatal problem.
             BEGIN
                  select wjr_status, wjr_job_key, wjr_publish_fail, NVL(wjr_idle_thread_wait,30)
                  into v_run_status, p_job_id, v_FailMsg, v_idle_thread_wait
                  from ws_wrk_job_run
                  where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
                  and wjr_sequence = pi_sequence;

                  select count(1)
                  into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;

             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                                   'Cannot restart. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

              -- If we have a parent job then setup to use it's keys in the audit log
              IF v_child_job = 0 THEN
                v_audit_job_id := p_job_id;
                v_pm_job_key := p_job_id;
              END IF;

             -- Setup to default for a failure if a Fail command has been provided
             If v_FailMsg is not Null Then
                 po_action_key := 2;
                 po_action_msg := v_FailMsg;
             Else
                 po_action_key := 0;
             End If;
             If v_run_status <> 'P' Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not prepared for re-run. '||
                                                   'Cannot restart. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                          v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            END;


            -- Copy the job run record to the log record
             --BEGIN
             --     insert into ws_wrk_job_log
             --     select * from ws_wrk_job_run
             --     where wjr_job_key = p_job_id
             --     and wjr_sequence = pi_sequence;
             --
             --     update ws_wrk_job_log
             --     set wjl_status = F
             --     where wjl_job_key = p_job_id
             --     and wjl_sequence = pi_sequence;
             --     COMMIT;
             --EXCEPTION WHEN OTHERS THEN
             --     v_MsgText := Job ||pi_job_name|| failed in copy to ws_wrk_job_log. ||
             --                                       No Action !!!;
             --    v_result := WsWrkAudit(F,v_audit_job_name,v_audit_task_name, pi_sequence,
             --                                              v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
             --    RETURN -2;
             --END;

             -- Copy the failed task run records to the log record
             --BEGIN
             --     insert into ws_wrk_task_log
             --     select * from ws_wrk_task_run
             --     where wtr_job_key = p_job_id
             --     and wtr_sequence = pi_sequence
             --     and wtr_run_status not in (W,C,H);
             --     COMMIT;
             --EXCEPTION WHEN OTHERS THEN
             --     v_MsgText := Job ||pi_job_name|| failed in copy of tasks to ws_wrk_task_log. ||
             --                                       No Action !!!;
             --    v_result := WsWrkAudit(F,v_audit_job_name,v_audit_task_name, pi_sequence,
             --                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
             --    RETURN -2;
             --END;

             -- Set the job status to pending so our threads don't start
             -- And increment the restart counter
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'P',
             --           wjr_okay_count = 0,
             --           wjr_info_count = 0,
             --           wjr_warning_count = 0,
             --           wjr_error_count = 0,
             --           wjr_detail_count = 0,
                        wjr_restart = wjr_restart + 1
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed to change state to pending restart '||
                                                   'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                              v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             END;
             -- 5.1.0.1 commit removed to make full transaction
             --COMMIT;

             -- Loop through All the Task records.
             -- Clearing any halted or failed statuses
             FOR v_TaskRec in c_TaskRun LOOP

                 If v_TaskRec.wtr_run_status = 'H' OR v_TaskRec.wtr_run_status = 'F'
                 OR v_TaskRec.wtr_run_status = 'U' Then
                     BEGIN
                          Update ws_wrk_task_run set
                               wtr_restart = wtr_restart + 1,
                               wtr_started = NULL,
                               wtr_completed = NULL,
                               wtr_elapsed_hh = 0,
                               wtr_elapsed_mi = 0,
                               wtr_run_status = 'W',
                               wtr_audit_status = NULL,
                               wtr_info_count = 0,
                               wtr_warning_count = 0,
                               wtr_detail_count = 0,
                               wtr_return_msg = NULL
                           where wtr_task_key = v_TaskRec.wtr_task_key
                           and wtr_job_key = v_TaskRec.wtr_job_key
                           and wtr_sequence = v_TaskRec.wtr_sequence;
                           -- 5.1.0.1 commit removed to make full transaction
                           --COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' failed resetting records in ws_wrk_task_run table. '||
                                                   ' No Action !!!';
                          v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                            v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                             po_result_code := -2;
                             RETURN;
                    END;
                 Else
                     BEGIN
                          Update ws_wrk_task_run set
                               wtr_restart = wtr_restart + 1
                           where wtr_task_key = v_TaskRec.wtr_task_key
                           and wtr_job_key = v_TaskRec.wtr_job_key
                           and wtr_sequence = v_TaskRec.wtr_sequence;
                           -- 5.1.0.1 commit removed to make full transaction
                           --COMMIT;
                     EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' failed resetting records in ws_wrk_task_run table. '||
                                                   ' No Action !!!';
                          v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                 v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                         po_result_code := -2;
                         RETURN;
                    END;
                 End If;

             END LOOP;

             -- ======================
             -- Fix up any child jobs
             -- ======================
              update ws_wrk_job_run
              set wjr_status = 'P',
                    wjr_restart = wjr_restart + 1
              where wjr_job_key in
              (Select wjr_job_key from ws_wrk_job_run
                where wjr_chkp_count = p_job_id
                and wjr_sequence = pi_sequence)
              and wjr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;

              Update ws_wrk_task_run set
                   wtr_restart = wtr_restart + 1
              where wtr_job_key in
              (Select wjr_job_key from ws_wrk_job_run
                where wjr_chkp_count = p_job_id
                and wjr_sequence = pi_sequence)
              and wtr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;

              Update ws_wrk_task_run set
                   wtr_started = NULL,
                   wtr_completed = NULL,
                   wtr_elapsed_hh = 0,
                   wtr_elapsed_mi = 0,
                   wtr_run_status = 'W',
                   wtr_audit_status = NULL,
                   wtr_info_count = 0,
                   wtr_warning_count = 0,
                   wtr_detail_count = 0,
                   wtr_return_msg = NULL
              where wtr_job_key in
              (Select wjr_job_key from ws_wrk_job_run
                where wjr_chkp_count = p_job_id
                and wjr_sequence = pi_sequence)
              and wtr_sequence = pi_sequence
              and wtr_run_status in ('H','F','U');

              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;

              update ws_wrk_job_run
              set wjr_status = 'R'
              where wjr_job_key in
              (Select wjr_job_key from ws_wrk_job_run
                where wjr_chkp_count = p_job_id
                and wjr_sequence = pi_sequence)
              and wjr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;

             -- End of child job fixup.


             -- Set the job status to running
             BEGIN
                  update ws_wrk_job_run
                  set wjr_status = 'R'
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
             EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed to change state to running '||
                                                   'in ws_wrk_job_run. No Action!!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                              v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                     po_result_code := -2;
                     RETURN;
             END;
             COMMIT;

             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Restarted. ';
             v_result := WsWrkAudit('B',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,v_audit_task_id,p_job_id);


        --=====================================================
        -- If we are not thread 0
        -- or are a a child job then wait up to two minutes for the okay
        --=====================================================
        Else
             -- Get the job key for the job name. There should be one and
             -- only one key. Otherwise a fatal problem.
             BEGIN
                  select wjr_job_key, NVL(wjr_idle_thread_wait,30)
                  into p_job_id, v_idle_thread_wait
                  from ws_wrk_job_run
                  where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
                  --5.1.0.1 Added sequence .. as is possible to have 2 jobs in fail state
                  --        due to parent job wait failure
                  and wjr_sequence = pi_sequence;
                  v_rec_count := 1;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in Restart. '||
                                                   v_rec_count||' such records exist. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

              -- If we have a parent job then setup to use it's keys in the audit log
              IF v_child_job = 0 THEN
                v_audit_job_id := p_job_id;
                v_pm_job_key := p_job_id;
              END IF;

            --=====================================================
            -- Record this thread as being active
            --=====================================================
            BEGIN
                select sid,serial#
                into v_sid, v_serial
                from v$session where audsid = userenv('sessionid') ;
            EXCEPTION WHEN OTHERS THEN
                v_sid := 0;
                v_serial := 0;
            END;

            BEGIN
                Insert into ws_wrk_job_thread (
                        wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
                Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
               COMMIT;
            EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
                   v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            END;

             v_loop_count := 0;

             LOOP
                  -- Make sure we are running
                  -- Otherwise wait some more then go. Wait maximum of 2 minutes
                  BEGIN
                       select wjr_status, NVL(wjr_idle_thread_wait,30)
                      into v_run_status, v_idle_thread_wait
                       from ws_wrk_job_run
                       where wjr_job_key = p_job_id
                       and wjr_sequence = pi_sequence;
                  EXCEPTION WHEN OTHERS THEN
                       v_run_status := 'P';
                  END;

                  If v_run_status = 'R' Then
                       EXIT;
                  End If;

                  v_loop_count := v_loop_count + 1;
                  If v_loop_count < 13 Then
                       DBMS_LOCK.SLEEP(10);
                  Else
                      v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                             ' Thread '||pi_thread||' failed to locate job. Terminating ...';
                      v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                     po_result_code := -98;
                     RETURN;
                  End If;
             END LOOP;
       End If;

    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --                  R E J O I N       J O B
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- If we are a Rejoin job then  we have completed a host
    -- subtask. So check we are in a running state.
    -- Set the result status for the task we have just actioned
    -- and proceed with other tasks
    --=====================================================
    ElsIf SUBSTR(UPPER(pi_action),1,6) = 'REJOIN' OR UPPER(pi_action) = 'EXTRETURN' Then

       v_step := 400;
--v_MsgText := 'Rejoin Job '|| pi_job_name
--|| ' parent job ' || v_pm_job_name
--|| ' job key ' || pi_job_key
--|| ' parent key ' || v_pm_job_key
--|| ' task key ' || pi_task_key
--|| ' audit key ' || v_pm_job_key
--|| ' child flag ' || v_child_job
--|| ' job key list ' || SUBSTR(pm_rejoin_job_keys,1,20)
--|| ' task key list ' || SUBSTR(pm_rejoin_task_keys,1,20);
--v_result := WsWrkAudit('H',v_audit_job_name, v_audit_task_name, v_ctrl_sequence,
--v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);

       -- If there are child jobs then rejoin them
       IF INSTR(pm_rejoin_job_keys,',') > 0 THEN
         p_job_id := pi_job_key;

         -- Get the top job key off the list which should be my key
         v_cpos := INSTR(pm_rejoin_job_keys,',');
         IF v_cpos > 0 THEN
           v_my_job_key := TO_NUMBER(SUBSTR(pm_rejoin_job_keys,1,v_cpos-1));
           IF v_my_job_key > 0 THEN
             v_rejoin_job_keys := SUBSTR(pm_rejoin_job_keys,v_cpos+1,256);
           END IF; -- end of got my job key
         ELSE
           v_my_job_key := TO_NUMBER(pm_rejoin_job_keys);
           v_rejoin_job_keys := NULL;
         END IF;

         -- If not my job then a fatal problem
         IF v_my_job_key <> pi_job_key THEN
          v_MsgText := 'Job ' || pi_job_name || ' Encountered bad rejoin job key list.';
          v_result := WsWrkAudit('E',v_audit_job_name, v_audit_task_name, pi_sequence,
                                        v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
          po_result_code := -2;
          po_result_msg := v_MsgText;
          RETURN;
         END IF;


         -- Get the next job key off the list (child) and lookup the job name
         v_cpos := INSTR(v_rejoin_job_keys,',');
         IF v_cpos > 0 THEN
          v_sub_job_key := TO_NUMBER(SUBSTR(v_rejoin_job_keys,1,v_cpos-1));
         ELSE
          v_sub_job_key := TO_NUMBER(v_rejoin_job_keys);
         END IF;


         -- If no key then a fatal problem
         IF v_sub_job_key = 0 THEN
          v_MsgText := 'Job ' || pi_job_name || ' Unable to rejoin to sub job. Bad key list ';
          v_result := WsWrkAudit('E',v_audit_job_name, v_audit_task_name, pi_sequence,
                                        v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
          po_result_code := -2;
          po_result_msg := v_MsgText;
          RETURN;
         END IF;

         -- Get the sub job name
         v_sub_job_name := NULL;
         SELECT
          wjr_name, NVL(wjr_idle_thread_wait,30)
         INTO v_sub_job_name, v_idle_thread_wait
         FROM ws_wrk_job_run
         WHERE wjr_job_key = v_sub_job_key
         AND wjr_sequence = pi_sequence;

          -- If no running job to join to then a fatal problem
         IF v_sub_job_name IS NULL THEN
          v_MsgText := 'Job ' || pi_job_name || ' Unable to rejoin to sub job. No such running job';
          v_result := WsWrkAudit('E',v_audit_job_name, v_audit_task_name, pi_sequence,
                                        v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
          po_result_code := -2;
          po_result_msg := v_MsgText;
          RETURN;
         END IF;

         -- Get the top task key off the list which should be my task key
         v_cpos := INSTR(pm_rejoin_task_keys,',');
         IF v_cpos > 0 THEN
          v_my_task_key := TO_NUMBER(SUBSTR(pm_rejoin_task_keys,1,v_cpos-1));
          IF v_my_task_key > 0 THEN
            v_rejoin_task_keys := SUBSTR(pm_rejoin_task_keys,v_cpos+1,256);
          END IF;
         ELSE
          v_my_task_key := TO_NUMBER(pm_rejoin_task_keys);
          v_rejoin_task_keys := NULL;
         END IF;


         -- Get the next task key off the list (child task) and lookup the task name
         v_cpos := INSTR(v_rejoin_task_keys,',');
         IF v_cpos > 0 THEN
          v_sub_task_key := TO_NUMBER(SUBSTR(v_rejoin_task_keys,1,v_cpos-1));
         ELSE
          v_sub_task_key := TO_NUMBER(v_rejoin_task_keys);
         END IF;


         -- If no key then a fatal problem
         IF v_my_task_key = 0 THEN
          v_MsgText := 'Job ' || pi_job_name || ' Unable to locate calling task. Bad key list ';
          v_result := WsWrkAudit('E',v_audit_job_name, v_audit_task_name, pi_sequence,
                                        v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
          po_result_code := -2;
          po_result_msg := v_MsgText;
          RETURN;
         END IF;

         -- Get sub task name
         v_my_task_name := NULL;
         SELECT
          wtr_name
         INTO v_my_task_name
         FROM ws_wrk_task_run
         WHERE wtr_job_key = pi_job_key
         AND wtr_task_key = v_my_task_key
         AND wtr_sequence = pi_sequence;

          -- If no task to then a fatal problem
         IF v_my_task_name IS NULL THEN
          v_MsgText := 'Job ' || pi_job_name || ' Unable to rejoin to job. Unable to locate calling Task';
          v_result := WsWrkAudit('E',v_audit_job_name, v_audit_task_name, pi_sequence,
                                        v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
          po_result_code := -2;
          po_result_msg := v_MsgText;
          RETURN;
         END IF;

         -- Rejoin this sub job
         Ws_Job_Exec_411(v_sub_job_name,pi_task_name,pi_action,0,pi_sequence,
                         v_sub_job_key, pi_task_key,pi_task_status,pi_task_msg,
                         v_pm_job_name, v_pm_job_key, v_rejoin_job_keys, v_rejoin_task_keys,
                         p_status_code,
                         p_return_msg,
                         v_job_job_key,
                         v_job_task_key, v_job_task_name,
                         v_job_action_key, v_job_action_msg,
                         v_job_key_list, v_task_key_list,
                         v_task_data);


         IF p_status_code = -3 THEN
            p_return_msg := 'Called job ' || RTRIM(v_sub_job_name) || ' FAILED with unhandled error';
         END IF;
         IF p_status_code = -2 THEN
            p_return_msg := 'Called job ' || RTRIM(v_sub_job_name) || ' FAILED';
         END IF;
         IF p_status_code = -1 THEN
            p_return_msg := 'Called job ' || RTRIM(v_sub_job_name) || ' completed with WARNINGS';
         END IF;
         IF p_status_code = 0 THEN
            p_return_msg := 'Called job ' || RTRIM(v_sub_job_name) || ' FAILED with unhandled problem';
            p_status_code := -2;
         END IF;
         IF p_status_code = 1 THEN
            p_return_msg := 'Called job ' || RTRIM(v_sub_job_name) || ' completed successfully';
         END IF;
         IF p_status_code > 1 THEN
            po_job_key := p_job_id;
            po_task_key := v_job_task_key;
            po_task_name := v_job_task_name;
            po_result_msg := p_return_msg;
            po_action_key := v_job_action_key;
            po_action_msg := v_job_action_msg;
            po_result_code := p_status_code;
            ps_job_key_list := p_job_id || ',' || NVL(v_job_key_list,'');
            ps_task_key_list := v_my_task_key || ',' || NVL(v_task_key_list,'');
            po_task_data := v_task_data;
            return;
         END IF;

         -- put up my task key for the drop through on this rejoin.
         p_task_id := v_my_task_key;
         p_task_name := v_my_task_name;
         v_audit_job_id := v_pm_job_key;
         v_audit_task_id := p_task_id;
         v_audit_task_name := v_my_task_name;

       --==========================================================================
       --==========================================================================
       --==========================================================================
       --==========================================================================
       --==========================================================================
       -- Normal rejoin (no child jobs )
       --==========================================================================
       --==========================================================================
       --==========================================================================
       --==========================================================================

       ELSE
         --Setup our return codes
         p_status_code := pi_task_status;
         p_return_msg := pi_task_msg;
         p_task_id := pi_task_key;
         p_job_id := pi_job_key;
         v_audit_job_id := v_pm_job_key;
         v_audit_task_id := p_task_id;
         v_audit_task_name := pi_task_name;
       END IF; -- end of sub jobs to rejoin


       --=====================================================
       -- Make sure we have a valid return status
       -- Otherwise make this a failure
       -- Update the status of the task we have completed.
       --=====================================================
       If p_status_code = 1 Then
          v_audit_status := 'S';
          v_run_status := 'C';
       ElsIf p_status_code = -1 Then
           v_audit_status := 'W';
           v_run_status := 'C';
       ElsIf p_status_code = -2 Then
           v_audit_status := 'E';
           v_run_status := 'F';
       ElsIf p_status_code = -3 Then
           v_audit_status := 'F';
           v_run_status := 'F';
       ELSE
           v_audit_status := 'U';
           v_run_status := 'U';
           p_status_code := -3;
           p_return_msg := substr('Invalid return code '||pi_task_status||
             '. Msg was '||pi_task_msg,1,970)||
             '. Expecting return code of 1,-1,-2, or -3';
       End If;

        --=====================================================
        -- Record this thread as being active
        --=====================================================
        BEGIN
            select sid,serial#
            into v_sid, v_serial
            from v$session where audsid = userenv('sessionid') ;
        EXCEPTION WHEN OTHERS THEN
            v_sid := 0;
            v_serial := 0;
        END;
        BEGIN
            Insert into ws_wrk_job_thread (
                    wjt_job_key, wjt_sequence, wjt_thread, wjt_sid, wjt_serial)
            Values (p_job_id, pi_sequence, pi_thread, v_sid, v_serial);
           COMMIT;
        EXCEPTION WHEN OTHERS THEN
               v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
               v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
        END;



       -- Delete the temporary script we have created for this
       -- task to use
       BEGIN
            delete
            from ws_wrk_task_scr_line
            where wtsl_task_key = p_task_id
            and  wtsl_job_key = v_audit_job_id 			-- 5.6.2.1 changed from p_job_id
            and wtsl_sequence = pi_sequence;

            delete
            from ws_wrk_task_scr_hdr
            where wtsh_task_key = p_task_id
            and  wtsh_job_key = v_audit_job_id 			-- 5.6.2.1 changed from p_job_id
            and wtsh_sequence = pi_sequence;
            COMMIT;
       EXCEPTION WHEN OTHERS THEN
            v_rec_count := 0;
       END;

       -- Make sure we are in run tables (i.e. have a job_run record)
       -- And have a waiting state
       -- Otherwise a fatal problem.
       BEGIN
            select wjr_status, wjr_job_key, wjr_publish_fail, NVL(wjr_idle_thread_wait,30)
            into v_run_status, p_job_id, v_FailMsg, v_idle_thread_wait
            from ws_wrk_job_run
            where rtrim(upper(wjr_name)) = rtrim(upper(pi_job_name))
            and wjr_sequence = pi_sequence;

            select count(1)
            into v_rec_count
            from ws_wrk_job_run
            where wjr_job_key = p_job_id
            and wjr_sequence = pi_sequence;
       EXCEPTION WHEN OTHERS THEN
            v_rec_count := 0;
       END;
       If v_rec_count <> 1 Then
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                             'Cannot rejoin. '||v_rec_count||' jobs running. No Action !!!';
           v_result := WsWrkAudit('E',v_audit_job_name,RTRIM(v_audit_task_name), pi_sequence,
                                                     v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);

           -- See if we can work out what has happened to the job
           -- and let them know
           If v_rec_count = 0 Then
               BEGIN
                    select wjl_status, wjl_publish_fail, NVL(wjl_idle_thread_wait,30)
                    into v_run_status, v_FailMsg, v_idle_thread_wait
                    from ws_wrk_job_log
                    where wjl_name = pi_job_name
                    and wjl_sequence = pi_sequence;
                    v_MsgText := substr('Job '||pi_job_name||' sequence '||pi_sequence||' has a log entry with status '||
                                    v_run_status||' '||v_FailMsg,1,1023);
                    v_result := WsWrkAudit('E',v_audit_job_name,RTRIM(v_audit_task_name), pi_sequence,
                                          v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
               EXCEPTION WHEN OTHERS THEN
                    v_rec_count := 0;
               END;
           End If;

           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, v_audit_job_name,RTRIM(v_audit_task_name), p_sequence,
                     p_return_msg, NULL, NULL, v_audit_task_id, v_audit_job_id);
           po_result_code := -2;
           RETURN;
       End If;


       -- Setup to default for a failure if a Fail command has been provided
       If v_FailMsg is not Null Then
           po_action_key := 2;
           po_action_msg := v_FailMsg;
       Else
           po_action_key := 0;
       End If;

       -- Get some info about the task we have just completed
       BEGIN
            select wtr_obj_key, wtr_obj_type, wtr_action_type
            into v_obj_key, v_obj_type, v_action_type
            from ws_wrk_task_run
            where wtr_job_key = p_job_id
            and wtr_task_key = p_task_id
            and wtr_sequence = pi_sequence;
       EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                        ' Task ' || p_task_name || ' not running. '||
                                             'Cannot rejoin. No Action !!!';
           v_result := WsWrkAudit('E',v_audit_job_name,RTRIM(v_audit_task_name), pi_sequence,
                                                     v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, v_audit_job_name,RTRIM(v_audit_task_name), p_sequence,
                     p_return_msg, NULL, NULL, v_audit_task_id, v_audit_job_id);

           po_result_code := -2;
           RETURN;
       END;


       --=====================================================
       -- If a Load then we have just completed the load phase
       -- And now need to run any post load procedure if the
       -- load was a success
       -- If a Load and the action is a process then we need
       -- to do any index builds as well
       --=====================================================
       v_step := 500;
       If v_obj_type = v_ws_obj_load Then
          If p_status_code >= -1 Then
             IF UPPER(pi_action) = 'REJOIN' OR UPPER(pi_action) = 'REJOIN91' -- NOT a procedure execute rejoin
             THEN
               v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                        p_return_msg_2, p_status_code_2);

               If p_status_code_2 = 1 Then
                  v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name , pi_sequence,
                                        p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);

               ElsIf p_status_code_2 < 1 Then
                  v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                          p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);

               End If;

               -- If this procedure is a SQLBLOCK then we'll get back a result of 2
               -- Skip out to process it
               -- When we rejoin the job any post action (index build) will be run
               IF v_result = 2
               THEN

                 -- Need to first output the info message for the load step
                 v_result := WsWrkAudit(v_audit_status,v_audit_job_name,v_audit_task_name, pi_sequence,
                                        p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);

                 po_job_key := p_job_id;
                 po_task_key := p_task_id;
                 po_task_name := p_task_name;
                 po_result_msg := 'execute sql';
                 po_action_key := v_obj_key;
                 po_action_msg := 'no action';
                 ps_job_key_list := TO_CHAR(p_job_id);
                 ps_task_key_list := TO_CHAR(p_task_id);
                 po_result_code := p_status_code_2; -- 16 or 17

                 --=====================================================
                 -- Remove this thread as being active
                 --=====================================================
                 v_step := 600;
                 BEGIN
                   IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                   End If;
                   COMMIT;
                 EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                 END;
                 RETURN;
               END IF;  -- SQLBLOCK post procedure
             ELSE -- Procedure Exec REJOIN
                p_status_code_2 := p_status_code;
                p_return_msg_2  := p_return_msg;
                v_result := 1;
                If p_status_code_2 = 1 Then
                   v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name , pi_sequence,
                                        p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                ElsIf p_status_code_2 < 1 Then
                   v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                        p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                End If;


             END IF; -- action test (REJOIN or not)

             --
             -- Now build any indexes if action is PROCESS
             --
             If v_result >= -1 And v_action_type = v_ws_act_process
             THEN
                  v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                           v_obj_key,
                                           v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                           p_return_msg_3, p_status_code_3);
                  If p_status_code_3 = 1 Then
                     v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                           p_return_msg_3,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  ElsIf p_status_code_3 < 1 Then
                     v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                            p_return_msg_3,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  End If;
             Else
                  p_status_code_2 := 1;
             End If;

             -- If our post load procedure failed and the load worked then
             -- record the post load failure
             If p_status_code_2 < p_status_code Then
                p_status_code := p_status_code_2;
             End If;
             If p_status_code_3 < p_status_code Then
                p_status_code := p_status_code_3;
             End If;

          End If; -- Status code >= -1
       End If;  -- Object = Load

       --=====================================================
       -- If an Export then we have just completed the export phase
       -- And now need to run any post load procedure if the
       -- export was a success
       --=====================================================
       v_step := 700;
       If v_obj_type = v_ws_obj_export Then

         If p_status_code >= -1
         THEN
           IF UPPER(pi_action) = 'REJOIN' --Standard REJOIN
           THEN
              v_step := 800;
              v_result := ws_act_post_export(p_sequence,v_obj_type,v_action_type,
                                      v_obj_key,
                                      v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                      p_return_msg_2, p_status_code_2);
              -- If this procedure is a SQLBLOCK then we'll get back a result of 2
              -- Skip out to process it
              -- When we rejoin the job any post action (index build) will be run
              IF v_result = 2
              THEN
                 -- Need to first output the info message for the export step
                 v_result := WsWrkAudit(v_audit_status,v_audit_job_name,v_audit_task_name, pi_sequence,
                                        p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);

                 po_job_key := p_job_id;
                 po_task_key := p_task_id;
                 po_task_name := p_task_name;
                 po_result_msg := 'execute sql';
                 po_action_key := v_obj_key;
                 po_action_msg := 'no action';
                 ps_job_key_list := TO_CHAR(p_job_id);
                 ps_task_key_list := TO_CHAR(p_task_id);
                 po_result_code := p_status_code_2; -- 16 or 17

                 --=====================================================
                 -- Remove this thread as being active
                 --=====================================================
                 v_step := 900;
                 BEGIN
                   IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                   End If;
                   COMMIT;
                 EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                 END;
                 RETURN;
              END IF;-- SQLBLOCK post procedure

            ELSE -- Procedure Exec REJOIN
              p_status_code_2 := p_status_code;
              p_return_msg_2  := p_return_msg;
              v_result := 1;

            END IF; -- REJOIN or REJOIN16/17


            If p_status_code_2 = 1 Then
               v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name , pi_sequence,
                                        p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            ElsIf p_status_code_2 < 1 Then
               v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                        p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            End If;


            -- If our post export procedure failed and the export worked then
            -- record the post export failure
            If p_status_code_2 < p_status_code Then
                 p_status_code := p_status_code_2;
            End If;
            If p_status_code_3 < p_status_code Then
                 p_status_code := p_status_code_3;
            End If;

         End If; --p_status_code >= -1
       End If; --Export

      --=====================================================
      -- If a Retro Initial load then we have just completed
      -- the load phase
      -- And now need to run any index creates if the
      -- load was a success

      -- EXTENDED TO ALL OBJECTTYPES FOR ACT_INITIAL
      --  AS MAY BE FROM EXIT FOR PROCEDURE/SQLBLOCK
      --=====================================================
       v_step := 1000;
      -- If v_obj_type = v_ws_obj_retro_copy  AND v_action_type = v_ws_act_initial THEN
      IF v_action_type = v_ws_act_initial
      AND UPPER(pi_action) <> 'REJOIN90'
      THEN

          If p_status_code >= -1 Then
            v_step := 1100;

            v_result := ws_act_build_all(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                            p_return_msg_2, p_status_code_2);
            If p_status_code_2 = 1 Then
                 v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name , pi_sequence,
                                      p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            ElsIf p_status_code_2 < 1 Then
                 v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                      p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            End If;

              -- If index build failed and the load worked then
              -- record the index build failure
            If p_status_code_2 < p_status_code Then
                   p_status_code := p_status_code_2;
            End If;

          End If; --p_status_code >= -1
       End If;--v_action_type = v_ws_act_initial

      --REJOIN AFTER UPDATE SQLBLOCK(REJOIN16)
      -- Need to do the build indexes for process action
      If  v_obj_type <> v_ws_obj_olap_cube
      AND v_obj_type <> v_ws_obj_olap_dim
      AND v_obj_type <> v_ws_obj_olap_role
      AND v_obj_type <> v_ws_obj_cube
      AND v_obj_type <> v_ws_obj_cube_virtual
      AND v_obj_type <> v_ws_obj_load
      AND v_obj_type <> v_ws_obj_export
      AND v_obj_type <> v_ws_obj_job
      THEN
          IF  p_status_code >= -1
          AND v_action_type >= v_ws_act_process
          AND UPPER(pi_action) = 'REJOIN16'
          THEN
            v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                     v_obj_key,
                                     v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                     p_return_msg_2, p_status_code_2);
            IF p_status_code_2 = 1
            THEN
              v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            ELSIF p_status_code_2 < 1
            THEN
              v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
            END IF;

            -- If index build failed and the action worked then
            -- record the index build failure
            IF p_status_code_2 < p_status_code Then
               p_status_code := p_status_code_2;
            END IF;

          END IF; --p_status_code >= -1  etc
      END IF; -- Selected object Types

       --=====================================================
       -- Log the results in the audit trail
       --=====================================================
       v_step := 1200;
       If p_status_code = 1 Then
          v_audit_status := 'S';
          v_run_status := 'C';
       ElsIf p_status_code = -1 Then
           v_audit_status := 'W';
           v_run_status := 'C';
       ElsIf p_status_code = -2 Then
           v_audit_status := 'E';
           v_run_status := 'F';
       ElsIf p_status_code = -3 Then
           v_audit_status := 'F';
           v_run_status := 'F';
       ELSE
           v_audit_status := 'U';
           v_run_status := 'U';
           p_status_code := -3;
       End If;
       v_result := WsWrkAudit(v_audit_status, v_audit_job_name,RTRIM(v_audit_task_name), p_sequence,
                 p_return_msg, NULL, NULL, v_audit_task_id, v_audit_job_id);

       --=====================================================
       -- Update the run record to indicate our final status
       --=====================================================
       v_step := 1300;
       BEGIN
         update ws_wrk_task_run
         set wtr_run_status = v_run_status,
               wtr_audit_status = v_audit_status,
               wtr_return_msg = p_return_msg,
               wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
               wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                trunc(to_number(sysdate-wtr_started)*24,0)*60),
               wtr_completed = sysdate
         where wtr_task_key = p_task_id
         and wtr_job_key = p_job_id;
       EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' failed in final update of ws_wrk_task_run for task id '||
                                      p_task_id ||'. Run incomplete !!!';
           v_result := WsWrkAudit('F',v_audit_job_name,RTRIM(v_audit_task_name), pi_sequence,
                                              v_MsgText,SQLCODE,SQLERRM,0,v_audit_job_id);
           po_result_code := -2;
           RETURN;
       END;
       COMMIT;


    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --                 C A N C E L       J O B
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- If we are a Cancel job then check we are in a halted or aborted
    -- state.
    -- Archive the _run table to the log table
     --=====================================================
    ElsIf upper(pi_action) = 'CANCEL' Then
        --=====================================================
        -- If we are thread 0 then do some checks and archive
        --=====================================================
        If pi_thread = 0 Then

             -- Get the job key for the job name. There should be one and
             -- only one key. Otherwise a fatal problem.
             BEGIN
                  select wjc_job_key into p_job_id
                  from ws_wrk_job_ctrl
                  where rtrim(upper(wjc_name)) = rtrim(upper(pi_job_name));
                  v_rec_count := 1;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' passed invalid job name in Cancel. '||
                                                   v_rec_count||' such records exist. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             End If;

             -- Make sure we are already running (i.e. have a job_run record)
             -- Otherwise a fatal problem.
             BEGIN
                  select count(1) into v_rec_count
                  from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
             EXCEPTION WHEN OTHERS THEN
                  v_rec_count := 0;
             END;
             If v_rec_count <> 1 Then
                 v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||' not running. '||
                                                   'Cannot cancel. No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                po_result_code := -2;
                RETURN;
             End If;

             -- Move the job run record to the log record
             BEGIN
                  insert into ws_wrk_job_log
                  select * from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
                  delete from ws_wrk_job_run
                  where wjr_job_key = p_job_id
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;

                  -- delete any child jobs
                  delete from ws_wrk_job_run
                  where wjr_job_key in
                  ( Select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = p_job_id
                    and wjr_sequence = pi_sequence)
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
             EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Job '||pi_job_name||' failed in xfer to ws_wrk_job_log. '||
                                                   ' No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                po_result_code := -2;
                RETURN;
             END;

             -- Move the task run records to the log record
             BEGIN
                  insert into ws_wrk_task_log
                  select * from ws_wrk_task_run
                  where wtr_job_key = p_job_id
                  and wtr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
	           delete from ws_wrk_task_run
                  where wtr_job_key = p_job_id
                  and wtr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
            EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Job '||pi_job_name||' failed in xfer of tasks to ws_wrk_task_log. '||
                                                   ' No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             END;
             -- 5.1.0.1 commit removed to make full transaction
             --COMMIT;

             -- Clean up any child jobs
             BEGIN
                  insert into ws_wrk_task_log
                  select * from ws_wrk_task_run
                  where wtr_job_key in
                  ( Select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = p_job_id
                    and wjr_sequence = pi_sequence)
                  and wtr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
	           delete from ws_wrk_task_run
                  where wtr_job_key in
                  ( Select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = p_job_id
                    and wjr_sequence = pi_sequence)
                  and wtr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
                  update ws_wrk_task_log
                  set wtl_job_key = p_job_id
                  where wtl_job_key in
                  ( Select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = p_job_id
                    and wjr_sequence = pi_sequence)
                  and wtl_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;
                  -- delete any child jobs
                  delete from ws_wrk_job_run
                  where wjr_job_key in
                  ( Select wjr_job_key from ws_wrk_job_run where wjr_chkp_count = p_job_id
                    and wjr_sequence = pi_sequence)
                  and wjr_sequence = pi_sequence;
                  -- 5.1.0.1 commit removed to make full transaction
                  --COMMIT;

            EXCEPTION WHEN OTHERS THEN
                  v_MsgText := 'Job '||pi_job_name||' failed in xfer of tasks to ws_wrk_task_log. '||
                                                   ' No Action !!!';
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             END;
             COMMIT;

             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                      ' Canceled. ';
             v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);

        --=====================================================
        -- If we are not thread 0 then wait for ten seconds and proceed.
        --=====================================================
        Else
             DBMS_LOCK.SLEEP(10);
       End If;


   -- not a New or a Restart so we have a problem
   Else
         v_MsgText := 'Job '||pi_job_name||' passed invalid option: '||
                                pi_action||'. No Action !!!';
         v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
    End If;

    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --                  E X E C U T E      T A S K S
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    --**********************************************************************
    -- Okay to start processing tasks. Three possible types of tasks
    -- will be handled. These Being (P)procedures, (F)functions and
    -- (C) checkpoints.
    -- Open the cursor we will use t run the tasks
    --**********************************************************************
    --=====================================================
--    v_cursor := DBMS_SQL.OPEN_CURSOR;
    v_task_count := 1;
    v_step := 1400;
    v_depend_loop := 0;

    -- While More tasks loop
    WHILE v_task_count > 0 LOOP

        v_step := 1500;
        v_task_count := 0;
        v_running_count := 0;
        v_halted_count := 0;
        v_failed_count := 0;
        v_just_done := 0;
        v_idle_thread := 0;
        FOR v_TaskRec in c_TaskRun LOOP
            --=====================================================
            -- Check the status of each task
            -- If it is waiting then we will check dependencies etc.
            -- and see if it needs to be executed.
            --=====================================================
            v_step := 1600;
            v_process := 0;
            If v_TaskRec.wtr_run_status = 'W' Then
                v_step := 1700;
                v_task_count := 1;
                --=====================================================
                -- Check the dependencies for the task
                --=====================================================
                BEGIN
                    select count(1) into v_rec_count from ws_wrk_dependency
                    where wdp_job_key = p_job_id
                    and wdp_child_task_key = v_TaskRec.wtr_task_key;
                EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in read of ws_wrk_dependency. '||
                                                   ' Run incomplete !!!';
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;
                END;
                -- If parent dependencies then check each to see if it has completed.
                v_child_key := v_TaskRec.wtr_task_key;
                v_halted := 0;
                v_okay := 0;
                v_checked := 0;
                v_step := 1800;
                FOR v_DepRec in c_Dependency LOOP
                     -- get the parent task record from the task_run table
                     BEGIN
                        select wtr_run_status, wtr_audit_status, wtr_abort_level
                        into v_run_status, v_audit_status, v_abort_level
                        from ws_wrk_task_run
                        where wtr_job_key = p_job_id
                        and wtr_task_key = v_DepRec.wdp_parent_task_key;
                     EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in parent task read of ws_wrk_task_run. '||
                                                   ' Run incomplete !!!';
                       v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                       po_result_code := -2;
                       RETURN;
                    END;
                    v_step := 1900;

                    -- Get the status for the parent task.
                    -- If the parent is waiting or running then skip the rest of the tests as we cant go
                    -- If the parent has been halted then set the flag to halt this task also.
                    -- If the parent has failed or completed check the audit status
                    -- The abort level will tell us if we should count this as a halt or an okay
                    If v_run_status = 'W' Then
                        EXIT;
                    ElsIf v_run_status = 'R' Then
                        EXIT;
                    ElsIf v_run_status = 'H' Then
                        v_halted := 1;
                        EXIT;
                    ElsIf v_run_status = 'F' Then
                        If v_abort_level = 5 Then
                            v_checked := v_checked + 1;
                        Else
                            v_halted := 1;
                            EXIT;
                        End If;
                    ElsIf v_run_status = 'U' Then
                        If v_abort_level = 5 Then
                            v_checked := v_checked + 1;
                        Else
                            v_halted := 1;
                            EXIT;
                        End If;
                    ElsIf v_run_status = 'C' Then
                        If v_abort_level <= 3 Then
                             If v_audit_status = 'W' Then
                                  v_halted := 1;
                                  EXIT;
                             Else
                                 v_checked := v_checked + 1;
                             End If;
                        Else
                             v_checked := v_checked + 1;
                        End If;
                    Else
                        EXIT;
                    End If;

                END LOOP; -- End of dependency Loop

                -- See if we passed our dependency check
                -- We either passed, need to halt the task or need to skip this task
                -- 5.6.1.1 also reset the depend_loop now to minimise erroneous errors
                --         that result if tasks have contention etc

                If v_checked = v_rec_count Then
                     v_okay := 1;
                     v_depend_loop := 0;
                End If;

                v_step := 2000;
                --=====================================================
                -- See if the task is okay to run and a procedure if so run it
                --=====================================================
                v_wants_to_run := 1;

                If v_okay = 1
                And (   (v_TaskRec.wtr_obj_type > 0 And v_TaskRec.wtr_obj_type <= v_ws_obj_max)
                     OR (v_TaskRec.wtr_obj_type = v_ws_obj_source_mapping)
                     OR (v_TaskRec.wtr_obj_type = v_ws_obj_job)
                    )
                Then
                    v_step := 2100;
                    --=====================================================
                    -- Update the run record to indicate we are running.
                    -- Need to lock the record first to prevent another thread from
                    -- grabbing it, or in case another thread has already got it,
                    -- or updated it
                    --=====================================================
                   BEGIN
                      SELECT wtr_run_status
                      , DECODE(NVL(wtr_action_ind,''),'A',0,'B',0,1)
                      INTO v_run_status, v_wants_to_run
                      from ws_wrk_task_run
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id
                      and wtr_sequence = pi_sequence
                      for update nowait;

                      If v_run_status = 'W' Then
                        If v_wants_to_run = 0 Then
                            v_task_count := 0;
                            v_okay := 0;
                            UPDATE ws_wrk_task_run
                            SET    wtr_run_status = 'C'
                                 , wtr_thread     = pi_thread
                                 , wtr_started    = sysdate
                                 , wtr_audit_status = 'S'
                                 , wtr_return_msg   = 'Task Disabled, Skipped.'
                                 , wtr_elapsed_hh   = 0
                                 , wtr_elapsed_mi   = 0
                                 , wtr_completed    = sysdate
                            WHERE  wtr_task_key = v_TaskRec.wtr_task_key
                            AND    wtr_job_key  = p_job_id;
                        Else
                            update ws_wrk_task_run
                            set wtr_run_status = 'R',
                                  wtr_thread = pi_thread,
                                  wtr_started = sysdate
                            where wtr_task_key = v_TaskRec.wtr_task_key
                            and wtr_job_key = p_job_id;
                        End If;
                      ElsIf v_run_status = 'R' Then
                          -- someone else got the record and is running it
                          v_running_count := v_running_count + 1;
                          v_task_count := 0;
                          v_okay := 0;
                      Else
                          -- someone else got the record
                          v_okay := 0;
                      End If;
                   EXCEPTION WHEN OTHERS THEN
                      -- If a resource busy someone else has the record
                      -- so skip it
                      If SQLCODE = -54 Then
                          v_okay := 0;
                      Else
                          v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in update of ws_wrk_task_run for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                          v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                          po_result_code := -2;
                          RETURN;
                       End If;
                   END;
                   COMMIT;
                   v_step := 2200;
                   -- If we still have a go, then run it
                   -- Break out of this loop and run the task by setting the v_process flag
                   If v_okay = 1 Then
                       v_process := 1;
                       p_task_id := v_TaskRec.wtr_task_key;
                       p_task_name := v_TaskRec.wtr_name;
                       v_action_type := v_TaskRec.wtr_action_type;
                       v_obj_type := v_TaskRec.wtr_obj_type;
                       v_obj_key := v_TaskRec.wtr_obj_key;
                       v_task_key := v_TaskRec.wtr_task_key;
                       Exit;
                   End if;
                --=====================================================
                -- See if OKay and A Checkpoint
                --=====================================================
                ElsIf v_okay = 1 And v_TaskRec.wtr_type = 'C' Then
                    --=====================================================
                    -- Update the run record to indicate we are running.
                    -- Need to lock the record first to prevent another thread from
                    -- grabbing it, or in case another thread has already go it,
                    -- or updated it
                    --=====================================================
                   v_step := 2300;
                   BEGIN
                      select wtr_run_status into v_run_status
                      from ws_wrk_task_run
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id
                      for update nowait;
                      If v_run_status = 'W' Then
                          update ws_wrk_task_run
                          set wtr_run_status = 'R',
                                wtr_started = sysdate
                          where wtr_task_key = v_TaskRec.wtr_task_key
                          and wtr_job_key = p_job_id;
                      Else
                          -- someone else got the record
                          v_okay := 0;
                       End If;
                   EXCEPTION WHEN OTHERS THEN
                      -- If a resource busy someone else has the record
                      -- so skip it
                      If SQLCODE = -54 Then
                          v_okay := 0;
                      Else
                          v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in update of ws_wrk_task_ctrl for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                          v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                          po_result_code := -2;
                          RETURN;
                       End If;
                   END;
                   COMMIT;
                    v_step := 2400;
                    -- If still okay (i.e we got the record then record the checkpoint
                    If v_okay = 1 Then
                        v_run_status := 'C';
                        v_audit_status := 'S';
                        p_task_name := 'Checkpoint';
                        p_return_msg := 'Checkpoint completed';
                        v_result := WsWrkAudit(v_audit_status, v_audit_job_name,v_audit_task_name, p_sequence,
                             p_return_msg, NULL, NULL, v_audit_task_id, v_audit_job_id);
                        If v_TaskRec.wtr_chkp_number <> 0 Then
                               v_result := WsWrkChkPoint(p_job_id, pi_sequence, v_TaskRec.wtr_chkp_number);
                        End If;
                        v_just_done := 1;
                    End If;

                End If;  -- End of task
                v_step := 2500;
                --=====================================================
                -- See if the task needs a status update.
                --=====================================================
                If v_okay = 1 OR v_halted = 1 Then
                    --=====================================================
                    -- Update the run record to indicate our final status
                    -- If we have a halt then generate a message
                    --=====================================================
                    v_step := 2600;
                    If v_halted = 1 Then
                         p_return_msg := 'Halted by dependency failure or halt';
                         v_run_status := 'H';
                         v_audit_status := NULL;
                    End If;
                    BEGIN
                      update ws_wrk_task_run
                      set wtr_run_status = v_run_status,
                            wtr_audit_status = v_audit_status,
                            wtr_return_msg = p_return_msg,
                            wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
                            wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                             trunc(to_number(sysdate-wtr_started)*24,0)*60),
                            wtr_completed = sysdate
                      where wtr_task_key = v_TaskRec.wtr_task_key
                      and wtr_job_key = p_job_id;
                    EXCEPTION WHEN OTHERS THEN
                        v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                                   ' failed in final update of ws_wrk_task_run for task id '||
                                                   v_taskRec.wtr_task_key||'. Run incomplete !!!';
                        v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                           v_MsgText,SQLCODE,SQLERRM,0,v_audit_job_id);
                        po_result_code := -2;
                        RETURN;
                    END;
                    COMMIT;
                End If;  -- End of task record update
            ElsIf v_TaskRec.wtr_run_status = 'R' Then
                  v_running_count := v_running_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'H' Then
                  v_halted_count := v_halted_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'F' Then
                  v_failed_count := v_failed_count + 1;
            ElsIf v_TaskRec.wtr_run_status = 'U' Then
                  v_failed_count := v_failed_count + 1;
            End If; -- End of Waiting task if statement
            v_step := 2700;
        END LOOP;  -- End of task Loop

        -- A task that we are ready to run will break out of the Task loop
        -- with the v_Process flag set, so proceed to process it.
        If v_Process = 1 Then
           v_step := 2800;

           v_audit_task_id := p_task_id;
           v_audit_task_name := p_task_name;
           --=====================================================
           -- Work out the type of action and run the appropriate
           -- function.
           --=====================================================
           p_status_code := -3;
           p_return_msg := 'Unhandled exception in action';

           v_bda_connect_key := 0;
           v_is_hive_target := 0;

           -- Determine if there is any Hive target
           BEGIN
             SELECT DISTINCT 1 INTO v_any_hive_targets FROM ws_dbc_connect
             JOIN ws_dbc_target ON dt_connect_key = dc_obj_key
             WHERE dc_db_type_ind = 8;
           EXCEPTION
             WHEN NO_DATA_FOUND THEN
               v_any_hive_targets := 0;
             WHEN OTHERS THEN
               v_MsgText := 'Unhandled exception checking if there is any Hive target.';
               v_rec_count := 0;
               v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                      v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
               po_result_code := -2;
               RETURN;
           END;

           -- Get the BDA connection key for a BDA operation.
           -- There should be at most one key, otherwise a fatal problem.
           -- Attention: lt_obj_key can also hold a job key! We need to explicitly exclude job keys as they can accidentally point to a Hive or Hadoop object
           If v_any_hive_targets = 1 and v_obj_type <> v_ws_obj_job Then
           BEGIN
                 SELECT bda.connect_key, bda.is_hive_target
                 INTO v_bda_connect_key, v_is_hive_target
                 FROM (
                   -- Use key only for Apache, File and Script loads to send to BDA, other load types, e.g. ODBC, are treated as remote targets
                   -- All Load tables using Apache Sqoop from Hive or Hadoop
                   SELECT src_con.dc_obj_key connect_key, CASE WHEN tgt_con.dc_db_type_ind = 8 THEN 1 ELSE 0 END is_hive_target	-- 8 = WS_DB_HIVE
                   FROM ws_load_tab
                   JOIN ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
                   JOIN ws_obj_object ON lt_obj_key = oo_obj_key
                   LEFT JOIN ws_dbc_target ON oo_target_key = dt_target_key
                   LEFT JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
                   WHERE lt_obj_key = v_obj_key
                   AND (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))	-- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
                       UNION ALL
                   -- All other non-Script-based Load tables with Hive targets
                   SELECT CASE WHEN lt_type IN ('A','F','D') THEN tgt_con.dc_obj_key ELSE 0 END connect_key, 1 is_hive_target
                   FROM ws_load_tab
                   JOIN ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
                   JOIN ws_obj_object ON lt_obj_key = oo_obj_key
                   JOIN ws_dbc_target ON oo_target_key = dt_target_key
                   JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
                   WHERE lt_obj_key = v_obj_key
                   AND NOT (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))	-- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
                   AND tgt_con.dc_db_type_ind = 8		-- 8 = WS_DB_HIVE
                       UNION ALL
                   -- All other non-Load tables with Hive targets, except Script-based exports
                   SELECT tgt_con.dc_obj_key connect_key, 1 is_hive_target
                   FROM ws_obj_object
                   JOIN ws_dbc_target ON oo_target_key = dt_target_key
                   JOIN ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
                   WHERE oo_obj_key = v_obj_key
                   AND oo_type_key <> v_ws_obj_load
                   AND NOT (oo_type_key = v_ws_obj_export AND (SELECT et_type from ws_export_tab WHERE et_obj_key = oo_obj_key) = 'S')
                   AND tgt_con.dc_db_type_ind = 8		-- 8 = WS_DB_HIVE
              ) bda;

               EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                   v_bda_connect_key := 0;
                   v_is_hive_target := 0;

                 WHEN TOO_MANY_ROWS THEN
                   v_MsgText := 'Multiple BDA connection keys found for job: '||pi_job_name||'.';

                   v_rec_count := 0;
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                          v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;

                 WHEN OTHERS THEN
                   v_MsgText := 'Unhandled exception checking if job is a BDA operation: '||pi_job_name||'.';

                   v_rec_count := 0;
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                          v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;

               END;
           END IF;
           -- Determine if the job is an MSAS Tabular operation.
           BEGIN
             SELECT 1
             INTO v_is_msas_tabular_target
             FROM ws_obj_object
             JOIN ws_dbc_target ON oo_target_key = dt_target_key
             JOIN ws_dbc_connect ON dt_connect_key = dc_obj_key
             WHERE oo_obj_key = v_obj_key
             AND dc_db_type_ind = 12;		-- 12 = WS_DB_MSASTABULAR
           EXCEPTION
             WHEN NO_DATA_FOUND THEN
               v_is_msas_tabular_target := 0;
             WHEN OTHERS THEN
               v_MsgText := 'Unhandled exception checking if job is an MSAS Tabular operation: '||pi_job_name||'.';
               v_rec_count := 0;
               v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                      v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
               po_result_code := -2;
               RETURN;
           END;

           -- Determine if the job requires on-the-fly Create DDL template evaluation.
           v_is_template_ddl_target := 0;
           IF v_action_type = v_ws_act_create
           THEN
             BEGIN
               SELECT 1
               INTO v_is_template_ddl_target
               FROM ws_table_attributes
               WHERE ta_obj_key = v_obj_key
                 AND ta_type = 'L'
                 AND (  v_ws_create_ddl_type = ta_ind_1
                     OR v_ws_create_ddl_type = ta_ind_2
                     OR v_ws_create_ddl_type = ta_ind_3
                     OR v_ws_create_ddl_type = ta_ind_4
                     OR v_ws_create_ddl_type = ta_ind_5
                     OR v_ws_create_ddl_type = ta_ind_6
                     OR v_ws_create_ddl_type = ta_ind_7
                     OR v_ws_create_ddl_type = ta_ind_8
                     OR v_ws_create_ddl_type = ta_ind_9
                     OR v_ws_create_ddl_type = ta_ind_10
                     OR v_ws_create_ddl_type = ta_ind_11
                     OR v_ws_create_ddl_type = ta_ind_12
                     )
               ;
             EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  v_is_template_ddl_target := 0;
               WHEN OTHERS THEN
                 v_MsgText := 'Unhandled exception checking if job requires on-the-fly template DDL evaluation: '||pi_job_name||'.';
                 v_rec_count := 0;
                 v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                        v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                 po_result_code := -2;
                 RETURN;
             END;

             -- override DDL trumps on-the-fly DDL template
             IF v_is_template_ddl_target = 1
             THEN
               BEGIN
                 SELECT NVL(ta_text_1, '')
                 INTO v_work
                 FROM ws_table_attributes
                 WHERE ta_obj_key = v_obj_key
                   AND ta_type = 'D'
                 ;
               EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                    v_work := '';
                 WHEN OTHERS THEN
                   v_MsgText := 'Unhandled exception checking if job uses override DDL: '||pi_job_name||'.';
                   v_rec_count := 0;
                   v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                          v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                   po_result_code := -2;
                   RETURN;
               END;
               IF TRIM(v_work) IS NOT NULL THEN
                  v_is_template_ddl_target := 0;
               END IF;
             END IF;
           END IF;

           If v_bda_connect_key > 0 And v_is_hive_target = 1 Then
              v_step := 2850;

              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_msg := 'BDA Server task with Hive target';
              po_action_key := 0;
              po_action_msg := 'no action';
              ps_job_key_list := TO_CHAR(p_job_id);
              ps_task_key_list := TO_CHAR(p_task_id);
              po_result_code := 90;

              -- Put BDA connection settings into task data (used by the Linux/Unix Scheduler).
              -- There should be at most one record, otherwise a fatal problem.
              BEGIN

                SELECT ta_text_1
                INTO v_task_data
                FROM ws_table_attributes
                WHERE ta_obj_key = v_bda_connect_key AND ta_type = 'B';

              EXCEPTION
                WHEN NO_DATA_FOUND THEN
                  v_task_data := '';

                WHEN TOO_MANY_ROWS THEN
                  v_MsgText := 'Multiple BDA connection parameters found for job: '||pi_job_name||'.';

                  v_rec_count := 0;
                  v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                         v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                  po_result_code := -2;
                  RETURN;

                WHEN OTHERS THEN
                  v_MsgText := 'Unhandled exception getting BDA connection parameters for job: '||pi_job_name||'.';

                  v_rec_count := 0;
                  v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                         v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                  po_result_code := -2;
                  RETURN;

              END;

              -- Put the BDA connection key into task data (used by the Windows Scheduler).
              v_task_data := v_task_data
                || 'SCH_BDA_ConnectKey[WSH]' || TO_CHAR(v_bda_connect_key) || '[WSH]';

              -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
              v_task_data := v_task_data
                || 'SCH_BDA_ObjKey[WSH]' || TO_CHAR(v_obj_key) || '[WSH]'
                || 'SCH_BDA_Action[WSH]' || TO_CHAR(v_action_type) || '[WSH]';

              -- Put the shared secret timestamp and base64 bytes into task data.
              BEGIN
                SELECT ta_val_1 AS secret_id, ta_text_1 AS secret_text
                  INTO v_secret_id, v_secret_text
                  FROM ws_table_attributes
                 WHERE ta_type = 'Z'
                   AND ta_obj_key = 0;

              EXCEPTION
                WHEN NO_DATA_FOUND THEN
                  v_MsgText := 'No shared secret for BDA connection found for job: ' || pi_job_name || '.';
                  v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                         v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                  v_secret_id := 0;
                  v_secret_text := '';

                WHEN OTHERS THEN
                  v_MsgText := 'Unhandled exception getting shared secret for BDA connection for job: '||pi_job_name||'.';

                  v_rec_count := 0;
                  v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                         v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                  po_result_code := -2;
                  RETURN;

              END;

              v_task_data := v_task_data
                || 'SCH_BDA_SecretId[WSH]' || TO_CHAR(v_secret_id) || '[WSH]'
                || 'SCH_BDA_Secret[WSH]' || TRIM(v_secret_text) || '[WSH]';

              po_task_data := v_task_data;

              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 2860;
              BEGIN
                IF p_job_id > 0 And v_sid <> 0 Then
                  Delete from ws_wrk_job_thread
                  Where wjt_job_key = p_job_id
                  And wjt_thread = pi_thread
                  And wjt_sequence = pi_sequence
                  And wjt_sid = v_sid
                  And wjt_serial = v_serial;
                End If;
                COMMIT;
              EXCEPTION WHEN OTHERS THEN
                 v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;

          --=====================================================
          -- Treat other Hive Loads, e.g. ODBC loads as external objects
          -- Process tables with MSAS Tabular targets as external objects
          -- Process tables with on-the-fly template DDL as external objects
          --=====================================================
          ElsIf v_is_hive_target = 1 Or v_is_msas_tabular_target = 1 OR v_is_template_ddl_target = 1 Then

              v_step := 2870;

              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_code := 18;
              If v_is_hive_target = 1 Then
                po_result_msg := 'Other Load with Hive target';
              ElsIf v_is_msas_tabular_target = 1 Then
                po_result_msg := 'Table operation with MSAS Tabular target';
              ElsIf v_is_template_ddl_target = 1 Then
                po_result_msg := 'Table operation with template DDL';
                po_result_code := 22;
              Else
                -- We should never get this message
                po_result_msg := 'External object table operation';
              End If;
              po_action_key := 0;
              po_action_msg := 'no action';
              ps_job_key_list := TO_CHAR(p_job_id);
              ps_task_key_list := TO_CHAR(p_task_id);

              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 2880;
              BEGIN
                IF p_job_id > 0 And v_sid <> 0 Then
                  Delete from ws_wrk_job_thread
                  Where wjt_job_key = p_job_id
                  And wjt_thread = pi_thread
                  And wjt_sequence = pi_sequence
                  And wjt_sid = v_sid
                  And wjt_serial = v_serial;
                End If;
                COMMIT;
              EXCEPTION WHEN OTHERS THEN
                 v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;
           END IF;

           IF v_obj_type <> v_ws_obj_job Then
             -- ====================================================
             -- Determine if need to return to caller due to being
             -- an 'external object'
             -- ====================================================
             IF v_obj_type = v_ws_obj_source_mapping Then
               BEGIN
                 SELECT    NVL(ws_obj_object.oo_target_key, 0)
                         , NVL(ws_dbc_connect.dc_db_type_ind, 5) -- Presume local
                 INTO      v_target_key
                         , v_target_db_type
                 FROM      ws_source_mapping_tab
                 JOIN      ws_obj_object ON ws_source_mapping_tab.smt_parent_obj_key = ws_obj_object.oo_obj_key
                 LEFT JOIN ws_dbc_target ON ws_obj_object.oo_target_key = ws_dbc_target.dt_target_key
                 LEFT JOIN ws_dbc_connect ON ws_dbc_target.dt_connect_key = ws_dbc_connect.dc_obj_key
                 WHERE ws_source_mapping_tab.smt_source_mapping_key = v_obj_key;

               EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                    v_target_key := 0;
                    v_target_db_type := 0;

                 WHEN OTHERS THEN
                    v_MsgText := 'Unhandled exception getting target database type for job: '||pi_job_name||'.';

                    v_rec_count := 0;
                    v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                    po_result_code := -2;
                    RETURN;
               END;
             Else
               BEGIN
                 SELECT    NVL(ws_obj_object.oo_target_key, 0)
                         , NVL(ws_dbc_connect.dc_db_type_ind, 5) -- Presume local
                 INTO      v_target_key
                         , v_target_db_type
                 FROM      ws_obj_object
                 LEFT JOIN ws_dbc_target ON ws_obj_object.oo_target_key = ws_dbc_target.dt_target_key
                 LEFT JOIN ws_dbc_connect ON ws_dbc_target.dt_connect_key = ws_dbc_connect.dc_obj_key
                 WHERE (ws_obj_object.oo_obj_key = v_obj_key AND ws_obj_object.oo_type_key <> v_ws_obj_export)
                 OR UPPER(ws_obj_object.oo_name) IN (
                     SELECT DISTINCT UPPER(ws_export_col.ec_src_table)
                     FROM ws_export_col
                     WHERE ws_export_col.ec_obj_key = v_obj_key
                     );

               EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                    v_target_key := 0;
                    v_target_db_type := 0;

                 WHEN OTHERS THEN
                    v_MsgText := 'Unhandled exception getting target database type for job: '||pi_job_name||'.';

                    v_rec_count := 0;
                    v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                           v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                    po_result_code := -2;
                    RETURN;
               END;
             END IF;

             -- we can only process target here if type for local Oracle;
             -- something else (like Custom) needs to go to Odl
             -- TODO: remote Oracle target job also needs to go to Odl but
             --       currently remote targets not supported for Oracle
             If (v_target_key <> 0) AND (v_target_db_type <> 0) AND (v_target_db_type <> 5) Then

               -- If this execute is for an external object
               -- return value of 18
               -- passed back to the scheduler and let it do the processing
               po_job_key       := p_job_id;
               po_task_key      := p_task_id;
               po_task_name     := p_task_name;
               po_result_msg    := 'External Object';
               po_action_key    := 0;
               po_action_msg    := 'no action';
               po_result_code   := 18;
               ps_job_key_list  := TO_CHAR(p_job_id);
               ps_task_key_list := TO_CHAR(p_task_id);

               If v_bda_connect_key > 0 Then
                 po_result_msg := po_result_msg + ' as BDA Server task with non-Hive target';

                 -- Don't need to put BDA connection settings into task data (only used by the Linux/Unix Scheduler).
                 v_task_data := '';

                 -- Put the BDA connection key into task data (used by the Windows Scheduler).
                 v_task_data := v_task_data
                   + 'SCH_BDA_ConnectKey[WSH]' + TO_CHAR(v_bda_connect_key) + '[WSH]';

                 -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
                 v_task_data := v_task_data
                   + 'SCH_BDA_ObjKey[WSH]' + TO_CHAR(v_obj_key) + '[WSH]'
                   + 'SCH_BDA_Action[WSH]' + TO_CHAR(v_action_type) + '[WSH]';

                 po_task_data := v_task_data;
               END IF;

               --=====================================================
               --Remove this thread as being active
               --=====================================================
               v_step := 2890;
               BEGIN
                   IF p_job_id > 0 And v_sid <> 0 Then
                       Delete from ws_wrk_job_thread
                       Where wjt_job_key = p_job_id
                       And wjt_thread = pi_thread
                       And wjt_sequence = pi_sequence
                       And wjt_sid = v_sid
                       And wjt_serial = v_serial;
                   End If;
                  COMMIT;
               EXCEPTION WHEN OTHERS THEN
                      v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
               END;
               RETURN;
             END IF;
           END IF;

           --=====================================================
           -- E X E C U T E
           --=====================================================
           If v_action_type = v_ws_act_execute then
              --=====================================================
              -- E X E C U T E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_olap_cube
              Or v_obj_type = v_ws_obj_olap_dim
              Or v_obj_type = v_ws_obj_olap_role
              Or v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 8
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube execute';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 8;
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 2900;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
               --=====================================================
               -- E X E C U T E    P R O C E D U R E
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_procedure
               THEN
                 SELECT NVL(ph_type,'P')
                 INTO   v_procedure_type
                 FROM   ws_pro_header
                 WHERE  ph_obj_key = v_obj_key;

                 v_step := 3000;

                 IF v_procedure_type = 'B'
                 THEN

                   po_job_key := p_job_id;
                   po_task_key := p_task_id;
                   po_task_name := p_task_name;
                   po_result_msg := 'execute sql';
                   po_action_key := v_obj_key;
                   po_action_msg := 'no action';
                   ps_job_key_list := TO_CHAR(p_job_id);
                   ps_task_key_list := TO_CHAR(p_task_id);
                   po_result_code := 16;

                   --=====================================================
                   -- Remove this thread as being active
                   --=====================================================
                   v_step := 3100;
                   BEGIN
                     IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                     End If;
                     COMMIT;
                   EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                   END;
                   RETURN;
                 END IF;  -- SQLBLOCK post procedure

                 -- Normal Procedure
                 v_result := ws_act_execute(p_sequence,v_obj_type,v_action_type,
                                                v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                                p_return_msg, p_status_code);
               --=====================================================
               -- E X E C U T E    S C R I P T
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_script Then
                   v_result := ws_act_host_script(p_sequence,v_obj_type,v_action_type,v_obj_key,
                                                v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                                p_return_msg, p_status_code);
                   -- If script build worked then skip out to process it
                   -- If it failed then the standard handling will deal with it.
                   If v_result >= -1 Then
                       po_job_key := p_job_id;
                       po_task_key := p_task_id;
                       po_task_name := p_task_name;
                       po_result_msg := 'execute script';
                       po_action_key := 0;
                       po_action_msg := 'no action';
                       po_result_code := 2;
                       ps_job_key_list := TO_CHAR(p_job_id);
                       ps_task_key_list := TO_CHAR(p_task_id);
                       RETURN;
                   End If;
               --=====================================================
               -- E X E C U T E    U N S U P P O R T E D
               --=====================================================
               Else
                  v_MsgText := 'Job '||p_task_name||' sequence '||pi_sequence||
                                           ' could not perform action. Unsupported action '||
                                           v_action_type||' for object ' ||v_obj_type;
                  v_result := WsWrkAudit('E',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                   v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  p_status_code  := -2;
                  p_return_msg := 'Unsupported action '||
                                   v_action_type||' for object ' ||v_obj_type;
                  v_result := 1;
           End If;
           --=====================================================
           -- L O A D
           --=====================================================
           ElsIf v_action_type = v_ws_act_load then
             --=====================================================
             -- R E T R O     L O A D
             --=====================================================
             If v_obj_type = v_ws_obj_retro_copy Then

               -- If this a Retrofit ODBC based load then
               -- Skip out to process it
               po_job_key := p_job_id;
               po_task_key := p_task_id;
               po_task_name := p_task_name;
               po_result_msg := 'retro table';
               po_action_key := v_obj_key;
               po_action_msg := 'no action';
               po_result_code := 13;
               ps_job_key_list := TO_CHAR(p_job_id);
               ps_task_key_list := TO_CHAR(p_task_id);
               --=====================================================
               -- Remove this thread as being active
               --=====================================================
               v_step := 3200;
               BEGIN
                   IF p_job_id > 0 And v_sid <> 0 Then
                       Delete from ws_wrk_job_thread
                       Where wjt_job_key = p_job_id
                       And wjt_thread = pi_thread
                       And wjt_sequence = pi_sequence
                       And wjt_sid = v_sid
                       And wjt_serial = v_serial;
                   End If;
                  COMMIT;
               EXCEPTION WHEN OTHERS THEN
                      v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
               END;
               RETURN;

             --=====================================================
             -- L O A D     O B J E C T      L O A D
             --=====================================================
             Else
               v_result := ws_act_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
               If v_result >= -1 Then
                  If p_status_code = 1 Then
                     v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  ElsIf p_status_code <> 2 Then
                       v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  End If;
                  -- If this load requires a host script then we will have a
                  -- return value of 2
                  -- If script build worked then skip out to process it
                  -- If it failed then the standard handling will deal with it.
                  -- When we Rejoin the job any post load procedure will be run
                  If v_result = 2 Then
                      po_job_key := p_job_id;
                      po_task_key := p_task_id;
                      po_task_name := p_task_name;
                      po_result_msg := 'load table';
                      po_action_key := 0;
                      po_action_msg := 'no action';
                      po_result_code := 2;
                      ps_job_key_list := TO_CHAR(p_job_id);
                      ps_task_key_list := TO_CHAR(p_task_id);
                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 3300;
                        BEGIN
                            IF p_job_id > 0 And v_sid <> 0 Then
                                Delete from ws_wrk_job_thread
                                Where wjt_job_key = p_job_id
                                And wjt_thread = pi_thread
                                And wjt_sequence = pi_sequence
                                And wjt_sid = v_sid
                                And wjt_serial = v_serial;
                            End If;
                           COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                               v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                      RETURN;
                  -- If this load requires an ODBC based load then we will have a
                  -- return value of 3
                  -- Skip out to process it
                  -- When we Rejoin the job any post load procedure will be run
                  ElsIf v_result = 3 Then
                      po_job_key := p_job_id;
                      po_task_key := p_task_id;
                      po_task_name := p_task_name;
                      po_result_msg := 'load table';
                      po_action_key := v_obj_key;
                      po_action_msg := 'no action';
                      po_result_code := 3;
                      ps_job_key_list := TO_CHAR(p_job_id);
                      ps_task_key_list := TO_CHAR(p_task_id);
                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 3400;
                        BEGIN
                            IF p_job_id > 0 And v_sid <> 0 Then
                                Delete from ws_wrk_job_thread
                                Where wjt_job_key = p_job_id
                                And wjt_thread = pi_thread
                                And wjt_sequence = pi_sequence
                                And wjt_sid = v_sid
                                And wjt_serial = v_serial;
                            End If;
                           COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                               v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                      RETURN;
                  -- If this load requires a Native ODBC based load then we will have a return value of 12
                  -- If this load requires a SSIS based load then we will have a return value of 14
                  -- Skip out to process it
                  -- When we Rejoin the job any post load procedure will be run
                  ElsIf v_result = 12
                  OR    v_result = 14 Then
                      po_job_key := p_job_id;
                      po_task_key := p_task_id;
                      po_task_name := p_task_name;
                      po_result_msg := 'load table';
                      po_action_key := v_obj_key;
                      po_action_msg := 'no action';
                      po_result_code := v_result;
                      ps_job_key_list := TO_CHAR(p_job_id);
                      ps_task_key_list := TO_CHAR(p_task_id);
                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 3500;
                        BEGIN
                            IF p_job_id > 0 And v_sid <> 0 Then
                                Delete from ws_wrk_job_thread
                                Where wjt_job_key = p_job_id
                                And wjt_thread = pi_thread
                                And wjt_sequence = pi_sequence
                                And wjt_sid = v_sid
                                And wjt_serial = v_serial;
                            End If;
                           COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                               v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                      RETURN;

                  -- If this load is a BDA Server operation with non-Hive target
                  -- then we will have a return value of 91
                  -- Skip out to process it
                  -- When we Rejoin the job any post load procedure will be run
                  ElsIf v_result = 91 Then
                    v_step := 3550;

                    po_job_key := p_job_id;
                    po_task_key := p_task_id;
                    po_task_name := p_task_name;
                    po_result_msg := p_return_msg || ' with non-Hive target';
                    po_action_key := 0;
                    po_action_msg := 'no action';
                    ps_job_key_list := TO_CHAR(p_job_id);
                    ps_task_key_list := TO_CHAR(p_task_id);
                    po_result_code := 91;

                    -- Put BDA connection settings into task data (used by the Linux/Unix Scheduler).
                    -- There should be at most one record, otherwise a fatal problem.
                    BEGIN

                      SELECT ta_text_1
                      INTO v_task_data
                      FROM ws_table_attributes
                      WHERE ta_obj_key = v_bda_connect_key AND ta_type = 'B';

                    EXCEPTION
                      WHEN NO_DATA_FOUND THEN
                        v_task_data := '';

                      WHEN TOO_MANY_ROWS THEN
                        v_MsgText := 'Multiple BDA connection parameters found for job: '||pi_job_name||'.';

                        v_rec_count := 0;
                        v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                               v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                        po_result_code := -2;
                        RETURN;

                      WHEN OTHERS THEN
                        v_MsgText := 'Unhandled exception getting BDA connection parameters for job: '||pi_job_name||'.';

                        v_rec_count := 0;
                        v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                               v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                        po_result_code := -2;
                        RETURN;

                    END;

                    -- Put the BDA connection key into task data (used by the Windows Scheduler).
                    v_task_data := v_task_data
                      || 'SCH_BDA_ConnectKey[WSH]' || TO_CHAR(v_bda_connect_key) || '[WSH]';

                    -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
                    v_task_data := v_task_data
                      || 'SCH_BDA_ObjKey[WSH]' || TO_CHAR(v_obj_key) || '[WSH]'
                      || 'SCH_BDA_Action[WSH]' || TO_CHAR(v_action_type) || '[WSH]';

                    -- Put the shared secret timestamp and base64 bytes into task data.
                    BEGIN
                      SELECT ta_val_1 AS secret_id, ta_text_1 AS secret_text
                        INTO v_secret_id, v_secret_text
                        FROM ws_table_attributes
                       WHERE ta_type = 'Z'
                         AND ta_obj_key = 0;

                    EXCEPTION
                      WHEN NO_DATA_FOUND THEN
                        v_MsgText := 'No shared secret for BDA connection found for job: ' || pi_job_name || '.';
                        v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                               v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                        v_secret_id := 0;
                        v_secret_text := '';

                      WHEN OTHERS THEN
                        v_MsgText := 'Unhandled exception getting shared secret for BDA connection for job: '||pi_job_name||'.';

                        v_rec_count := 0;
                        v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                               v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                        po_result_code := -2;
                        RETURN;

                    END;

                    v_task_data := v_task_data
                      || 'SCH_BDA_SecretId[WSH]' || TO_CHAR(v_secret_id) || '[WSH]'
                      || 'SCH_BDA_Secret[WSH]' || TRIM(v_secret_text) || '[WSH]';

                    po_task_data := v_task_data;

                    --=====================================================
                    -- Remove this thread as being active
                    --=====================================================
                    v_step := 3560;
                    BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                      End If;
                      COMMIT;
                    EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                    END;
                    RETURN;

                  End If;

                  v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                        p_return_msg_2, p_status_code_2);
                  If p_status_code_2 = 1 Then
                     v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                          p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  ElsIf p_status_code_2 < 1 Then
                     v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                          p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  End If;

                  IF v_result = 2
                  THEN

                    po_job_key := p_job_id;
                    po_task_key := p_task_id;
                    po_task_name := p_task_name;
                    po_result_msg := 'execute sql';
                    po_action_key := v_obj_key;
                    po_action_msg := 'no action';
                    ps_job_key_list := TO_CHAR(p_job_id);
                    ps_task_key_list := TO_CHAR(p_task_id);
                    po_result_code := p_status_code_2; -- 16 or 17

                    --=====================================================
                    -- Remove this thread as being active
                    --=====================================================
                    v_step := 3600;
                    BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                      End If;
                      COMMIT;
                    EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                    END;
                    RETURN;
                  END IF;  -- SQLBLOCK post procedure


                  -- If our post load procedure failed and the load worked then
                  -- record the post load failure
                  If p_status_code_2 < p_status_code Then
                       p_status_code := p_status_code_2;
                  End If;
               End If;
             End If;
           --=====================================================
           -- U P D A T E
           --=====================================================
           ElsIf v_action_type = v_ws_act_update then
              --=====================================================
              -- U P D A T E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_olap_cube
              Or v_obj_type = v_ws_obj_olap_dim
              Or v_obj_type = v_ws_obj_olap_role
              Or v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 9
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube update';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 9;
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 3700;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_step := 3800;
                 v_result := ws_act_update(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
                 v_step := 3900;

                 IF v_result = 2
                 THEN
                   v_step := 4000;

                   po_job_key := p_job_id;
                   po_task_key := p_task_id;
                   po_task_name := p_task_name;
                   po_result_msg := 'execute sql';
                   po_action_key := v_obj_key;
                   po_action_msg := 'no action';
                   ps_job_key_list := TO_CHAR(p_job_id);
                   ps_task_key_list := TO_CHAR(p_task_id);
                   po_result_code := p_status_code; -- 16 or 17

                   --=====================================================
                   -- Remove this thread as being active
                   --=====================================================
                   v_step := 4100;
                   BEGIN
                     IF p_job_id > 0 And v_sid <> 0 Then
                       Delete from ws_wrk_job_thread
                       Where wjt_job_key = p_job_id
                       And wjt_thread = pi_thread
                       And wjt_sequence = pi_sequence
                       And wjt_sid = v_sid
                       And wjt_serial = v_serial;
                     End If;
                     COMMIT;
                   EXCEPTION WHEN OTHERS THEN
                      v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                   END;
                   RETURN;
                 END IF;  -- SQLBLOCK post procedure

              End If;
           --=====================================================
           -- C R E A T E
           --=====================================================
           ElsIf v_action_type = v_ws_act_create then
               If v_obj_type = v_ws_obj_olap_cube
               Or v_obj_type = v_ws_obj_olap_dim
               Or v_obj_type = v_ws_obj_olap_role
               Or v_obj_type = v_ws_obj_cube
               Or v_obj_type = v_ws_obj_cube_virtual Then
                  -- If this is a cube then let the scheduler handle it
                  -- return value of 4
                  -- Skip out to process it
                  po_job_key := p_job_id;
                  po_task_key := p_task_id;
                  po_task_name := p_task_name;
                  po_result_msg := 'cube create';
                  po_action_key := v_obj_key;
                  po_action_msg := 'no action';
                  po_result_code := 4;
                  ps_job_key_list := TO_CHAR(p_job_id);
                  ps_task_key_list := TO_CHAR(p_task_id);
                  --=====================================================
                  -- Remove this thread as being active
                  --=====================================================
                  v_step := 4200;
                  BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                          Delete from ws_wrk_job_thread
                          Where wjt_job_key = p_job_id
                          And wjt_thread = pi_thread
                          And wjt_sequence = pi_sequence
                          And wjt_sid = v_sid
                          And wjt_serial = v_serial;
                      End If;
                     COMMIT;
                  EXCEPTION WHEN OTHERS THEN
                         v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                  END;
                  RETURN;
               Else
                  v_result := ws_act_create(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
               End If;
           --=====================================================
           -- D R O P
           --=====================================================
           ElsIf v_action_type = v_ws_act_drop then
              --=====================================================
              -- D R O P       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_olap_cube
              Or v_obj_type = v_ws_obj_olap_dim
              Or v_obj_type = v_ws_obj_olap_role
              Or v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 10
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube drop';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                po_result_code := 10;
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 4300;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_result := ws_act_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- T R U N C A T E
           --=====================================================
           ElsIf v_action_type = v_ws_act_truncate then
               v_result := ws_act_truncate(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- D R O P    A L L
           --=====================================================
           ElsIf v_action_type = v_ws_act_drop_all then
               v_result := ws_act_drop_all(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- B U I L D
           --=====================================================
           ElsIf v_action_type = v_ws_act_build then
               v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- B U I L D    A L L
           --=====================================================
           ElsIf v_action_type = v_ws_act_build_all then
               v_result := ws_act_build_all(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- P R E   D R O P
           --=====================================================
           ElsIf v_action_type = v_ws_act_pre_drop then
               v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- A N A L Y Z E
           --=====================================================
           ElsIf v_action_type = v_ws_act_analyze then
              --=====================================================
              -- A N A L Y Z E      C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_olap_cube
              Or v_obj_type = v_ws_obj_olap_dim
              Or v_obj_type = v_ws_obj_olap_role
              Or v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 8
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube analyze';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 8;
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 4400;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                 v_result := ws_act_analyze(p_sequence,v_obj_type,v_action_type, 100,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- Q U I C K    A N A L Y Z E
           --=====================================================
           ElsIf v_action_type = v_ws_act_quick_analyze then
              --=====================================================
              -- Q U I C K    A N A L Y Z E       C U B E
              --=====================================================
              If v_obj_type = v_ws_obj_olap_cube
              Or v_obj_type = v_ws_obj_olap_dim
              Or v_obj_type = v_ws_obj_olap_role
              Or v_obj_type = v_ws_obj_cube
              Or v_obj_type = v_ws_obj_cube_virtual Then
                -- If this is a cube then let the scheduler handle it
                -- return value of 9
                -- Skip out to process it
                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'cube quick analyze';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                po_result_code := 9;
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 4500;
                BEGIN
                    IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                    End If;
                   COMMIT;
                EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              Else
                v_result := ws_act_analyze(p_sequence,v_obj_type,v_action_type, 3,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
              End If;
           --=====================================================
           -- S T A T I S T I C S
           --=====================================================
           ElsIf v_action_type = v_ws_act_statistics then
               v_result := ws_act_dbms_stats(p_sequence,v_obj_type,v_action_type, 100,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- Q U I C K   S T A T S
           --=====================================================
           ElsIf v_action_type = v_ws_act_quick_statistics then
               v_result := ws_act_dbms_stats(p_sequence,v_obj_type,v_action_type, 3,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
           --=====================================================
           -- P R O C E S S
           --=====================================================
           ElsIf v_action_type = v_ws_act_process then


               --=====================================================
               -- P R O C E S S      C U B E
               --=====================================================
               If v_obj_type = v_ws_obj_olap_cube
               Or v_obj_type = v_ws_obj_olap_dim
               Or v_obj_type = v_ws_obj_olap_role
               Or v_obj_type = v_ws_obj_cube
               Or v_obj_type = v_ws_obj_cube_virtual Then
                  -- If this is a cube then let the scheduler handle it
                  -- return value of 5
                  -- Skip out to process it
                  po_job_key := p_job_id;
                  po_task_key := p_task_id;
                  po_task_name := p_task_name;
                  po_result_msg := 'cube process';
                  po_action_key := v_obj_key;
                  po_action_msg := 'no action';
                  po_result_code := 5;
                  ps_job_key_list := TO_CHAR(p_job_id);
                  ps_task_key_list := TO_CHAR(p_task_id);
                  --=====================================================
                  -- Remove this thread as being active
                  --=====================================================
                  v_step := 4600;
                  BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                          Delete from ws_wrk_job_thread
                          Where wjt_job_key = p_job_id
                          And wjt_thread = pi_thread
                          And wjt_sequence = pi_sequence
                          And wjt_sid = v_sid
                          And wjt_serial = v_serial;
                      End If;
                     COMMIT;
                  EXCEPTION WHEN OTHERS THEN
                         v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                  END;
                  RETURN;
               End If;
               --=====================================================
               -- P R O C E S S      L O A D
               --=====================================================
               If v_obj_type = v_ws_obj_load Then
                   v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
                   If v_result >= -1 Then
                      If p_status_code = 1 Then
                          v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      Else
                          v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      End If;
                      v_result := ws_act_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
                      -- If this load requires a host script then we will have a
                      -- return value of 2
                      -- If script build worked then skip out to process it
                      -- If it failed then the standard handling will deal with it.
                      -- When we Rejoin the job any post load procedure will be run
                      If v_result = 2 Then
                          po_job_key := p_job_id;
                          po_task_key := p_task_id;
                          po_task_name := p_task_name;
                          po_result_msg := 'process table';
                          po_action_key := 0;
                          po_action_msg := 'no action';
                          po_result_code := 2;
                          ps_job_key_list := TO_CHAR(p_job_id);
                          ps_task_key_list := TO_CHAR(p_task_id);
                            --=====================================================
                            -- Remove this thread as being active
                            --=====================================================
                            v_step := 4700;
                            BEGIN
                                IF p_job_id > 0 And v_sid <> 0 Then
                                    Delete from ws_wrk_job_thread
                                    Where wjt_job_key = p_job_id
                                    And wjt_thread = pi_thread
                                    And wjt_sequence = pi_sequence
                                    And wjt_sid = v_sid
                                    And wjt_serial = v_serial;
                                End If;
                               COMMIT;
                            EXCEPTION WHEN OTHERS THEN
                                v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                            END;
                          RETURN;
                      -- If this load requires an ODBC load then we will have a
                      -- return value of 3
                      -- Skip out to process it
                      -- When we Rejoin the job any post load procedure will be run
                      ElsIf v_result = 3 Then
                          po_job_key := p_job_id;
                          po_task_key := p_task_id;
                          po_task_name := p_task_name;
                          po_result_msg := 'process table';
                          po_action_key := v_obj_key;
                          po_action_msg := 'no action';
                          po_result_code := 3;
                          ps_job_key_list := TO_CHAR(p_job_id);
                          ps_task_key_list := TO_CHAR(p_task_id);
                            --=====================================================
                            -- Remove this thread as being active
                            --=====================================================
                            v_step := 4800;
                            BEGIN
                                IF p_job_id > 0 And v_sid <> 0 Then
                                    Delete from ws_wrk_job_thread
                                    Where wjt_job_key = p_job_id
                                    And wjt_thread = pi_thread
                                    And wjt_sequence = pi_sequence
                                    And wjt_sid = v_sid
                                    And wjt_serial = v_serial;
                                End If;
                               COMMIT;
                            EXCEPTION WHEN OTHERS THEN
                                v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                            END;
                          RETURN;
                      -- If this load requires a Native ODBC load then we will have a
                      -- return value of 12
                      -- Skip out to process it
                      -- When we Rejoin the job any post load procedure will be run
                      ElsIf v_result = 12
                      or v_result = 14 Then --RED_3266
                          po_job_key := p_job_id;
                          po_task_key := p_task_id;
                          po_task_name := p_task_name;
                          po_result_msg := 'process table';
                          po_action_key := v_obj_key;
                          po_action_msg := 'no action';
                          po_result_code := v_result;--RED_3266
                          ps_job_key_list := TO_CHAR(p_job_id);
                          ps_task_key_list := TO_CHAR(p_task_id);
                            --=====================================================
                            -- Remove this thread as being active
                            --=====================================================
                            v_step := 4900;
                            BEGIN
                                IF p_job_id > 0 And v_sid <> 0 Then
                                    Delete from ws_wrk_job_thread
                                    Where wjt_job_key = p_job_id
                                    And wjt_thread = pi_thread
                                    And wjt_sequence = pi_sequence
                                    And wjt_sid = v_sid
                                    And wjt_serial = v_serial;
                                End If;
                               COMMIT;
                            EXCEPTION WHEN OTHERS THEN
                                v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                            END;
                          RETURN;

                      -- If this load is a BDA Server operation with non-Hive target
                      -- then we will have a return value of 91
                      -- Skip out to process it
                      -- When we Rejoin the job any post load procedure will be run
                      ElsIf v_result = 91 Then
                        v_step := 4950;

                        po_job_key := p_job_id;
                        po_task_key := p_task_id;
                        po_task_name := p_task_name;
                        po_result_msg := p_return_msg || ' with non-Hive target';
                        po_action_key := 0;
                        po_action_msg := 'no action';
                        ps_job_key_list := TO_CHAR(p_job_id);
                        ps_task_key_list := TO_CHAR(p_task_id);
                        po_result_code := 91;

                        -- Put BDA connection settings into task data (used by the Linux/Unix Scheduler).
                        -- There should be at most one record, otherwise a fatal problem.
                        BEGIN

                          SELECT ta_text_1
                          INTO v_task_data
                          FROM ws_table_attributes
                          WHERE ta_obj_key = v_bda_connect_key AND ta_type = 'B';

                        EXCEPTION
                          WHEN NO_DATA_FOUND THEN
                            v_task_data := '';

                          WHEN TOO_MANY_ROWS THEN
                            v_MsgText := 'Multiple BDA connection parameters found for job: '||pi_job_name||'.';

                            v_rec_count := 0;
                            v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                   v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                            po_result_code := -2;
                            RETURN;

                          WHEN OTHERS THEN
                            v_MsgText := 'Unhandled exception getting BDA connection parameters for job: '||pi_job_name||'.';

                            v_rec_count := 0;
                            v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                   v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                            po_result_code := -2;
                            RETURN;

                        END;

                        -- Put the BDA connection key into task data (used by the Windows Scheduler).
                        v_task_data := v_task_data
                          || 'SCH_BDA_ConnectKey[WSH]' || TO_CHAR(v_bda_connect_key) || '[WSH]';

                        -- Put the object key and action type into task data (used by the Windows Scheduler and Linux/Unix Scheduler).
                        v_task_data := v_task_data
                          || 'SCH_BDA_ObjKey[WSH]' || TO_CHAR(v_obj_key) || '[WSH]'
                          || 'SCH_BDA_Action[WSH]' || TO_CHAR(v_action_type) || '[WSH]';

                        -- Put the shared secret timestamp and base64 bytes into task data.
                        BEGIN
                          SELECT ta_val_1 AS secret_id, ta_text_1 AS secret_text
                            INTO v_secret_id, v_secret_text
                            FROM ws_table_attributes
                           WHERE ta_type = 'Z'
                             AND ta_obj_key = 0;

                        EXCEPTION
                          WHEN NO_DATA_FOUND THEN
                            v_MsgText := 'No shared secret for BDA connection found for job: ' || pi_job_name || '.';
                            v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                   v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                            v_secret_id := 0;
                            v_secret_text := '';

                          WHEN OTHERS THEN
                            v_MsgText := 'Unhandled exception getting shared secret for BDA connection for job: '||pi_job_name||'.';

                            v_rec_count := 0;
                            v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, v_ctrl_sequence,
                                                   v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                            po_result_code := -2;
                            RETURN;

                        END;

                        v_task_data := v_task_data
                          || 'SCH_BDA_SecretId[WSH]' || TO_CHAR(v_secret_id) || '[WSH]'
                          || 'SCH_BDA_Secret[WSH]' || TRIM(v_secret_text) || '[WSH]';

                        po_task_data := v_task_data;

                        --=====================================================
                        -- Remove this thread as being active
                        --=====================================================
                        v_step := 4960;
                        BEGIN
                          IF p_job_id > 0 And v_sid <> 0 Then
                            Delete from ws_wrk_job_thread
                            Where wjt_job_key = p_job_id
                            And wjt_thread = pi_thread
                            And wjt_sequence = pi_sequence
                            And wjt_sid = v_sid
                            And wjt_serial = v_serial;
                          End If;
                          COMMIT;
                        EXCEPTION WHEN OTHERS THEN
                           v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                        END;
                        RETURN;

                      End If;
                   End If;
                   If v_result >= -1
                   THEN
                     v_result := ws_act_post_load(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg_2, p_status_code_2);

                     IF v_result = 2
                     THEN
                       v_step := 5000;

                       po_job_key := p_job_id;
                       po_task_key := p_task_id;
                       po_task_name := p_task_name;
                       po_result_msg := 'execute sql';
                       po_action_key := v_obj_key;
                       po_action_msg := 'no action';
                       ps_job_key_list := TO_CHAR(p_job_id);
                       ps_task_key_list := TO_CHAR(p_task_id);
                       po_result_code := p_status_code_2; -- 16 or 17

                       --=====================================================
                       -- Remove this thread as being active
                       --=====================================================
                       v_step := 5100;
                       BEGIN
                         IF p_job_id > 0 And v_sid <> 0 Then
                           Delete from ws_wrk_job_thread
                           Where wjt_job_key = p_job_id
                           And wjt_thread = pi_thread
                           And wjt_sequence = pi_sequence
                           And wjt_sid = v_sid
                           And wjt_serial = v_serial;
                         End If;
                         COMMIT;
                       EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                       END;
                       RETURN;
                     END IF;  -- SQLBLOCK post procedure


                   Else
                       p_status_code_2 := 1;
                   End If;
                   If v_result >= -1 Then
                      If p_status_code_2 = 1 Then
                          v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      Else
                          v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      End If;
                      v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                            p_return_msg_3, p_status_code_3);
                      If p_status_code_3 = 1 Then
                         v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                              p_return_msg_3,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      ElsIf p_status_code_3 < 1 Then
                         v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                              p_return_msg_3,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      End If;
                   Else
                       p_status_code_3 := 1;
                   End If;

                   -- If our index build failed and the load worked then
                   -- record the index failure
                   If p_status_code_2 < p_status_code Then
                        p_status_code := p_status_code_2;
                   End If;
                   If p_status_code_3 < p_status_code Then
                        p_status_code := p_status_code_3;
                   End If;

               --=====================================================
               -- P R O C E S S      E X P O R T
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_export Then
                   v_result := ws_act_export(p_sequence,v_obj_type,v_action_type,
                                         v_obj_key,
                                         v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                         p_return_msg, p_status_code);

                   If v_result >= -1 Then
                       -- If this load requires a host script then we will have a
                       -- return value of 2
                       -- If script build worked then skip out to process it
                       -- If it failed then the standard handling will deal with it.
                       -- When we Rejoin the job any post load procedure will be run
                       If v_result = 2 Then
                           po_job_key := p_job_id;
                           po_task_key := p_task_id;
                           po_task_name := p_task_name;
                           po_result_msg := 'process table';
                           po_action_key := 0;
                           po_action_msg := 'no action';
                           po_result_code := 11;
                           ps_job_key_list := TO_CHAR(p_job_id);
                           ps_task_key_list := TO_CHAR(p_task_id);
                             --=====================================================
                             -- Remove this thread as being active
                             --=====================================================
                             v_step := 5200;
                             BEGIN
                                 IF p_job_id > 0 And v_sid <> 0 Then
                                     Delete from ws_wrk_job_thread
                                     Where wjt_job_key = p_job_id
                                     And wjt_thread = pi_thread
                                     And wjt_sequence = pi_sequence
                                     And wjt_sid = v_sid
                                     And wjt_serial = v_serial;
                                 End If;
                                COMMIT;
                             EXCEPTION WHEN OTHERS THEN
                                 v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                             END;
                           RETURN;
                       End If;
                       -- If this load requires SSIS then we will have a
                       -- return value of 14
                       -- When we Rejoin the job any post load procedure will be run
                       If v_result = 14 Then
                           po_job_key := p_job_id;
                           po_task_key := p_task_id;
                           po_task_name := p_task_name;
                           po_result_msg := 'process table';
                           po_action_key := 0;
                           po_action_msg := 'no action';
                           po_result_code := 14;
                           ps_job_key_list := TO_CHAR(p_job_id);
                           ps_task_key_list := TO_CHAR(p_task_id);
                             --=====================================================
                             -- Remove this thread as being active
                             --=====================================================
                             v_step := 5250;
                             BEGIN
                                 IF p_job_id > 0 And v_sid <> 0 Then
                                     Delete from ws_wrk_job_thread
                                     Where wjt_job_key = p_job_id
                                     And wjt_thread = pi_thread
                                     And wjt_sequence = pi_sequence
                                     And wjt_sid = v_sid
                                     And wjt_serial = v_serial;
                                 End If;
                                COMMIT;
                             EXCEPTION WHEN OTHERS THEN
                                 v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                             END;
                           RETURN;
                       End If;
                   End If;
                   If v_result >= -1
                   THEN
                     v_result := ws_act_post_export(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg_2, p_status_code_2);
                     IF v_result = 2
                     THEN
                       v_step := 5300;

                       po_job_key := p_job_id;
                       po_task_key := p_task_id;
                       po_task_name := p_task_name;
                       po_result_msg := 'execute sql';
                       po_action_key := v_obj_key;
                       po_action_msg := 'no action';
                       ps_job_key_list := TO_CHAR(p_job_id);
                       ps_task_key_list := TO_CHAR(p_task_id);
                       po_result_code := p_status_code_2; -- 16 or 17

                       --=====================================================
                       -- Remove this thread as being active
                       --=====================================================
                       v_step := 5400;
                       BEGIN
                         IF p_job_id > 0 And v_sid <> 0 Then
                           Delete from ws_wrk_job_thread
                           Where wjt_job_key = p_job_id
                           And wjt_thread = pi_thread
                           And wjt_sequence = pi_sequence
                           And wjt_sid = v_sid
                           And wjt_serial = v_serial;
                         End If;
                         COMMIT;
                       EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                       END;
                       RETURN;
                     END IF;  -- SQLBLOCK post procedure
                   Else
                       p_status_code_2 := 1;
                   End If;
                   If v_result >= -1 Then
                      If p_status_code_2 = 1 Then
                          v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      Else
                          v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                      End If;
                   Else
                       p_status_code_3 := 1;
                   End If;

               --=====================================================
               -- P R O C E S S      J O B
               --=====================================================
               ElsIf v_obj_type = v_ws_obj_job Then

                 v_job_action := 'NEW';

                 IF v_restart_flag = 1 THEN
                   SELECT count(*) into v_run_count
                   FROM  ws_wrk_job_run
                   WHERE wjr_name = p_task_name
                   AND   wjr_sequence = pi_sequence;

                   IF v_run_count = 1 THEN
                     v_job_action := 'RESTART';
                   END IF;

                 END IF;

                 Ws_Job_Exec_411(p_task_name,NULL,v_job_action,0,pi_sequence,
                              p_job_id, p_task_id,0,NULL,
                              v_pm_job_name, v_pm_job_key,
                              NULL,NULL,
                              p_status_code,
                              p_return_msg,
                              v_job_job_key,
                              v_job_task_key,v_job_task_name,
                              v_job_action_key, v_job_action_msg,
                              v_job_key_list, v_task_key_list,
                              v_task_data);

                  IF p_status_code = -3 THEN
                    p_return_msg := 'Called job ' || p_task_name || ' FAILED with unhandled error';
                  END IF;
                  IF p_status_code = -2 THEN
                    p_return_msg := 'Called job ' || p_task_name || ' FAILED';
                  END IF;
                  IF p_status_code = -1 THEN
                    p_return_msg := 'Called job ' || p_task_name || ' completed with WARNINGS';
                  END IF;
                  IF p_status_code = 0 THEN
                    p_return_msg := 'Called job ' || p_task_name || ' FAILED with unhandled problem';
                    p_status_code := -2;
                  END IF;
                  IF p_status_code = 1 THEN
                    p_return_msg := 'Called job ' || p_task_name || ' completed successfully';
                  END IF;
                  IF p_status_code > 1 THEN
                    po_job_key := p_job_id;
                    po_task_key := v_job_task_key;
                    po_task_name := v_job_task_name;
                    po_result_msg := p_return_msg;
                    po_action_key := v_job_action_key;
                    po_action_msg := v_job_action_msg;
                    po_result_code := p_status_code;
                    ps_job_key_list := TO_CHAR(p_job_id) || ',' || NVL(v_job_key_list,'');
                    ps_task_key_list := TO_CHAR(p_task_id) || ',' || NVL(v_task_key_list,'');
                    po_task_data := v_task_data;
                    return;
                  END IF;

               --=====================================================
               -- P R O C E S S      U P D A T E
               --=====================================================
               Else
                    v_result := ws_act_pre_drop(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);
                   If v_result >= -1 Then
                     If p_status_code = 1 Then
                         v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                     Else
                          v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                     End If;

                     v_result := ws_act_update(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);

                     IF v_result = 2
                     THEN
                       v_step := 5500;

                       po_job_key := p_job_id;
                       po_task_key := p_task_id;
                       po_task_name := p_task_name;
                       po_result_msg := 'execute sql';
                       po_action_key := v_obj_key;
                       po_action_msg := 'no action';
                       ps_job_key_list := TO_CHAR(p_job_id);
                       ps_task_key_list := TO_CHAR(p_task_id);
                       po_result_code := p_status_code; -- 16 or 17

                       --=====================================================
                       -- Remove this thread as being active
                       --=====================================================
                       v_step := 5600;
                       BEGIN
                         IF p_job_id > 0 And v_sid <> 0 Then
                           Delete from ws_wrk_job_thread
                           Where wjt_job_key = p_job_id
                           And wjt_thread = pi_thread
                           And wjt_sequence = pi_sequence
                           And wjt_sid = v_sid
                           And wjt_serial = v_serial;
                         End If;
                         COMMIT;
                       EXCEPTION WHEN OTHERS THEN
                          v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                       END;
                       RETURN;
                     END IF;  -- SQLBLOCK post procedure


                   End If;
                   If v_result >= -1 Then
                       v_result := ws_act_build(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                            p_return_msg_2, p_status_code_2);
                       If p_status_code_2 = 1 Then
                          v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                       ElsIf p_status_code_2 < 1 Then
                          v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
                       End If;
                   Else
                      p_status_code_2 := 1;
                   End If;

                   -- If our index build failed and the update worked then
                   -- record the index failure
                   If p_status_code_2 < p_status_code Then
                        p_status_code := p_status_code_2;
                   End If;
               End If;
           --=====================================================
           -- I N I T I A L     L O A D
           --=====================================================
           ElsIf v_action_type = v_ws_act_initial then


             --=====================================================
             -- R E T R O     I N I T I A L     L O A D
             --=====================================================
             If v_obj_type = v_ws_obj_retro_copy THEN
               -- First create the table
               v_result := ws_act_create(p_sequence,v_obj_type,v_action_type,
                                            v_obj_key,
                                            v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                            p_return_msg, p_status_code);

               -- If this a Retrofit ODBC based load then
               -- Skip out to process it
               po_job_key := p_job_id;
               po_task_key := p_task_id;
               po_task_name := p_task_name;
               po_result_msg := 'retro table';
               po_action_key := v_obj_key;
               po_action_msg := 'no action';
               po_result_code := 13;
               ps_job_key_list := TO_CHAR(p_job_id);
               ps_task_key_list := TO_CHAR(p_task_id);
               --=====================================================
               -- Remove this thread as being active
               --=====================================================
               v_step := 5700;
               BEGIN
                   IF p_job_id > 0 And v_sid <> 0 Then
                       Delete from ws_wrk_job_thread
                       Where wjt_job_key = p_job_id
                       And wjt_thread = pi_thread
                       And wjt_sequence = pi_sequence
                       And wjt_sid = v_sid
                       And wjt_serial = v_serial;
                   End If;
                  COMMIT;
               EXCEPTION WHEN OTHERS THEN
                      v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
               END;
               RETURN;

             --==========================================================
             -- O T H E R     O B J E C T     I N I T I A L     L O A D
             --==========================================================
             Else
                v_result := ws_act_drop_all(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                        p_return_msg, p_status_code);
               If v_result >= -1 Then
                  If p_status_code = 1 Then
                      v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  Else
                      v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                           p_return_msg,NULL,NULL,v_audit_task_id,v_audit_job_id);
                  End If;
                  v_result := ws_act_initial_build(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                        p_return_msg, p_status_code);
                  IF v_result = 2
                  THEN
                    v_step := 5800;

                    po_job_key := p_job_id;
                    po_task_key := p_task_id;
                    po_task_name := p_task_name;
                    po_result_msg := 'execute sql';
                    po_action_key := v_obj_key;
                    po_action_msg := 'no action';
                    ps_job_key_list := TO_CHAR(p_job_id);
                    ps_task_key_list := TO_CHAR(p_task_id);
                    po_result_code := p_status_code; -- 16 or 17

                    --=====================================================
                    -- Remove this thread as being active
                    --=====================================================
                    v_step := 5900;
                    BEGIN
                      IF p_job_id > 0 And v_sid <> 0 Then
                        Delete from ws_wrk_job_thread
                        Where wjt_job_key = p_job_id
                        And wjt_thread = pi_thread
                        And wjt_sequence = pi_sequence
                        And wjt_sid = v_sid
                        And wjt_serial = v_serial;
                      End If;
                      COMMIT;
                    EXCEPTION WHEN OTHERS THEN
                       v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                    END;
                    RETURN;
                  END IF;  -- SQLBLOCK post procedure

               End If;
               If v_result >= -1 Then
                   v_result := ws_act_build_all(p_sequence,v_obj_type,v_action_type,
                                        v_obj_key,
                                        v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,NULL,
                                        p_return_msg_2, p_status_code_2);
               End If;
               If p_status_code_2 = 1 Then
                  v_result := WsWrkAudit('I',v_audit_job_name,v_audit_task_name, pi_sequence,
                                       p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
               ElsIf p_status_code_2 < 1 Then
                  v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                       p_return_msg_2,NULL,NULL,v_audit_task_id,v_audit_job_id);
               End If;

               -- If our index build failed and the initial load worked then
               -- record the index failure
               If p_status_code_2 < p_status_code Then
                    p_status_code := p_status_code_2;
               End If;
             End If;
           --=====================================================
           -- C U S T O M
           --=====================================================
           ElsIf v_action_type = v_ws_act_custom then
              v_result := ws_act_initial_build(p_sequence,v_obj_type,v_action_type,
                                    v_obj_key,
                                    v_audit_job_name, v_audit_task_name, v_audit_job_id, v_audit_task_id,
                                    p_return_msg, p_status_code);
              IF v_result = 2
              THEN
                v_step := 6000;

                po_job_key := p_job_id;
                po_task_key := p_task_id;
                po_task_name := p_task_name;
                po_result_msg := 'execute sql';
                po_action_key := v_obj_key;
                po_action_msg := 'no action';
                ps_job_key_list := TO_CHAR(p_job_id);
                ps_task_key_list := TO_CHAR(p_task_id);
                po_result_code := p_status_code; -- 16 or 17

                --=====================================================
                -- Remove this thread as being active
                --=====================================================
                v_step := 6100;
                BEGIN
                  IF p_job_id > 0 And v_sid <> 0 Then
                    Delete from ws_wrk_job_thread
                    Where wjt_job_key = p_job_id
                    And wjt_thread = pi_thread
                    And wjt_sequence = pi_sequence
                    And wjt_sid = v_sid
                    And wjt_serial = v_serial;
                  End If;
                  COMMIT;
                EXCEPTION WHEN OTHERS THEN
                   v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
                END;
                RETURN;
              END IF;  -- SQLBLOCK post procedure
           --=====================================================
           -- C U B E   P R O C E S S    C U B E   D I M S
           --=====================================================
           ElsIf v_action_type = v_ws_act_cube_dim then
              -- If this is a cube then let the scheduler handle it
              -- return value of 6
              -- Skip out to process it
              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_msg := 'cube process cube dimensions';
              po_action_key := v_obj_key;
              po_action_msg := 'no action';
              po_result_code := 6;
              ps_job_key_list := TO_CHAR(p_job_id);
              ps_task_key_list := TO_CHAR(p_task_id);
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 6200;
              BEGIN
                  IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                  End If;
                 COMMIT;
              EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;
           --=====================================================
           -- C U B E   P R O C E S S    D A T A B A S E   D I M S
           --=====================================================
           ElsIf v_action_type = v_ws_act_db_dim then
              -- If this is a cube then let the scheduler handle it
              -- return value of 7
              -- Skip out to process it
              po_job_key := p_job_id;
              po_task_key := p_task_id;
              po_task_name := p_task_name;
              po_result_msg := 'cube process db dimensions';
              po_action_key := v_obj_key;
              po_action_msg := 'no action';
              po_result_code := 7;
              ps_job_key_list := TO_CHAR(p_job_id);
              ps_task_key_list := TO_CHAR(p_task_id);
              --=====================================================
              -- Remove this thread as being active
              --=====================================================
              v_step := 6300;
              BEGIN
                  IF p_job_id > 0 And v_sid <> 0 Then
                      Delete from ws_wrk_job_thread
                      Where wjt_job_key = p_job_id
                      And wjt_thread = pi_thread
                      And wjt_sequence = pi_sequence
                      And wjt_sid = v_sid
                      And wjt_serial = v_serial;
                  End If;
                 COMMIT;
              EXCEPTION WHEN OTHERS THEN
                     v_MsgText := 'Job '||pi_job_name||' unable to remove thread from ws_wrk_job_thread ';
              END;
              RETURN;
           --=====================================================
           -- U N S U P P O R T E D
           --=====================================================
           Else
              v_MsgText := 'Job '||p_task_name||' sequence '||pi_sequence||
                                       ' could not perform action. Unsupported action '||
                                       v_action_type||' for object ' ||v_obj_type;
              v_result := WsWrkAudit('E',v_audit_job_name,v_audit_task_name, pi_sequence,
                                               v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);
              p_status_code  := -2;
              p_return_msg := 'Unsupported action '||
                               v_action_type||' for object ' ||v_obj_type;
              v_result := 1;
           End If;
           COMMIT;
           v_step := 6400;
           --=====================================================
           -- Check that our function worked. If not then task failed
           --=====================================================
           --If v_result = -3 Then
           --    p_status_code := -3;
           --    If ltrim(rtrim(p_return_msg)) =  Then
           --         p_return_msg := Unhandled exception in action;
           --    End If;
           --End If;

           v_just_done := 1;
           v_step := 6500;
           --=====================================================
           -- Log the results in the audit trail
           --=====================================================
           If p_status_code = 1 Then
              v_audit_status := 'S';
              v_run_status := 'C';
           ElsIf p_status_code = -1 Then
               v_audit_status := 'W';
               v_run_status := 'C';
           ElsIf p_status_code = -2 Then
               v_audit_status := 'E';
               v_run_status := 'F';
           ElsIf p_status_code = -3 Then
               v_audit_status := 'F';
               v_run_status := 'F';
           ELSE
               v_audit_status := 'U';
               v_run_status := 'U';
               p_status_code := -3;
           End If;
           v_result := WsWrkAudit(v_audit_status, v_audit_job_name,v_audit_task_name, p_sequence,
                     p_return_msg, NULL, NULL, v_audit_task_id, v_audit_job_id);
            --=====================================================
            -- See if the task needs a status update.
            --=====================================================
            If v_okay = 1 OR v_halted = 1 Then
                --=====================================================
                -- Update the run record to indicate our final status
                -- If we have a halt then generate a message
                --=====================================================
                v_step := 6600;
                If v_halted = 1 Then
                     p_return_msg := 'Halted by dependency failure or halt';
                     v_run_status := 'H';
                     v_audit_status := NULL;
                End If;
                BEGIN
                  update ws_wrk_task_run
                  set wtr_run_status = v_run_status,
                        wtr_audit_status = v_audit_status,
                        wtr_return_msg = p_return_msg,
                        wtr_elapsed_hh =  trunc(to_number(sysdate-wtr_started)*24,0),
                        wtr_elapsed_mi = round(to_number(sysdate-wtr_started)*24*60,0) - (
                                                         trunc(to_number(sysdate-wtr_started)*24,0)*60),
                        wtr_completed = sysdate
                  where wtr_task_key = v_task_key
                  and wtr_job_key = p_job_id;
                EXCEPTION WHEN OTHERS THEN
                    v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                               ' failed in final update of ws_wrk_task_run for task id '||
                                               v_task_key||'. Run incomplete !!!';
                    v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
                    po_result_code := -2;
                    RETURN;
                END;
                COMMIT;
            End If;  -- End of task record update
        Else -- not processing, so must be an idle thread
           v_idle_thread := 1;
           --
           -- Check that we have running tasks.
           -- If we have waiting tasks and no running tasks then we must have a dependency loop
           -- So tell them about it and abort.
           IF  v_task_count = 1
           AND v_running_count = 0 THEN
             IF v_depend_loop = 1 THEN
               v_task_count := 0; -- force a break out of the loop
             ELSE
               v_depend_loop := 1; -- set dependency flag so we break out next time through
             END IF;
           ELSIF v_running_count > 0 THEN -- running tasks so no loop yet
             v_depend_loop := 0; -- clear any dependency loop as nothing waiting
           ELSIF v_task_count = 0 THEN -- no Waiting Tasks so no loop. will exit
             v_depend_loop := 0; -- clear any dependency loop as nothing waiting
           END IF;
        End If; -- End of Processing of a task

        -- If just processed then sleep for 2 seconds and look for next task
        If v_just_done = 0 Then
            DBMS_LOCK.SLEEP(2);
        End If;

        -- If the thread is idle then sleep for 30 seconds.
        If v_idle_thread = 1 And v_running_count > 0 Then
--            DBMS_LOCK.SLEEP(30);
            DBMS_LOCK.SLEEP(v_idle_thread_wait);
        End If;

    END LOOP; -- End of While More tasks Loop

    v_step := 6700;

--    DBMS_SQL.CLOSE_CURSOR(v_cursor);

   --=====================================================
    --      A L L      T A S K S      D O N E
    --=====================================================
    --=====================================================
    -- Here if no more waiting tasks. If no more running tasks
    -- then all threads are finished, so update the job_run
    -- record to a completed state
    -- WMR Need to update the ctrl record and move the run records to the log tables. WMR
    --=====================================================
    po_action_key := 0;
    po_action_msg := NULL;
    po_result_code := 1;
    v_step := 6800;
    If v_running_count = 0 Then

      v_okay := 0;

      -- work out what the return will be
      If v_halted_count = 0 AND v_failed_count = 0 AND v_depend_loop = 0 Then
           v_job_status := 'C';
           v_audit_status := 'S';
           v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                  ' Completed. ';
           BEGIN
              Select wjr_publish_okay into v_OkayMsg
              From ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              v_FailMsg := NULL;
           EXCEPTION WHEN OTHERS THEN
              v_OkayMsg := NULL;
              v_FailMsg := NULL;
           END;
      Else
           If v_depend_loop = 1 AND v_failed_count = 0 THEN
             po_result_code := -2;
             v_job_status := 'F';
             v_audit_status := 'F';
             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                    ' CANNOT COMPLETE. Possible task dependency loop. ';
             BEGIN
                Select wjr_publish_fail into v_FailMsg
                From ws_wrk_job_run
                where wjr_job_key = p_job_id
                and wjr_sequence = pi_sequence;
                v_OkayMsg := NULL;
             EXCEPTION WHEN OTHERS THEN
                v_OkayMsg := NULL;
                v_FailMsg := NULL;
             END;
           ELSE
             po_result_code := -2;
             v_job_status := 'F';
             v_audit_status := 'F';
             v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                    ' FAILED. ';
             BEGIN
                Select wjr_publish_fail into v_FailMsg
                From ws_wrk_job_run
                where wjr_job_key = p_job_id
                and wjr_sequence = pi_sequence;
                v_OkayMsg := NULL;
             EXCEPTION WHEN OTHERS THEN
                v_OkayMsg := NULL;
                v_FailMsg := NULL;
             END;
           END IF;
      End If;

      --=====================================================
      -- All tasks done
      -- Set the job status on the run record and job finish time
      -- Need to lock the record first to prevent another thread from
      -- grabbing it, or in case another thread has already got it,
      -- or updated it
      --=====================================================
     v_step := 6900;
     BEGIN
        select wjr_status into v_run_status
        from ws_wrk_job_run
        where wjr_job_key = p_job_id
        and wjr_sequence = pi_sequence
        for update nowait;
        If v_run_status = 'R' Then
           update ws_wrk_job_run
           set wjr_status = v_job_status,
                 wjr_elapsed_hh =  trunc(to_number(sysdate-wjr_started)*24,0),
                 wjr_elapsed_mi = round(to_number(sysdate-wjr_started)*24*60,0) - (
                                                         trunc(to_number(sysdate-wjr_started)*24,0)*60),
                wjr_completed = sysdate
           where wjr_job_key = p_job_id
           and wjr_sequence = pi_sequence;
           v_okay := 1;
        Else
            -- someone else got the record
            v_okay := 0;
         End If;
     EXCEPTION WHEN OTHERS THEN
        -- If a resource busy someone else has the record
        -- so skip it
        -- If a no data found then the run record has already been
        -- changed to log so all okay
        If SQLCODE = -54 Then
            v_okay := 0;
        ElsIf SQLCODE = 100 Then
            v_okay := 0;
        Else
            v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                            ' failed to change state to completed '||
                                            'in ws_wrk_job_run.!!!';
            v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            po_result_code := -2;
            RETURN;
         End If;
     END;
     COMMIT;

     -- if we are the thread doing the update then
     -- write to the audit trail and complete the cleanup
     If v_okay = 1 Then

       If v_OkayMsg is not Null Then
           po_action_key := 1;
           po_action_msg := v_OkayMsg;
       End If;
       If v_FailMsg is not Null Then
           po_action_key := 2;
           po_action_msg := v_FailMsg;
       End If;

       -- substitute any variables.
       IF po_action_msg IS NOT NULL THEN
         po_action_msg := REPLACE(po_action_msg,'$JOB_KEY$',NVL(v_audit_job_id,0));
         po_action_msg := REPLACE(po_action_msg,'$JOB_SEQ$',NVL(pi_sequence,0));
         po_action_msg := REPLACE(po_action_msg,'$JOB_THREAD$',NVL(pi_thread,-1));
         po_action_msg := REPLACE(po_action_msg,'$JOB_NAME$',RTRIM(v_audit_job_name));
       END IF;

       --
       -- replace any DSS parameters with their current values
       --

       v_spos := INSTR(po_action_msg,'$P');
       WHILE  v_spos > 0 LOOP
         v_spos := INSTR(po_action_msg,'$P');
         If v_spos > 0 Then
           v_epos := INSTR(po_action_msg,'$',v_spos+2);
           If v_epos = 0 Then
             v_spos := 0;
           Else
             v_work := SUBSTR(po_action_msg,v_spos+2,v_epos-v_spos-2);
             v_parameter := WsParameterRead(v_work);
             v_work := SUBSTR(po_action_msg,v_spos,v_epos-v_spos+1);
             po_action_msg := REPLACE(po_action_msg,v_work,v_parameter);
           End If;
         End If;
       END LOOP;

       v_result := WsWrkAudit(v_audit_status,v_audit_job_name,v_audit_task_name, pi_sequence,
                                                v_MsgText,NULL,NULL,v_audit_task_id,v_audit_job_id);

       -- Set the job status on the control record for the job and finish time.
       -- WMR need to set the status to HOLD or Waiting depending on if another run.
       v_step := 7000;
       BEGIN
           update ws_wrk_job_ctrl
           set wjc_last_status = v_job_status,
                wjc_completed = sysdate
           where wjc_job_key = p_job_id;
       EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Job '||pi_job_name||' sequence '||pi_sequence||
                                            ' failed to change completed time for job '||
                                            'in ws_wrk_job_ctrl.!!!';
            v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                    v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
            po_result_code := -2;
            RETURN;
       END;
       -- 5.1.0.1 commit removed to make full transaction
       --COMMIT;

       v_step := 7100;
       If v_job_status = 'C' Then
         -- Move the job run record to the log record
         v_step := 7200;
         BEGIN
              insert into ws_wrk_job_log
              select * from ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;
              IF v_child_job = 1 THEN
                DELETE FROM ws_wrk_job_log
                WHERE wjl_job_key = p_job_id
                AND wjl_sequence = pi_sequence;
                -- 5.1.0.1 commit removed to make full transaction
                --COMMIT;
              END IF;
              delete from ws_wrk_job_run
              where wjr_job_key = p_job_id
              and wjr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;
         EXCEPTION WHEN OTHERS THEN
              v_MsgText := 'Job '||pi_job_name||' failed in xfer to ws_wrk_job_log. '||
                                               ' No Action !!!';
              v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
              po_result_code := -2;
              RETURN;
         END;

         -- Move the task run records to the log record
         v_step := 7300;
         BEGIN
              insert into ws_wrk_task_log
              select * from ws_wrk_task_run
              where wtr_job_key = p_job_id
              and wtr_sequence = pi_sequence;
              -- 5.1.0.1 commit removed to make full transaction
              --COMMIT;
              IF v_child_job = 1 THEN
                UPDATE ws_wrk_task_log
                SET wtl_job_key = v_audit_job_id
                WHERE wtl_job_key = p_job_id
                AND wtl_sequence = pi_sequence;
                -- 5.1.0.1 commit removed to make full transaction
                --COMMIT;
              END IF;
              v_step := 7400;
  	           delete from ws_wrk_task_run
              where wtr_job_key = p_job_id
              and wtr_sequence = pi_sequence;
              COMMIT;
         EXCEPTION WHEN OTHERS THEN
              v_MsgText := 'Job '||pi_job_name||' failed in xfer of tasks to ws_wrk_task_log. '||
                                               ' No Action !!!';
             v_result := WsWrkAudit('F',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                       v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
             po_result_code := -2;
             RETURN;
         END;
       End If;

       -- If this job has a blocked iteration waiting then release it
       v_step := 7500;
       BEGIN
            update ws_wrk_job_ctrl
                set wjc_status = 'W'
                where wjc_job_key = p_job_id
                and wjc_status = 'B';
            COMMIT;
       EXCEPTION WHEN OTHERS THEN
            v_MsgText := 'Job '||pi_job_name||' failed to release blocked job. '||
                                             ' No Action !!!';
            v_result := WsWrkAudit('W',v_audit_job_name,v_audit_task_name, pi_sequence,
                                                     v_MsgText,SQLCODE,SQLERRM,v_audit_task_id,v_audit_job_id);
       END;

     End If; -- end of final thread

    End If; -- end of running count 0

    --=====================================================
    -- Remove this thread as being active
    --=====================================================
    v_step := 7600;
    BEGIN
        IF p_job_id > 0 And v_sid <> 0 Then
            Delete from ws_wrk_job_thread
            Where wjt_job_key = p_job_id
            And wjt_thread = pi_thread
            And wjt_sequence = pi_sequence
            And wjt_sid = v_sid
            And wjt_serial = v_serial;
        End If;
       COMMIT;
    EXCEPTION WHEN OTHERS THEN
           v_MsgText := 'Job '||pi_job_name||' unable to record thread in ws_wrk_job_thread ';
    END;

   v_step := 7700;
   COMMIT;

    -- If the master job then set the result code to 1 to indicate that the job completed okay
    -- even if it may have failed.
    IF v_child_job = 0 THEN
      po_result_code := 1;
    END IF;


   RETURN;

EXCEPTION
  WHEN OTHERS THEN
    v_MsgText := 'Unhandled Exception in ws_job_exec_411 '|| v_ws_pro_version ||
                ' Step ' ||v_step;
    v_result := WsWrkAudit('F', v_audit_job_name,v_audit_task_name, pi_sequence,
                          v_MsgText,SQLCODE, SQLERRM, v_audit_task_id,v_audit_job_id);
   po_result_code := -3;
   RETURN;
END ws_job_exec_411;
 
_PROCEDURE_ Ws_Rep_Diagram_Build 
CREATE OR REPLACE PROCEDURE ws_rep_diagram_build
( p_top_table_name         ws_rep_v_track_back.rb_table_name%TYPE
, p_diagram_type           ws_rep_diagram.rd_diagram_type%TYPE
, p_user_key               integer
)
IS
  v_index                  INTEGER := 0;
  v_level                  INTEGER := 0;
  v_max_level              INTEGER := 0;
  i                        INTEGER;
  v_return                 INTEGER;
  v_obj_key                INTEGER;
  v_counter                INTEGER := 0;
  v_src_loop_flag          VARCHAR2(1);

  TYPE t_sources_tab IS TABLE OF ws_rep_v_track_back.rb_src_table%TYPE;
  TYPE t_sources_src IS TABLE OF ws_rep_v_track_back.rb_src_table%TYPE;
  TYPE t_sources_lev IS TABLE OF NUMBER;
  TYPE t_sources_rmf IS TABLE OF ws_rep_v_track_back.rb_remote_flag%TYPE;
  TYPE t_sources_cnt IS TABLE OF NUMBER;

  v_sources_tab            t_sources_tab;
  v_sources_src            t_sources_src;
  v_sources_lev            t_sources_lev;
  v_sources_rmf            t_sources_rmf;
  v_sources_cnt            t_sources_cnt;

  FUNCTION ws_rep_diagram_build_source
  ( p_table_name           ws_rep_v_track_back.rb_table_name%TYPE)
  RETURN NUMBER
  IS

    i                      INTEGER;
    j                      INTEGER;
    v_local_return         INTEGER;
    v_return_code          INTEGER;
    v_found                BOOLEAN;
    v_sources_tab_tmp      t_sources_tab;
    v_sources_src_tmp      t_sources_src;
    v_sources_lev_tmp      t_sources_lev;
    v_sources_rmf_tmp      t_sources_rmf;

    CURSOR c_sources IS
    SELECT rb_table_name
         , rb_src_table
         , v_level
         , rb_remote_flag
    FROM   ws_rep_v_track_back
    WHERE  rb_table_name = p_table_name;

  BEGIN

    v_level := v_level + 1;

    IF (v_level > v_max_level) THEN
      v_max_level := v_level;
    END IF;

    OPEN  c_sources;

    FETCH c_sources BULK COLLECT INTO v_sources_tab_tmp
                                    , v_sources_src_tmp
                                    , v_sources_lev_tmp
                                    , v_sources_rmf_tmp;

    IF (c_sources%ROWCOUNT <= 0) THEN

      v_return_code := 1;

    ELSE

      FOR i IN v_sources_tab_tmp.FIRST..v_sources_tab_tmp.LAST LOOP

        v_sources_tab.EXTEND;
        v_sources_src.EXTEND;
        v_sources_lev.EXTEND;
        v_sources_rmf.EXTEND;
        v_sources_cnt.EXTEND;

        v_index := v_index + 1;
        v_counter := v_counter + 1;

        v_sources_tab(v_index) := v_sources_tab_tmp(i);
        v_sources_src(v_index) := v_sources_src_tmp(i);
        v_sources_lev(v_index) := v_sources_lev_tmp(i);
        v_sources_rmf(v_index) := v_sources_rmf_tmp(i);
        v_sources_cnt(v_index) := v_counter;

        v_found := FALSE;

        FOR j IN 1..v_index LOOP

          IF (v_sources_tab(j) = v_sources_src_tmp(i)) AND (v_sources_lev(j) <> 1) THEN

            v_found := TRUE;

            IF (v_level+1 > v_sources_lev(j)) THEN
              v_sources_lev(j) := v_level+1;
            END IF;

          END IF;

        END LOOP;

        IF NOT v_found AND (v_sources_src(i) <> p_top_table_name) THEN
          v_local_return := ws_rep_diagram_build_source(v_sources_src(v_index));
        END IF;

      END LOOP;

      v_return_code := 0;

    END IF;

    CLOSE c_sources;

    v_level := v_level - 1;

    RETURN v_return_code;

  END;

BEGIN

  IF (p_diagram_type = 2) THEN

    SELECT MAX(oo_obj_key)
    INTO   v_obj_key
    FROM   ws_obj_object
    WHERE  oo_name = p_top_table_name;

    DELETE ws_rep_diagram
    WHERE  rd_diagram_type = p_diagram_type
    AND    rd_user_key = p_user_key;

    v_sources_tab := t_sources_tab(NULL);
    v_sources_src := t_sources_src(NULL);
    v_sources_lev := t_sources_lev(NULL);
    v_sources_rmf := t_sources_rmf(NULL);
    v_sources_cnt := t_sources_cnt(NULL);

    v_return := ws_rep_diagram_build_source(p_top_table_name);

    FOR i IN 1..v_index LOOP

      IF (v_sources_rmf(i) = 'Y') THEN

        v_sources_lev(i) := v_max_level;
        v_counter := v_counter + 1;

        INSERT INTO ws_rep_diagram
        ( rd_diagram_type
        , rd_obj_key
        , rd_table_name
        , rd_src_table
        , rd_level_no
        , rd_remote_flag
        , rd_record_no
        , rd_src_loop_flag
        , rd_user_key)
        VALUES
        ( p_diagram_type
        , v_obj_key
        , v_sources_src(i)
        , NULL
        , v_max_level + 1
        , 'S'
        , v_counter
        , 'N'
        , p_user_key);

      END IF;

      IF ( v_sources_lev(i) > 1 ) AND (v_sources_tab(i) = p_top_table_name) THEN
        v_src_loop_flag := 'Y';
      ELSE
        v_src_loop_flag := 'N';
      END IF;

      INSERT INTO ws_rep_diagram
      ( rd_diagram_type
      , rd_obj_key
      , rd_table_name
      , rd_src_table
      , rd_level_no
      , rd_remote_flag
      , rd_record_no
      , rd_src_loop_flag
      , rd_user_key
      )
      VALUES
      ( p_diagram_type
      , v_obj_key
      , v_sources_tab(i)
      , v_sources_src(i)
      , v_sources_lev(i)
      , v_sources_rmf(i)
      , v_sources_cnt(i)
      , v_src_loop_flag
      , p_user_key);

    END LOOP;

  END IF;

END;

 
_PROCEDURE_ Ws_Connect_Replace 
-- Notes / History
--
-- WMR 07/01/2006   Version 5.0.0.2
-- RS  11/06/2014   Version 6.8.0.1 Changed to support new column dc_authentication
-- AD  24/04/2018   Version 8.2.1.0 Fix not updating Database Type in target connection
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_connect_replace
  (
  p_sequence    IN  number,
  p_job_name    IN  varchar2,
  p_task_name   IN  varchar2,
  p_job_id      IN  number,
  p_task_id     IN  number,
  p_action      IN  varchar2,
  p_source      IN  varchar2,
  p_target      IN  varchar2,
  p_return_code OUT varchar2,
  p_return_msg  OUT varchar2
  )
  Return integer
  AUTHID CURRENT_USER
  IS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      :    Oracle
  -- Script Name    :    ws_connect_replace
  -- Description    :    Copies the contents of one connection to another
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  v_MsgText         varchar2(1024); -- Text in audit_trail
  v_step            integer := 0;   -- return code
  v_result          integer := 0;   -- return code
  v_ConRec          ws_dbc_connect%ROWTYPE;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  v_step := 100;
  IF UPPER(p_action) = 'REPLACE' THEN
    v_step := 101;
  ELSE
    p_return_code := 'E';
    p_return_msg := 'Invalid action code in Ws_Connect_Replace. Valid actions are Replace.';
    v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
      p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
    RETURN -2;
  END IF;

  --***********************************************************************
  -- Get the info for the source connection
  --***********************************************************************
  v_step := 200;
  BEGIN
    SELECT *
    INTO  v_ConRec
    FROM  ws_dbc_connect
    WHERE UPPER(dc_name) = UPPER(p_source);

  EXCEPTION WHEN OTHERS THEN
      p_return_code := 'E';
      v_MsgText := 'Failed to get info for source connection '||p_source||' '||SQLERRM;
      p_return_msg := substr(v_MsgText,1,1023);
      v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
        p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
      RETURN -2;
  END;


  IF v_ConRec.dc_obj_key <= 0 THEN
    p_return_code := 'E';
    p_return_msg := 'Failed to find source connection '||p_source;
    v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
      p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
    RETURN -2;
  END IF;

  --***********************************************************************
  -- Update the target connection
  --***********************************************************************
  v_step := 300;
  BEGIN

    UPDATE ws_dbc_connect
    SET
      dc_type = v_ConRec.dc_type
    , dc_method = v_ConRec.dc_method
    , dc_host_id = v_ConRec.dc_host_id
    , dc_dblink_id = v_ConRec.dc_dblink_id
    , dc_database_id = v_ConRec.dc_database_id
    , dc_odbc_source = v_ConRec.dc_odbc_source
    , dc_extract_userid = v_ConRec.dc_extract_userid
    , dc_extract_pwd = v_ConRec.dc_extract_pwd
    , dc_admin_userid = v_ConRec.dc_admin_userid
    , dc_admin_pwd = v_ConRec.dc_admin_pwd
    , dc_work_dir = v_ConRec.dc_work_dir
    , dc_database_home = v_ConRec.dc_database_home
    , dc_pre_login_act = v_ConRec.dc_pre_login_act
    , dc_login_prompt = v_ConRec.dc_login_prompt
    , dc_password_prompt = v_ConRec.dc_password_prompt
    , dc_post_login_act = v_ConRec.dc_post_login_act
    , dc_command_prompt = v_ConRec.dc_command_prompt
    , dc_telnet_attributes = v_ConRec.dc_telnet_attributes
    , dc_attributes = v_ConRec.dc_attributes
    , dc_connect_string = v_ConRec.dc_connect_string
    , dc_server = v_ConRec.dc_server
    , dc_doc_1 = v_ConRec.dc_doc_1
    , dc_doc_2 = v_ConRec.dc_doc_2
    , dc_doc_3 = v_ConRec.dc_doc_3
    , dc_doc_4 = v_ConRec.dc_doc_4
    , dc_doc_5 = v_ConRec.dc_doc_5
    , dc_doc_6 = v_ConRec.dc_doc_6
    , dc_doc_7 = v_ConRec.dc_doc_7
    , dc_doc_8 = v_ConRec.dc_doc_8
    , dc_doc_9 = v_ConRec.dc_doc_9
    , dc_doc_10 = v_ConRec.dc_doc_10
    , dc_doc_11 = v_ConRec.dc_doc_11
    , dc_doc_12 = v_ConRec.dc_doc_12
    , dc_doc_13 = v_ConRec.dc_doc_13
    , dc_doc_14 = v_ConRec.dc_doc_14
    , dc_doc_15 = v_ConRec.dc_doc_15
    , dc_doc_16 = v_ConRec.dc_doc_16
    , dc_wizard_set_key = v_ConRec.dc_wizard_set_key
    , dc_db_type_ind = v_ConRec.dc_db_type_ind
    , dc_authentication = v_ConRec.dc_authentication
    WHERE UPPER(dc_name) = UPPER(p_target);
  EXCEPTION WHEN OTHERS THEN
      p_return_code := 'E';
      v_MsgText := 'Failed to update connection '||p_target||' '||SQLERRM;
      p_return_msg := substr(v_MsgText ,1,1023);
      v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
        p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
      RETURN -2;
  END;

  COMMIT;

  p_return_code := 'S';
  p_return_msg := 'Connection information for '||p_target|| ' replaced from '||p_source;
  v_result := WsWrkAudit('I', p_job_name, p_job_name, p_sequence,
    p_return_msg,NULL,NULL, p_task_id, p_job_id);

  RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    p_return_code := 'F';
    v_MsgText := 'Unhandled Exception in Ws_Connect_Replace. '||
            ' Step ' ||v_step;
    v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
    p_return_msg := substr(v_MsgText,1,1023);
    RETURN -3;

END ws_connect_replace;
 
_PROCEDURE_ Ws_Job_Clear_Logs_by_Date 
-- Notes / History
--
-- WMR 13/03/2005   Version 5.0.1.4
-- NRB 24/07/2007   Version 5.6.1.1 Modified to include archiving records from audit
--                                  and error tables that have no entry in job log.
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.
--

CREATE OR REPLACE function ws_job_clear_logs_by_date
    (
    p_sequence     IN  number,
    p_job_name     IN  varchar2,
    p_task_name    IN  varchar2,
    p_job_id       IN  number,
    p_task_id      IN  number,
    p_job_to_clean IN  varchar2,
    p_day_count     IN  number,
    p_return_code  OUT varchar2,
    p_return_msg   OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name 	      :	Oracle
    -- Script Name 		:	ws_job_clear_logs_by_date
    -- Description 		:	Removes a set number of days logs
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_job_sequence    integer;
    v_job_key         integer;
    v_job_status      varchar2(1);
    v_job_count       integer := 0;
    v_del_count       integer := 0;
    v_job_status      varchar2(1);
    v_delete_date     date;          -- delete date

    --=====================================================
    -- Cursor for all job logs
    --=====================================================
    Cursor c_Logs is
          Select wjl_job_key, wjl_sequence
          from ws_wrk_job_log
          Where wjl_name like p_job_to_clean
          And wjl_completed < v_delete_date;


-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

  v_step := 10;
  -- If zero days specified in logs to keep then return
  If p_day_count < 0 Then
    p_return_code := 'W';
    p_return_msg := 'Job '|| p_job_to_clean ||' negative value passed in retain days value. No action.';
    RETURN 1;
  End If;

  -- set delete date
  v_delete_date := sysdate - p_day_count;

  --***********************************************************************
  -- Loop through all the logs in descending order skip over the first
  -- n that are to be kept
  --***********************************************************************
  FOR v_LogRec in c_Logs LOOP

    v_job_count := v_job_count + 1;

    -- Have a log to delete so move the tasks, job, audit and error info

    -- Copy the audit info to archive
    INSERT INTO wx_wrk_audit_archive (
      wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
      wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
    SELECT
      wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
      wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
    FROM
      ws_wrk_audit_log
    WHERE wa_job_key = v_LogRec.wjl_job_key
    AND   wa_sequence = v_LogRec.wjl_sequence;


    -- Delete the audit info
    DELETE FROM ws_wrk_audit_log
    WHERE wa_job_key = v_LogRec.wjl_job_key
    AND   wa_sequence = v_LogRec.wjl_sequence;

    -- Copy the detail info to archive
    INSERT INTO wx_wrk_error_archive (
      wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
      wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
      wd_severity, wd_action )
    SELECT
      wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
      wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
      wd_severity, wd_action
    FROM
      ws_wrk_error_log
    WHERE wd_job_key = v_LogRec.wjl_job_key
    AND   wd_sequence = v_LogRec.wjl_sequence;

    v_del_count := v_del_count + 1;

    -- Delete the detail info
    DELETE FROM ws_wrk_error_log
    WHERE wd_job_key = v_LogRec.wjl_job_key
    AND   wd_sequence = v_LogRec.wjl_sequence;

    -- Delete the task log
    DELETE FROM ws_wrk_task_log
    WHERE wtl_job_key = v_LogRec.wjl_job_key
    AND   wtl_sequence = v_LogRec.wjl_sequence;

    -- Delete the job log
    DELETE FROM ws_wrk_job_log
    WHERE wjl_job_key = v_LogRec.wjl_job_key
    AND   wjl_sequence = v_LogRec.wjl_sequence;


  END LOOP;

  COMMIT;

  --***********************************************************************
  -- Archive Detail and audit info for records with no parent in job log
  --***********************************************************************
  -- Copy the audit info to archive
  INSERT INTO wx_wrk_audit_archive (
    wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
    wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number )
  SELECT
    wa_time_stamp, wa_sequence, wa_job, wa_task, wa_status, wa_message,
    wa_db_msg_code, wa_db_msg_desc, wa_task_key, wa_job_key, wa_row_number
  FROM
    ws_wrk_audit_log
  WHERE wa_time_stamp < v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_audit_log.wa_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_audit_log.wa_sequence = ws_wrk_job_log.wjl_sequence);


  -- Delete the audit info
  DELETE FROM ws_wrk_audit_log
  WHERE wa_time_stamp < v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_audit_log.wa_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_audit_log.wa_sequence = ws_wrk_job_log.wjl_sequence);

  -- Copy the detail info to archive
  INSERT INTO wx_wrk_error_archive (
    wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
    wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
    wd_severity, wd_action )
  SELECT
    wd_time_stamp, wd_sequence, wd_job, wd_task, wd_status, wd_message,
    wd_db_msg_code, wd_db_msg_desc, wd_task_key, wd_job_key, wd_row_number,
    wd_severity, wd_action
  FROM
    ws_wrk_error_log
  WHERE wd_time_stamp < v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_error_log.wd_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_error_log.wd_sequence = ws_wrk_job_log.wjl_sequence);

  -- Delete the detail info
  DELETE FROM ws_wrk_error_log
  WHERE wd_time_stamp < v_delete_date
  AND NOT EXISTS (SELECT 1
                    FROM ws_wrk_job_log
                    WHERE ws_wrk_error_log.wd_job_key = ws_wrk_job_log.wjl_job_key
                    AND   ws_wrk_error_log.wd_sequence = ws_wrk_job_log.wjl_sequence);


  p_return_code := 'S';
  p_return_msg := 'Job ' || p_job_to_clean || ' had ' ||
                     v_del_count || ' logs removed. ';

  RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'W';
        v_MsgText := 'Unhandled Exception in ws_job_clear_logs_by_date. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_clear_logs_by_date;
 
_PROCEDURE_ Ws_Job_Dependency 
-- Notes / History
--
-- WMR 02/11/2006   Version 5.5.0.6
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_dependency
  (
  p_sequence    IN  number,
  p_job_name    IN  varchar2,
  p_task_name   IN  varchar2,
  p_job_id      IN  number,
  p_task_id     IN  number,
  p_action      IN  varchar2,
  p_parent      IN  varchar2,
  p_child       IN  varchar2,
  p_required    IN  varchar2,
  p_look_back   IN  integer,
  p_max_wait    IN  integer,
  p_return_code OUT varchar2,
  p_return_msg  OUT varchar2
  )
  Return integer
  AUTHID CURRENT_USER
  IS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           :    Oracle
  -- Script Name         :    ws_job_dependency
  -- Description         :    Maintain job dependencies
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  v_MsgText         varchar2(1024); -- Text in audit_trail
  v_step            integer := 0;   -- return code
  v_result          integer := 0;   -- return code
  v_msg             varchar2(4000);
  v_action          integer := 0;
  v_existing        integer := 0;

BEGIN

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  v_step := 100;
  IF UPPER(p_action) = 'ADD' THEN
    v_action := 1;
  ELSIF UPPER(p_action) = 'DELETE' THEN
    v_action := 2;
  ELSE
    p_return_code := 'E';
    p_return_msg := 'Invalid action code. Valid actions are ADD and DELETE.';
    v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
      p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
    RETURN -2;
  END IF;

  --***********************************************************************
  -- Check to see if the entry is present
  --***********************************************************************
  v_step := 200;
  BEGIN
    v_existing := 0;
    SELECT
      COUNT(*)
    INTO
      v_existing
    FROM
      ws_wrk_job_dependency
    WHERE
      wjd_parent_job_name = p_parent
    AND
      wjd_child_job_name = p_child;
  EXCEPTION WHEN OTHERS THEN
    v_existing := 0;
  END;

  --***********************************************************************
  -- If an Add then add a new record if not already present
  --***********************************************************************
  v_step := 300;
  IF v_action = 1 THEN
    BEGIN
      IF v_existing = 1 THEN
        p_return_code := 'W';
        p_return_msg := 'Job Dependency already exists. Can not add.';
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
          p_return_msg,NULL,NULL, p_task_id, p_job_id);
        RETURN -1;
      END IF;

      INSERT INTO ws_wrk_job_dependency(
        wjd_sequence
      , wjd_parent_job_name
      , wjd_child_job_name
      , wjd_first_check_lag
      , wjd_wait_interval
      , wjd_require_parent
      ) VALUES (
        ws_wrk_job_dependency_seq.NEXTVAL
      , p_parent
      , p_child
      , p_look_back
      , p_max_wait
      , p_required
      );
    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to insert entry into job dependency table. '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        v_result := WsWrkAudit('E', p_job_name, p_job_name, p_sequence,
          p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
        RETURN -2;
    END;
  END IF;

  --***********************************************************************
  -- If a Delete then delete the record if present
  --***********************************************************************
  v_step := 400;
  IF v_action = 2 THEN
    BEGIN
      IF v_existing = 0 THEN
        p_return_code := 'W';
        p_return_msg := 'Job Dependency does not exist. Can not delete.';
        v_result := WsWrkAudit('W', p_job_name, p_job_name, p_sequence,
          p_return_msg,NULL,NULL, p_task_id, p_job_id);
        RETURN -1;
      END IF;

      DELETE FROM ws_wrk_job_dependency
      WHERE wjd_parent_job_name = p_parent
      AND   wjd_child_job_name = p_child;
    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to delete entry from job dependency table. '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        v_result := WsWrkAudit('E', p_job_name, p_job_name, p_sequence,
          p_return_msg,SQLCODE,SQLERRM, p_task_id, p_job_id);
        RETURN -2;
    END;
  END IF;

  COMMIT;

  p_return_code := 'S';
  p_return_msg := 'Job '||p_child||' dependent on Job '||p_parent||' '||p_action||'ed';
  v_result := WsWrkAudit('I', p_job_name, p_job_name, p_sequence,
    p_return_msg,NULL,NULL, p_task_id, p_job_id);

  RETURN 1;

EXCEPTION
  WHEN OTHERS THEN
    p_return_code := 'F';
    v_MsgText := 'Unhandled Exception in ws_job_dependency. '||
            ' Step ' ||v_step;
    v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                      v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
    p_return_msg := substr(v_MsgText,1,1023);
    RETURN -3;

END ws_job_dependency;

 
_PROCEDURE_ Ws_Job_CreateWait 
-- Notes / History
--
-- WMR 01/11/2006   Version 5.5.0.6
-- KH   1/11/2018   Version 8.3.1.0 RED-9838 wtc_action_ind added to task copy row.
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function ws_job_createwait
    (
    p_sequence        IN  number,
    p_job_name        IN  varchar2,
    p_task_name       IN  varchar2,
    p_job_id          IN  number,
    p_task_id         IN  number,
    p_template_job    IN  varchar2,
    p_new_job         IN  varchar2,
    p_description     IN  varchar2,
    p_state           IN  varchar2,
    p_release_time    IN  date,
    p_threads         IN  number,
    p_scheduler       IN  varchar2,
    p_logs            IN  number,
    p_okay            IN  varchar2,
    p_fail            IN  varchar2,
    p_att1            IN  varchar2,
    p_att2            IN  varchar2,
    p_att3            IN  varchar2,
    p_att4            IN  varchar2,
    p_att5            IN  varchar2,
    p_att6            IN  varchar2,
    p_att7            IN  varchar2,
    p_att8            IN  varchar2,
    p_return_code     OUT varchar2,
    p_return_msg      OUT varchar2
    )
    Return integer
    AUTHID CURRENT_USER
    IS

    -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

    -- =============================================================================
    -- DBMS Name           :    Oracle
    -- Script Name         :    ws_job_createwait
    -- Description         :    Creates a new job at a scheduled time
    -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
    -- =============================================================================

    --=====================================================
    -- Variables
    --=====================================================
    v_MsgText         varchar2(1024); -- Text in audit_trail
    v_step            integer := 0;   -- return code
    v_result          integer := 0;   -- return code
    v_count           integer := 0;
    v_part_count      integer := 0;
    v_specific_index  integer := 0;
    v_specific_part   integer := 0;
    v_status          number := 0;
    v_status_code     number := 0;
    v_msg             varchar2(4000);
    v_old_key         integer;
    v_old_sequence    integer;
    v_old_status      varchar2(1);
    v_new_key         integer;
    v_new_sequence    integer;
    v_wjc_status      varchar2(1);
    v_wjc_type        varchar2(1);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN

    v_step := 10;
    --***********************************************************************
    -- First see if the job name specified is in a held or waiting state
    -- If not in a held or waiting state report and exit
    --***********************************************************************
    BEGIN
        Select wjc_job_key, wjc_sequence, wjc_status
        Into v_old_key, v_old_sequence, v_old_status
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_template_job));
    EXCEPTION WHEN OTHERS THEN
        v_old_key := 0;
    END;

    v_step := 20;
    --***********************************************************************
    -- If not scheduled exit with that information
    --***********************************************************************
    If nvl(v_old_key,0) = 0 Then
        p_return_msg := 'Job '||p_template_job||' is not in a holding or waiting state. Cannot create new job';
        p_return_code := 'N';
        return -1;
    End If;

    v_step := 30;
    --***********************************************************************
    -- Make sure we have no job that matches our new job name
    --***********************************************************************
    BEGIN
        Select count(*)
        Into v_count
        From ws_wrk_job_ctrl
        Where rtrim(upper(wjc_name)) = rtrim(upper(p_new_job));
    EXCEPTION WHEN OTHERS THEN
        v_count := 1;
    END;

    IF v_count > 0 THEN
        p_return_msg := 'Job '||p_new_job||' already exists. Cannot create a new job of the same name';
        p_return_code := 'P';
        return -1;
    END IF;

    v_step := 60;
    --***********************************************************************
    -- Get the right state for the new job and the sequence
    --***********************************************************************
    IF rtrim(upper(p_state)) = 'ONCE' THEN
      v_wjc_status := 'W';
      v_wjc_type := 'O';
    ELSIF rtrim(upper(p_state)) = 'ONCE+HOLD' THEN
      v_wjc_status := 'W';
      v_wjc_type := 'S';
    ELSE
      v_wjc_status := 'H';
      v_wjc_type := 'H';
    END IF;


    v_step := 62;
    SELECT ws_job_seq.nextval INTO v_new_sequence FROM dual;


    v_step := 70;
    --***********************************************************************
    -- Add the new job in a held state, so that we can add the tasks/dependencies
    --***********************************************************************
    BEGIN
        INSERT into ws_wrk_job_ctrl
        (
          wjc_job_key
        , wjc_name
        , wjc_description
        , wjc_sequence
        , wjc_group_key
        , wjc_project_key
        , wjc_status
        , wjc_last_status
        , wjc_type
        , wjc_submitted
        , wjc_first_schedule
        , wjc_start_hour
        , wjc_start_minute
        , wjc_start_day
        , wjc_user_key
        , wjc_start_after
        , wjc_started
        , wjc_completed
        , wjc_max_elapsed
        , wjc_task_elapsed
        , wjc_avg_elapsed
        , wjc_avg_count
        , wjc_publish_okay
        , wjc_publish_fail
        , wjc_task_fatal
        , wjc_task_error
        , wjc_task_warning
        , wjc_task_info
        , wjc_task_okay
        , wjc_chkp_count
        , wjc_max_threads
        , wjc_priority
        , wjc_publish_flag
        , wjc_scheduler
        , wjc_cust_sa_hh
        , wjc_cust_sa_mm
        , wjc_cust_sb_hh
        , wjc_cust_sb_mm
        , wjc_cust_min
        , wjc_cust_days
        )
        SELECT
          v_new_sequence
        , p_new_job
        , NVL(p_description,wjc_description)
        , v_new_sequence
        , wjc_group_key
        , wjc_project_key
        , 'H'
        , wjc_last_status
        , v_wjc_type
        , wjc_submitted
        , wjc_first_schedule
        , wjc_start_hour
        , wjc_start_minute
        , wjc_start_day
        , wjc_user_key
        , p_release_time
        , wjc_started
        , wjc_completed
        , wjc_max_elapsed
        , wjc_task_elapsed
        , wjc_avg_elapsed
        , NVL(p_logs,wjc_avg_count)
        , NVL(p_okay,wjc_publish_okay)
        , NVL(p_fail,wjc_publish_fail)
        , wjc_task_fatal
        , wjc_task_error
        , wjc_task_warning
        , wjc_task_info
        , wjc_task_okay
        , wjc_chkp_count
        , NVL(p_threads,wjc_max_threads)
        , wjc_priority
        , wjc_publish_flag
        , NVL(p_scheduler,wjc_scheduler)
        , wjc_cust_sa_hh
        , wjc_cust_sa_mm
        , wjc_cust_sb_hh
        , wjc_cust_sb_mm
        , wjc_cust_min
        , wjc_cust_days
        FROM ws_wrk_job_ctrl
        Where wjc_job_key = v_old_key
        And wjc_status in ('H','W');

        --***********************************************************************
        -- Add all the tasks
        --***********************************************************************
        INSERT into ws_wrk_task_ctrl
        (
          wtc_task_key
        , wtc_job_key
        , wtc_obj_key
        , wtc_name
        , wtc_type
        , wtc_sequence
        , wtc_obj_type
        , wtc_action_type
        , wtc_order
        , wtc_order_a
        , wtc_order_b
        , wtc_order_c
        , wtc_run_status
        , wtc_audit_status
        , wtc_started
        , wtc_completed
        , wtc_avg_elapsed
        , wtc_avg_count
        , wtc_task_fatal
        , wtc_task_error
        , wtc_task_warning
        , wtc_task_info
        , wtc_task_okay
        , wtc_chkp_number
        , wtc_abort_level
        , wtc_action_ind
        )
        SELECT
          ws_task_seq.nextval
        , v_new_sequence
        , wtc_obj_key
        , wtc_name
        , wtc_type
        , v_new_sequence
        , wtc_obj_type
        , wtc_action_type
        , wtc_order
        , wtc_order_a
        , wtc_order_b
        , wtc_order_c
        , wtc_run_status
        , wtc_audit_status
        , wtc_started
        , wtc_completed
        , wtc_avg_elapsed
        , wtc_avg_count
        , wtc_task_fatal
        , wtc_task_error
        , wtc_task_warning
        , wtc_task_info
        , wtc_task_okay
        , wtc_chkp_number
        , wtc_abort_level
        , NVL(wtc_action_ind,'')
        FROM ws_wrk_task_ctrl
        Where wtc_job_key = v_old_key;

        --***********************************************************************
        -- Add all the dependencies
        --***********************************************************************
        INSERT into ws_wrk_dependency
        (
          wdp_job_key
        , wdp_parent_task_key
        , wdp_child_task_key
        )
        SELECT
          v_new_sequence,
          b_new.wtc_task_key,
          c_new.wtc_task_key
        FROM
          ws_wrk_dependency a,
          ws_wrk_task_ctrl b_old,
          ws_wrk_task_ctrl c_old,
          ws_wrk_task_ctrl b_new,
          ws_wrk_task_ctrl c_new
        WHERE a.wdp_job_key = v_old_key
        AND b_new.wtc_job_key = v_new_sequence
        AND c_new.wtc_job_key = v_new_sequence
        AND a.wdp_parent_task_key = b_old.wtc_task_key
        AND a.wdp_child_task_key = c_old.wtc_task_key
        AND b_old.wtc_order = b_new.wtc_order
        AND c_old.wtc_order = c_new.wtc_order;


        --***********************************************************************
        -- Set the job to the request state
        --***********************************************************************
        UPDATE ws_wrk_job_ctrl
        SET wjc_status = v_wjc_status
    WHERE wjc_job_key = v_new_sequence
    AND  wjc_sequence = v_new_sequence;

        Commit;

        p_return_code := 'S';
        p_return_msg := 'Job '||p_new_job||' created.';
        RETURN 1;

    EXCEPTION WHEN OTHERS THEN
        p_return_code := 'E';
        v_msg := 'Failed to create Job '||p_new_job||' '||SQLERRM;
        p_return_msg := substr(v_msg,1,1023);
        RETURN -2;
    END;

    COMMIT;
    RETURN -3;

EXCEPTION
    WHEN OTHERS THEN
        p_return_code := 'F';
        v_MsgText := 'Unhandled Exception in ws_job_createwait. '||
                ' Step ' ||v_step;
        v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence,
                          v_MsgText,SQLCODE, SQLERRM, p_task_id, p_job_id);
        p_return_msg := substr(v_MsgText,1,1023);
       RETURN -3;

END ws_job_createwait;
 
_PROCEDURE_ Ws_Version_Clear 
-- Notes / History
--
-- V5.6.0.9  NRB 27/06/2007 Original Version
-- V5.6.1.1  AP  30/08/2007 Delete based on obj name not key, as indexes etc get new key
--                          when regenerate.
-- V6.1.0.1  JML 30/03/2010 Changes to write to wx...archive tables before deleting for:
--                          - ws_obj_object
--                          - ws_pro_header_v
--                          - ws_pro_line_v
--                          - ws_scr_header_v
--                          - ws_scr_line_v
-- V6.8.4.3  BC  14/08/2015 RED-5520 Replaced occurrences of the != SQL operator with <>
-- V8.4.1.0  HM  13/02/2019 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION Ws_Version_Clear
  (
  p_sequence          IN  number,
  p_job_name          IN  varchar2,
  p_task_name         IN  varchar2,
  p_job_id            IN  number,
  p_task_id           IN  number,
  p_day_count         IN  number,
  p_keep_count        IN  number,
  p_options           IN  varchar2,
  p_return_code       OUT varchar2,
  p_return_msg        OUT varchar2
  )
  RETURN INTEGER
  AUTHID CURRENT_USER
  IS PRAGMA AUTONOMOUS_TRANSACTION;

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            :  Oracle
  -- Script Name          :  Ws_Version_Clear
  -- Description          :  Deletes old version records
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Constants
  --=====================================================
  v_ws_pro_version           constant varchar(15) := '(8.4.1.0)';
  v_ws_obj_procedure         constant number := 1;
  v_ws_obj_fact_kpi          constant number := 2;
  v_ws_obj_script            constant number := 3;
  v_ws_obj_template          constant number := 4;
  v_ws_obj_fact              constant number := 5;
  v_ws_obj_dim               constant number := 6;
  v_ws_obj_stage             constant number := 7;
  v_ws_obj_load              constant number := 8;
  v_ws_obj_agg               constant number := 9;
  v_ws_obj_index             constant number := 10;
  v_ws_obj_connect           constant number := 11;
  v_ws_obj_dim_view          constant number := 12;
  v_ws_obj_export            constant number := 13;
  v_ws_obj_cube              constant number := 15;
  v_ws_obj_cube_virtual      constant number := 16;
  v_ws_obj_report            constant number := 17;
  v_ws_obj_view              constant number := 18;
  v_ws_obj_join              constant number := 20;
  v_ws_obj_retro             constant number := 21;
  v_ws_obj_retro_copy        constant number := 22;

  v_ws_act_drop              constant number := 1;
  v_ws_act_create            constant number := 2;
  v_ws_act_drop_all          constant number := 3;
  v_ws_act_pre_drop          constant number := 4;
  v_ws_act_load              constant number := 5;
  v_ws_act_update            constant number := 6;
  v_ws_act_execute           constant number := 7;
  v_ws_act_process           constant number := 8;
  v_ws_act_build             constant number := 9;
  v_ws_act_build_all         constant number := 10;
  v_ws_act_analyze           constant number := 11;
  v_ws_act_quick_analyze     constant number := 12;
  v_ws_act_statistics        constant number := 13;
  v_ws_act_quick_statistics  constant number := 14;
  v_ws_act_initial           constant number := 15;
  v_ws_act_cube_dim          constant number := 16;
  v_ws_act_db_dim            constant number := 17;
  v_ws_act_custom            constant number := 18;
  v_ws_act_truncate          constant number := 19;
  v_ws_act_compile           constant number := 20;

  --===============================================================
  -- Control variables used in most programs
  --===============================================================
  v_MsgText               varchar2(1024); -- Text for audit_trail
  v_sql                   varchar2(4000); -- sql statements
  v_step                  integer := 0;   -- return code
  v_version_delete_count  integer := 0;   -- no of records deleted
  v_version_insert_count  integer := 0;   -- no of records inserted
  v_delete_count          integer := 0;   -- no of records deleted
  v_insert_count          integer := 0;   -- no of records inserted
  v_count                 integer := 0;   -- General counter;
  v_result                integer := 0;   -- return status

  --===============================================================
  -- General Variables
  --===============================================================
  v_version_no            integer := 0;  -- version no
  v_obj_key               integer := 0;  -- object key
  v_obj_name              varchar2(64);  -- object key
  v_creation_date         date;          -- creation date for record
  v_retain_till_date      date;          -- retain date
  v_table_name            varchar2(100); -- table name
  v_column_name           varchar2(100); -- column name
  v_delete_date           date;          -- delete date
  v_prev_obj_name         varchar2(64);  -- previous object key
  v_process_flag          integer;       -- identifies if record can be processed
  v_delete_sql            varchar2(500); -- delete sql statement
  v_insert_sql            varchar2(500); -- insert sql statement

  --===============================================================
  -- Cursor to get Version records
  --===============================================================
  CURSOR c_Versions is
  SELECT   ov_version_no
         , ov_obj_key
         , ov_obj_name
         , ov_creation_date
         , ov_retain_till_date
  FROM     ws_obj_versions
  ORDER BY ov_obj_name
         , ov_creation_date DESC;

  --===============================================================
  -- Cursor to get metadata tables for deleting versioned records
  --===============================================================
  CURSOR c_Tables is
  SELECT   a.table_name
         , a.column_name
  FROM     all_tab_columns a
         , ws_meta b
  WHERE    a.table_name like 'WS_%_V'
  AND      a.column_name like '%_VERSION_NO'
  AND      a.OWNER = UPPER(b.meta_dss_schema);

BEGIN

  v_step := 100;

  v_version_delete_count := 0;
  v_version_insert_count := 0;
  v_delete_count := 0;
  v_insert_count := 0;
  v_prev_obj_name := '_';
  v_count:= 0;
  v_process_flag := 0;

  --================================================================
  -- Check to see if need to delete based on date
  --================================================================
  IF p_day_count >= 0 THEN

    v_delete_date := sysdate - p_day_count;

    p_return_msg := 'Delete Date: ' || TO_CHAR(v_delete_date, 'DD-MON-YYYY HH24:MI:SS');
    v_result := WsWrkAudit('I',p_job_name, p_task_name, p_sequence,
                    p_return_msg,SQLCODE,SQLERRM,p_task_id, p_job_id);

  ELSE

    v_delete_date := sysdate;

  END IF;

  v_step := 200;

  --================================================================
  -- Check to see if need to keep minimum number of versioned records
  --================================================================
  IF p_keep_count > 0 THEN

    -- log min versions to keep
    p_return_msg := 'Versions to Keep: ' || p_keep_count;
    v_result := WsWrkAudit('I',p_job_name, p_task_name, p_sequence,
                    p_return_msg,SQLCODE,SQLERRM,p_task_id, p_job_id);

  END IF;

  v_step := 300;

  --================================================================
  -- Loop on version records
  --================================================================
  FOR v_Versions_rec in c_Versions LOOP

    --=============================================================
    -- check to see if object key has changed and reset counter
    --=============================================================
    IF v_prev_obj_name <> v_Versions_rec.ov_obj_name THEN

      v_prev_obj_name := v_Versions_rec.ov_obj_name;
      v_count := 0;
      v_process_flag := 0;

    END IF;

    -- increment counter for object key
    v_count := v_count + 1;

    v_step := 400;

    --=============================================================
    -- reset flag if deleting based on retain date, as
    -- need to chech each individual record
    --=============================================================
    IF p_day_count < 0 THEN

      v_process_flag := 0;

    END IF;

    v_step := 500;

    --=============================================================
    -- check to see if versioned record can be deleted
    --=============================================================
    IF v_process_flag = 0 THEN

      -- check to see if min versins to keep has been passed
      IF v_count > p_keep_count THEN

        -- check to see if deleting records old enough
        IF p_day_count >= 0 THEN

          IF v_delete_date >= v_Versions_rec.ov_creation_date THEN

            v_process_flag := 1;

          END IF;

        ELSE

          IF v_delete_date >= v_Versions_rec.ov_retain_till_date THEN

            v_process_flag := 1;

          END IF;

        END IF;

      END IF;  -- end check for min verions to keep

    END IF;

    v_step := 600;

    --=============================================================
    -- If flag set, delete version record
    --=============================================================
    IF v_process_flag = 1 THEN

      --===============================================================
      -- Archive rows in ws_obj_versions
      --===============================================================
      EXECUTE IMMEDIATE 'INSERT INTO WX_OBJ_VERSIONS_ARCHIVE '
                     || 'SELECT * '
                     || 'FROM   WS_OBJ_VERSIONS '
                     || 'WHERE  OV_VERSION_NO = :1'
              USING v_Versions_rec.ov_version_no;

      v_version_insert_count := v_version_insert_count + 1;

      v_step := 700;

      --===============================================================
      -- Delete rows from ws_obj_versions
      --===============================================================
      EXECUTE IMMEDIATE 'DELETE FROM WS_OBJ_VERSIONS '
                     || 'WHERE OV_VERSION_NO = :1'
              USING v_Versions_rec.ov_version_no;

      v_version_delete_count := v_version_delete_count + 1;

      v_step := 800;

      --===============================================================
      -- commit every 500 versioned records
      --===============================================================
      IF MOD(v_version_delete_count, 500) = 0 THEN

        COMMIT;

      END IF;

    END IF;

  END LOOP;

  COMMIT;

  v_step := 900;

  --===============================================================
  -- delete detail version data if versions have been deleted
  --===============================================================
  IF v_version_delete_count > 0 THEN

    --================================================================
    -- Loop on version detail tables
    --================================================================
    FOR v_Tables_rec in c_Tables LOOP

      v_step := 1000;

      v_insert_count := 0;

      --================================================================
      -- If the detail table is procedure/script headers/lines
      -- then archive the rows before deleting
      --================================================================
      IF UPPER(v_Tables_rec.table_name) IN ('WS_PRO_HEADER_V','WS_PRO_LINE_V','WS_SCR_HEADER_V','WS_SCR_LINE_V') THEN

        v_step := 1100;

        -- generate insert SQL
        v_insert_sql := 'INSERT /*+ APPEND */ INTO WX' || SUBSTR(v_Tables_rec.table_name,3,28) || '_ARCHIVE '
                           ||'SELECT * '
                           ||'FROM   '|| v_Tables_rec.table_name ||' a '
                           ||'WHERE NOT EXISTS (SELECT 1 '
                           ||'                  FROM   ws_obj_versions b '
                           ||'                  WHERE  a.'|| v_Tables_rec.column_name ||' = b.ov_version_no)';

        EXECUTE IMMEDIATE v_insert_sql;

        v_insert_count := SQL%ROWCOUNT;

        IF v_insert_count > 0 THEN

          v_MsgText := v_insert_count ||' records archived to '
                       || 'WX' || SUBSTR(v_Tables_rec.table_name,3,28) || '_ARCHIVE';
          v_result := WsWrkAudit('I',p_job_name, p_task_name, p_sequence,
                        v_MsgText,SQLCODE,SQLERRM,p_task_id, p_job_id);

          COMMIT;

        END IF;

      END IF;

      v_step := 1200;

      v_delete_count := 0;

      -- generate delete SQL
      v_delete_sql := 'DELETE FROM '|| v_Tables_rec.table_name ||' a '
                         ||'WHERE NOT EXISTS (SELECT 1 '
                         ||'                  FROM   ws_obj_versions b '
                         ||'                  WHERE  a.'|| v_Tables_rec.column_name ||' = b.ov_version_no)';

      EXECUTE IMMEDIATE v_delete_sql;

      v_delete_count := SQL%ROWCOUNT;

      IF v_delete_count > 0 THEN

        v_MsgText := v_delete_count ||' records deleted from '
                     || v_Tables_rec.table_name;
        v_result := WsWrkAudit('I',p_job_name, p_task_name, p_sequence,
                      v_MsgText,SQLCODE,SQLERRM,p_task_id, p_job_id);

        COMMIT;

      END IF;

    END LOOP;

  END IF;

  v_step := 1300;

  --===============================================================
  --All Done report the results and return.
  --===============================================================
  COMMIT;

  v_step := 1400;
  p_return_code := 'S';
  p_return_msg := 'Version Records deleted: ' || v_version_delete_count;

  RETURN 1;

EXCEPTION
--=================================================================
-- Unhandled Exception. Return with Fatal Error
--=================================================================
WHEN OTHERS THEN
  p_return_code := 'W';
  p_return_msg := 'Unhandled Exception in Ws_Version_Clear '|| v_ws_pro_version ||
    ' Step ' ||v_step || ' '||SQLERRM;
  v_result := WsWrkAudit('F',p_job_name, p_task_name, p_sequence,
    p_return_msg,SQLCODE,SQLERRM,p_task_id, p_job_id);
  RETURN -3;

END Ws_Version_Clear;
 
_PROCEDURE_ Ws_Job_Clear_Archive 
-- Notes / History
--
-- AP 10/08/2006
--
-- NB  19/07/2007                   Add parameters for job name and options.
-- NB  04/10/2007                   Modified to pre-calculate the delete date
-- AP  30/07/2009                   Corrected placement of calculated delete date
-- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE function Ws_Job_Clear_Archive
  (
  p_sequence     IN  number,
  p_job_name     IN  varchar2,
  p_task_name    IN  varchar2,
  p_job_id       IN  number,
  p_task_id      IN  number,
  p_day_count    IN  number,
  p_job          IN  varchar2,
  p_options      IN  varchar2,
  p_return_code  OUT varchar2,
  p_return_msg   OUT varchar2
  )
  Return integer
  AUTHID CURRENT_USER
  IS PRAGMA AUTONOMOUS_TRANSACTION;

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    	:	ORACLE
  -- Script Name 		:	Ws_Job_Clear_Archive
  -- Description 		:	Deletes from archives old job logs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Control variables used in most programs
  --=====================================================
  v_msgtext         varchar2(1024); -- Text for audit_trail
  v_result          integer := 0;   -- return code
  v_sql             varchar2(4000); -- Text for sql statements
  v_set             integer := 0;   -- commit set
  v_analyze_flag    integer := 0;   -- analyze flag
  v_step            integer := 0;   --
  v_update_count    integer := 0;   -- no of records updated
  v_insert_count    integer := 0;   -- no of records inserted
  v_count           integer := 0;   -- General counter;
  v_delete_date     date;           -- delete date

  v_row_count        integer;
  v_count            integer;
  v_job_sequence     integer;
  v_job_key          integer;
  v_audit_del_count  integer;
  v_detail_del_count integer;
  v_job_status       varchar2(1);



  v_trunc_flag       integer := 0;
  v_job              varchar2(64);

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
BEGIN
  v_step := 10;
  v_audit_del_count  := 0;
  v_detail_del_count := 0;

  -- If zero specified in logs to keep then return
  IF p_day_count < 0
  THEN
    p_return_code := 'W';
    p_return_msg := ' negative value passed in days to keep count. No action.';
    RETURN 1;
  END IF;

  -- set delete date
  v_delete_date := sysdate - NVL(p_day_count,0);

  v_job := NVL(p_job, '');

  --***********************************************************************
  -- Process options
  --***********************************************************************

  v_step := 100;
  IF p_options is not null
  THEN
    IF UPPER(p_options) = 'TRUNCATE'
    THEN
      v_trunc_flag := 1;
    END IF;
  END IF;


  --***********************************************************************
  -- Delete relevant archive records
  --***********************************************************************
  v_step := 500;

  IF v_trunc_flag = 1
  THEN
    v_step := 600;
    --***********************************************************************
    -- truncate audit and detail archive info
    --***********************************************************************
    EXECUTE IMMEDIATE 'truncate table wx_wrk_audit_archive';

    EXECUTE IMMEDIATE 'truncate table wx_wrk_error_archive';
  ELSE
    v_step := 700;
    --***********************************************************************
    -- construct and process DELETE statements
    --***********************************************************************
    IF LENGTH(v_job) > 0
    THEN
      v_step := 710;

      -- set delete date
      --v_delete_date := sysdate - p_day_count;

      --***********************************************************************
      -- delete includes job name (possibly with wildcard)
      --***********************************************************************
      DELETE
      FROM   wx_wrk_audit_archive
      WHERE  wa_time_stamp < v_delete_date
      AND    wa_job like p_job;

      v_audit_del_count  := SQL%ROWCOUNT;
      COMMIT;

      DELETE
      FROM   wx_wrk_error_archive
      WHERE  wd_time_stamp < v_delete_date
      AND    wd_job like p_job;


      v_detail_del_count :=  SQL%ROWCOUNT;
      COMMIT;

    ELSE
      v_step := 720;
      --***********************************************************************
      -- Delete based on just the day count
      --***********************************************************************
      DELETE
      FROM   wx_wrk_audit_archive
      WHERE  wa_time_stamp < v_delete_date;

      v_audit_del_count  := SQL%ROWCOUNT;
      COMMIT;

      DELETE
      FROM   wx_wrk_error_archive
      WHERE  wd_time_stamp < v_delete_date;

      v_detail_del_count :=  SQL%ROWCOUNT;
      COMMIT;
    END IF;  -- end if length(v_job)

  END IF;  -- end if v_trunc_flag

  v_step := 800;

  p_return_code := 'S';

  IF v_trunc_flag = 1
  THEN
    p_return_msg := 'audit archive logs and detail archive logs tables truncated.';
  ELSE
    p_return_msg := TO_CHAR(NVL(v_audit_del_count,0))  || ' audit archive logs removed and '
                      || TO_CHAR(NVL(v_detail_del_count,0))  || ' detail archive logs removed. ';
  END IF;

  RETURN 1;

EXCEPTION
WHEN OTHERS THEN
  v_MsgText:= 'Unhandled Exception in Ws_Job_Clear_Archive. '||
    ' Step ' ||v_step || ' '||SQLERRM;
  v_result := WsWrkAudit('F',p_job_name, p_task_name, p_sequence,
    v_MsgText,SQLCODE,SQLERRM,p_task_id, p_job_id);
  p_return_msg := substr(v_MsgText,1,1023);


  RETURN -3;
END Ws_Job_Clear_Archive;
 
_PROCEDURE_ Ws_Job_Status 
  -- Notes / History
  --
  -- V5.6.3.0 JML 19/11/2007   First Version
  -- V6.8.4.4 BC  05/11/2015   RED-5392 Eliminate a potential race condition when getting
  --                           the details of a running job which could have completed in
  --                           the mean time, where its details will have been moved out of
  --                           ws_wrk_job_run into ws_wrk_job_log.
  -- V8.4.1.0 HM  13/02/2019   RED-7407 Increase message size from 256 to 1024 characters.

CREATE OR REPLACE FUNCTION Ws_Job_Status
( p_sequence            IN  NUMBER
, p_job_name            IN  VARCHAR2
, p_task_name           IN  VARCHAR2
, p_job_id              IN  NUMBER
, p_task_id             IN  NUMBER
, p_check_sequence      IN  NUMBER
, p_check_job           IN  VARCHAR2
, p_started_in_last_mi  IN  NUMBER
, p_started_after_dt    IN  DATE
, p_return_code         OUT VARCHAR2
, p_return_msg          OUT VARCHAR2
, p_job_status_simple   OUT VARCHAR2
, p_job_status_standard OUT VARCHAR2
, p_job_status_enhanced OUT VARCHAR2
)
RETURN INTEGER
AUTHID CURRENT_USER
IS

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		:	Oracle
  -- Script Name 		:	ws_job_status
  -- Description 		:	Returns the status of a job.
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================

  --=====================================================
  -- Variables
  --=====================================================
  v_msgtext                VARCHAR2(1024); -- Text in audit_trail
  v_step                   INTEGER;        -- return code
  v_result                 INTEGER := 0;   -- return code
  v_sql_code               INTEGER;        -- SQL Error Code for Audit Trail
  v_sql_error              VARCHAR2(1024); -- SQL Error Code for Audit Trail as varchar
  v_job_not_found          CHAR(1) := 'N';
  v_job_sequence           INTEGER;
  v_job_status_simple      VARCHAR2(1);
  v_job_status_standard    VARCHAR2(1);
  v_job_status_enhanced    VARCHAR2(2);
  v_job_state              VARCHAR2(20);
  v_job_status_msg         VARCHAR2(256);
  v_task_count             INTEGER;
  v_started_after_dt       DATE;
  v_sql                    VARCHAR2(32000);

BEGIN

  --=====================================================
  -- Main
  --=====================================================
  v_step := 100;

  p_return_code := 'S';

  v_step := 200;

  -- Check to ensure neither time based parameters have been specified if check sequence has been.
  -- Abort in this case.
  IF (( p_check_sequence IS NOT NULL ) AND (( p_started_in_last_mi IS NOT NULL) OR ( p_started_after_dt IS NOT NULL ))) THEN

    v_step := 300;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Unable to proceed: neither p_started_in_last_mi or p_started_after_dt may not be specified if p_check_sequence is specified.';
    p_return_code := 'E';

    RETURN -2;

  -- Check to ensure zero or one time based parameters have been specified.
  -- Abort if both have been specified.
  ELSIF (( p_started_in_last_mi IS NOT NULL) AND ( p_started_after_dt IS NOT NULL )) THEN

    v_step := 400;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Unable to proceed: both p_started_in_last_mi and p_started_after_dt have been set. At most one of these may be set.';
    p_return_code := 'E';

    RETURN -2;

  ELSIF ((( p_started_in_last_mi IS NOT NULL) OR ( p_started_after_dt IS NOT NULL )) AND ( p_check_job IS NULL )) THEN

    v_step := 500;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Unable to proceed: if p_started_in_last_mi or p_started_after_dt have been set, then p_check_job must also be set.';
    p_return_code := 'E';

    RETURN -2;

  END IF;

  v_step := 600;

  -- If the job sequence has been specified, see if it is in the control, run
  -- or log tables.
  IF ( p_check_sequence IS NOT NULL ) THEN

    v_step := 700;

    SELECT NVL(MAX(job_state),'0')
    INTO   v_job_state
    FROM ( SELECT sequence_data.*
                , ROWNUM AS rank_job_state
           FROM ( SELECT '0' AS job_state
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_sequence = p_check_sequence
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                  FROM   ws_wrk_job_run
                  WHERE  wjr_sequence = p_check_sequence
                  UNION
                  SELECT '2' AS job_state
                  FROM   ws_wrk_job_log
                  WHERE  wjl_sequence = p_check_sequence
                  UNION
                  SELECT '3' AS job_state
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_sequence = p_check_sequence
                  AND    wjc_status <> 'B'
                  ORDER BY 1 ASC
                ) sequence_data
         ) ranked_date
    WHERE rank_job_state = 1
    ;

    v_step := 800;

    IF ( v_job_state = 0 ) THEN

      v_step := 900;

      p_job_status_simple := '0';
      p_job_status_standard := '0';
      p_job_status_enhanced := '0';
      p_return_msg := 'Unable to locate specified job sequence.';
      p_return_code := 'E';

      RETURN -1;

    END IF;

    v_job_sequence := p_check_sequence;

  -- If either date and time parameter has been specified...
  ELSIF (( p_started_in_last_mi IS NOT NULL ) OR ( p_started_after_dt IS NOT NULL )) THEN

    -- If the started in the last X minutes parameter has been specified, then
    -- convert this into a day.
    IF ( p_started_in_last_mi IS NOT NULL ) THEN

      v_step := 1000;

      -- Work out allowable start date and store in v_started_after_dt using the day, hour
      -- and minute interval values.
      v_started_after_dt := SYSDATE - p_started_in_last_mi/60/24;

    -- Start after date parameter specified, so assign this to v_started_after_dt.
    ELSIF ( p_started_after_dt IS NOT NULL ) THEN

      v_started_after_dt := p_started_after_dt;

    END IF;

    v_step := 1100;

    -- Get the sequence of the job and see if it is in the control, run
    -- or log tables.
    -- Note order of precedence: has run, is running, has not yet run.
    SELECT NVL(MAX(job_state),'0')
         , NVL(MAX(job_sequence),0)
    INTO   v_job_state
         , v_job_sequence
    FROM ( SELECT sequence_data.*
                , ROWNUM AS rank_job_state
           FROM ( SELECT '0' AS job_state
                       , wjc_sequence AS job_sequence
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_started >= v_started_after_dt
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                       , wjr_sequence AS job_sequence
                  FROM   ws_wrk_job_run
                  WHERE  wjr_name = p_check_job
                  AND    wjr_started >= v_started_after_dt
                  UNION
                  SELECT '2' AS job_state
                       , wjl_sequence AS job_sequence
                  FROM   ws_wrk_job_log
                  WHERE  wjl_name = p_check_job
                  AND    wjl_started >= v_started_after_dt
                  UNION
                  SELECT '3' AS job_state
                       , wjc_sequence AS job_sequence
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_name = p_check_job
                  AND    wjc_started >= v_started_after_dt
                  AND    wjc_status <> 'B'
                  ORDER BY job_state ASC
                         , job_sequence DESC
                ) sequence_data
         ) ranked_date
    WHERE rank_job_state = 1
    ;

    -- If job sequence hasn't been found, set v_job_not_found to Y for later use.
    IF ( v_job_sequence = 0 ) THEN

      v_job_not_found := 'Y';

    END IF;

  END IF;

  -- If the sequence parameter or neither date parameters has been specified or
  -- both previous checks failed to find the job look for the max sequence of
  -- the specified job.
  -- Note order of precedence: has run, is running, has not yet run.
  IF ((( p_check_sequence IS NULL ) AND ( p_started_in_last_mi IS NULL ) AND ( p_started_after_dt IS NULL )) OR ( v_job_not_found = 'Y' )) THEN

    v_step := 1200;

    SELECT NVL(MAX(job_state),'0')
         , NVL(MAX(job_sequence),0)
    INTO   v_job_state
         , v_job_sequence
    FROM ( SELECT sequence_data.*
                , ROWNUM AS rank_job_state
           FROM ( SELECT '0' AS job_state
                       , wjc_sequence AS job_sequence
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_name = p_check_job
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                       , wjr_sequence AS job_sequence
                  FROM   ws_wrk_job_run
                  WHERE  wjr_name = p_check_job
                  UNION
                  SELECT '2' AS job_state
                       , wjl_sequence AS job_sequence
                  FROM   ws_wrk_job_log
                  WHERE  wjl_name = p_check_job
                  UNION
                  SELECT '3' AS job_state
                       , wjc_sequence AS job_sequence
                  FROM   ws_wrk_job_ctrl
                  WHERE  wjc_name = p_check_job
                  AND    wjc_status <> 'B'
                  ORDER BY job_state ASC
                         , job_sequence DESC
                ) sequence_data
         ) ranked_date
    WHERE rank_job_state = 1
    ;

  END IF;

  v_step := 1300;

  -- If the job could not be found, abort.
  IF ( v_job_sequence = 0 ) THEN

    v_step := 1400;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Unable to locate job.';
    p_return_code := 'E';

    RETURN -1;

  -- If the job exists but not starting in the last X minutes then abort.
  ELSIF ( p_started_in_last_mi IS NOT NULL AND v_job_not_found = 'Y' ) THEN

    v_step := 1500;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Job Not Found having started in the last ' || TRIM(TO_CHAR(p_started_in_last_mi)) ||' minutes.';
    p_return_code := 'N';

    RETURN -1;

  -- If the job exists but not starting since the specified date and time then abort.
  ELSIF ( p_started_after_dt IS NOT NULL AND v_job_not_found = 'Y' ) THEN

    v_step := 1600;

    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := 'Job Not Found having started after ' || TO_CHAR(p_started_after_dt,'YYYY-MM-DD hh24:mi:ss') ||'.';
    p_return_code := 'N';

    RETURN -1;

  END IF;

  v_step := 1700;

  -- If the job was found and is currently running or has failed and not been
  -- aborted, get its details.
  IF ( v_job_state = '1' ) THEN

    v_step := 1800;

    v_sql := '
    SELECT NVL(MAX(
           CASE
             WHEN job_status = ''H'' THEN ''N''
             WHEN job_status = ''W'' THEN ''N''
             WHEN job_status = ''B'' THEN ''N''
             WHEN job_status = ''P'' THEN ''N''
             WHEN job_status = ''R'' THEN ''R''
             WHEN job_status = ''F'' THEN ''F''
             WHEN job_status = ''C'' THEN ''C''
             WHEN job_status = ''G'' THEN ''F''
             WHEN job_status = ''E'' THEN ''F''
             ELSE ''0''
           END),''0'') AS Job_Status_Simple
         , NVL(MAX(job_status),''0'') AS Job_Status_Standard
         , NVL(MAX(
           CASE
             WHEN job_status = ''H'' THEN ''1''
             WHEN job_status = ''W'' THEN ''2''
             WHEN job_status = ''B'' THEN ''3''
             WHEN job_status = ''P'' THEN ''4''
             WHEN job_status = ''R'' THEN ''5''
             WHEN job_status = ''F'' THEN ''8''
             WHEN job_status = ''C'' THEN ''9''
             WHEN job_status = ''G'' THEN ''11''
             WHEN job_status = ''E'' THEN ''12''
             ELSE ''0''
           END),''0'') AS Job_Status_Enhanced
         , NVL(MAX(CASE
             WHEN job_status = ''H'' THEN ''On Hold''
             WHEN job_status = ''R'' THEN ''Running''
             WHEN job_status = ''P'' THEN ''Pending''
             WHEN job_status = ''W'' THEN ''Waiting''
             WHEN job_status = ''C'' THEN ''Completed''
             WHEN job_status = ''B'' THEN ''Blocked''
             WHEN job_status = ''F'' THEN ''Failed''
             WHEN job_status = ''G'' THEN ''Failed - Aborted''
             WHEN job_status = ''E'' THEN ''Error Completion''
             ELSE ''Unknown''
           END),''Unknown'') AS Job_Status_Message
    FROM (
        SELECT wjr_status AS job_status
        FROM ws_wrk_job_run
        WHERE wjr_sequence = :b1
          UNION
        SELECT wjl_status AS job_status
        FROM ws_wrk_job_log
        WHERE wjl_sequence = :b2
    ) sequence_data'
    ;

    EXECUTE IMMEDIATE v_sql
    INTO   v_job_status_simple
         , v_job_status_standard
         , v_job_status_enhanced
         , v_job_status_msg
    USING  v_job_sequence
         , v_job_sequence;

    v_step := 1900;

    -- If the job is still running, check to see if any completed tasks
    -- have any errors or warning.   Then enhance the return message and
    -- status.   If there are both warnings and errors then report as a
    -- running with errors.
    IF ( v_job_status_enhanced = '5' ) THEN

      v_step := 2000;

      SELECT COUNT(*)
      INTO   v_task_count
      FROM   ws_wrk_task_run
      WHERE  wtr_sequence = v_job_sequence
      AND    wtr_audit_status IN ('E','F')
      ;

      v_step := 2100;

      IF ( v_task_count > 0 ) THEN

        v_step := 2200;

        v_job_status_enhanced := '6';
        v_job_status_msg := 'Running with Errors';

      ELSE

        v_step := 2300;

        SELECT COUNT(*)
        INTO   v_task_count
        FROM   ws_wrk_task_run
        WHERE  wtr_sequence = v_job_sequence
        AND    wtr_audit_status = 'W'
        ;

        v_step := 2400;

        IF ( v_task_count > 0 ) THEN

          v_step := 2500;

          v_job_status_enhanced := '7';
          v_job_status_msg := 'Running with Warnings';

        END IF;

      END IF;

    END IF;

  -- If the job was found and has completed running, get its details.
  ELSIF ( v_job_state = '2' ) THEN

    v_step := 2600;

    v_sql := '
    SELECT NVL(MAX(
           CASE
             WHEN wjl_status = ''H'' THEN ''N''
             WHEN wjl_status = ''W'' THEN ''N''
             WHEN wjl_status = ''B'' THEN ''N''
             WHEN wjl_status = ''P'' THEN ''N''
             WHEN wjl_status = ''R'' THEN ''R''
             WHEN wjl_status = ''F'' THEN ''F''
             WHEN wjl_status = ''C'' THEN ''C''
             WHEN wjl_status = ''G'' THEN ''F''
             WHEN wjl_status = ''E'' THEN ''F''
             ELSE ''0''
           END),''0'') AS Job_Status_Simple
         , NVL(MAX(wjl_status),''0'') AS Job_Status_Standard
         , NVL(MAX(
           CASE
             WHEN wjl_status = ''H'' THEN ''1''
             WHEN wjl_status = ''W'' THEN ''2''
             WHEN wjl_status = ''B'' THEN ''3''
             WHEN wjl_status = ''P'' THEN ''4''
             WHEN wjl_status = ''R'' THEN ''5''
             WHEN wjl_status = ''F'' THEN ''8''
             WHEN wjl_status = ''C'' THEN ''9''
             WHEN wjl_status = ''G'' THEN ''11''
             WHEN wjl_status = ''E'' THEN ''12''
             ELSE ''0''
           END),''0'') AS Job_Status_Enhanced
         , NVL(MAX(CASE
             WHEN wjl_status = ''H'' THEN ''On Hold''
             WHEN wjl_status = ''R'' THEN ''Running''
             WHEN wjl_status = ''P'' THEN ''Pending''
             WHEN wjl_status = ''W'' THEN ''Waiting''
             WHEN wjl_status = ''C'' THEN ''Completed''
             WHEN wjl_status = ''B'' THEN ''Blocked''
             WHEN wjl_status = ''F'' THEN ''Failed''
             WHEN wjl_status = ''G'' THEN ''Failed - Aborted''
             WHEN wjl_status = ''E'' THEN ''Error Completion''
             ELSE ''Unknown''
           END),''Unknown'') AS Job_Status_Message
    FROM   ws_wrk_job_log
    WHERE  wjl_sequence = :b1'
    ;

    EXECUTE IMMEDIATE v_sql
    INTO   v_job_status_simple
         , v_job_status_standard
         , v_job_status_enhanced
         , v_job_status_msg
    USING  v_job_sequence;

    v_step := 2700;

    -- If the job completed successfully, check to see if there were
    -- any warnings.   Then enhance the return message and status.
    IF ( v_job_status_enhanced = '9' ) THEN

      v_step := 2800;

      SELECT COUNT(*)
      INTO   v_task_count
      FROM   ws_wrk_task_log
      WHERE  wtl_sequence = v_job_sequence
      AND    wtl_audit_status = 'W'
      ;

      v_step := 2900;

      IF ( v_task_count > 0 ) THEN

        v_step := 3000;

        v_job_status_enhanced := '10';
        v_job_status_msg := 'Completed with Warnings';

      END IF;

    END IF;

  -- If the job was found and has not yet run, get its details.
  ELSIF ( v_job_state IN ('0','3') ) THEN

    v_step := 3100;

    v_sql := '
    SELECT NVL(MAX(
           CASE
             WHEN wjc_status = ''H'' THEN ''N''
             WHEN wjc_status = ''W'' THEN ''N''
             WHEN wjc_status = ''B'' THEN ''N''
             WHEN wjc_status = ''P'' THEN ''N''
             WHEN wjc_status = ''R'' THEN ''R''
             WHEN wjc_status = ''F'' THEN ''F''
             WHEN wjc_status = ''C'' THEN ''C''
             WHEN wjc_status = ''G'' THEN ''F''
             WHEN wjc_status = ''E'' THEN ''F''
             ELSE ''0''
           END),''0'') AS Job_Status_Simple
         , NVL(MAX(wjc_status),''0'') AS Job_Status_Standard
         , NVL(MAX(
           CASE
             WHEN wjc_status = ''H'' THEN ''1''
             WHEN wjc_status = ''W'' THEN ''2''
             WHEN wjc_status = ''B'' THEN ''3''
             WHEN wjc_status = ''P'' THEN ''4''
             WHEN wjc_status = ''R'' THEN ''5''
             WHEN wjc_status = ''F'' THEN ''8''
             WHEN wjc_status = ''C'' THEN ''9''
             WHEN wjc_status = ''G'' THEN ''11''
             WHEN wjc_status = ''E'' THEN ''12''
             ELSE ''0''
           END),''0'') AS Job_Status_Enhanced
         , NVL(MAX(CASE
             WHEN wjc_status = ''H'' THEN ''On Hold''
             WHEN wjc_status = ''R'' THEN ''Running''
             WHEN wjc_status = ''P'' THEN ''Pending''
             WHEN wjc_status = ''W'' THEN ''Waiting''
             WHEN wjc_status = ''C'' THEN ''Completed''
             WHEN wjc_status = ''B'' THEN ''Blocked''
             WHEN wjc_status = ''F'' THEN ''Failed''
             WHEN wjc_status = ''G'' THEN ''Failed - Aborted''
             WHEN wjc_status = ''E'' THEN ''Error Completion''
             ELSE ''Unknown''
           END),''Unknown'') AS Job_Status_Message
    FROM   ws_wrk_job_ctrl
    WHERE  wjc_sequence = :b1'
    ;

    v_step := 3200;

    EXECUTE IMMEDIATE v_sql
    INTO   v_job_status_simple
         , v_job_status_standard
         , v_job_status_enhanced
         , v_job_status_msg
    USING  v_job_sequence;

  END IF;

  v_step := 3300;

  p_job_status_simple := v_job_status_simple;
  p_job_status_standard := v_job_status_standard;
  p_job_status_enhanced := v_job_status_enhanced;
  p_return_msg := 'Job Sequence ' || TO_CHAR(v_job_sequence) || ' ' || v_job_status_msg;

  RETURN 1;

EXCEPTION
  --=================================================================
  -- Unhandled Exception. Return with Fatal Error
  --=================================================================
  WHEN OTHERS THEN
    v_msgtext := SUBSTR('Unhandled Exception in Ws_Job_Status. '||
        ' Step ' || TO_CHAR(v_step) ||
        '   SQL Error Code: ' || SQLCODE || ' - ' || SQLERRM,1,1023);
    v_result := WsWrkAudit('F', p_job_name, p_job_name, p_sequence
                          , v_MsgText, SQLCODE, SQLERRM, p_task_id, p_job_id);
    p_job_status_simple := '0';
    p_job_status_standard := '0';
    p_job_status_enhanced := '0';
    p_return_msg := v_msgtext;
    p_return_code := 'F';
    RETURN -3;

END Ws_Job_Status;
