_PROCEDWSL_ Ws_Procedure_Save 
CREATE procedure [METABASE].Ws_Procedure_Save
( IN  p_obj_key      integer
, IN  p_lines0       varchar(8000)
, IN  p_lines1       varchar(8000)
, IN  p_lines2       varchar(8000)
, IN  p_lines3       varchar(8000)
, IN  p_lines4       varchar(8000)
, IN  p_lines5       varchar(8000)
, IN  p_lines6       varchar(8000)
, IN  p_lines7       varchar(8000)
, IN  p_lines8       varchar(1)
, IN  p_lines9       varchar(1)
, OUT p_ret_msg      varchar(1024)
, OUT p_result       integer)

WSPROSAVE:
BEGIN

-- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

-- =============================================================================
-- DBMS Name      : Teradata
-- Script Name    : ws_procedure_save
-- Description    : Save a procedure to ws_pro_line
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
-- =============================================================================
-- Notes / History
--
-- WMR 22/01/2002  Version 1.0.0
-- JML 25/11/2005  Version 5.0.0    Teradata version
-- RS  18/01/2016  Version 6.8.5.2  Changed error handler
-- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_line_no         integer;        -- line counter
  DECLARE v_stmt            varchar(4000);
  DECLARE v_lined           varchar(32767);
  DECLARE v_cursor          numeric;
  DECLARE v_step            numeric;
  DECLARE v_pos             numeric;
  DECLARE v_loop            integer;
  DECLARE v_start           integer;
  DECLARE v_end             integer;
  DECLARE v_size            integer;
  DECLARE v_msgtext         varchar(1024); -- Text for audit_trail
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_stmt_no         integer;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unexpected Error in Ws_Procedure_Save,'||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_ret_msg = v_msgtext;
      SET p_result = -3;
    END;

  SET v_line_no = 0;  -- line counter

  SET v_step = 10;
  --=====================================================
  -- IF a key of 0 and a string of CHECK is passed THEN
  -- return -98 to indicate this procedure is incompatible
  -- with the version of RED in use
  --=====================================================
  IF p_obj_key = 0 AND p_lines0 = 'CHECK' THEN
    SET v_step = 20;
    SET p_result = -98;
    SET p_ret_msg = 'Please upgrade meta data';
    LEAVE WSPROSAVE;
  END IF;

  --=====================================================
  -- IF a key of 0 and a string of CHECK is passed THEN
  -- return -99 to indicate this procedure is active
  --=====================================================
  IF p_obj_key = 0 AND p_lines0 = 'CHECKIT' THEN
    SET v_step = 21;
    SET p_result = -99;
    SET p_ret_msg = 'Ready';
    LEAVE WSPROSAVE;
  END IF;

  BEGIN TRANSACTION;

  LOCKING TABLE [METABASE].ws_zt_pro_line FOR WRITE;

  --=====================================================
  -- Delete the previous lines in this procedure
  -- All treated as one transaction with a rollback
  -- IF the insert fails
  --=====================================================
  DELETE FROM [METABASE].ws_pro_line
  WHERE  pl_obj_key = :p_obj_key;

  --=====================================================
  -- IF a total delete
  -- I.e. the new data is null THEN return
  --=====================================================
  IF p_lines0 is NULL THEN
    SET p_result = 0;
    SET p_ret_msg = 'procedure deleted';
    LEAVE WSPROSAVE;
  END IF;

  --=====================================================
  -- Loop through the text passed
  -- saving a line after each newline character
  -- a line is a max of 4000 bytes long
  --=====================================================
  SET v_line_no = 0;
  SET v_start = 0;
  SET v_end = 0;
  SET v_lined = '';
  SET v_stmt_no = 0;

  WHILE v_stmt_no <= 7 DO

    SET v_step = 30;

    IF v_start < v_end THEN
      SET v_size = (v_end - v_start) + 1;
      SET v_lined = SUBSTR(v_lined,v_start,v_size);
    ELSE
      SET v_lined = '';
    END IF;

    IF v_stmt_no = 0 THEN
      SET v_lined = p_lines0;
    ELSEIF v_stmt_no = 1 THEN
      SET v_lined = v_lined||p_lines1;
    ELSEIF v_stmt_no = 2 THEN
      SET v_lined = v_lined||p_lines2;
    ELSEIF v_stmt_no = 3 THEN
      SET v_lined = v_lined||p_lines3;
    ELSEIF v_stmt_no = 4 THEN
      SET v_lined = v_lined||p_lines4;
    ELSEIF v_stmt_no = 5 THEN
      SET v_lined = v_lined||p_lines5;
    ELSEIF v_stmt_no = 6 THEN
      SET v_lined = v_lined||p_lines6;
    ELSEIF v_stmt_no = 7 THEN
      SET v_lined = v_lined||p_lines7;
    END IF;

    SET v_start = 1;
    SET v_end = COALESCE(CHAR(v_lined),0);
    SET v_step = 40;

    IF v_end < v_start THEN
      SET v_loop = 0;
    ELSE
      SET v_loop = 1;
    END IF;

    WHILE v_loop = 1 DO

      SET v_step = 50;
      SET v_pos = v_start + INDEX(SUBSTR(v_lined,v_start),'0A'xc) - 1;
      SET v_step = 60;

      IF v_pos < v_start THEN

        SET v_loop = 0 ;

      ELSE

        SET v_step = 70;
        SET v_size = (v_pos - v_start) + 1;

        -- Maximum of 4000 characters in a line
        IF v_size > 4000 THEN
          SET v_size = 4000;
        END IF;

        SET v_stmt = SUBSTR(v_lined,v_start,v_size);
        SET v_step = 80;
        SET v_line_no = v_line_no + 1;
        SET v_step = 90;

        INSERT INTO [METABASE].ws_zt_pro_line
        ( pl_obj_key
        , pl_line_no
        , pl_line)
        VALUES
        ( :p_obj_key
        , :v_line_no
        , :v_stmt);

        SET v_start = v_pos + 1;
        SET v_step = 100;

        IF v_start >= v_end THEN
          SET v_loop = 0;
        END IF;

      END IF;

    END WHILE;

    SET v_stmt_no = v_stmt_no + 1;

  END WHILE;

  END TRANSACTION;

  SET v_step = 900;
  SET p_result = v_line_no;
  SET p_ret_msg = 'procedure saved';

END;
_PROCEDWSL_ WsWrkAudit 
CREATE PROCEDURE _DATABASE_WsWrkAudit
( IN  p_status_code   varchar(1)
, IN  p_job_name      varchar(64)
, IN  p_task_name     varchar(64)
, IN  p_sequence      integer
, IN  p_message       varchar(1024)
, IN  p_db_code       varchar(10)
, IN  p_db_msg        varchar(1024)
, IN  p_task_key      integer
, IN  p_job_key       integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   Teradata
  -- Script Name   :   WsWrkAudit.sql
  -- Description   :   Writes row to audit log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History:
  -- Inserts messages into the ws_wrk_audit_log table
  -- Called by the scheduler or ws_job_execute when ever a task completes.
  -- Also called by procedures wishing to log additional information.
  -- Passed the following parameters:
  --
  -- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
  --                                       (W)arning, (E)rror, (F)atal
  -- job_name           - Name of the Job, or some other name for result grouping
  -- task_name          - Name of the procedure or Task or procedure
  -- sequence           - Sequence number of the run
  -- message            - Textual message to be placed in the audit log
  -- rdbms_code         - The database error code if appropriate
  -- rdbms_msg          - The database message if appropriate
  -- task_id            - Key to the pms scheduler task
  -- job_id             - Key to the pms scheduler job
  --
  -- ============================================================================
  -- Calling:
  -- CALL WsWrkAudit(v_status_code, v_job_name, v_task_name, v_sequence,
  --                  v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key);
  -- ============================================================================
  -- WMR  22/01/2002   Version 1.0.0
  -- WMR  01/08/2003   Version 4.1.0    Added insert of wa_row_number
  -- JML  21/09/2004   Version 4.1.0    First Teradata Version
  -- WMR  12/09/2005   Version 5.0.0    Teradata Version
  -- HM   09/01/2017   Version 6.8.7.0  RED-7676 Fix for blocking on scheduled tasks due to all-row scan
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  DECLARE v_okay_count    integer;
  DECLARE v_info_count    integer;
  DECLARE v_warn_count    integer;
  DECLARE v_error_count   integer;
  DECLARE v_return        integer;
  DECLARE v_return_status integer;
  DECLARE v_lock_result   integer;


  DECLARE EXIT HANDLER
  FOR SQLEXCEPTION
  BEGIN
    SET v_return = -3;
  END;



  SET v_okay_count    = 0;
  SET v_info_count    = 0;
  SET v_warn_count    = 0;
  SET v_error_count   = 0;


  -- =========================================================================
  -- Insert the message into the audit log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  SET v_return = 1;

  INSERT INTO _DATABASE_ws_wrk_audit_log
  ( wa_time_stamp
  , wa_sequence
  , wa_job
  , wa_task
  , wa_status
  , wa_message
  , wa_db_msg_code
  , wa_db_msg_desc
  , wa_task_key
  , wa_job_key
  , wa_row_number
  )
  VALUES
  ( CURRENT_TIMESTAMP
  , :p_sequence
  , :p_job_name
  , :p_task_name
  , :p_status_code
  , :p_message
  , :p_db_code
  , :p_db_msg
  , :p_task_key
  , :p_job_key
  , NULL
  );


 -- =========================================================================
  -- If the task or job key is not zero we need to know which counter to increment
  -- =========================================================================

  IF p_task_key <> 0 OR p_job_key <> 0 THEN
    IF p_status_code = 'S' THEN
     SET v_okay_count = 1;
    ELSEIF p_status_code = 'I' THEN
      SET v_info_count = 1;
    ELSEIF p_status_code = 'W' THEN
      SET v_warn_count = 1;
    ELSEIF p_status_code = 'E' THEN
       SET v_error_count = 1;
    ELSEIF p_status_code = 'F' THEN
      SET v_error_count = 1;
    END IF;
  END IF;

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF p_task_key <> 0 THEN
    UPDATE _DATABASE_ws_wrk_task_run
    SET
    wtr_info_count = wtr_info_count + :v_info_count
    , wtr_warning_count = wtr_warning_count + :v_warn_count
    WHERE wtr_task_key = :p_task_key
    AND   wtr_job_key = :p_job_key
    AND   wtr_sequence = :p_sequence;
  END IF;

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF p_job_key <> 0 THEN
    UPDATE _DATABASE_ws_wrk_job_run
    SET
    wjr_okay_count = wjr_okay_count + :v_okay_count
    , wjr_info_count = wjr_info_count + :v_info_count
    , wjr_warning_count = wjr_warning_count + :v_warn_count
    , wjr_error_count = wjr_error_count + :v_error_count
    WHERE wjr_job_key = :p_job_key
    AND   wjr_sequence = :p_sequence;
  END IF;

END;
_PROCEDWSL_ WsWrkError 
REPLACE PROCEDURE _DATABASE_WsWrkError
 ( IN  p_status_code   VARCHAR(1)
 , IN  p_job_name      VARCHAR(64)
 , IN  p_task_name     VARCHAR(64)
 , IN  p_sequence      INTEGER
 , IN  p_message       VARCHAR(1024)
 , IN  p_db_code       VARCHAR(10)
 , IN  p_db_msg        VARCHAR(1024)
 , IN  p_task_key      INTEGER
 , IN  p_job_key       INTEGER
 , IN  p_msg_type      VARCHAR(10))


BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   Teradata
  -- Script Name   :   WsWrkError.sql
  -- Description   :   Writes row to error/detail log and if applicable to job_run and task_run
  -- Author        :   Wayne Richmond
  -- Date          :   2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History:
  -- Inserts messages into the ws_wrk_error_log table
  -- Called by procedures wishing to log additional information.
  -- Passed the following parameters:
  --
  -- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
  --                                       (W)arning, (E)rror, (F)atal
  -- job_name           - Name of the Job, or some other name for result grouping
  -- task_name          - Name of the procedure or Task or procedure
  -- sequence           - Sequence number of the run
  -- message            - Textual message to be placed in the audit log
  -- rdbms_code         - The database error code if appropriate
  -- rdbms_msg          - The database message if appropriate
  -- task_id            - Key to the pms scheduler task
  -- job_id             - Key to the pms scheduler job
  -- msg_type           - Code to indicate the type of error message
  --
  -- ============================================================================
  -- Calling:
  -- CALL WsWrkAudit(v_status_code, v_job_name, v_task_name, v_sequence,
  --                 v_message, v_rdbms_code, v_rdbms_msg, v_task_key, v_job_key,
  --                 v_pmg_type);
  -- ============================================================================
  -- WMR  22/01/2002   Version 1.0.0
  -- WMR  06/11/2003   Version 4.1.0.5  Made three separate transactions for insert/updates
  -- WMR  12/09/2005   Version 5.0.0    Teradata Version
  -- KNH  28/11/2017   Version 8.0.2.0  RED-8679 include PI column in predicate for ws_wrk_task_run updates
  -- FS   05/12/2017                    RED-9068 resolve deadlock issues
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  DECLARE v_okay_count    integer;
  DECLARE v_info_count    integer;
  DECLARE v_warn_count    integer;
  DECLARE v_error_count   integer;
  DECLARE v_return        integer;
  DECLARE v_return_status integer;
  DECLARE v_lock_result   integer;
  DECLARE v_update_jobkey varchar(500);
  DECLARE v_update_task   VARCHAR(500);   --  JWH 8 Sept 2017


  DECLARE EXIT HANDLER
  FOR SQLEXCEPTION
  BEGIN
    SET v_return = -3;
  END;



  SET v_okay_count    = 0;
  SET v_info_count    = 0;
  SET v_warn_count    = 0;
  SET v_error_count   = 0;


  -- =========================================================================
  -- Insert the message into the audit log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  SET v_return = 1;

  INSERT INTO _DATABASE_ws_wrk_error_log
  ( wd_time_stamp
  , wd_sequence
  , wd_job
  , wd_task
  , wd_status
  , wd_message
  , wd_db_msg_code
  , wd_db_msg_desc
  , wd_task_key
  , wd_job_key
  , wd_msg_type_code
  , wd_row_number
  )
  VALUES
  ( CURRENT_TIMESTAMP
  , :p_sequence
  , :p_job_name
  , :p_task_name
  , :p_status_code
  , :p_message
  , :p_db_code
  , :p_db_msg
  , :p_task_key
  , :p_job_key
  , :p_msg_type
  , NULL
  );


  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF p_task_key <> 0 THEN
     SET v_update_task = 'UPDATE _DATABASE_ws_wrk_task_run SET wtr_detail_count = wtr_detail_count + 1 ' -- 8 Sept 2017
      || ' WHERE wtr_task_key = '  || p_task_key || ' AND   wtr_job_key = ' || p_job_key                 -- 8 Sept 2017
      || ' AND   wtr_sequence = ' || p_sequence || ';'                                                   -- 8 Sept 2017
     ;

    CALL DBC.SysExecSQL (:v_update_task);

  END IF;

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================
  IF p_job_key <> 0 THEN
   SET v_update_jobkey =  'UPDATE _DATABASE_ws_wrk_job_run SET  wjr_detail_count = wjr_detail_count + 1 '      -- JWH 1 Sept 2017
    || ' WHERE wjr_job_key =  ' || p_job_key || ' AND   wjr_sequence = ' || p_sequence || ';'                  -- JWH 8 Sept 2017

  ;

   CALL DBC.SysExecSQL (:v_update_jobkey);       --  JWH 1 Sept 2017
  END IF;

END;
_PROCEDWSL_ WsWrkTask 
CREATE PROCEDURE _DATABASE_WsWrkTask
( IN p_job_key        integer
, IN p_task_key       integer
, IN p_sequence       integer
, IN p_inserted       integer
, IN p_updated        integer
, IN p_replaced       integer
, IN p_deleted        integer
, IN p_discarded      integer
, IN p_rejected       integer
, IN p_errored        integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   Teradata
  -- Script Name   :   WsWrkTask.sql
  -- Description   :   Updates info in the task run record
  -- Author        :   Wayne Richmond
  -- Date          :   26 November 2003
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2017
  -- =============================================================================
  -- Notes / History:
  -- ============================================================================
  -- WMR  12/09/2005   Teradata Version (version 5.0.0)
  -- AD   28/11/2017   Version 8.0.2.0  RED-8685 Resolve deadlock issue

  DECLARE v_return        integer;
  DECLARE v_return_status integer;
  DECLARE v_lock_result   integer;

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2017

  SET v_return = 0;
  -- =========================================================================
  -- If the job, task or sequence are zero then probably run interactively
  -- and not as part of a job so return a warning
  -- =========================================================================
  IF p_task_key = 0 OR p_job_key = 0 OR p_sequence = 0 THEN
    SET v_return = -1;
  END IF;

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================
  IF p_task_key <> 0 THEN
    UPDATE _DATABASE_ws_wrk_task_run
    SET
      wtr_rec_inserted =  :p_inserted
    , wtr_rec_updated =   :p_updated
    , wtr_rec_replaced =  :p_replaced
    , wtr_rec_deleted =   :p_deleted
    , wtr_rec_discarded = :p_discarded
    , wtr_rec_rejected =  :p_rejected
    , wtr_rec_errored =   :p_errored
    WHERE wtr_job_key  = :p_job_key
    AND   wtr_task_key = :p_task_key
    AND   wtr_sequence = :p_sequence;
  END IF;

END;










_PROCEDWSL_ WsWrkAuditBulk 
CREATE PROCEDURE [METABASE].WsWrkAuditBulk (
  IN  p_status_code      VARCHAR(64)
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_sequence         INTEGER
, IN  p_message          VARCHAR(61440)
, IN  p_db_code          VARCHAR(10)
, IN  p_db_msg           VARCHAR(1024)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, OUT p_result           INTEGER)

WsWrkAuditBulk:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : WsWrkAuditBulk
  -- Description         : Writes rows to audit log multiple rows in a single call
  -- Author              : Wayne Richmond
  -- Date                : 2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- in a single call, delimited by ASCII 10.
  -- Passed the following parameters:
  --
  -- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
  --                                       (W)arning, (E)rror, (F)atal
  -- job_name           - Name of the Job, or some other name for result grouping
  -- task_name          - Name of the procedure or Task or procedure
  -- sequence           - Sequence number of the run
  -- message            - Textual message to be placed in the audit log
  -- db_code            - The database error code if appropriate
  -- db_msg             - The database message if appropriate
  -- task_id            - Key to the pms scheduler task
  -- job_id             - Key to the pms scheduler job
  -- result             - The return code (1=success, -1=warning, -2=error, -3=fatal error)
  -- ============================================================================
  -- Calling:
  -- CALL [METABASE].WsWrkAuditBulk(:p_status_code,:p_job_name,:p_task_name,:p_sequence
  --             ,:p_message,:p_db_code,:p_db_msg,:p_task_id,:p_job_id,:v_result);
  -- ============================================================================
  -- WMR  22/01/2002   Version 1.0.0.0
  -- WMR  01/08/2003   Version 4.1.0.0  added insert of wa_row_number
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- JML  29/03/2011   Version 6.5.4.1  RED_2071 Corrected Issue with incorrect parsing
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- KNH  29/11/2017   Version 8.0.2.0  RED-8679 include PI column in predicate for ws_wrk_task_run updates
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_okay_count               INTEGER;
  DECLARE v_info_count               INTEGER;
  DECLARE v_warn_count               INTEGER;
  DECLARE v_error_count              INTEGER;
  DECLARE v_row_count                INTEGER;
  DECLARE v_stmt                     VARCHAR(1024);
  DECLARE v_return                   INTEGER;
  DECLARE v_pos                      INTEGER;
  DECLARE v_loop                     INTEGER;
  DECLARE v_start                    INTEGER;
  DECLARE v_end                      INTEGER;
  DECLARE v_size                     INTEGER;
  DECLARE v_tilde                    INTEGER;
  DECLARE v_rows                     INTEGER;
  DECLARE v_work                     VARCHAR(61440);
  DECLARE v_update                   varchar(500);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in WsWrkAuditBulk. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.0.2.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;
  SET v_okay_count               = 0;
  SET v_info_count               = 0;
  SET v_warn_count               = 0;
  SET v_error_count              = 0;
  SET v_row_count                = 0;
  SET v_return                   = 1;
  SET v_tilde                    = 0;
  SET v_rows                     = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2017

  SET v_step = 100;

  -- =========================================================================
  -- Insert the messages into the audit log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  --=====================================================
  -- Loop through the text passed
  -- saving a line after each newline charachter
  -- a line is a max of 256 bytes long
  --=====================================================
  SET v_loop = 1;
  SET v_start = 1;
  SET v_end = CHAR(p_message);

  SET v_step = 200;

  WHILE ( v_loop = 1 )
  DO

    SET v_step = 300;

    SET v_work = SUBSTR(p_message,v_start,CHAR(p_message)-v_start+1);

-- JML  29/03/2011
-- SET v_pos = INDEX(v_work,X'10') + v_start - 1;
    SET v_pos = INDEX(v_work,X'10');

    IF ( COALESCE(v_pos,0) < 1 ) THEN

-- JML  29/03/2011
-- SET v_pos = INDEX(v_work,'~') + v_start - 1;
      SET v_pos = INDEX(v_work,'~');

      IF ( COALESCE(v_pos,0) >= 1 ) THEN

        SET v_tilde = 1;

      ELSE

        SET v_tilde = 0;

      END IF;

    ELSE

      SET v_tilde = 0;

    END IF;

    SET v_step = 400;

    IF ( COALESCE(v_pos,0) < 1 ) THEN

      SET v_size = COALESCE(CHAR(p_message),-1);
      SET v_loop = 0;
      SET v_size = (v_size - v_start);

      IF ( v_tilde = 0 ) THEN

        SET v_size = v_size + 1;

      END IF;

      IF ( v_size > 0 ) THEN

        -- Maximum of 1024 characters in a line
        IF ( v_size > 1024 ) THEN

          SET v_size = 1024;

        END IF;

        SET v_stmt = SUBSTR(p_message,v_start,v_size);

        SET v_step = 500;

        SET v_row_count = v_row_count + 1;

        SET v_step = 600;

        INSERT INTO [METABASE].ws_wrk_audit_log
        ( wa_time_stamp
        , wa_sequence
        , wa_job
        , wa_task
        , wa_status
        , wa_message
        , wa_db_msg_code
        , wa_db_msg_desc
        , wa_task_key
        , wa_job_key
        , wa_row_number)
        VALUES
        ( CURRENT_TIMESTAMP
        , :p_sequence
        , :p_job_name
        , :p_task_name
        , :p_status_code
        , :v_stmt
        , :p_db_code
        , :p_db_msg
        , :p_task_id
        , :p_job_id
        , NULL)
        ;

      END IF;

    ELSE

      SET v_step = 700;

-- JML  29/03/2011
-- SET v_size = (v_pos - v_start);
      SET v_size = (v_pos - 1);

      -- Maximum of 1024 characters in a line
      IF ( v_size > 1024 ) THEN

        SET v_size = 1024;

      END IF;

      SET v_stmt = SUBSTR(p_message,v_start,v_size);

      SET v_step = 800;

      SET v_row_count = v_row_count +1;

      SET v_step = 900;

      INSERT INTO [METABASE].ws_wrk_audit_log
      ( wa_time_stamp
      , wa_sequence
      , wa_job
      , wa_task
      , wa_status
      , wa_message
      , wa_db_msg_code
      , wa_db_msg_desc
      , wa_task_key
      , wa_job_key
      , wa_row_number)
      VALUES
      ( CURRENT_TIMESTAMP
      , :p_sequence
      , :p_job_name
      , :p_task_name
      , :p_status_code
      , :v_stmt
      , :p_db_code
      , :p_db_msg
      , :p_task_id
      , :p_job_id
      , NULL)
      ;

-- JML  29/03/2011
-- SET v_start = v_pos + 1;
      SET v_start = v_start + v_pos;

      SET v_step = 1000;

      IF ( v_start >= v_end ) THEN

        SET v_loop = 0;

      END IF;

    END IF;

    -- only allow a maximum of 1000 rows from one task to
    -- prevent a blowout of the audit trail.
    SET v_rows = v_rows + 1;

    IF ( v_rows > 999 ) THEN

      SET v_loop = 0;

      SET v_stmt = 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkAuditBulk';

      INSERT INTO [METABASE].ws_wrk_audit_log
      ( wa_time_stamp
      , wa_sequence
      , wa_job
      , wa_task
      , wa_status
      , wa_message
      , wa_db_msg_code
      , wa_db_msg_desc
      , wa_task_key
      , wa_job_key
      , wa_row_number)
      VALUES
      ( CURRENT_TIMESTAMP
      , :p_sequence
      , :p_job_name
      , :p_task_name
      , :p_status_code
      , :v_stmt
      , :p_db_code
      , :p_db_msg
      , :p_task_id
      , :p_job_id
      , NULL)
      ;

    END IF;

  END WHILE;

  -- =========================================================================
  -- If the task or job key is not zero we need to know which counter to increment
  -- =========================================================================

  IF (( p_task_id <> 0 ) OR ( p_job_id <> 0 )) THEN

    IF ( p_status_code  = 'S' ) THEN

      SET v_okay_count = v_row_count;

    ELSEIF ( p_status_code  = 'I' ) THEN

      SET v_info_count = v_row_count;

    ELSEIF ( p_status_code  = 'W' ) THEN

      SET v_warn_count = v_row_count;

    ELSEIF ( p_status_code  = 'E' ) THEN

      SET v_error_count = v_row_count;

    ELSEIF ( p_status_code  = 'F' ) THEN

      SET v_error_count = v_row_count;

    END IF;

  END IF;

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================

  IF ( p_task_id <> 0 ) THEN

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN

          SET v_return = -1;

        END;

      SET v_update = 'UPDATE [METABASE].ws_wrk_task_run
      SET wtr_info_count = wtr_info_count + ' || v_info_count ||
      ', wtr_warning_count = wtr_warning_count + ' || v_warn_count ||
      'WHERE  wtr_task_key = ' || p_task_id ||
      'AND    wtr_sequence = ' || p_sequence ||
      'AND    wtr_job_key = ' || p_job_id || ';'
      ;

      CALL DBC.SysExecSQL (:v_update);

    END;

  END IF;

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================

  IF ( p_job_id <> 0 ) THEN

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN

          SET v_return = -1;

        END;

      UPDATE [METABASE].ws_wrk_job_run
      SET    wjr_okay_count = wjr_okay_count + :v_okay_count
           , wjr_info_count = wjr_info_count + :v_info_count
           , wjr_warning_count = wjr_warning_count + :v_warn_count
           , wjr_error_count = wjr_error_count + :v_error_count
      WHERE  wjr_job_key = :p_job_id
      AND    wjr_sequence = :p_sequence
      ;

    END;

  END IF;

  SET p_result = v_return;   -- insert OK, or a warning on the update

END;
_PROCEDWSL_ WsWrkErrorBulk 
CREATE PROCEDURE [METABASE].WsWrkErrorBulk (
  IN  p_status_code      VARCHAR(64)
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_sequence         INTEGER
, IN  p_message          VARCHAR(61440)
, IN  p_db_code          VARCHAR(10)
, IN  p_db_msg           VARCHAR(1024)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, IN  p_msg_type         VARCHAR(10)
, OUT p_result           INTEGER)

WsWrkErrorBulk:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : WsWrkErrorBulk
  -- Description         : Writes rows to error log multiple rows in a single call
  -- Author              : Wayne Richmond
  -- Date                : 2 December 1996
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- in a sinlge call, delimited by ascii 10.
  -- Passed the following parameters:
  --
  -- status_code        - Normal codes are (B)egin, (I)nformation, (S)uccess,
  --                                       (W)arning, (E)rror, (F)atal
  -- job_name           - Name of the Job, or some other name for result grouping
  -- task_name          - Name of the procedure or Task or procedure
  -- sequence           - Sequence number of the run
  -- message            - Textual message to be placed in the error log
  -- db_code            - The database error code if appropriate
  -- db_msg             - The database message if appropriate
  -- task_id            - Key to the pms scheduler task
  -- job_id             - Key to the pms scheduler job
  -- result             - The return code (1=success, -1=warning, -2=error, -3=fatal error)
  -- ============================================================================
  -- Calling:
  -- CALL [METABASE].WsWrkErrorBulk(:p_status_code,:p_job_name,:p_task_name,:p_sequence
  --             ,:p_message,:p_db_code,:p_db_msg,:p_task_id,:p_job_id,:v_result);
  -- ============================================================================
  -- WMR  22/01/2002   Version 1.0.0.0
  -- WMR  01/08/2003   Version 4.1.0.0  added insert of wd_row_number
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- JML  29/03/2011   Version 6.5.4.1  RED_2071 Corrected Issue with incorrect parsing
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- KNH  29/11/2017   Version 8.0.2.0  RED-8679 include PI column in predicate for ws_wrk_task_run updates
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_okay_count               INTEGER;
  DECLARE v_info_count               INTEGER;
  DECLARE v_warn_count               INTEGER;
  DECLARE v_error_count              INTEGER;
  DECLARE v_row_count                INTEGER;
  DECLARE v_stmt                     VARCHAR(1024);
  DECLARE v_return                   INTEGER;
  DECLARE v_pos                      INTEGER;
  DECLARE v_loop                     INTEGER;
  DECLARE v_start                    INTEGER;
  DECLARE v_end                      INTEGER;
  DECLARE v_size                     INTEGER;
  DECLARE v_tilde                    INTEGER;
  DECLARE v_rows                     INTEGER;
  DECLARE v_work                     VARCHAR(61440);
  DECLARE v_update                   varchar(500);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in WsWrkErrorBulk. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;
  SET v_okay_count               = 0;
  SET v_info_count               = 0;
  SET v_warn_count               = 0;
  SET v_error_count              = 0;
  SET v_row_count                = 0;
  SET v_return                   = 1;
  SET v_tilde                    = 0;
  SET v_rows                     = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  -- =========================================================================
  -- Insert the messages into the error log. Catch all errors as we do not want to halt the
  -- calling procedure in the case of an insert failure
  -- =========================================================================

  --=====================================================
  -- Loop through the text passed
  -- saving a line after each newline character
  -- a line is a max of 256 bytes long
  --=====================================================
  SET v_loop = 1;
  SET v_start = 1;
  SET v_end = CHAR(p_message);

  SET v_step = 200;

  WHILE ( v_loop = 1 )
  DO

    SET v_step = 300;

    SET v_work = SUBSTR(p_message,v_start,CHAR(p_message)-v_start+1);

-- JML  29/03/2011
-- SET v_pos = INDEX(v_work,X'10') + v_start - 1;
    SET v_pos = INDEX(v_work,X'10');

    IF ( COALESCE(v_pos,0) < 1 ) THEN

-- JML  29/03/2011
-- SET v_pos = INDEX(v_work,'~') + v_start - 1;
      SET v_pos = INDEX(v_work,'~');

      IF ( COALESCE(v_pos,0) >= 1 ) THEN

        SET v_tilde = 1;

      ELSE

        SET v_tilde = 0;

      END IF;

    ELSE

      SET v_tilde = 0;

    END IF;

    SET v_step = 400;

    IF ( COALESCE(v_pos,0) < 1 ) THEN

      SET v_size = COALESCE(CHAR(p_message),-1);
      SET v_loop = 0;
      SET v_size = (v_size - v_start);

      IF ( v_tilde = 0 ) THEN

        SET v_size = v_size + 1;

      END IF;

      IF ( v_size > 0 ) THEN

        -- Maximum of 1024 characters in a line
        IF ( v_size > 1024 ) THEN

          SET v_size = 1024;

        END IF;

        SET v_stmt = SUBSTR(p_message,v_start,v_size);

        SET v_step = 500;

        SET v_row_count = v_row_count + 1;

        SET v_step = 600;

        INSERT INTO [METABASE].ws_wrk_error_log
        ( wd_time_stamp
        , wd_sequence
        , wd_job
        , wd_task
        , wd_status
        , wd_message
        , wd_db_msg_code
        , wd_db_msg_desc
        , wd_task_key
        , wd_job_key
        , wd_msg_type_code
        , wd_row_number)
        VALUES
        ( CURRENT_TIMESTAMP
        , :p_sequence
        , :p_job_name
        , :p_task_name
        , :p_status_code
        , :v_stmt
        , :p_db_code
        , :p_db_msg
        , :p_task_id
        , :p_job_id
        , :p_msg_type
        , NULL)
        ;

      END IF;

    ELSE

      SET v_step = 700;

-- JML  29/03/2011
-- SET v_size = (v_pos - v_start);
      SET v_size = (v_pos - 1);

      -- Maximum of 1024 characters in a line
      IF ( v_size > 1024 ) THEN

        SET v_size = 1024;

      END IF;

      SET v_stmt = SUBSTR(p_message,v_start,v_size);

      SET v_step = 800;

      SET v_row_count = v_row_count +1;

      SET v_step = 900;

      INSERT INTO [METABASE].ws_wrk_error_log
      ( wd_time_stamp
      , wd_sequence
      , wd_job
      , wd_task
      , wd_status
      , wd_message
      , wd_db_msg_code
      , wd_db_msg_desc
      , wd_task_key
      , wd_job_key
      , wd_msg_type_code
      , wd_row_number)
      VALUES
      ( CURRENT_TIMESTAMP
      , :p_sequence
      , :p_job_name
      , :p_task_name
      , :p_status_code
      , :v_stmt
      , :p_db_code
      , :p_db_msg
      , :p_task_id
      , :p_job_id
      , :p_msg_type
      , NULL)
      ;

-- JML  29/03/2011
-- SET v_start = v_pos + 1;
      SET v_start = v_start + v_pos;

      SET v_step = 1000;

      IF ( v_start >= v_end ) THEN

        SET v_loop = 0;

      END IF;

    END IF;

    -- only allow a maximum of 1000 rows from one task to
    -- prevent a blowout of the error trail.
    SET v_rows = v_rows + 1;

    IF ( v_rows > 999 ) THEN

      SET v_loop = 0;

      SET v_stmt = 'Maximum number of error rows reached. OUTPUT ABORTED by WsWrkErrorBulk';

      INSERT INTO [METABASE].ws_wrk_error_log
      ( wd_time_stamp
      , wd_sequence
      , wd_job
      , wd_task
      , wd_status
      , wd_message
      , wd_db_msg_code
      , wd_db_msg_desc
      , wd_task_key
      , wd_job_key
      , wd_msg_type_code
      , wd_row_number)
      VALUES
      ( CURRENT_TIMESTAMP
      , :p_sequence
      , :p_job_name
      , :p_task_name
      , :p_status_code
      , :v_stmt
      , :p_db_code
      , :p_db_msg
      , :p_task_id
      , :p_job_id
      , :p_msg_type
      , NULL)
      ;

    END IF;

  END WHILE;

  -- =========================================================================
  -- If the task or job key is not zero we need to know which counter to increment
  -- =========================================================================

  IF (( p_task_id <> 0 ) OR ( p_job_id <> 0 )) THEN

    IF ( p_status_code  = 'S' ) THEN

      SET v_okay_count = v_row_count;

    ELSEIF ( p_status_code  = 'I' ) THEN

      SET v_info_count = v_row_count;

    ELSEIF ( p_status_code  = 'W' ) THEN

      SET v_warn_count = v_row_count;

    ELSEIF ( p_status_code  = 'E' ) THEN

      SET v_error_count = v_row_count;

    ELSEIF ( p_status_code  = 'F' ) THEN

      SET v_error_count = v_row_count;

    END IF;

  END IF;

  -- =========================================================================
  -- If the task key is not zero attempt to update the counters in the task_run table.
  -- =========================================================================

  IF ( p_task_id <> 0 ) THEN

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN

          SET v_return = -1;

        END;

      SET v_update = 'UPDATE [METABASE].ws_wrk_task_run
      SET wtr_detail_count = wtr_detail_count + ' || v_warn_count ||
      'WHERE  wtr_task_key = ' || p_task_id ||
      'AND    wtr_sequence = ' || p_sequence ||
      'AND    wtr_job_key = ' || p_job_id || ';'
      ;

      CALL DBC.SysExecSQL (:v_update);

    END;

  END IF;

  -- =========================================================================
  -- If the job key is not zero attempt to update the counters in the job_run table.
  -- =========================================================================

  IF ( p_job_id <> 0 ) THEN

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN

          SET v_return = -1;

        END;

      UPDATE [METABASE].ws_wrk_job_run
      SET    wjr_detail_count = wjr_detail_count + :v_error_count
      WHERE  wjr_job_key = :p_job_id
      AND    wjr_sequence = :p_sequence
      ;

    END;

  END IF;

  SET p_result = v_return;   -- insert OK, or a warning on the update

END;
_PROCEDWSL_ WsWrkAuditL 
CREATE PROCEDURE [METABASE].WsWrkAuditL
( IN  p_status_code   varchar(1)
, IN  p_task_name     varchar(64)
, IN  p_sequence      integer
, IN  p_message       varchar(1024)
, IN  p_db_code       varchar(10)
, IN  p_db_msg        varchar(1024))

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   Teradata
  -- Script Name   :   WsWrkTaskL.sql
  -- Description   :   Updates info in the task run record for load tables
  --                   using task name and sequence.
  -- Author        :   Jason Laws
  -- Date          :   16 August 2006
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History:
  -- ============================================================================
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  
  DECLARE v_job_key       integer;
  DECLARE v_task_key      integer;
  DECLARE v_job_name      varchar(64);
  DECLARE v_return        integer;
  DECLARE v_return_status integer;
  DECLARE v_lock_result   integer;

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_return = 0;

  -- =========================================================================
  -- Get the job and task keys
  -- =========================================================================
  SELECT COALESCE(MAX(wtr_job_key),0)
       , COALESCE(MAX(wtr_task_key),0)
       , COALESCE(MAX(wjr_name),0)
  INTO   :v_job_key
       , :v_task_key
       , :v_job_name
  FROM   [METABASE].ws_wrk_task_run
       , [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = wtr_job_key
  AND    wtr_name = :p_task_name
  AND    wtr_sequence = :p_sequence
  AND    wtr_run_status = 'R'
  AND    wtr_action_type = 8
  AND    wtr_obj_type = 8;

  -- =========================================================================
  -- Call WsWrkTask
  -- =========================================================================
  CALL [METABASE].WsWrkAudit ( :p_status_code
  , :v_job_name
  , :p_task_name
  , :p_sequence
  , :p_message
  , :p_db_code
  , :p_db_msg
  , :v_task_key
  , :v_job_key);

END;
_PROCEDWSL_ WsWrkTaskL 
REPLACE PROCEDURE [METABASE].WsWrkTaskL
( IN p_sequence       integer
, IN p_task_name      varchar(64)
, IN p_inserted       integer
, IN p_updated        integer
, IN p_replaced       integer
, IN p_deleted        integer
, IN p_discarded      integer
, IN p_rejected       integer
, IN p_errored        integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name     :   Teradata
  -- Script Name   :   WsWrkTaskL.sql
  -- Description   :   Updates info in the task run record for load tables
  --                   using task name and sequence.
  -- Author        :   Jason Laws
  -- Date          :   16 August 2006
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- Notes / History:
  -- ============================================================================

  DECLARE v_job_key       integer;
  DECLARE v_task_key      integer;
  DECLARE v_return        integer;
  DECLARE v_return_status integer;
  DECLARE v_lock_result   integer;

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  SET v_return = 0;

  -- =========================================================================
  -- Get the job and task keys
  -- =========================================================================
  SELECT COALESCE(MAX(wtr_job_key),0)
       , COALESCE(MAX(wtr_task_key),0)
  INTO   :v_job_key
       , :v_task_key
  FROM   [METABASE].ws_wrk_task_run
  WHERE  wtr_name = :p_task_name
  AND    wtr_sequence = :p_sequence
  AND    wtr_run_status = 'R'
  AND    wtr_action_type = 8
  AND    wtr_obj_type = 8;

  -- =========================================================================
  -- Call WsWrkTask
  -- =========================================================================
  CALL [METABASE].WsWrkTask ( :v_job_key
  , :v_task_key
  , :p_sequence
  , :p_inserted
  , :p_updated
  , :p_replaced
  , :p_deleted
  , :p_discarded
  , :p_rejected
  , :p_errored);

END;
_PROCEDWSL_ WsParameterRead 
CREATE PROCEDURE _DATABASE_WsParameterRead
( IN  p_parameter    varchar(64)
, OUT p_value        varchar(2000)
, OUT p_comment      varchar(256))

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   Teradata
  -- Script Name    :   WsParameterRead.sql
  -- Description    :   Reads an entry from the parameter table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================
  -- Notes / History:
  --
  -- ============================================================================
  -- Calling:
  -- v_value := WsParameterRead(v_parameter_name);
  -- ============================================================================
  -- WMR  22/01/2002   Version 1.0.0  DECLARE
  -- WMR  14/09/2005   Version 5.0.0  Teradata port
  -- RS   17/08/2016   Version 6.8.6  Added locking to table select
  -- FS   07/06/2018   Version 8.2.1  Optimized query


  DECLARE v_return_status   integer;       -- Update result status
  DECLARE v_row_count       integer;       -- General row count

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  -- =========================================================================
  -- Select the parameter from the table and return the value
  -- =========================================================================
  SET p_value = NULL;
  SET p_comment = 'parameter not found';

  LOCK ROW FOR ACCESS
  SELECT
    dss_parameter_value
  , dss_parameter_comments
  INTO
    :p_value
  , :p_comment
  FROM
    _DATABASE_dss_parameter
  WHERE
    dss_parameter_name = TRIM(:p_parameter);


END;


_PROCEDWSL_ WsParameterReadG 
CREATE PROCEDURE [METABASE].WsParameterReadG (
  IN  p_parameter    VARCHAR(64)
, IN  p_job_id       INTEGER
, IN  p_task_id      INTEGER
, OUT p_value        VARCHAR(2000))

WsParameterReadG:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : WsParameterReadG
  -- Description         : Reads a Global parameter
  -- Author              : Wayne Richmond
  -- Date                : 14/01/2003
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- WMR  14/01/2003   Version 4.1.0.0
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(255);       -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(255);       -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_return_status            INTEGER;       -- Update result status
  DECLARE v_value                    VARCHAR(2000);
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_obj_type                 INTEGER;

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET p_value = '';
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '6.7.0.1';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;
  SET v_obj_key                  = 0;
  SET v_obj_type                 = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2008

  -- =========================================================================
  -- If the job number is zero then the task number is the object id
  -- otherwise we need to find the object from the task.
  -- =========================================================================
  IF (( p_job_id IS NULL ) OR ( p_job_id = 0 )) THEN

    SET v_obj_key = p_task_id;

  ELSE

    SELECT MAX(wtr_obj_key)
    INTO   :v_obj_key
    FROM   [METABASE].ws_wrk_task_run
    WHERE  wtr_task_key = :p_task_id
    AND    wtr_job_key = :p_job_id
    ;

  END IF;

  -- =========================================================================
  -- make sure we have a valid object key else quit
  -- =========================================================================
  IF (( v_obj_key IS NULL ) OR ( v_obj_key = 0 )) THEN

    SET p_value = '';

    LEAVE WsParameterReadG;  -- return null

  END IF;

  -- =========================================================================
  -- get the object type
  -- =========================================================================
  SELECT MAX(oo_type_key)
  INTO   :v_obj_type
  FROM   [METABASE].ws_obj_object
  WHERE  oo_obj_key = :v_obj_key
  ;

  -- =========================================================================
  -- make sure we have a valid object type else quit
  -- =========================================================================
  IF (( v_obj_type IS NULL ) OR ( v_obj_type  = 0 )) THEN

    SET p_value = '';

    LEAVE WsParameterReadG;  -- return null

  END IF;

  -- =========================================================================
  -- If the parameter is $$TABLE_NAME then return the table name
  -- =========================================================================
  IF ( UPPER(TRIM(p_parameter)) = '$$TABLE_NAME' ) THEN

    IF ( v_obj_type = v_ws_obj_load ) THEN

      SET v_value = '';

      SELECT lt_table_name
      INTO   :v_value
      FROM   [METABASE].ws_load_tab
      WHERE  lt_obj_key = :v_obj_key
      ;

      SET p_value = v_value;

      LEAVE WsParameterReadG;

    END IF;

  END IF;

  -- =========================================================================
  -- If the parameter is $$SOURCE_TABLE then return the source table
  -- =========================================================================
  IF ( UPPER(TRIM(p_parameter)) = '$$SOURCE_TABLE' ) THEN

    IF ( v_obj_type = v_ws_obj_load ) THEN

      SET v_value = '';

      SELECT MAX(lc_src_table)
      INTO   :v_value
      FROM   [METABASE].ws_load_col
      WHERE  lc_obj_key = :v_obj_key
      ;

      SET p_value = v_value;

      LEAVE WsParameterReadG;

    END IF;

  END IF;

  SET p_value = '';

END;
_PROCEDWSL_ WsParameterReadJ 
CREATE PROCEDURE [METABASE].WsParameterReadJ (
  IN  p_parameter        VARCHAR(256)
, IN  p_job_id           INTEGER
, OUT p_result           VARCHAR(2000))

WsParameterReadJ:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : WsParameterReadJ
  -- Description         : Reads job parameters
  -- Author              : Wayne Richmond
  -- Date                : 23/04/2004
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- WMR  23/04/2004   Version 4.1.0.8
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(255);       -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(255);       -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_value                    VARCHAR(2000);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET p_result = '';
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '6.7.0.1';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2008

  -- =========================================================================
  -- make sure we have a valid job key else quit
  -- =========================================================================
  IF (( p_job_id IS NULL ) OR ( p_job_id  = 0 )) THEN

    SET p_result = '';

    LEAVE WsParameterReadJ;

  END IF;

  -- =========================================================================
  -- If the parameter is NAME then return the job name
  -- =========================================================================
  IF ( UPPER(TRIM(p_parameter)) = 'NAME' ) THEN

    SET v_value = '';

    SELECT wjr_name
    INTO   :v_value
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_job_key = :p_job_id
    ;

    SET p_result = v_value;

    LEAVE WsParameterReadJ;

  END IF;

  SET p_result = '';

END;
_PROCEDWSL_ WsParameterWrite 
CREATE PROCEDURE _DATABASE_WsParameterWrite
( IN p_parameter    varchar(64)
, IN p_value        varchar(2000)
, IN p_comment      varchar(256))

BEGIN
 
  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ============================================================================
  -- DBMS Name      :   Teradata
  -- Script Name    :   WsParameterWrite.sql
  -- Description    :   Write or update an entry in the parameter table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2018
  -- =============================================================================
  -- Notes / History:
  --
  -- ============================================================================
  -- Calling:
  -- v_result := WsParameterWrite(v_parameter_name, v_value, v_comments);
  -- ============================================================================
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 14/09/2005  Version 5.0.0
  -- FS  07/06/2018  Version 8.2.1  Optimized queries


  DECLARE v_return_status   integer;       -- Update result status
  DECLARE v_row_count       integer;       -- General row count
  DECLARE v_result          integer;       -- result of the procedure
  DECLARE v_comment         varchar(256);  -- new comment value

  SET v_result = -3;

  -- =========================================================================
  -- Update or Insert the parameter
  -- =========================================================================
  UPDATE _DATABASE_dss_parameter
  SET
    dss_parameter_value = :p_value
  , dss_parameter_comments = COALESCE(:p_comment,dss_parameter_comments)
  WHERE
    dss_parameter_name = TRIM(:p_parameter);

  SET v_row_count = ACTIVITY_COUNT;

  IF v_row_count > 0 THEN
    SET v_result = 1;
  END IF;

  IF v_row_count = 0 THEN
    SET v_comment = p_comment;

    IF v_comment IS NULL THEN
      SET v_comment = 'Inserted via WsParameterWrite';
    END IF;

    INSERT INTO _DATABASE_dss_parameter
    ( dss_parameter_name
    , dss_parameter_value
    , dss_parameter_comments
    )
    VALUES
    ( TRIM(:p_parameter)
    , :p_value
    , :v_comment
    );

    SET v_result = 2;
  END IF;

END;
_PROCEDWSL_ Ws_Job_Abort 
CREATE PROCEDURE [METABASE].Ws_Job_Abort
( IN p_job_name           VARCHAR(64)
, IN p_job_sequence       INTEGER
, IN p_job_msg            VARCHAR(1024)
)
WS_JOB_ABORT:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name          	Teradata
  -- Script Name 			ws_job_abort
  -- Description 			Abort a job in a running state. Scheduler
  --                          can't find the job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 08/03/2002    Version 1.0.0
  -- WMR 06/11/2002    Version 1.2.1    Sql server port
  -- WMR 10/02/2004    Version 4.1.0    Put transactions around updates
  -- WMR 28/02/2005    Version 4.1.1.3  Handle jobs within jobs
  -- WMR 07/07/2006    Version 5.0.1.6  Changed lock check to > 0 from = 0
  -- AP   16/08/2006   Version 5.5.0.5  Implemented a lock timeout on the lock call
  --                                    this should help address locking issues
  -- WMR 14/09/2007    Version 5.6.1.1  DB2 port
  -- JML 01/09/2008    Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013    Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016    Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019    Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_row_count                INTEGER;
  DECLARE v_thread_count             INTEGER;
  DECLARE v_job_id                   INTEGER;
  DECLARE v_sid                      INTEGER;
  DECLARE v_rec_count                INTEGER;
  DECLARE v_job_msg                  VARCHAR(1024);

  --=====================================================
  -- Cursor to find all active tasks
  --=====================================================
  DECLARE c_Sid CURSOR FOR
    SELECT wjt_sid
    FROM   [METABASE].ws_wrk_job_thread
    WHERE  wjt_sequence = p_job_sequence
    ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Job_Abort Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_job_name, p_job_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, v_job_id);
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_thread_count = 0;
  SET v_job_id = 0;
  SET v_row_count = 0;
  SET v_rec_count = 0;
  SET v_job_id = 0;

  SET v_job_msg = COALESCE(p_job_msg,'');

  -- Get the job key for the job name. There should be one and
  -- only one key. Otherwise a fatal problem.
  SELECT wjr_job_key
  INTO   v_job_id
  FROM   [METABASE].ws_wrk_job_run
  WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(p_job_name))
  ;

  IF v_job_id = 0 OR v_job_id IS NULL THEN

    SET v_msgtext = 'Job ' || (COALESCE(p_job_name,'none')) ||
      ' passed invalid job name to Ws_Job Abort. Job does not exist. No Action.';
    CALL [METABASE].WsWrkAudit('E', p_job_name, p_job_name, p_job_sequence,
      v_msgtext, NULL, NULL, 0, v_job_id);

    LEAVE WS_JOB_ABORT;

  END IF;

  -- Make sure we are already running (i.e. have a job_run record)
  -- Otherwise a fatal problem.
  SELECT COUNT(1)
  INTO   v_rec_count
  FROM   [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = v_job_id
  AND    wjr_sequence = p_job_sequence
  ;

  IF v_rec_count = 0 OR v_rec_count IS NULL THEN

    SET v_msgtext = 'Job ' || (COALESCE(p_job_name,'none')) ||
      ' sequence ' || TRIM(CAST((COALESCE(p_job_sequence,-1)) AS VARCHAR(18))) ||
      ' not running. Cannot abort. No Action.';
    CALL [METABASE].WsWrkAudit('E', p_job_name, p_job_name, p_job_sequence,
      v_msgtext, NULL, NULL, 0, v_job_id);

    LEAVE WS_JOB_ABORT;

  END IF;

  -- Have the job id now hold any tasks not started
  --
  UPDATE [METABASE].ws_wrk_task_run
  SET   wtr_run_status = 'H'
  WHERE wtr_job_key = v_job_id
  AND   wtr_sequence = p_job_sequence
  AND   wtr_run_status = 'W'
  ;

  -- Flag the job as failed
  --
  UPDATE [METABASE].ws_wrk_job_run
  SET    wjr_status = 'F',
         wjr_completed = CURRENT_TIMESTAMP
  WHERE  wjr_job_key = v_job_id
  AND    wjr_sequence = p_job_sequence
  ;

  -- Fail any running tasks
  --
  UPDATE [METABASE].ws_wrk_task_run
  SET    wtr_run_status = 'F',
         wtr_completed = CURRENT_TIMESTAMP,
         wtr_return_msg = v_job_msg
  WHERE  wtr_job_key = v_job_id
  AND    wtr_sequence = p_job_sequence
  AND    wtr_run_status = 'R'
  ;

  --=====================================================
  -- Loop through the ready jobs
  -- We will just take the first one
  --=====================================================
  SET v_no_more_data1 = 0;

  BEGIN

    DECLARE CONTINUE HANDLER FOR NOT FOUND
      SET v_no_more_data1 = 1;

    OPEN c_Sid;

    FETCH FROM c_Sid INTO v_sid;

    WHILE v_no_more_data1 = 0 DO

      IF v_sid <> 0 THEN

        -- Output Process Not Killed for any running processes...

        SET v_msgtext = 'Process killing is not enabled for RED on Teradata.';
        CALL [METABASE].WsWrkAudit('W', p_job_name, p_job_name, p_job_sequence
          , v_msgtext, NULL, NULL, 0, v_job_id);

      END IF;

      FETCH FROM c_Sid INTO v_sid;

    END WHILE;

    CLOSE c_Sid;

  END;

  IF NULLIF(TRIM(v_job_msg),'') IS NOT NULL THEN

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_job_name, p_job_sequence,
      v_job_msg, NULL, NULL, 0, v_job_id);

  END IF;

  SET v_msgtext = 'Job '|| p_job_name || ' sequence ' ||
                  TRIM(CAST((COALESCE(p_job_sequence,-1)) AS VARCHAR(18))) || ' Aborted. ';

  CALL [METABASE].WsWrkAudit('F', p_job_name, p_job_name, p_job_sequence,
    v_msgtext, NULL, NULL, 0, v_job_id);

  LEAVE WS_JOB_ABORT;

END;
_PROCEDWSL_ Ws_Job_Check 
CREATE PROCEDURE [METABASE].Ws_Job_Check
( OUT p_job_count     INTEGER
, OUT p_pending_count INTEGER
, OUT p_job_list      VARCHAR(4000)
, OUT p_name_list     VARCHAR(4000)
, OUT p_seq_list      VARCHAR(4000)
)
WS_JOB_CHECK:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            	Teradata
  -- Script Name 			ws_job_check
  -- Description 			Check that jobs are running okay
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 08/03/2002 Version 1.0.0
  -- WMR 23/05/2002 Version 1.0.9    Restricted checking to only Unix jobs
  -- WMR 29/07/2002 Version 1.2.1    Enhanced checking to U% jobs (was UNIX%)
  -- WMR 01/03/2005 Version 4.1.1.3  Ignore all child jobs
  -- WMR 07/07/2008 Version 6.0.0.0  DB2
  -- JML 01/09/2008 Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- JML 14/12/2012 Version 6.7.0.1  RED_2747 Bug in While loop due to missing second fetch
  -- JML 14/12/2012 Version 6.7.0.1  RED_2748 Change UNIX proc name to be sequence_thread_job
  -- RS  14/02/2013 Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  DECLARE v_ws_pro_version           VARCHAR(15);

  --=====================================================
  -- General Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_job_count                INTEGER;
  DECLARE v_pending_count            INTEGER;
  DECLARE v_job_list                 VARCHAR(4000);
  DECLARE v_name_list                VARCHAR(4000);
  DECLARE v_seq_list                 VARCHAR(4000);

  --=====================================================
  -- Cursor Variables
  --=====================================================
  DECLARE v_wjr_name                 VARCHAR(64);
  DECLARE v_wjr_threads              INTEGER;
  DECLARE v_wjr_sequence             INTEGER;
  DECLARE v_wjr_job_key              INTEGER;


  --=====================================================
  -- Cursor for all running jobs
  -- Note wjr_chkp_count contains a parent job key if a child job
  --=====================================================
  DECLARE c_Running CURSOR FOR
    SELECT wjr_name, wjr_max_threads, wjr_sequence, wjr_job_key
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_status IN ('P','R')
    AND    COALESCE(wjr_chkp_count,0) = 0
    AND    UPPER(wjr_scheduler) LIKE 'U%'
    ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Job_Check '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      CALL [METABASE].WsWrkAudit('E', 'Ws_Job_Check', 'Scheduler', 0
        , v_msgtext, v_sql_code, v_sql_error, 0, 0);
      SET p_job_count = 0;
      SET p_pending_count = 0;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- MAIN
  --=====================================================
  SET v_job_count = 0;
  SET v_pending_count = 0;
  SET v_name_list = '~';
  SET v_seq_list = '~';
  SET v_job_list = '~';

  --=====================================================
  -- Loop through the running jobs
  --=====================================================
  SET v_no_more_data1 = 0;
  BEGIN

    DECLARE CONTINUE HANDLER FOR NOT FOUND
      SET v_no_more_data1 = 1;

    OPEN c_Running;

    FETCH FROM c_Running INTO
      v_wjr_name
    , v_wjr_threads
    , v_wjr_sequence
    , v_wjr_job_key;

    WHILE v_no_more_data1 = 0 DO

      SET v_job_count = v_job_count + 1;

      IF v_job_count = 1 THEN

        SET v_name_list = '';
        SET v_job_list = '';
        SET v_seq_list = '';

      ELSE

        SET v_name_list = v_name_list||',';
        SET v_job_list = v_job_list||',';
        SET v_seq_list = v_seq_list||',';

      END IF;

      SET v_name_list = v_name_list||v_wjr_name;
      SET v_seq_list = v_seq_list||CAST(v_wjr_sequence AS VARCHAR(18));
--      SET v_job_list = v_job_list||v_wjr_name||'_'||CAST(v_wjr_sequence AS VARCHAR(18));
      SET v_job_list = v_job_list||CAST(v_wjr_sequence AS VARCHAR(18))||'_000_'||v_wjr_name;

      FETCH FROM c_Running INTO
        v_wjr_name
      , v_wjr_threads
      , v_wjr_sequence
      , v_wjr_job_key;

    END WHILE;

    CLOSE c_Running;

  END;

  SET p_job_count = v_job_count;
  SET p_pending_count = v_pending_count;
  SET p_name_list = v_name_list;
  SET p_job_list = v_job_list;
  SET p_seq_list = v_seq_list;

END;
_PROCEDWSL_ Ws_Job_Dependency 
CREATE PROCEDURE [METABASE].Ws_Job_Dependency (
  IN  p_sequence         INTEGER
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, IN  p_action           VARCHAR(10)
, IN  p_parent           VARCHAR(64)
, IN  p_child            VARCHAR(64)
, IN  p_required         VARCHAR(1)
, IN  p_look_back        INTEGER
, IN  p_max_wait         INTEGER
, OUT p_return_code      VARCHAR(1)
, OUT p_return_msg       VARCHAR(1024)
, OUT p_result           INTEGER
)
WS_JOB_DEPENDENCY:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            Teradata
  -- Script Name          Ws_Job_Dependency
  -- Description          Maintain job dependencies
  -- Author               Wayne Richmond
  -- Date                 02/11/2006
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 02/11/2006  Version 5.5.0.6
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_action                   INTEGER;
  DECLARE v_existing                 INTEGER;

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Dependency. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;
  SET v_action                   = 0;
  SET v_existing                 = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************

  SET v_step = 100;

  IF UPPER(p_action) = 'ADD' THEN

    SET v_action = 1;

  ELSEIF UPPER(p_action) = 'DELETE' THEN

    SET v_action = 2;

  ELSE

    SET v_msgtext = 'Invalid action code. Valid actions are ADD and DELETE.';

    CALL [METABASE].WsWrkAudit('W', p_job_name, p_task_name, p_sequence
      , v_msgtext, '', '', p_task_id, p_job_id);

    SET p_return_msg = v_msgtext;
    SET p_return_code = 'E';
    SET p_result = -2;

    LEAVE Ws_Job_Dependency;

  END IF;

  --***********************************************************************
  -- Check to see if the entry is present
  --***********************************************************************
  SET v_step = 200;

  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_existing = 0;

      END;

    SET v_existing = 0;

    SELECT COUNT(*)
    INTO   v_existing
    FROM   [METABASE].ws_wrk_job_dependency
    WHERE  wjd_parent_job_name = p_parent
    AND    wjd_child_job_name = p_child
    ;

  END;

  --***********************************************************************
  -- If an Add then add a new record if not already present
  --***********************************************************************
  SET v_step = 300;

  IF v_action = 1 THEN

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Failed to insert entry into job dependency table.' ||
              '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          SET p_return_code = 'E';
          SET p_result = -2;
        END;

      IF v_existing = 1 THEN

        SET v_msgtext = 'Job Dependency already exists. Can not add.';

        CALL [METABASE].WsWrkAudit('W', p_job_name, p_task_name, p_sequence
          , v_msgtext, '', '', p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_return_code = 'W';
        SET p_result = -1;

        LEAVE Ws_Job_Dependency;

      END IF;

      INSERT INTO [METABASE].ws_wrk_job_dependency
      ( wjd_sequence
      , wjd_parent_job_name
      , wjd_child_job_name
      , wjd_first_check_lag
      , wjd_wait_interval
      , wjd_require_parent
      ) VALUES
      ( NULL
      , p_parent
      , p_child
      , p_look_back
      , p_max_wait
      , p_required)
      ;

    END;

  END IF;

  --***********************************************************************
  -- If a Delete then delete the record if present
  --***********************************************************************
  SET v_step = 400;

  IF v_action = 2 THEN

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Failed to delete entry from job dependency table.' ||
              '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          SET p_return_code = 'E';
          SET p_result = -2;
        END;

      IF v_existing = 0 THEN

        SET v_msgtext = 'Job Dependency does not exist. Can not delete.';
        CALL [METABASE].WsWrkAudit('W', p_job_name, p_task_name, p_sequence
          , v_msgtext, '', '', p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_return_code = 'W';
        SET p_result = -1;

        LEAVE Ws_Job_Dependency;

      END IF;

      DELETE FROM [METABASE].ws_wrk_job_dependency
      WHERE  wjd_parent_job_name = p_parent
      AND    wjd_child_job_name = p_child
      ;

    END;

  END IF;


  SET v_msgtext = 'Job ' || p_child || ' dependent on Job ' || p_parent || ' ' || p_action || 'ed';
  CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence
    , v_msgtext, '', '', p_task_id, p_job_id);

  SET p_return_msg = v_msgtext;
  SET p_return_code = 'S';
  SET p_result = 1;

END;
_PROCEDWSL_ WsParameterReplace 
CREATE PROCEDURE [METABASE].WsParameterReplace 
( IN  p_incoming   varchar(20000) 
, IN  p_max        integer 
, OUT p_return_value    varchar(32000) 
) 

BEGIN 

-- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

-- ============================================================================ 
-- DBMS Name      :   Teradata
-- Script Name    :   WsParameterReplace.sql
-- Description    :   Replaces occurrences of Parameters in a string
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
-- ============================================================================= 
-- Notes / History: 
-- 
-- ============================================================================ 
-- Calling: 
-- CALL [METABASE].WsParameterReplace(v_msgtext,20000,:v_msgtext); 
-- ============================================================================ 
-- AP  19/09/2006   Version 5.5.0.5 
-- AP  07/11/2006   Version 5.5.0.9  Ensure no replace of values in params 
--                                   Don't process as $P if has "'s around it 
--                                   Leave parameter name there if no value exits 
--                                   Decided to not use the "'s logic so force to not work    
-- AP  31/01/2006   Version 5.5.0.12 correct call to WsParameterRead for version 5 of Teradata 
-- AP  31/01/2006   Version 5.6.3.1  Increased size of variables
-- AP  20/07/2011   Version 6.5.4.1  When no param found continue search from after the found $P
--                                    previously it searched from after terminating $ and hence risked missing
--                                    the next $P
-- HM  31/07/2014   Version 6.8.1.1  Increased string limits


   DECLARE v_return_status   integer;       -- Update result status 
   DECLARE v_row_count       integer;       -- General row count 
   DECLARE v_work            VARCHAR(32000); 
   DECLARE v_work2           VARCHAR(32000); 
   DECLARE v_parameter       VARCHAR(32000); 
   DECLARE v_param_comment   VARCHAR(32000); 
   DECLARE v_spos            integer; 
   DECLARE v_epos            integer; 
   DECLARE v_qpos            integer; 
   DECLARE v_search_value    VARCHAR(32000); 
   DECLARE v_return_value    VARCHAR(32000); 

     DECLARE EXIT HANDLER 
     FOR SQLEXCEPTION 
     BEGIN 
       SET v_return_value = ''; 
       SET p_return_value = v_return_value; 
     END; 

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  SET v_return_value = ''; 
  SET v_search_value = p_incoming; 
  -- look for first $P 
  SET v_spos = POSITION('$P' IN v_search_value); 
  WHILE  v_spos > 0 
  DO 
    -- look for first double quote 
    SET v_qpos = 0; -- (forced removal of this check) POSITION('"' IN v_search_value); 

    -- Check if Quotes before or after the parameter 
    IF v_qpos < v_spos 
    AND v_qpos > 0 
    THEN     -- have double quotes somewhere before the first parameter 
      -- append upto the " 
      SET v_return_value = v_return_value || SUBSTR(v_search_value,1,v_qpos); 
      -- remove upto and including the quote from the search string 
      SET v_search_value = SUBSTR(v_search_value,v_qpos+1,CHAR_LENGTH(v_search_value)-v_qpos ); 

      -- find terminating quote 
      SET v_qpos = POSITION('"' IN v_search_value); 

      IF v_qpos > 0 
      THEN 
        -- append upto the " 
        SET v_return_value = v_return_value || SUBSTR(v_search_value,1,v_qpos); 
        -- remove upto and including the quote from the search string 
        SET v_search_value = SUBSTR(v_search_value,v_qpos+1,CHAR_LENGTH(v_search_value)-v_qpos ); 
      END IF; 

      -- look for anymore $P 
      SET v_spos = POSITION('$P' IN v_search_value); 

    ELSE 
      -- append upto the $P 
      SET v_return_value = v_return_value || SUBSTR(v_search_value,1,v_spos-1); 
      --remove upto and including the $P from the search string 
      SET v_search_value = SUBSTR(v_search_value,v_spos+2,CHAR_LENGTH(v_search_value)-v_spos-1); 

      --find terminating $ 
      SET v_epos = POSITION('$' IN v_search_value); 

      IF v_epos = 0 
      THEN 
        SET v_spos = 0; 
        SET v_return_value = v_return_value || '$P'; 
      ELSE 
        -- determine the parameter name 
        SET v_work = SUBSTR(v_search_value,1,v_epos-1); 

        -- extract the parameter value 
        CALL [METABASE].WsParameterRead(:v_work, :v_parameter, :v_param_comment); 

        IF v_parameter IS NULL 
        THEN 
           -- leave the search string alone and just append the $P to the return value
           SET v_return_value = v_return_value || '$P'; 
        ELSE
          -- append the parameter value 
          SET v_return_value = v_return_value || v_parameter; 

          -- remove upto terminating $ from the search string 
          SET v_search_value = SUBSTR(v_search_value,v_epos+1,CHAR_LENGTH(v_search_value)-v_epos); 
        END IF; 


        -- look for anymore $P 
        SET v_spos = POSITION('$P' IN v_search_value); 

      END IF; 
    END IF; 
  END WHILE; 

  -- Append rest of string 
  SET v_return_value = v_return_value || v_search_value; 

  -- If going to be too big then NULL it out to be handled on return 
  IF CHAR_LENGTH(v_return_value) > p_max THEN 
    SET v_return_value = NULL; 
  END IF; 

  SET p_return_value = v_return_value; 

END; 
_PROCEDWSL_ Ws_Job_Get_Start 
CREATE PROCEDURE [METABASE].Ws_Job_Get_Start
  (
  IN  pi_job_key       integer
 ,OUT po_start_after   timestamp
 ,OUT po_job_status    char(1)
 ,OUT po_result_code   integer
 ,OUT po_return_msg    varchar(1024)
  )
WS_JOB_GET_START:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      :    Teradata
  -- Script Name    :    Ws_Job_Starttime
  -- Description    :    Return next valid starttime for a job
  -- Author         :    Chris Lerew
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  --     Does NOT do any updates
  --     WARNING: integers being converted to INTERVALS can be no bigger than 99 or they fail.
  --     For Custom schedules, allows for StartAfter to be later than StartBefore.  i.e. exclusion period in the middle of the day.
  -- CJL 2009-06-23 Allow job_type = 'H' (same action as for 'S')
  -- AP  20100702  Version 6.1.1.1   RED_1670 - Change start before to 2400 if 0000 irrespective of start before
  -- JML 20110921  Version 6.5.4.2   RED_2357 - Add support for V2R6
  -- RS  20130214  Version 6.7.0.1   Changed Default Declaration to Variable Assignment
  -- BC  2015-04-23 Version 6.8.3.3  RED-4549 Change the daily, weekly, monthly, and annually calculations of the new 'start after' datetime
  --                                 to calculate from the old 'start after' datetime rather than from the current datetime.
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(50);

  --=====================================================
  -- Control variables
  --=====================================================
  DECLARE v_msgtext         varchar(1024); -- Text for audit_trail
  DECLARE v_step            integer;       -- return code
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_type           varchar(1);
  DECLARE v_start_after        timestamp;
  DECLARE v_start_hh           integer;
  DECLARE v_start_mi           integer;
  DECLARE v_start_day          integer;
  DECLARE v_cust_sa_hh         integer;
  DECLARE v_cust_sa_mm         integer;
  DECLARE v_cust_sb_hh         integer;
  DECLARE v_cust_sb_mm         integer;
  DECLARE v_cust_min           integer;
  DECLARE v_cust_days          integer;
  -- Variables for Custom schedule calculations
  DECLARE v_Cust_SDate         timestamp; -- Proposed Start, Date part only
  DECLARE v_Cust_SATime        timestamp; -- Start After  time on proposed date
  DECLARE v_Cust_SBTime        timestamp; -- Start Before time on proposed date
  DECLARE v_Cust_SADay         char(9);   -- Day of week of proposed date
  DECLARE v_Cust_SDayOK        integer;   -- 0 = Not scheduled on this day
  DECLARE v_more               integer;
  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET po_return_msg= v_ws_pro_version
                      || ' step '             || CAST(v_step AS VARCHAR(64))
                      || '  SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10))
                      || ' - '                || v_sql_error;
      SET po_start_after = CAST('9999-12-31' AS TIMESTAMP FORMAT 'YYYY-MM-DD');
      SET po_job_status  = 'H';
      SET po_result_code = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';

  --=====================================================
  -- MAIN
  --=====================================================

  SET v_step = 100;
  -- Set assumption for failure
  SET po_result_code = -3;
  SET po_start_after = CAST('9999-12-31' AS TIMESTAMP FORMAT 'YYYY-MM-DD');
  SET po_job_status  = 'H';
  SET po_return_msg  = v_ws_pro_version || ' Failed to determine next start for job key '
                      || CAST((CASE WHEN pi_job_key IS NULL THEN 0 ELSE pi_job_key END) as varchar(10));

  SET v_step = 200;
  SET v_job_type = NULL;
  SELECT wjc_type
       , wjc_start_hour
       , wjc_start_minute
       , wjc_start_day
       , COALESCE(wjc_cust_sa_hh,0)
       , COALESCE(wjc_cust_sa_mm,0)
       , COALESCE(wjc_cust_sb_hh,0)
       , COALESCE(wjc_cust_sb_mm,0)
       , COALESCE(wjc_cust_min,0)
       , COALESCE(wjc_cust_days,0)
       , wjc_start_after
  INTO   v_job_type
       , v_start_hh
       , v_start_mi
       , v_start_day
       , v_cust_sa_hh
       , v_cust_sa_mm
       , v_cust_sb_hh
       , v_cust_sb_mm
       , v_cust_min
       , v_cust_days
       , v_start_after
  FROM   [METABASE].ws_wrk_job_ctrl
  WHERE wjc_job_key = pi_job_key;

  IF v_job_type IS NULL
  THEN
    SET po_result_code = -2;
    SET po_return_msg  = v_ws_pro_version || ' Failed to find job for job key '
                        || CAST((CASE WHEN pi_job_key IS NULL THEN 0 ELSE pi_job_key END) as varchar(10));

    LEAVE WS_JOB_GET_START;
  END IF;

  SET v_step = 300;
  -- Assume custom range 0000 to 0000 is really 0000 to 2400 (all day)
  -- RED_1670
  -- IF  v_cust_sa_hh + v_cust_sa_mm = 0
  IF v_cust_sb_hh + v_cust_sb_mm = 0 THEN
    SET v_cust_sb_hh = 24;
  END IF;

  SET v_step = 400;
  SET po_job_status = 'W'; -- Default for most job types

  IF v_job_type IN ('H','S') THEN  -- Hold, or Once and Hold Schedule.

      SET v_start_after = CURRENT_TIMESTAMP;
      SET po_job_status = 'H';

  ELSEIF v_job_type = 'D' THEN -- Daily
      WHILE v_start_after < CURRENT_TIMESTAMP DO -- play catch up in case we got behind
		  SET v_start_after = CAST(CAST(v_start_after AS DATE) AS TIMESTAMP)
							 + INTERVAL '1' DAY   + CAST(v_start_hh AS INTERVAL HOUR) + CAST(v_start_mi AS INTERVAL MINUTE);
      END WHILE;

  ELSEIF v_job_type = 'W' THEN -- Weekly
      WHILE v_start_after < CURRENT_TIMESTAMP DO -- play catch up in case we got behind
		  SET v_start_after = CAST(CAST(v_start_after AS DATE) AS TIMESTAMP)
							 + INTERVAL '7' DAY   + CAST(v_start_hh AS INTERVAL HOUR) + CAST(v_start_mi AS INTERVAL MINUTE);
      END WHILE;

  ELSEIF v_job_type = 'M' THEN -- Monthly
      WHILE v_start_after < CURRENT_TIMESTAMP DO -- play catch up in case we got behind
		  SET v_start_after = CAST(CAST(v_start_after AS DATE) AS TIMESTAMP)
							 + INTERVAL '1' MONTH + CAST(v_start_hh AS INTERVAL HOUR) + CAST(v_start_mi AS INTERVAL MINUTE);
      END WHILE;

  ELSEIF v_job_type = 'A' THEN -- Annually
      WHILE v_start_after < CURRENT_TIMESTAMP DO -- play catch up in case we got behind
		  SET v_start_after = CAST(CAST(v_start_after AS DATE) AS TIMESTAMP)
							 + INTERVAL '1' YEAR  + CAST(v_start_hh AS INTERVAL HOUR) + CAST(v_start_mi AS INTERVAL MINUTE);
      END WHILE;

  ELSEIF v_job_type = 'C' THEN -- Custom

      SET v_step = 500;
      WHILE v_start_after < CURRENT_TIMESTAMP DO -- play catch up in case we got behind
        SET v_start_after = v_start_after -- Add first 'Interval' minutes for next proposed start date and time
                           + CAST(v_cust_min/60 AS INTERVAL HOUR) + CAST(v_cust_min MOD 60 AS INTERVAL MINUTE);
      END WHILE;

      SET v_more = 1;

      SET v_step = 600;
      WHILE v_more = 1 AND v_start_after < CURRENT_TIMESTAMP + INTERVAL '8' DAY DO -- Must be a mistake if we get over a week out with no match.
        SET v_Cust_SDate  = CAST(CAST(v_start_after AS DATE) AS TIMESTAMP);
        SET v_Cust_SADay  = CAST(CAST(v_start_after AS FORMAT 'E4') AS CHAR(9));
        SET v_Cust_SATime = v_Cust_SDate + CAST(v_cust_sa_hh AS INTERVAL HOUR) + CAST(v_cust_sa_mm AS INTERVAL MINUTE);
        SET v_Cust_SBTime = v_Cust_SDate + CAST(v_cust_sb_hh AS INTERVAL HOUR) + CAST(v_cust_sb_mm AS INTERVAL MINUTE);

        -- Check that the proposed Day is scheduled
        SET v_step = 700;
        SET v_Cust_SDayOK  = -- v_cust_days: Bit 1 is MON(=1), bit 2 TUE(=2), bit 3 WED(=4), bit 4 THU(=8) etc
          CASE               -- Equivalent to bitwise AND with v_cust_days. Equal to Zero if that day not scheduled
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-01' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 2  >= 1  THEN 1   --Monday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-02' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 4  >= 2  THEN 1   --Tuesday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-03' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 8  >= 4  THEN 1   --Wednesday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-04' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 16 >= 8  THEN 1   --Thursday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-05' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 32 >= 16 THEN 1   --Friday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-06' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days MOD 64 >= 32 THEN 1   --Saturday
            WHEN v_Cust_SADay = CAST(CAST(CAST('1900-01-07' AS TIMESTAMP FORMAT 'YYYY-MM-DD') AS FORMAT 'E4') AS CHAR(9))
             AND v_cust_days        >= 64 THEN 1   --Sunday
            ELSE 0
          END;

        -- Day not scheduled, skip to next day
        IF v_Cust_SDayOK = 0
        THEN
          SET v_start_after = v_Cust_SDate + INTERVAL '1' DAY;

        -- Exclusion period spans midnight. e.g. allow start After 2am and start Before 10pm
        ELSEIF v_Cust_SATime <= v_Cust_SBTime
        THEN
          SET v_step = 800;
          IF v_start_after < v_Cust_SATime      -- Prior to the Start After time
          THEN                                  -- so jump directly to the Start After time and exit loop
            SET v_start_after = v_Cust_SATime;
            SET v_more = 0;
          ELSEIF v_start_after > v_Cust_SBTime  -- Past the Start Before time
          THEN
            SET v_start_after = v_Cust_SDate + INTERVAL '1' DAY; -- so skip to the next day
          ELSE
            SET v_more = 0;                      -- Between valid start times so exit the loop
          END IF;

        -- Exclusion period does not span midnight. e.g. allow start Before 2am and start again After 3am
        ELSE  --v_Cust_SATime > v_Cust_SBTime
          SET v_step = 900;
          IF  v_start_after >  v_Cust_SBTime -- In exclusion period, jump to end of it, OK, exit loop
          AND v_start_after <  v_Cust_SATime
          THEN
            SET v_start_after = v_Cust_SATime;
            SET v_more = 0;
          ELSE                                -- Not in exclusion period, OK, so exit loop
            SET v_more = 0;
          END IF;
        END IF;

      END WHILE;

      IF v_start_after >= CURRENT_TIMESTAMP + INTERVAL '8' DAY
      THEN
        SET v_start_after = CAST('9999-12-31' AS TIMESTAMP FORMAT 'YYYY-MM-DD');
      END IF;
  -- end of v_job_Type = 'C'ustom

  ELSE -- Unknown schedule type.
      SET v_step = 1000;
      SET po_return_msg = v_ws_pro_version || ' Unknown schedule type ' ||
                          (CASE WHEN v_job_type IS NULL THEN 'Null' ELSE v_job_type END) ||
                          ', or unknown job key ' ||
                          CAST((CASE WHEN pi_job_key IS NULL THEN 0 ELSE pi_job_key END) as varchar(10));
      SET v_start_after = CAST('9999-12-31' AS TIMESTAMP FORMAT 'YYYY-MM-DD');
      SET po_result_code = -2;
      SET po_job_status  = 'H';
      LEAVE WS_JOB_GET_START;
  END IF; -- of CASE job_type

  SET po_start_after = v_start_after;
  SET po_result_code = 1;
  SET po_return_msg  = 'New job Start time assigned';

END;
_PROCEDWSL_ Ws_Job_Exec_Thread 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_Thread
( IN  pi_thread_action    varchar(12)
, IN  pi_job_key          integer
, IN  pi_sequence         integer
, IN  pi_thread           integer
, IN  pi_sid              integer
, OUT po_result_code      integer
)
WS_JOB_EXEC_THREAD:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_thread
  -- Description  Adds or removes a thread for a job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- RS  14/02/2013     Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(255);  -- Text for audit_trail
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(255);  -- SQL Error Code for Audit Trail as varchar
  DECLARE v_sid                      INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '6.7.0.1';

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  SET po_result_code = -2;

  IF pi_job_key > 0 AND pi_sid <> 0 THEN

    IF UPPER(pi_thread_action) = 'ADD' THEN

      SET v_sid = SESSION;

      INSERT INTO [METABASE].ws_wrk_job_thread
      ( wjt_job_key
      , wjt_sequence
      , wjt_thread
      , wjt_sid)
      VALUES
      ( pi_job_key
      , pi_sequence
      , pi_thread
      , pi_sid);

      SET po_result_code = 1;

    ELSEIF UPPER(pi_thread_action) = 'DELETE' THEN

      DELETE FROM [METABASE].ws_wrk_job_thread
      WHERE  wjt_job_key = pi_job_key
      AND    wjt_thread = pi_thread
      AND    wjt_sequence = pi_sequence
      AND    wjt_sid = pi_sid;

      SET po_result_code = 1;

    END IF;

  END IF;

END;
_PROCEDWSL_ Ws_Save_Script_Line 
CREATE PROCEDURE [METABASE].Ws_Save_Script_Line
( IN  p_script_key       INTEGER
, IN  p_line_no          INTEGER
, IN  p_line             VARCHAR(4000)
)
WS_SAVE_SCRIPT_LINE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    	:	Teradata
  -- Script Name 		:	Ws_Save_Script_Line
  -- Description 		:	Writes a script line into Ws_Scr_Line
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- Notes / History
  --
  -- JML 01/09/2008  Version 6.0.2.0

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_step            INTEGER;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET v_step = 100;
    END;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  -- Insert script line
  INSERT INTO [METABASE].ws_scr_line
  ( sl_obj_key
  , sl_line_no
  , sl_line)
  VALUES
  ( :p_script_key
  , :p_line_no
  , :p_line)
  ;

END;
_PROCEDWSL_ Ws_String_Replace 
CREATE PROCEDURE [METABASE].Ws_String_Replace
( IN  p_instr            varchar(20000)
, IN  p_oldstr           varchar(8000)
, IN  p_newstr           varchar(8000)
, OUT p_outstr           varchar(32000)
)
WS_STRING_REPLACE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    	Teradata
  -- Script Name 			Ws_String_Replace
  -- Description 			Replaces a value in a string with a new value.
  --                          Returns the new string in p_outstr.
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
  -- =============================================================================
  -- Notes / History
  --
  -- JML 01/09/2008  Version 6.0.2.0
  -- HM  31/07/2014  Version 6.8.1.1  Increased string limits
  -- RS  18/09/20154 Version 6.8.4.4  Fixed issue with NULL input string

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_work            VARCHAR(32000);
  DECLARE v_work2           VARCHAR(32000);
  DECLARE v_oldstr          VARCHAR(8000);
  DECLARE v_newstr          VARCHAR(8000);
  DECLARE v_start           VARCHAR(20000);
  DECLARE v_oldlen          INTEGER;
  DECLARE v_not_found       INTEGER;
  DECLARE i                 INTEGER;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET p_outstr = p_instr;
    END;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  SET v_work = p_instr;
  SET v_oldstr = p_oldstr;
  SET v_oldstr = NULLIF(v_oldstr,'');
  SET v_newstr = p_newstr;
  SET v_newstr = COALESCE(v_newstr,'');

  IF p_instr IS NULL THEN
  
    SET p_outstr = v_work;

  ELSEIF NULLIF(TRIM(v_oldstr),'') IS NULL THEN

    SET p_outstr = v_work;

  ELSE

    SET v_oldlen = CHAR(v_oldstr);

    SET v_not_found = 0;
    SET v_work2 = '';

    WHILE v_not_found = 0 DO

      SET i = INDEX(v_work,v_oldstr);

      IF i = 0 THEN

        SET v_not_found = 1;
        SET v_work2 = v_work2 || v_work;

      ELSE

        IF i = 1 THEN

          SET v_start = '';

        ELSE

          SET v_start = SUBSTR(v_work,1,i-1);

        END IF;

        SET v_work = SUBSTR(v_work,i+v_oldlen,CHAR(v_work)-v_oldlen-i+1);

        SET v_work2 = v_work2 || v_start || v_newstr;

      END IF;

    END WHILE;

    SET p_outstr = v_work2;

  END IF;

END;
_PROCEDWSL_ Ws_Object_Info 
CREATE PROCEDURE [METABASE].Ws_Object_Info
( IN  p_sequence        integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, IN  p_obj_key         integer
, IN  p_obj_name        varchar(64)
, IN  p_info_type       varchar(64)
, OUT p_return_code     varchar(1)
, OUT p_return_msg      varchar(1024)
, OUT p_result          integer
, OUT p_value           varchar(32000)
)
WS_OBJECT_INFO:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : Ws_Object_Info
  -- Description  : Returns request information regarding an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 24/01/2008  Version 5.6.3.1  First Version
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  15/06/2015  Version 6.8.4.2  RED_4810 Move from schema to database to allow target support
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- step number
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_obj_count                INTEGER;
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_obj_name                 VARCHAR(64);
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_info_type                VARCHAR(64);
  DECLARE v_database                 VARCHAR(64);
  DECLARE v_post_fix                 VARCHAR(4000);
  DECLARE v_pct_free                 INTEGER;
  DECLARE v_primary_index_unique     VARCHAR(1);
  DECLARE v_multiset_ind             VARCHAR(1);
  DECLARE v_fallback_ind             VARCHAR(1);
  DECLARE v_data_block_size          VARCHAR(64);
  DECLARE v_table_name               VARCHAR(64);
  DECLARE v_where                    VARCHAR(4000);
  DECLARE v_update_key               INTEGER;
  DECLARE v_build_key                INTEGER;
  DECLARE v_view_where               VARCHAR(4000);
  DECLARE v_type_ind                 VARCHAR(1);
  DECLARE v_attributes               VARCHAR(4000);
  DECLARE v_gen_spec                 VARCHAR(4000);
  DECLARE v_lock_mode                VARCHAR(24);
  DECLARE v_short_name               VARCHAR(22);
  DECLARE v_value                    VARCHAR(32000);

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Object_Info. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
    SET p_return_code = 'F';
    SET p_result = -3;
    SET p_value = '';
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_database                 = '';
  SET v_post_fix                 = '';
  SET v_pct_free                 = 0;
  SET v_primary_index_unique     = '';
  SET v_multiset_ind             = '';
  SET v_fallback_ind             = '';
  SET v_data_block_size          = '';
  SET v_table_name               = '';
  SET v_where                    = '';
  SET v_update_key               = 0;
  SET v_build_key                = 0;
  SET v_view_where               = '';
  SET v_type_ind                 = '';
  SET v_attributes               = '';
  SET v_gen_spec                 = '';
  SET v_lock_mode                = '';
  SET v_short_name               = '';

  --=====================================================
  -- Start
  --=====================================================

  SET v_step = 100;

  IF p_obj_key IS NOT NULL AND p_obj_key > 0 THEN

    SET v_step = 200;

    SELECT COUNT(*)
    INTO   :v_obj_count
    FROM   [METABASE].ws_obj_object
    WHERE  oo_obj_key = :p_obj_key
    ;

  ELSEIF NULLIF(TRIM(p_obj_name),'') IS NOT NULL THEN

    SET v_step = 300;

    SELECT COUNT(*)
    INTO   :v_obj_count
    FROM   [METABASE].ws_obj_object
    WHERE  LOWER(oo_name) = LOWER(:p_obj_name)
    ;

  ELSE

    SET v_step = 400;

    SET p_return_code = 'E';
    SET p_return_msg = 'Unable to check for object existance, either p_obj_key or p_obj_name must be specified.';
    SET p_result = -2;
    SET p_value = '';

  END IF;

  SET v_step = 500;

  IF v_obj_count = 1 THEN

    SET v_step = 600;

    IF p_obj_key IS NOT NULL AND p_obj_key > 0 THEN

      SET v_step = 700;

      SELECT oo_type_key
           , oo_name
      INTO   :v_obj_type
           , :v_obj_name
      FROM   [METABASE].ws_obj_object
      WHERE  oo_obj_key = :p_obj_key
      ;

      SET v_obj_key = p_obj_key;

    ELSEIF NULLIF(TRIM(p_obj_name),'') IS NOT NULL THEN

      SET v_step = 800;

      SELECT oo_obj_key
           , oo_type_key
      INTO   :v_obj_key
           , :v_obj_type
      FROM   [METABASE].ws_obj_object
      WHERE  LOWER(oo_name) = LOWER(:p_obj_name)
      ;

      SET v_obj_name = p_obj_name;

    ELSE

      SET v_step = 900;

      SET p_return_code = 'E';
   SET p_return_msg = 'Unable to check for object type, either p_obj_key or p_obj_name must be specified.';
      SET p_result = -2;
      SET p_value = '';

      LEAVE WS_OBJECT_INFO;

    END IF;

    SET v_obj_name = p_obj_name;

    IF UPPER(p_info_type) IN ('DATABASE','POST_FIX','PCT_FREE','PRIMARY_INDEX_UNIQUE','MULTISET_IND'
                             ,'FALLBACK_IND','DATA_BLOCK_SIZE','TABLE_NAME','WHERE','VIEW_WHERE'
                             ,'TYPE_IND','ATTRIBUTES','GEN_SPEC','LOCK_MODE','UPDATE_KEY','BUILD_KEY'
                             ,'SHORT_NAME','ALL') THEN

      SET v_info_type = p_info_type;

    ELSE

      SET v_step = 1000;

      SET v_info_type = p_info_type;
      SET p_return_code = 'E';
    SET p_return_msg = 'Object ' || v_obj_name || ' (object key ' || CAST(v_obj_key AS VARCHAR(18)) || ') is an object type ' || CAST(v_obj_type AS VARCHAR(18));
      SET p_return_msg = 'Invalid information type requested ('|| v_info_type || ').';
      SET p_result = -2;
      SET p_value = '';

      LEAVE WS_OBJECT_INFO;

    END IF;

    SET v_step = 1100;

    --**********************************
    -- L O A D
    --**********************************
    IF v_obj_type = v_ws_obj_load THEN

      SET v_step = 1200;

      SELECT NULLIF(COALESCE(dt_database, lt_tablespace),'')
           , TRIM(lt_post_fix)
           , COALESCE(lt_pct_free,0)
           , lt_primary_index_unique
           , lt_multiset_ind
           , lt_fallback_ind
           , UPPER(TRIM(lt_data_block_size))
           , lt_table_name
           , NULL
           , lt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_short_name
      FROM   [METABASE].ws_load_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON lt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  lt_obj_key = :v_obj_key;

    --**********************************
    -- F A C T   A N D   K P I   F A C T
    --**********************************
    ELSEIF (( v_obj_type = v_ws_obj_fact ) OR ( v_obj_type = v_ws_obj_fact_kpi )) THEN

      SET v_step = 1300;

      SELECT NULLIF(COALESCE(dt_database, ft_tablespace),'')
           , TRIM(ft_post_fix)
           , COALESCE(ft_pct_free,0)
           , ft_primary_index_unique
           , ft_multiset_ind
           , ft_fallback_ind
           , UPPER(TRIM(ft_data_block_size))
           , ft_table_name
           , NULL
           , ft_update_key
           , ft_build_key
           , ft_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_fact_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON ft_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  ft_obj_key = :v_obj_key;

    --**********************************
    -- A G G R E G A T E
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_agg THEN

      SET v_step = 1400;

      SELECT NULLIF(COALESCE(dt_database, at_tablespace),'')
           , TRIM(at_post_fix)
           , COALESCE(at_pct_free,0)
           , at_primary_index_unique
           , at_multiset_ind
           , at_fallback_ind
           , UPPER(TRIM(at_data_block_size))
           , at_table_name
           , NULL
           , at_update_key
           , at_build_key
           , at_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_agg_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON at_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  at_obj_key = :v_obj_key;

    --**********************************
    -- D I M E N S I O N
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_dim THEN

      SET v_step = 1500;

      SELECT NULLIF(COALESCE(dt_database, dt_tablespace),'')
           , TRIM(dt_post_fix)
           , COALESCE(dt_pct_free,0)
           , dt_primary_index_unique
           , dt_multiset_ind
           , dt_fallback_ind
           , UPPER(TRIM(dt_data_block_size))
           , dt_table_name
           , NULL
           , dt_update_key
           , dt_build_key
           , dt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_dim_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON dt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  dt_obj_key = :v_obj_key;

    --**********************************
    -- S T A G E
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_stage THEN

      SET v_step = 1600;

      SELECT NULLIF(COALESCE(dt_database, st_tablespace),'')
           , TRIM(st_post_fix)
           , COALESCE(st_pct_free,0)
           , st_primary_index_unique
           , st_multiset_ind
           , st_fallback_ind
           , UPPER(TRIM(st_data_block_size))
           , st_table_name
           , NULL
           , st_update_key
           , st_build_key
           , st_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_stage_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON st_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  st_obj_key = :v_obj_key;

    --**********************************
    -- R E T R O   C O P Y   A N D
    -- R E T R O
    --**********************************
    ELSEIF (( v_obj_type = v_ws_obj_retro ) OR ( v_obj_type = v_ws_obj_retro_copy )) THEN

      SET v_step = 1700;

      SELECT NULLIF(COALESCE(dt_database, rt_tablespace),'')
           , TRIM(rt_post_fix)
           , COALESCE(rt_pct_free,0)
           , rt_primary_index_unique
           , rt_multiset_ind
           , rt_fallback_ind
           , UPPER(TRIM(rt_data_block_size))
           , rt_table_name
           , NULL
           , rt_update_key
           , rt_build_key
           , rt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_retro_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON rt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE   rt_obj_key = :v_obj_key;

    --**********************************
    -- O D S
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_ods THEN

      SET v_step = 1800;

      SELECT NULLIF(COALESCE(dt_database, ot_tablespace),'')
           , TRIM(ot_post_fix)
           , COALESCE(ot_pct_free,0)
           , ot_primary_index_unique
           , ot_multiset_ind
           , ot_fallback_ind
           , UPPER(TRIM(ot_data_block_size))
           , ot_table_name
           , NULL
           , ot_update_key
           , ot_build_key
           , ot_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_ods_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON ot_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  ot_obj_key = :v_obj_key;

    --**********************************
    -- N O R M A L
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_normal
        OR v_obj_type = v_ws_obj_hub
        OR v_obj_type = v_ws_obj_satellite
        OR v_obj_type = v_ws_obj_link
        OR v_obj_type = v_ws_obj_custom1
        OR v_obj_type = v_ws_obj_custom2
    THEN

      SET v_step = 1900;

      SELECT NULLIF(COALESCE(dt_database, nt_tablespace),'')
           , TRIM(nt_post_fix)
           , COALESCE(nt_pct_free,0)
           , nt_primary_index_unique
           , nt_multiset_ind
           , nt_fallback_ind
           , UPPER(TRIM(nt_data_block_size))
           , nt_table_name
           , NULL
           , nt_update_key
           , nt_build_key
           , nt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_multiset_ind
           , :v_fallback_ind
           , :v_data_block_size
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_normal_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON nt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  nt_obj_key = :v_obj_key;

    --**********************************
    -- J O I N
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_join THEN

      SET v_step = 2000;

      SELECT NULLIF(COALESCE(dt_database, jt_tablespace),'')
           , TRIM(jt_post_fix)
           , COALESCE(jt_pct_free,0)
           , jt_primary_index_unique
           , jt_table_name
           , jt_where
           , jt_update_key
           , jt_build_key
           , jt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_pct_free
           , :v_primary_index_unique
           , :v_table_name
           , :v_where
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_join_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON jt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  jt_obj_key = :v_obj_key;

    --**********************************
    -- V I E W
    --**********************************
    ELSEIF v_obj_type = v_ws_obj_view THEN

      SET v_step = 2100;

      SELECT NULLIF(COALESCE(dt_database, vt_tablespace),'')
           , TRIM(vt_post_fix)
           , vt_table_name
           , vt_where
           , vt_view_where
           , vt_type_ind
           , vt_attributes
           , vt_gen_spec
           , TRIM(vt_lock_mode)
           , vt_update_key
           , vt_build_key
           , vt_short_name
      INTO   :v_database
           , :v_post_fix
           , :v_table_name
           , :v_where
           , :v_view_where
           , :v_type_ind
           , :v_attributes
           , :v_gen_spec
           , :v_lock_mode
           , :v_update_key
           , :v_build_key
           , :v_short_name
      FROM   [METABASE].ws_view_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON vt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  vt_obj_key = :v_obj_key;

    ELSE

      SET v_step = 2200;

      SET p_return_code = 'E';
      SET p_return_msg = 'Unable to find object''s database: unsupported object type.';
      SET p_result = -2;
      SET p_value = '';

      LEAVE WS_OBJECT_INFO;

    END IF;

    SET v_step = 2300;

    SET p_return_code = 'S';
    SET p_return_msg = 'Object ' || v_obj_name || ' (object key ' || CAST(v_obj_key AS VARCHAR(18)) || ') is an object type ' || CAST(v_obj_type AS VARCHAR(18));
    SET p_result = 1;

    IF ( v_info_type = 'DATABASE' ) THEN

      SET p_value = v_database;

    ELSEIF ( v_info_type = 'POST_FIX' ) THEN

      SET p_value = v_post_fix;

    ELSEIF ( v_info_type = 'PCT_FREE' ) THEN

      SET p_value = CAST(v_pct_free AS VARCHAR(18));

    ELSEIF ( v_info_type = 'PRIMARY_INDEX_UNIQUE' ) THEN

      SET p_value = v_primary_index_unique;

    ELSEIF ( v_info_type = 'MULTISET_IND' ) THEN

      SET p_value = v_multiset_ind;

    ELSEIF ( v_info_type = 'FALLBACK_IND' ) THEN

      SET p_value = v_fallback_ind;

    ELSEIF ( v_info_type = 'DATA_BLOCK_SIZE' ) THEN

      SET p_value = v_data_block_size;

    ELSEIF ( v_info_type = 'TABLE_NAME' ) THEN

      SET p_value = v_table_name;

    ELSEIF ( v_info_type = 'WHERE' ) THEN

      SET p_value = v_where;

    ELSEIF ( v_info_type = 'VIEW_WHERE' ) THEN

      SET p_value = v_view_where;

    ELSEIF ( v_info_type = 'TYPE_IND' ) THEN

      SET p_value = v_type_ind;

    ELSEIF ( v_info_type = 'ATTRIBUTES' ) THEN

      SET p_value = v_attributes;

    ELSEIF ( v_info_type = 'GEN_SPEC' ) THEN

      SET p_value = v_gen_spec;

    ELSEIF ( v_info_type = 'LOCK_MODE' ) THEN

      SET p_value = v_lock_mode;

    ELSEIF ( v_info_type = 'UPDATE_KEY' ) THEN

      SET p_value = TRIM(CAST(v_update_key AS VARCHAR(18)));

    ELSEIF ( v_info_type = 'BUILD_KEY' ) THEN

      SET p_value = TRIM(CAST(v_build_key AS VARCHAR(18)));

    ELSEIF ( v_info_type = 'SHORT_NAME' ) THEN

      SET p_value = v_short_name;

    ELSEIF ( v_info_type = 'ALL' ) THEN

      SET v_value = (COALESCE(v_database,'')) || X'08' ||
                    (COALESCE(v_post_fix,'')) || X'08' ||
                    CAST((COALESCE(v_pct_free,0)) AS VARCHAR(18)) || X'08' ||
                    (COALESCE(v_primary_index_unique,'')) || X'08' ||
                    (COALESCE(v_multiset_ind,'')) || X'08' ||
                    (COALESCE(v_fallback_ind,'')) || X'08' ||
                    (COALESCE(v_data_block_size,'')) || X'08' ||
                    (COALESCE(v_table_name,'')) || X'08' ||
                    (COALESCE(v_where,'')) || X'08' ||
                    (COALESCE(v_view_where,'')) || X'08' ||
                    (COALESCE(v_type_ind,'')) || X'08' ||
                    (COALESCE(v_attributes,'')) || X'08' ||
                    (COALESCE(v_gen_spec,'')) || X'08' ||
                    (COALESCE(v_lock_mode,'')) || X'08' ||
                    (COALESCE(TRIM(CAST(v_update_key AS VARCHAR(18))),'')) || X'08' ||
                    (COALESCE(TRIM(CAST(v_build_key AS VARCHAR(18))),'')) || X'08' ||
                    (COALESCE(v_short_name,''))
                    ;

      SET p_value = v_value;

    END IF;

  ELSE

    SET v_step = 2400;

    SET p_return_code = 'E';

    IF NULLIF(TRIM(p_obj_name),'') IS NOT NULL THEN

      SET p_return_msg = 'The object ' || p_obj_name || ' does not exists.';

    ELSE

      SET p_return_msg = 'The object with key ' || CAST(p_obj_key AS VARCHAR(18)) || ' does not exists.';

    END IF;

    SET p_result = -2;
    SET p_value = '';

  END IF;

  SET v_step = 2500;

END;
_PROCEDWSL_ Ws_Merge_Utils 
CREATE PROCEDURE [METABASE].Ws_Merge_Utils (
  IN  p_sequence        INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, IN  p_table_name      VARCHAR(64)
, IN  p_option          VARCHAR(20)
, IN  p_parameter       VARCHAR(4000)
, OUT p_return_msg      VARCHAR(1024)
, OUT p_result          INTEGER
)
WS_MERGE_UTILS:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            Teradata
  -- Script Name          Ws_Merge_Utils
  -- Description          Perform Merge Utility Functions
  -- Author               Jason Laws
  -- Date                 1st April 2011
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS   10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_table             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_exists                   INTEGER;
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(256);
  DECLARE v_info_result              INTEGER;
  DECLARE v_database                 VARCHAR(30);
  DECLARE v_short_name               VARCHAR(22);
  DECLARE v_count                    INTEGER;
  DECLARE v_sql                      VARCHAR(32000);
  DECLARE v_error                    INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Merge_Utils Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_table             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_obj_key                  = -1;
  SET v_exists                   = 1;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET p_return_msg = '';

  SET v_step = 200;

  --=====================================================
  -- See if an table name has been specified
  -- and if so look up the object key for that table
  -- If we can't find it then we have an error
  --=====================================================

  IF NULLIF(TRIM(p_table_name),'') IS NOT NULL THEN

    SET v_step = 300;

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = 'Failure getting table '|| p_table_name ||' in call to Ws_Merge_Utils';
          CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
          SET p_result = -3;
          SET v_exists = 0;
        END;

      SET v_step = 400;

      SELECT oo_obj_key
      INTO   v_obj_key
      FROM   [METABASE].ws_obj_object
      WHERE  UPPER(oo_name) = UPPER(p_table_name);

      SET v_step = 500;

      IF v_obj_key < 1 THEN

        SET v_msgtext = 'Invalid table name '|| p_table_name ||' in call to Ws_Merge_Utils';
        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
          v_msgtext, NULL, NULL, p_task_id, p_job_id);

        SET p_result = -3;
        SET v_exists = 0;

      END IF;

    END;

  ELSE

    SET v_step = 600;

    SET v_MsgText = 'The name of a table must be specified '||
                    'in a call to Ws_Merge_Utils.';

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
              , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_result = -2;

    LEAVE WS_MERGE_UTILS;

  END IF;

  SET v_step = 700;

  --=====================================================
  -- Table exists, so process depending on the option.
  --=====================================================
  IF v_exists = 1 THEN

    SET v_step = 800;

    -- Get Database of table
    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                               , NULL, p_table_name
                               , 'DATABASE'
                               , v_info_return_code, v_info_return_msg
                               , v_info_result, v_database);

    SET v_step = 900;

    -- Get short name of table
    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                             , NULL, p_table_name
                             , 'SHORT_NAME'
                             , v_info_return_code, v_info_return_msg
                             , v_info_result, v_short_name);

    SET v_step = 1000;

    --=====================================================
    -- Process Option.
    --=====================================================

    -- Create Error Table
    IF UPPER(p_option) = 'CREATE' THEN

      SET v_step = 1100;

      SET v_sql = 'CREATE ERROR TABLE ' || v_database || '.' || v_short_name || '_err FOR ' || v_database || '.' || p_table_name;

      SET v_step = 1200;

      SET v_error = 0;

      BEGIN

        DECLARE CONTINUE HANDLER
          FOR SQLEXCEPTION
          BEGIN
            SET v_error = 1;
          END;

        CALL DBC.SYSEXECSQL ( v_sql );

        SET p_return_msg = 'Error Log table ' || v_database || '.' || v_short_name || '_err created for ' || v_database || '.' || p_table_name;

      END;

      IF ( v_error = 1 ) THEN

        SET p_result = -1;

        LEAVE WS_MERGE_UTILS;

      END IF;


    -- Drop Error Table
    ELSEIF UPPER(p_option) = 'DROP' THEN

      SET v_step = 1300;

      SET v_sql = 'DROP TABLE ' || v_database || '.' || v_short_name || '_err';

      SET v_step = 1400;

      SET v_error = 0;

      BEGIN

        DECLARE CONTINUE HANDLER
          FOR SQLEXCEPTION
          BEGIN
            SET v_error = 1;
          END;

        CALL DBC.SYSEXECSQL ( v_sql );

        SET p_return_msg = 'Error Log table ' || v_database || '.' || v_short_name || '_err dropped';

      END;

      IF ( v_error = 1 ) THEN

        SET p_result = -1;

        LEAVE WS_MERGE_UTILS;

      END IF;


    -- Delete all data from Error Table
    ELSEIF UPPER(p_option) = 'DELETE' THEN

      SET v_step = 1500;

      SET v_sql = 'DELETE FROM ' || v_database || '.' || v_short_name || '_err';

      SET v_step = 1600;

      CALL DBC.SYSEXECSQL ( v_sql );

      SET p_return_msg = 'Error Log table ' || v_database || '.' || v_short_name || '_err truncated';


    -- Sumarize all error log data into the RED audit log
    ELSEIF UPPER(p_option) = 'AUDIT' THEN

      SET v_step = 1700;
      -- RED-6226 Error messages simplified to remove select of table DBC.ErrorMsgs (needs review when doing RED-2172)
      /*
      SET v_sql = '
        INSERT INTO [METABASE].Ws_Wrk_Audit_Log
        ( wa_time_stamp
        , wa_sequence
        , wa_job
        , wa_task
        , wa_status
        , wa_message
        , wa_task_key
        , wa_job_key)
        SELECT   CURRENT_TIMESTAMP
               , ' || CAST(p_sequence AS VARCHAR(20)) || '
               , ''' || CAST(p_job_name AS VARCHAR(20)) || '''
               , ''' || CAST(p_task_name AS VARCHAR(20)) || '''
               , ''I''
               , ''Merge Errors: ''  ||
                   CAST(errs.ErrCount AS VARCHAR(20)) ||
                   (CASE WHEN errs.ErrCount = 1 THEN '' row'' ELSE '' rows'' END ) ||
                   '' not merged. Error: '' ||
                   CAST(errs.ErrCode AS VARCHAR(20)) ||
                   '' - '' ||
                   errs.ErrText
               , ' || CAST(p_task_id AS VARCHAR(20)) || '
               , ' || CAST(p_job_id AS VARCHAR(20)) || '
        FROM ( SELECT   errtbl.ETC_Errorcode ErrCode
                      , errmsg.Errortext ErrText
                      , COUNT(*) ErrCount
               FROM     ' || v_database || '.' || v_short_name || '_err errtbl
               LEFT JOIN DBC.ErrorMsgs errmsg
               ON       errtbl.ETC_ErrorCode= errmsg.ErrorCode
               WHERE    errtbl.ETC_DMLtype IS NOT NULL
               GROUP BY errtbl.ETC_Errorcode
                      , errmsg.Errortext
             ) AS errs
      ';
      */

      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;

      SET v_msgtext = 'Unhandled exception in Ws_Merge_Utils Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);

      SET v_step = 1800;

      -- RED-6226 Error messages simplified to remove select of table DBC.ErrorMsgs (needs review when doing RED-2172)
      --CALL DBC.SYSEXECSQL ( v_sql );

      --SET v_count = ACTIVITY_COUNT;

      SET p_return_msg = 'Error Log table ' || v_database || '.' || v_short_name || '_err summarized into audit log';

      SET v_step = 1900;

      -- Check merge error table if rows were inserted.
      -- RED-6226 Error messages simplified to remove select of table DBC.ErrorMsgs (needs review when doing RED-2172)
      /*
      IF ( v_count > 0 ) THEN

        SET v_msgtext = 'Merge Errors have occurred.  Check Merge Error Table: ' || UPPER(v_database) || '.' || UPPER(v_short_name) || '_ERR  for more information.';
        CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, '', '', :p_task_id, :p_job_id);

      END IF;
      */

    ELSE

      SET v_step = 2000;


      SET v_MsgText = 'Invalid option '|| p_option ||
                      ' in call to Ws_Merge_Utils. '||
                      'Valid options are CREATE, DROP, DELETE and AUDIT';

      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                , v_msgtext, NULL, NULL, p_task_id, p_job_id);

      SET p_result = -2;

      LEAVE WS_MERGE_UTILS;

    END IF;

    SET v_step = 2100;

    SET p_result = 1;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Execute 
CREATE PROCEDURE [METABASE].Ws_Act_Execute
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
, OUT p_stmt            varchar(4000)
)
WS_ACT_EXECUTE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name     Teradata
  -- Script Name   ws_act_execute
  -- Description   Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 25/10/2002  Version 1.2.1    Sql Server version
  -- WMR 13/09/2007  Version 5.6.0    DB2 version
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;       -- step
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_stmt                     VARCHAR(4000);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Act_Execute. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;
  SET p_result = 1;

  -- Execute the procedure
  SET v_stmt = 'CALL [METABASE].' || p_task_name || '(' || TRIM(CAST(p_sequence AS VARCHAR(20)));
  SET v_stmt = v_stmt || ',''' || p_job_name ||''',''' || p_task_name || ''',' || TRIM(CAST(p_job_id AS VARCHAR(20)));
  SET v_stmt = v_stmt || ',' || TRIM(CAST(p_task_id AS VARCHAR(20))) || ',?,?);';

  SET v_step = 300;

  SET p_return_msg = 'Statement prepared';
  SET p_result = 1;
  SET p_status_code = 1;
  SET p_stmt = v_stmt;

END;
_PROCEDWSL_ Ws_Act_Post_Export 
CREATE PROCEDURE [METABASE].Ws_Act_Post_Export
(     p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
, OUT p_stmt            varchar(4000)
)
WS_ACT_POST_EXPORT:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    		Teradata
  -- Script Name 			ws_act_post_export
  -- Description 			Execute the post export procedure associated with
  --                          a export object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 17/04/2007   Version 5.6.0.0
  -- WMR 13/09/2007   Version 5.6.0.0  DB2 Port
  -- AP  29/04/2008   Version 6.0.0.0  Standardized constants
  -- JML 01/09/2008   Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

 --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_procedure_key            INTEGER;
  DECLARE v_procedure                VARCHAR(64);
  DECLARE v_stmt                     VARCHAR(4000);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Post_Export Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET p_return_msg = '';
  SET p_result = 1;
  SET p_status_code = 1;

  --=====================================================
  -- Get the post export procedure if it exists
  --=====================================================
  SET v_step = 10;
  SET v_procedure_key = 0;

  SELECT et_procedure_key
  INTO   v_procedure_key
  FROM   [METABASE].ws_export_tab
  WHERE  et_obj_key = p_obj_key;

  IF v_procedure_key = 0 OR v_procedure_key IS NULL THEN

    SET p_return_msg = 'No post export procedure defined for '  || p_task_name;
    SET p_status_code = 1;
    SET p_result = 2;

    LEAVE WS_ACT_POST_EXPORT;

  END IF;

  --=====================================================
  -- Get the procedure name
  --=====================================================
  SET v_step = 40;
  SET v_procedure = NULL;

  SELECT ph_name
  INTO   v_procedure
  FROM   [METABASE].ws_pro_header
  WHERE  ph_obj_key = v_procedure_key;

  IF NULLIF(TRIM(v_procedure),'') IS NULL THEN

    SET v_msgtext = 'Unable to acquire post export procedure name for '  ||  p_task_name;
    SET p_return_msg = v_msgtext;

    CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
                             , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_status_code = -3;
    SET p_result = -3;

    LEAVE WS_ACT_POST_EXPORT;

  END IF;

  --=====================================================
  -- Execute the procedure
  --=====================================================
  SET v_stmt = 'CALL [METABASE].' || v_procedure || '(' || TRIM(CAST(p_sequence AS VARCHAR(18)));
  SET v_stmt = v_stmt || ',''' || p_job_name ||''',''' || p_task_name || ''',' || TRIM(CAST(p_job_id AS VARCHAR(18)));
  SET v_stmt = v_stmt || ',' || TRIM(CAST(p_task_id AS VARCHAR(18))) || ',?,?);';

  SET v_step = 92;

  SET p_return_msg = 'Statement prepared';
  SET p_result = 1;
  SET p_status_code = 1;
  SET p_stmt = v_stmt;

END;
_PROCEDWSL_ Ws_Act_Post_Load 
CREATE PROCEDURE [METABASE].Ws_Act_Post_Load
( IN  p_sequence        INTEGER
, IN  p_obj_type        INTEGER
, IN  p_action          INTEGER
, IN  p_obj_key         INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, OUT p_return_msg      VARCHAR(1024)
, OUT p_status_code     INTEGER
, OUT p_result          INTEGER
, OUT p_stmt            VARCHAR(4000)
)
WS_ACT_POST_LOAD:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name                Teradata
  -- Script Name              ws_act_post_load
  -- Description              Execute the post load procedure associated with
  --                          a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  22/01/2002   Version 1.0.0
  -- WMR  30/10/2002   Version 1.2.1.4  CASTed to sql server
  -- WMR  13/09/2007   Version 5.6.0.0  CASTed to DB2
  -- AP   29/04/2008   Version 6.0.0.0  Standardized constants
  -- JML  01/09/2008   Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS   10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM   31/03/2017   Version 6.9.1.0  Add target support
  -- HM   03/05/2017   Version 6.9.1.0  RED-7969 Do not update DSS_LOAD_DATE if already set
  -- BC   27/07/2017   Version 8.0.1.0  RED-8492 Renamed long variable name to not exceed 30 characters.
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  -- <<< NOTE: Limit variable name lengths to a maximum of 30 characters.

  -- =============================================================================
  -- Constants Declared
  -- =============================================================================
  DECLARE v_ws_pro_version               VARCHAR(15);
  DECLARE v_ws_obj_procedure             INTEGER;
  DECLARE v_ws_obj_fact_kpi              INTEGER;
  DECLARE v_ws_obj_script                INTEGER;
  DECLARE v_ws_obj_template              INTEGER;
  DECLARE v_ws_obj_fact                  INTEGER;
  DECLARE v_ws_obj_dim                   INTEGER;
  DECLARE v_ws_obj_stage                 INTEGER;
  DECLARE v_ws_obj_load                  INTEGER;
  DECLARE v_ws_obj_agg                   INTEGER;
  DECLARE v_ws_obj_index                 INTEGER;
  DECLARE v_ws_obj_connect               INTEGER;
  DECLARE v_ws_obj_dim_view              INTEGER;
  DECLARE v_ws_obj_export                INTEGER;
  DECLARE v_ws_obj_cube                  INTEGER;
  DECLARE v_ws_obj_cube_virtual          INTEGER;
  DECLARE v_ws_obj_report                INTEGER;
  DECLARE v_ws_obj_view                  INTEGER;
  DECLARE v_ws_obj_join                  INTEGER;
  DECLARE v_ws_obj_retro                 INTEGER;
  DECLARE v_ws_obj_retro_copy            INTEGER;
  DECLARE v_ws_obj_olap_cube             INTEGER;
  DECLARE v_ws_obj_olap_dim              INTEGER;
  DECLARE v_ws_obj_olap_role             INTEGER;
  DECLARE v_ws_obj_ods                   INTEGER;
  DECLARE v_ws_obj_normal                INTEGER;
  DECLARE v_ws_obj_hub                   INTEGER;
  DECLARE v_ws_obj_satellite             INTEGER;
  DECLARE v_ws_obj_link                  INTEGER;
  DECLARE v_ws_obj_custom1               INTEGER;
  DECLARE v_ws_obj_custom2               INTEGER;
  DECLARE v_ws_obj_max                   INTEGER;

  DECLARE v_ws_act_drop                  INTEGER;
  DECLARE v_ws_act_create                INTEGER;
  DECLARE v_ws_act_drop_all              INTEGER;
  DECLARE v_ws_act_pre_drop              INTEGER;
  DECLARE v_ws_act_load                  INTEGER;
  DECLARE v_ws_act_update                INTEGER;
  DECLARE v_ws_act_execute               INTEGER;
  DECLARE v_ws_act_process               INTEGER;
  DECLARE v_ws_act_build                 INTEGER;
  DECLARE v_ws_act_build_all             INTEGER;
  DECLARE v_ws_act_analyze               INTEGER;
  DECLARE v_ws_act_quick_analyze         INTEGER;
  DECLARE v_ws_act_statistics            INTEGER;
  DECLARE v_ws_act_quick_statistics      INTEGER;
  DECLARE v_ws_act_initial               INTEGER;
  DECLARE v_ws_act_cube_dim              INTEGER;
  DECLARE v_ws_act_db_dim                INTEGER;
  DECLARE v_ws_act_custom                INTEGER;
  DECLARE v_ws_act_truncate              INTEGER;
  DECLARE v_ws_act_compile               INTEGER;

  -- =============================================================================
  -- Variables
  -- =============================================================================
  DECLARE v_sql_code                     INTEGER;        -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                    VARCHAR(1024);  -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                         INTEGER;        -- step
  DECLARE v_no_more_data1                INTEGER;
  DECLARE v_no_more_data2                INTEGER;
  DECLARE v_msgtext                      VARCHAR(1024);  -- Text in audit_trail
  DECLARE v_row_count                    INTEGER;
  DECLARE v_procedure_key                INTEGER;
  DECLARE v_procedure                    VARCHAR(64);
  DECLARE v_stmt                         VARCHAR(20000);
  DECLARE v_stmt2                        VARCHAR(4000);
  DECLARE v_after_msg                    VARCHAR(1024);
  DECLARE v_row                          INTEGER;
  DECLARE v_dss_load_date_name           VARCHAR(255);   -- Configured name for DSS_LOAD_DATE
  DECLARE v_after_transform_new_row_only INTEGER;

  -- =============================================================================
  -- Load Table Variables
  -- =============================================================================
  DECLARE v_lt_pre_action                VARCHAR(1);
  DECLARE v_lt_table_name                VARCHAR(64);
  DECLARE v_lt_pre_sql                   VARCHAR(4000);
  DECLARE v_lt_load_statement            VARCHAR(4000);
  DECLARE v_lt_type                      VARCHAR(1);
  DECLARE v_lt_connect_key               INTEGER;
  DECLARE v_lt_database                  VARCHAR(64);
  DECLARE v_lt_transform_ind             VARCHAR(1);
  DECLARE v_lt_non_mandatory_ind         VARCHAR(1);
  DECLARE v_lt_source_schema             VARCHAR(64);
  DECLARE v_lt_source_columns            VARCHAR(4000);
  DECLARE v_lt_from_table                VARCHAR(4000);
  DECLARE v_lt_where_clause              VARCHAR(4000);
  DECLARE v_lt_missing_col_act           VARCHAR(1);

  -- =============================================================================
  -- Load Column Variables
  -- =============================================================================
  DECLARE v_lc_col_name                  VARCHAR(64);
  DECLARE v_lc_transform_code            VARCHAR(4000);

  -- =============================================================================
  -- Cursor for all columns in the load table
  -- =============================================================================
  DECLARE c_Load CURSOR FOR
  SELECT   lc_col_name
         , lc_transform_code
  FROM     [METABASE].ws_load_col
  WHERE    lc_obj_key = p_obj_key
  AND      lc_transform_type = 'A'
  ORDER BY lc_order;

  -- =============================================================================
  -- Default Exception Handler
  -- =============================================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Post_Load Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET v_msgtext = 'Last SQL was ' || (COALESCE(v_stmt,'NULL'));
      CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence
        , v_msgtext, '', '', p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  -- =============================================================================
  -- Set Values for Constants
  -- =============================================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  -- =============================================================================
  -- MAIN
  -- =============================================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET p_return_msg = '';
  SET p_result = 1;
  SET v_row = 0;
  SET p_status_code = 1;
  SET v_after_msg = '';

  -- =============================================================================
  -- Lookup DSS_LOAD_DATE name
  -- =============================================================================
  SET v_dss_load_date_name = 'dss_load_date';
  SELECT COALESCE(mn_name, 'dss_load_date')
  INTO v_dss_load_date_name
  FROM [METABASE].ws_meta_names
  WHERE mn_object = 'dss_load_date';

  -- =============================================================================
  -- First get the load table information
  -- =============================================================================
  SELECT lt_pre_action
       , lt_table_name
       , lt_pre_sql
       , lt_load_statement
       , lt_type
       , lt_connect_key
       , COALESCE(dt_database, lt_schema)
       , lt_transform_ind
       , lt_non_mandatory_ind
       , lt_source_schema
       , lt_source_columns
       , lt_from_table
       , lt_where_clause
       , lt_missing_col_act
  INTO   v_lt_pre_action
       , v_lt_table_name
       , v_lt_pre_sql
       , v_lt_load_statement
       , v_lt_type
       , v_lt_connect_key
       , v_lt_database
       , v_lt_transform_ind
       , v_lt_non_mandatory_ind
       , v_lt_source_schema
       , v_lt_source_columns
       , v_lt_from_table
       , v_lt_where_clause
       , v_lt_missing_col_act
  FROM   [METABASE].ws_load_tab
  LEFT JOIN [METABASE].ws_obj_object ws_obj_object
  ON lt_obj_key = oo_obj_key
  LEFT JOIN [METABASE].ws_dbc_target ws_dbc_target
  ON dt_target_key = oo_target_key
  LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
  ON dc_obj_key = dt_connect_key
  WHERE  lt_obj_key = p_obj_key
  ;

  -- =============================================================================
  -- Perform any after load transformations
  -- =============================================================================
  IF COALESCE(v_lt_transform_ind,'N') = 'Y' OR COALESCE(v_lt_type,'D') IN ('F','S','E') THEN

    -- =============================================================================
    -- Transformation
    -- =============================================================================
    SET v_stmt = 'UPDATE ';
    SET v_stmt = v_stmt || v_lt_database || '.';
    SET v_stmt = v_stmt || v_lt_table_name || ' SET ';

    SET v_no_more_data1 = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_Load;

      FETCH FROM c_Load INTO
        v_lc_col_name
      , v_lc_transform_code;

      SET v_after_transform_new_row_only = 0;

      WHILE v_no_more_data1 = 0 DO

        IF v_lc_transform_code <> '' THEN

          SET v_row = v_row + 1;

          IF v_row > 1 THEN

            SET v_stmt = v_stmt || ',';

          END IF;

          IF CHAR_LENGTH(v_stmt) + CHAR_LENGTH(v_lc_col_name) + CHAR_LENGTH(' = ') + CHAR_LENGTH(v_lc_transform_code) > 20000 THEN
            SET p_return_msg = 'Maximum length (20000 chars) of transformation expressions exceeded for '  || p_task_name;
            SET p_status_code = -2;
            SET p_result = -2;

            LEAVE WS_ACT_POST_LOAD;
          END IF;

          SET v_stmt = v_stmt || v_lc_col_name || ' = ';
          SET v_stmt = v_stmt || v_lc_transform_code;

          IF v_lc_col_name = v_dss_load_date_name THEN
            SET v_after_transform_new_row_only = 1;
          END IF;

        END IF;

        FETCH FROM c_Load INTO
          v_lc_col_name
        , v_lc_transform_code;

      END WHILE; -- End of cursor loop

      CLOSE c_Load;

    END;

    -- =============================================================================
    -- See if any columns needed an after transformation
    -- If we have any then do the update
    -- =============================================================================
    IF v_row > 0 THEN

      -- =============================================================================
      -- Perform the after transformation update
      -- =============================================================================
      SET v_step = 90;

      IF v_after_transform_new_row_only = 1 THEN
        SET v_stmt = v_stmt || ' WHERE ' || v_dss_load_date_name || ' IS NULL';
      END IF;

      CALL DBC.SYSEXECSQL ( v_stmt );

      SET v_row_count = ACTIVITY_COUNT;

      SET v_after_msg = TRIM(CAST((COALESCE(v_row_count,0)) AS VARCHAR(18))) ||
                        ' rows updated for ' || v_lt_table_name || ' ';

      SET p_return_msg = v_after_msg;

    END IF; -- End of we have a transformation to perform

  END IF; -- End of If setup for transformations

  -- =============================================================================
  -- Get the post load procedure if it exists
  -- =============================================================================
  SET v_step = 10;
  SET v_procedure_key = 0;

  SELECT lt_procedure_key
  INTO   v_procedure_key
  FROM   [METABASE].ws_load_tab
  WHERE  lt_obj_key = p_obj_key;

  IF v_procedure_key = 0 OR v_procedure_key IS NULL THEN

    SET p_return_msg = 'No post load procedure defined for '  || p_task_name;
    SET p_status_code = 1;
    SET p_result = 2;

    LEAVE WS_ACT_POST_LOAD;

  END IF;

  -- =============================================================================
  -- Get the procedure name
  -- =============================================================================
  SET v_step = 40;
  SET v_procedure = NULL;

  SELECT ph_name
  INTO   v_procedure
  FROM   [METABASE].ws_pro_header
  WHERE  ph_obj_key = v_procedure_key;

  IF NULLIF(TRIM(v_procedure),'') IS NULL THEN

    SET v_msgtext = 'Unable to acquire post load procedure name for '  || p_task_name;
    SET p_return_msg = v_msgtext;

    CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
                             , v_msgtext, '', '', p_task_id, p_job_id);

    SET p_status_code = -3;
    SET p_result = -3;

    LEAVE WS_ACT_POST_LOAD;

  END IF;

  -- =============================================================================
  -- Execute the procedure
  -- =============================================================================
  SET v_stmt2 = 'CALL [METABASE].' || v_procedure || '(' || TRIM(CAST(p_sequence AS VARCHAR(18)));
  SET v_stmt2 = v_stmt2 || ',''' || p_job_name ||''',''' || p_task_name || ''',' || TRIM(CAST(p_job_id AS VARCHAR(18)));
  SET v_stmt2 = v_stmt2 || ',' || TRIM(CAST(p_task_id AS VARCHAR(18))) || ',?,?);';

  SET v_step = 92;

  SET v_msgtext = SUBSTR(TRIM(v_after_msg),1,1000) || ' Statement prepared';
  SET p_return_msg = v_msgtext;
  SET p_result = 1;
  SET p_status_code = 1;
  SET p_stmt = v_stmt2;

END;
_PROCEDWSL_ Ws_Job_Exec_Cancel 
REPLACE PROCEDURE [METABASE].Ws_Job_Exec_Cancel
( IN  pi_job_name         varchar(64)
, IN  pi_task_name        varchar(64)
, IN  pi_thread           integer
, IN  pi_sequence         integer
, IN  pi_job_key          integer
, IN  pi_task_key         integer
, OUT po_result_code      integer
, OUT po_result_msg       varchar(1024)
, OUT po_action_key       integer
, OUT po_action_msg       varchar(256)
)
WS_JOB_EXEC_CANCEL:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_cancel
  -- Description  Cancels a Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- FS  05/12/2017   Version 8.0.2.0  RED-9068 resolve deadlock issues
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_count                INTEGER;
  DECLARE v_row_count                INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_delete                   VARCHAR(500);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_job_Exec_411_Cancel Version '||
        v_ws_pro_version || '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_job_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  -- Get the job key for the job name. There should be one and
  -- only one key. Otherwise a fatal problem.
  SELECT COUNT(*)
  INTO   v_job_count
  FROM   [METABASE].ws_wrk_job_ctrl
  WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(pi_job_name));

  -- Make sure we are already running (i.e. have a job_run record)
  -- Otherwise a fatal problem.
  SELECT COUNT(*)
  INTO   v_row_count
  FROM   [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = pi_job_key
  AND    wjr_sequence = pi_sequence;

  IF v_row_count <> 1 THEN

    SET v_MsgText = 'Ws_Job_Exec_411_Cancel'|| v_ws_pro_version || ' Job ' || pi_job_name || ' sequence ' ||
                    TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' not running. ' ||
                    'Cannot cancel. No Action !!!';

    CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                               v_MsgText,NULL,NULL,0,pi_job_key);

    SET po_result_code = -2;

    LEAVE WS_JOB_EXEC_CANCEL;

  END IF;

  -- Move the job run record to the log record
  INSERT INTO [METABASE].ws_wrk_job_log
  SELECT *
  FROM   [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = pi_job_key
  AND    wjr_sequence = pi_sequence;

  DELETE FROM [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = pi_job_key
  AND    wjr_sequence = pi_sequence;

  -- Move the task run records to the log record
  INSERT INTO [METABASE].ws_wrk_task_log
  SELECT *
  FROM   [METABASE].ws_wrk_task_run
  WHERE  wtr_job_key = pi_job_key
  AND    wtr_sequence = pi_sequence;

  SET v_delete = -- JWH  11 Sept 17
    'DELETE FROM [METABASE].ws_wrk_task_run
     WHERE wtr_job_key = ' || pi_job_key
     || ' AND wtr_sequence = ' || pi_sequence || ';'
   ;

  CALL DBC.SysExecSQL (:v_delete);       --  JWH 11 Sept 2017

  SET v_MsgText = 'Job ' || pi_job_name || ' sequence ' ||
                  TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' Canceled. ';

  CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                        v_MsgText,NULL,NULL,0,pi_job_key);

  SET po_result_code = 1;

END;
_PROCEDWSL_ Ws_Job_Clear_Logs 
CREATE PROCEDURE [METABASE].Ws_Job_Clear_Logs (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_job_to_clean     varchar(64)
, IN  p_log_keep         integer
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		:	Teradata
  -- Script Name 	:	ws_job_clear_logs
  -- Description 	:	Removes a set number of log files for a job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- V4.1.0.4 WMR 16/10/2003
  -- V5.0.0.0 JML 15/12/2006   Teradata port
  -- v6.6.3.0 AP  03/10/2012   RED-2885 Corrected sorting to be on complete date rather than sequence
  -- v6.8.5.2 RS  18/01/2016   Changed error handler
  -- v8.4.1.0 HM  13/02/2019   RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext         varchar(1024); -- Text in audit_trail
  DECLARE v_step            integer;       -- return code
  DECLARE v_result          integer;       -- return code
  DECLARE v_count           integer;
  DECLARE v_job_sequence    integer;
  DECLARE v_job_key         integer;
  DECLARE v_job_status      varchar(1);
  DECLARE v_job_count       integer;
  DECLARE v_del_count       integer;
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_LogFetch        integer;

  DECLARE v_del_job_key integer;
  DECLARE v_del_sequence integer;

  --=====================================================
  -- Cursor for all ready jobs
  --=====================================================
  DECLARE c_Log CURSOR FOR
    SELECT   wjl_job_key
           , wjl_sequence
    FROM     [METABASE].ws_wrk_job_log
    WHERE    wjl_name = :p_job_to_clean
    ORDER BY wjl_completed desc;
    --RED-2885 ORDER BY wjl_sequence desc;

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Clear_Logs. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'W';
      SET p_result = -3;
    END;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_job_count = 0;
  SET v_del_count = 0;

  SET v_step = 200;

  IF (p_log_keep < 0) THEN

    SET p_return_msg = 'Job '|| p_job_to_clean ||' negative value passed in log keep count. No action.';
    SET p_return_code = 'W';
    SET p_result = -1;

  ELSE

    --***********************************************************************
    -- Loop through all the logs in descending order skip over the first
    -- n that are to be kept
    --***********************************************************************
    SET v_step = 300;

    OPEN c_Log;

    SET v_step = 400;

    FETCH NEXT FROM c_Log
    INTO v_del_job_key
       , v_del_sequence;

    SET v_LogFetch = SQLCODE;

    SET v_step = 500;

    WHILE ( v_LogFetch = 0 )
    DO

      SET v_step = 600;

      SET v_job_count = v_job_count + 1;

      IF (v_job_count > p_log_keep ) THEN

        -- Have a log to delete so move the tasks, job, audit and error info

        SET v_step = 700;

        -- Copy the audit info to archive
        INSERT INTO [METABASE].wx_wrk_audit_archive
        ( wa_time_stamp
        , wa_sequence
        , wa_job
        , wa_task
        , wa_status
        , wa_message
        , wa_db_msg_code
        , wa_db_msg_desc
        , wa_task_key
        , wa_job_key
        , wa_row_number )
        SELECT wa_time_stamp
             , wa_sequence
             , wa_job
             , wa_task
             , wa_status
             , wa_message
             , wa_db_msg_code
             , wa_db_msg_desc
             , wa_task_key
             , wa_job_key
             , wa_row_number
        FROM   [METABASE].ws_wrk_audit_log
        WHERE  wa_job_key = :v_del_job_key
        AND    wa_sequence = :v_del_sequence;

        SET v_del_count = v_del_count + 1;

        SET v_step = 800;

        -- Delete the audit info
        DELETE FROM [METABASE].ws_wrk_audit_log
        WHERE  wa_job_key = :v_del_job_key
        AND    wa_sequence = :v_del_sequence;

        SET v_step = 900;

        -- Copy the detail info to archive
        INSERT INTO [METABASE].wx_wrk_error_archive
        ( wd_time_stamp
        , wd_sequence
        , wd_job
        , wd_task
        , wd_status
        , wd_message
        , wd_db_msg_code
        , wd_db_msg_desc
        , wd_task_key
        , wd_job_key
        , wd_row_number
        , wd_severity
        , wd_action )
        SELECT wd_time_stamp
             , wd_sequence
             , wd_job
             , wd_task
             , wd_status
             , wd_message
             , wd_db_msg_code
             , wd_db_msg_desc
             , wd_task_key
             , wd_job_key
             , wd_row_number
             , wd_severity
             , wd_action
        FROM   [METABASE].ws_wrk_error_log
        WHERE  wd_job_key = :v_del_job_key
        AND    wd_sequence = :v_del_sequence;

        SET v_del_count = v_del_count + 1;

        SET v_step = 1000;

        -- Delete the detail info
        DELETE FROM [METABASE].ws_wrk_error_log
        WHERE  wd_job_key = :v_del_job_key
        AND    wd_sequence = :v_del_sequence;

        SET v_step = 1100;

        -- Delete the task log
        DELETE FROM [METABASE].ws_wrk_task_log
        WHERE  wtl_job_key = :v_del_job_key
        AND    wtl_sequence = :v_del_sequence;

        SET v_step = 1200;

        -- Delete the job log
        DELETE FROM [METABASE].ws_wrk_job_log
        WHERE  wjl_job_key = :v_del_job_key
        AND    wjl_sequence = :v_del_sequence;

      END IF;

      SET v_LogFetch = 0;

      SET v_step = 1300;

      FETCH NEXT FROM c_Log
      INTO v_del_job_key
         , v_del_sequence;

      SET v_LogFetch = SQLCODE;

    END WHILE;

    SET v_step = 1400;

    CLOSE c_Log;

    SET p_return_code = 'S';
    SET p_return_msg = 'Job ' || p_job_to_clean || ' had ' || CAST(v_del_count AS VARCHAR(10)) || ' logs removed. ';
    SET p_result = 1;

  END IF;

END;
_PROCEDWSL_ Ws_Job_Exec_New 
REPLACE PROCEDURE [METABASE].Ws_Job_Exec_New
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
)
WS_JOB_EXEC_NEW:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_new
  -- Description  Establishes a new Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 29/06/2009   Added call to Ws_Job_Get_Start to replace start date/time logic.
  --                  Implement new '-99' return code for blocked job so handle nicer
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- JML 11/02/2014   Version 6.7.4.0  RED-3502: Fixed issue with incorrect status code
  --                                   data type when calling Ws_Job_Clear_Logs.
  -- RS  26/05/2014   Version 6.8.0.1  Changed status code check for call to get_start from <>1
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- AP  22/06/2016   Version 6.8.6.2  RED-3282 Support 'disabled' tasks
  -- AD  28/11/2017   Version 8.0.2.0  RED-8686 Resolve deadlock issue
  -- FS  05/12/2017   Version 8.0.2.0  RED-9068 resolve deadlock issues
  -- FS  11/01/2018   Version 8.0.2.0  RED-9151 fixed regression
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  DECLARE v_ws_act_disabled_once     char(1);
  DECLARE v_ws_act_disabled          char(1);

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_result                   INTEGER;
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status_code              INTEGER;
  DECLARE v_log_clear_status         VARCHAR(1);    --RED-3502

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_rec_count                INTEGER;
  DECLARE v_job_count                INTEGER;
  DECLARE v_FailMsg                  VARCHAR(255);  -- Failure result command
  DECLARE v_start_hh                 INTEGER;
  DECLARE v_start_mi                 INTEGER;
  DECLARE v_start_day                INTEGER;
  DECLARE v_job_type                 VARCHAR(1);
  DECLARE v_ctrl_sequence            INTEGER;
  DECLARE v_failed_sequence          INTEGER;
  DECLARE v_start_after              TIMESTAMP;
  DECLARE v_cust_sa_hh               INTEGER;
  DECLARE v_cust_sa_mm               INTEGER;
  DECLARE v_cust_sb_hh               INTEGER;
  DECLARE v_cust_sb_mm               INTEGER;
  DECLARE v_cust_min                 INTEGER;
  DECLARE v_cust_days                INTEGER;
  DECLARE v_cust_sb                  INTEGER;
  DECLARE v_cust_sa                  INTEGER;
  DECLARE v_more                     INTEGER;
  DECLARE v_AddDays                  INTEGER;
  DECLARE v_wait_HH                  INTEGER;
  DECLARE v_wait_MM                  INTEGER;
  DECLARE v_cur_HH                   INTEGER;
  DECLARE v_cur_MM                   INTEGER;
  DECLARE v_cur_HHMM                 INTEGER;
  DECLARE v_cur_day_name             VARCHAR(3);
  DECLARE v_Monday                   INTEGER;
  DECLARE v_Tuesday                  INTEGER;
  DECLARE v_Wednesday                INTEGER;
  DECLARE v_Thursday                 INTEGER;
  DECLARE v_Friday                   INTEGER;
  DECLARE v_Saturday                 INTEGER;
  DECLARE v_Sunday                   INTEGER;
  DECLARE v_log_keep                 INTEGER;
  DECLARE v_start_after_hour         INTEGER;
  DECLARE v_start_after_minute       INTEGER;
  DECLARE v_new_HH                   INTEGER;
  DECLARE v_new_MM                   INTEGER;
  DECLARE v_new_HHMM                 INTEGER;
  DECLARE v_increment                INTEGER;
  DECLARE v_increment_days           INTEGER;
  DECLARE v_increment_current        INTEGER;
  DECLARE v_start_status             CHAR(1);
  DECLARE v_delete                   VARCHAR(500);   --  JWH 11 Sept 2017
  DECLARE v_insert                   VARCHAR(500);   --  JWH 11 Sept 2017

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Job_Exec_New Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_job_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_ws_act_disabled_once     = 'A';
  SET v_ws_act_disabled          = 'B';
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  --                  N E W       J O B
  --=====================================================
  -- If we are a New job then check we are not already running, under
  -- this or some other sequence number.
  -- Create the job_run and task_run records
  --=====================================================

  --=====================================================
  -- If we are thread 0 then do some checks and create the records
  --=====================================================
  IF pi_thread = 0 THEN

    -- Get the job details for the job name. There should be one and
    -- only one key. Otherwise a fatal problem.
    SELECT wjc_type
         , wjc_start_hour
         , wjc_start_minute
         , wjc_start_day
         , wjc_sequence
         , wjc_publish_fail
         , COALESCE(wjc_cust_sa_hh,0)
         , COALESCE(wjc_cust_sa_mm,0)
         , COALESCE(wjc_cust_sb_hh,0)
         , COALESCE(wjc_cust_sb_mm,0)
         , COALESCE(wjc_cust_min,0)
         , COALESCE(wjc_cust_days,0)
         , COALESCE(wjc_avg_count,0)
         , EXTRACT(HOUR FROM wjc_start_after)
         , EXTRACT(MINUTE FROM wjc_start_after)
         , wjc_start_after
    INTO   v_job_type
         , v_start_hh
         , v_start_mi
         , v_start_day
         , v_ctrl_sequence
         , v_FailMsg
         , v_cust_sa_hh
         , v_cust_sa_mm
         , v_cust_sb_hh
         , v_cust_sb_mm
         , v_cust_min
         , v_cust_days
         , v_log_keep
         , v_start_after_hour
         , v_start_after_minute
         , v_start_after
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(pi_job_name));

    -- Setup to default for a failure if a Fail command has been provided
    IF NULLIF(TRIM(v_FailMsg),'') IS NOT NULL THEN

       SET po_action_key = 2;
       SET po_action_msg = v_FailMsg;

    ELSE

       SET po_action_key = 0;
       SET po_action_msg = '';

    END IF;

    -- Make sure we are not already running (i.e. have a job_run record)
    -- Otherwise a fatal problem.
    SELECT COUNT(*)
    INTO   v_rec_count
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    IF v_rec_count <> 0 THEN

      SET v_MsgText = 'Job ' || pi_job_name || ' already running. ' ||
                       'Cannot start a new iteration. No Action !!!';

      CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, v_ctrl_sequence,
                                 v_MsgText,NULL,NULL,0,pi_job_key);

      SET po_result_code = -2;

      LEAVE WS_JOB_EXEC_NEW;

    END IF;

    -- Make sure there is no other sequence of this job running
    -- Otherwise a fatal problem.
    -- WMR 24/08/2001. Put the job on hold, if there are running sequences.
    -- WMR 24/08/2001. If failed sequences then put out a warning and proceed.
    SELECT COUNT(*)
    INTO   v_rec_count
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_job_key = pi_job_key;

    IF v_rec_count <> 0 THEN

      SELECT COUNT(*)
      INTO   v_job_count
      FROM   [METABASE].ws_wrk_job_run
      WHERE  wjr_job_key = pi_job_key
      AND    wjr_status = 'F';

      IF v_job_count <> v_rec_count THEN

        SET v_MsgText = 'Job ' || pi_job_name || ' already has a running sequence. ' ||
                                       ' Job Blocked, until current job completes.';

        CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_job_name, v_ctrl_sequence,
                                               v_MsgText,NULL,NULL,0,pi_job_key);

        UPDATE [METABASE].ws_wrk_job_ctrl
        SET    wjc_status = 'B'
        WHERE  wjc_job_key = pi_job_key
        AND    wjc_sequence = v_ctrl_sequence;

        -- 6.0.4.1 added the following to break out!
        SET po_result_code = -99;

        LEAVE WS_JOB_EXEC_NEW;

      ELSE

        SET v_MsgText = 'Job ' || pi_job_name || ' has a previously Failed (incomplete) sequence. Now Aborted';

        CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_job_name, pi_sequence,
                                               v_MsgText,NULL,NULL,0,pi_job_key);

        -- there should no more than one instance of a failed job in the run table
        SELECT wjr_sequence
        INTO   v_failed_sequence
        FROM   [METABASE].ws_wrk_job_run
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_status = 'F';

        -- Update the job run record to be completed (Failed-Aborted)
        -- and set the completion date if it is null
        -- Move the job run record to the log record
        UPDATE [METABASE].ws_wrk_job_run
        SET    wjr_status = 'G'
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_sequence = v_failed_sequence;

        UPDATE [METABASE].ws_wrk_job_run
        SET    wjr_completed = CURRENT_TIMESTAMP
        WHERE  wjr_job_key = pi_job_key
         AND    wjr_sequence = v_failed_sequence
        AND    wjr_completed is NULL;

        INSERT INTO [METABASE].ws_wrk_job_log
        SELECT *
        FROM   [METABASE].ws_wrk_job_run
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_sequence = v_failed_sequence;

        SET v_delete = 'DELETE FROM [METABASE].ws_wrk_job_run WHERE  wjr_job_key = '
        || pi_job_key
        || 'AND    wjr_sequence = ' || v_failed_sequence || ';'
        ;                       -- JWH 11 Sept 17

            CALL DBC.SysExecSQL (:v_delete);       --  JWH 11 Sept 2017

        -- Move the task run records to the log record -- JWH 11 Sept 2017 (all of this
         SET v_insert = 'INSERT INTO [METABASE].ws_wrk_task_log
         SELECT *
         FROM   [METABASE].ws_wrk_task_run
         WHERE  wtr_job_key = ' || pi_job_key || '
         AND    wtr_sequence = ' || v_failed_sequence || ';'
         ; -- JWH 7 Sept 17

         CALL DBC.SysExecSQL (:v_insert);       --  JWH 11 Sept 2017

         SET v_delete = 'DELETE FROM [METABASE].ws_wrk_task_run WHERE  wtr_job_key = ' || pi_job_key  -- JWH 11 Sept 17
         || 'AND    wtr_sequence = ' || v_failed_sequence || ';';                        -- JWH 11 Sept 17

         CALL DBC.SysExecSQL (:v_delete);       --  JWH 11 Sept 2017

      END IF; -- End of no running sequence

    END IF; -- End of other sequences

    --=====================================================
    -- Record this thread as being active
    --=====================================================
    CALL [METABASE].Ws_Job_Exec_Thread('ADD', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

    -- Create the Job run record
    -- Set its initial state to P for pending until we have the task_run records built
    --      wjc_job_key, pi_sequence, 0, 'P', GETDATE(), GETDATE(), NULL, 0,0,
    -- NOTE wjr_chkp_count is used to hold the parent job number

    INSERT INTO [METABASE].ws_wrk_job_run
    ( wjr_job_key
    , wjr_sequence
    , wjr_restart
    , wjr_status
    , wjr_scheduled
    , wjr_started
    , wjr_completed
    , wjr_elapsed_hh
    , wjr_elapsed_mi
    , wjr_okay_count
    , wjr_info_count
    , wjr_warning_count
    , wjr_error_count
    , wjr_detail_count
    , wjr_chkp_count
    , wjr_chkp_number
    , wjr_name
    , wjr_user_key
    , wjr_max_threads
    , wjr_publish_okay
    , wjr_publish_fail
    , wjr_scheduler
    , wjr_idle_thread_wait)
    SELECT wjc_job_key
         , pi_sequence
         , 0
         , 'P'
         , CURRENT_TIMESTAMP
         , CURRENT_TIMESTAMP
         , CAST(NULL AS TIMESTAMP)
         , 0
         , 0
         , 0
         , 0
         , 0
         , 0
         , 0
         , 0
         , 0
         , wjc_name
         , wjc_user_key
         , wjc_max_threads
         , wjc_publish_okay
         , wjc_publish_fail
         , wjc_scheduler
         , COALESCE(wjc_idle_thread_wait,30)
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  wjc_job_key = pi_job_key;

    -- Create All the Task records.
    INSERT INTO [METABASE].ws_wrk_task_run
    ( wtr_task_key
    , wtr_job_key
    , wtr_sequence
    , wtr_restart
    , wtr_run_status
    , wtr_audit_status
    , wtr_started
    , wtr_completed
    , wtr_elapsed_hh
    , wtr_elapsed_mi
    , wtr_info_count
    , wtr_warning_count
    , wtr_detail_count
    , wtr_return_msg
    , wtr_type
    , wtr_abort_level
    , wtr_chkp_number
    , wtr_name
    , wtr_obj_type
    , wtr_action_type
    , wtr_obj_key
    , wtr_thread
    , wtr_order
    , wtr_action_ind)
    SELECT wtc_task_key
         , wtc_job_key
         , pi_sequence
         , 0
         , 'W'
         , NULL
         , NULL
         , NULL
         , 0
         , 0
         , 0
         , 0
         , 0
         , NULL
         , wtc_type
         , wtc_abort_level
         , wtc_chkp_number
         , wtc_name
         , wtc_obj_type
         , wtc_action_type
         , wtc_obj_key
         , wtc_order
         , wtc_order
         , wtc_action_ind
    FROM   [METABASE].ws_wrk_task_ctrl
    WHERE  wtc_job_key = pi_job_key
    ;

    -- All tasks added
    -- Set the job status to running so our threads can start running the tasks
    UPDATE [METABASE].ws_wrk_job_run
    SET    wjr_status = 'R'
        , wjr_started = CURRENT_TIMESTAMP
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    SET v_MsgText = 'Job ' || pi_job_name || ' sequence ' || TRIM(CAST(pi_sequence AS VARCHAR(18)))
                            || ' Started. ';

    CALL [METABASE].WsWrkAudit('B',pi_job_name, pi_job_name, pi_sequence,
                                          v_MsgText,NULL,NULL,pi_task_key,pi_job_key);

    --=====================================================
    -- Clear out any old logs for this job
    --=====================================================
    IF v_log_keep > 0 THEN

      -- we will create a log as part of this log, so keep 1 less
      SET v_log_keep = v_log_keep - 1;

      CALL [METABASE].Ws_Job_Clear_Logs(pi_sequence,
                        pi_job_name, pi_job_name, pi_job_key, pi_task_key,
                        pi_job_name, v_log_keep,
--RED-3502              v_status_code, v_return_msg,
                        v_log_clear_status, v_return_msg,               --RED-3502
                        v_result);

    END IF;

    -- Now either modify or delete the control record
    -- and if required delete the task records
    -- If it is a once only job then delete it from job control
    -- If a once and hold then set its status to Hold
    -- In all other cases work out when it will next run
    -- and put it in a wait state.
    SET v_handled = 0;

    IF v_job_type = 'O' THEN

      SET v_handled = 1;

      DELETE FROM [METABASE].ws_wrk_job_ctrl
      WHERE  wjc_job_key = pi_job_key;

      DELETE FROM [METABASE].ws_wrk_task_ctrl
      WHERE  wtc_job_key = pi_job_key;

    ELSE

      SET v_handled = 1;

      CALL [METABASE].Ws_Job_Get_Start(:pi_job_key, :v_start_after, :v_start_status, :v_status_code, :v_MsgText);

      IF ( v_status_code <> 1 ) THEN

        CALL [METABASE].WsWrkAudit('F',:pi_job_name, :pi_job_name, :pi_sequence,
            :v_MsgText, NULL, NULL, 0, :pi_job_key);

      END IF;

      UPDATE [METABASE].ws_wrk_job_ctrl
      SET    wjc_status = :v_start_status
           , wjc_start_after = :v_start_after
      WHERE  wjc_job_key = :pi_job_key;

      -- Update tasks that are disabled once back to enabled
      UPDATE [METABASE].ws_wrk_task_ctrl
      SET    wtc_action_ind = NULL
      WHERE  wtc_job_key = pi_job_key
      AND    COALESCE(wtc_action_ind,'') = v_ws_act_disabled_once;

    END IF;

  -- End of Thread 0
  ELSE
    --==========================================================================================================
    -- If we are any other thread record as active and return
    --==========================================================================================================
    CALL [METABASE].Ws_Job_Exec_Thread('ADD', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

  END IF; -- End Thread other than 0

  SET po_result_code = 1;

END;
_PROCEDWSL_ Ws_Job_Exec_Restart 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_Restart
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
)
WS_JOB_EXEC_RESTART:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_restart
  -- Description  Establishes a new Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- AP  01/02/2010   Version 6.1.0.0  New field on task_ctrl/run
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_rec_count                INTEGER;
  DECLARE v_run_status               VARCHAR(1);
  DECLARE v_FailMsg                  VARCHAR(255);  -- Failure result command
  DECLARE v_idle_thread_wait         INTEGER;
  DECLARE v_status_code              INTEGER;

  --=====================================================
  -- Variables for Task Run cursor
  --=====================================================
  DECLARE v_wtr_task_key             INTEGER;
  DECLARE v_wtr_job_key              INTEGER;
  DECLARE v_wtr_obj_key              INTEGER;
  DECLARE v_wtr_name                 VARCHAR(64);
  DECLARE v_wtr_sequence             INTEGER;
  DECLARE v_wtr_restart              INTEGER;
  DECLARE v_wtr_run_status           VARCHAR(1);
  DECLARE v_wtr_audit_status         VARCHAR(1);
  DECLARE v_wtr_started              TIMESTAMP;
  DECLARE v_wtr_completed            TIMESTAMP;
  DECLARE v_wtr_elapsed_hh           INTEGER;
  DECLARE v_wtr_elapsed_mi           INTEGER;
  DECLARE v_wtr_info_count           INTEGER;
  DECLARE v_wtr_warning_count        INTEGER;
  DECLARE v_wtr_detail_count         INTEGER;
  DECLARE v_wtr_return_msg           VARCHAR(256);
  DECLARE v_wtr_type                 VARCHAR(1);
  DECLARE v_wtr_obj_type             INTEGER;
  DECLARE v_wtr_action_type          INTEGER;
  DECLARE v_wtr_chkp_number          INTEGER;
  DECLARE v_wtr_abort_level          INTEGER;
  DECLARE v_wtr_thread               INTEGER;
  DECLARE v_wtr_inserted             INTEGER;
  DECLARE v_wtr_updated              INTEGER;
  DECLARE v_wtr_replaced             INTEGER;
  DECLARE v_wtr_deleted              INTEGER;
  DECLARE v_wtr_discarded            INTEGER;
  DECLARE v_wtr_rejected             INTEGER;
  DECLARE v_wtr_errored              INTEGER;
  DECLARE v_wtr_order                INTEGER;
  DECLARE v_wtr_action_ind           VARCHAR(1);

  --=====================================================
  -- Cursor for all the task run records waiting to be run
  --=====================================================
  DECLARE c_TaskRun CURSOR FOR
  SELECT   *
  FROM     [METABASE].ws_wrk_task_run
  WHERE    wtr_job_key = pi_job_key
  AND      wtr_sequence = pi_sequence
  ORDER BY wtr_order
  FOR READ ONLY
  ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_job_Exec_Restart Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_job_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, pi_job_key);

      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_no_more_data1            = 0;
  SET v_idle_thread_wait         = 30;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  --=====================================================
  -- If we are thread 0 then do some checks andreset any halted or
  -- failed tasks so that they will run
  --=====================================================
  IF pi_thread = 0 THEN

    -- Make sure we are in run tables (i.e. have a job_run record)
    -- And have a waiting state
    -- Otherwise a fatal problem.
    SELECT COUNT(*)
    INTO   v_rec_count
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    IF v_rec_count <> 1 THEN

      SET v_MsgText = 'Ws_Job_Exec_Restart'|| v_ws_pro_version || ' Job ' || pi_job_name || ' sequence ' ||
                       TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' not running. ' ||
                      'Cannot restart. No Action !!!';

      CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                               v_MsgText,NULL,NULL,0,pi_job_key);

      SET po_result_code = -2;

      LEAVE WS_JOB_EXEC_RESTART;

    END IF;

    SELECT wjr_status
         , wjr_publish_fail
    INTO   v_run_status
         , v_FailMsg
    FROM   [METABASE].ws_wrk_job_run
    WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(pi_job_name))
    AND    wjr_sequence = pi_sequence;

    -- Setup to default for a failure if a Fail command has been provided
    IF NULLIF(TRIM(v_FailMsg),'') IS NOT NULL THEN

      SET po_action_key = 2;
      SET po_action_msg = v_FailMsg;

    ELSE

      SET po_action_key = 0;
      SET po_action_msg = '';

    END IF;

    IF v_run_status <> 'P' THEN

      SET v_MsgText = 'Ws_Job_Exec_Restart'|| v_ws_pro_version || ' Job '|| pi_job_name || ' sequence ' ||
                       TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' not prepared for re-run. ' ||
                       'Cannot restart. No Action !!!';

      CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                                                 v_MsgText,NULL,NULL,0,pi_job_key);

      SET po_result_code = -2;

      LEAVE WS_JOB_EXEC_RESTART;

    END IF;

    --=====================================================
    -- Record this thread as being active
    --=====================================================
    CALL [METABASE].Ws_Job_Exec_Thread('ADD', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

    UPDATE [METABASE].ws_wrk_job_run
    SET    wjr_status = 'P'
         , wjr_restart = wjr_restart + 1
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    -- Loop through All the Task records.
    -- Clearing any halted or failed statuses
    SET v_no_more_data1 = 0;

    BEGIN
      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_TaskRun;

      FETCH FROM c_TaskRun INTO
          v_wtr_task_key
        , v_wtr_job_key
        , v_wtr_obj_key
        , v_wtr_name
        , v_wtr_sequence
        , v_wtr_restart
        , v_wtr_run_status
        , v_wtr_audit_status
        , v_wtr_started
        , v_wtr_completed
        , v_wtr_elapsed_hh
        , v_wtr_elapsed_mi
        , v_wtr_info_count
        , v_wtr_warning_count
        , v_wtr_detail_count
        , v_wtr_return_msg
        , v_wtr_type
        , v_wtr_obj_type
        , v_wtr_action_type
        , v_wtr_chkp_number
        , v_wtr_abort_level
        , v_wtr_thread
        , v_wtr_inserted
        , v_wtr_updated
        , v_wtr_replaced
        , v_wtr_deleted
        , v_wtr_discarded
        , v_wtr_rejected
        , v_wtr_errored
        , v_wtr_order
        , v_wtr_action_ind;

      WHILE v_no_more_data1 = 0 DO

        IF v_wtr_run_status = 'H' OR v_wtr_run_status = 'F' OR v_wtr_run_status = 'U' THEN

          UPDATE [METABASE].ws_wrk_task_run
          SET    wtr_restart = wtr_restart + 1
               , wtr_started = NULL
               , wtr_completed = NULL
               , wtr_elapsed_hh = 0
               , wtr_elapsed_mi = 0
               , wtr_run_status = 'W'
               , wtr_audit_status = NULL
               , wtr_info_count = 0
               , wtr_warning_count = 0
               , wtr_detail_count = 0
               , wtr_return_msg = NULL
          WHERE  wtr_task_key = v_wtr_task_key
          AND    wtr_job_key = v_wtr_job_key
          AND    wtr_sequence = v_wtr_sequence;

        ELSE

          UPDATE [METABASE].ws_wrk_task_run
          SET    wtr_restart = wtr_restart + 1
          WHERE  wtr_task_key = v_wtr_task_key
          AND    wtr_job_key = v_wtr_job_key
          AND    wtr_sequence = v_wtr_sequence;

        END IF; -- end of if failed or halted else

        FETCH FROM c_TaskRun INTO
          v_wtr_task_key
        , v_wtr_job_key
        , v_wtr_obj_key
        , v_wtr_name
        , v_wtr_sequence
        , v_wtr_restart
        , v_wtr_run_status
        , v_wtr_audit_status
        , v_wtr_started
        , v_wtr_completed
        , v_wtr_elapsed_hh
        , v_wtr_elapsed_mi
        , v_wtr_info_count
        , v_wtr_warning_count
        , v_wtr_detail_count
        , v_wtr_return_msg
        , v_wtr_type
        , v_wtr_obj_type
        , v_wtr_action_type
        , v_wtr_chkp_number
        , v_wtr_abort_level
        , v_wtr_thread
        , v_wtr_inserted
        , v_wtr_updated
        , v_wtr_replaced
        , v_wtr_deleted
        , v_wtr_discarded
        , v_wtr_rejected
        , v_wtr_errored
        , v_wtr_order
        , v_wtr_action_ind;

      END WHILE;-- end of cursor loop

      CLOSE c_TaskRun;

    END;

    -- Set the job status to running
    UPDATE [METABASE].ws_wrk_job_run
    SET    wjr_status = 'R'
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    SET v_MsgText = 'Job ' || pi_job_name || ' sequence '||
                    TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' Restarted. ';

    CALL [METABASE].WsWrkAudit('B',pi_job_name, pi_job_name, pi_sequence,
                                          v_MsgText,NULL,NULL,0,pi_job_key);

  --=====================================================
  -- If we are not thread 0 then wait for two minutes for the okay
  --=====================================================
  ELSE

    --=====================================================
    -- Record this thread as being active
    --=====================================================
    CALL [METABASE].Ws_Job_Exec_Thread('ADD', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

  END IF;-- end of none thread zero for Restart

  SET po_result_code = 1;

END;
_PROCEDWSL_ Ws_Act_Analyze 
CREATE PROCEDURE [METABASE].Ws_Act_Analyze
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_percent         integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
)
WS_ACT_ANALYZE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_analyze
  -- Description  : Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 05/04/2002  Version 1.0.7    Added for all indexed columns to analyze
  -- WMR 25/10/2002  Version 1.2.1    Sql Server version
  -- WMR 22/11/2002  Version 5.0.0    Teradata version
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_stmt                     VARCHAR(8000); -- Dynamic SQL variable
  DECLARE v_table_name               VARCHAR(64);   -- Table Name if an index
  DECLARE v_tablespace               VARCHAR(64);   -- Database name
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_obj_key                  INTEGER;       -- Used for table object key if an index
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_continue                 INTEGER;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Analyze Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_continue                 = 0;

  SET v_step = 10;
  SET p_result = 1;
  SET p_status_code = 1;

  --=====================================================
  -- Handle either an Index or a Table
  --=====================================================

  IF ( p_obj_type = v_ws_obj_index ) THEN

    --=====================================================
    -- Index
    --=====================================================

    -- Get table object type.
    SELECT ih_obj_key
    INTO   :v_obj_key
    FROM   [METABASE].ws_index_header
    WHERE  ih_index_key = :p_obj_key;

    -- Get table table name.
    SELECT oo_name
    INTO   :v_table_name
    FROM   [METABASE].ws_obj_object
    WHERE  oo_obj_key = :v_obj_key;

    -- Get the database of the table.
    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                 , NULL, :v_table_name
                                 , 'database'
                                 , :v_db_return_code, :v_db_return_msg
                                 , :v_db_result, :v_tablespace);

    -- If analyze
    IF ( p_action = v_ws_act_analyze ) THEN

      SET v_stmt = 'COLLECT STATISTICS ON ';

    -- Else If quick analyze
    ELSE

      SET v_stmt = 'COLLECT STATISTICS USING SAMPLE ON ';

    END IF;

    SET v_stmt = v_stmt||v_tablespace||'.';
    SET v_stmt = v_stmt||v_table_name;
    SET v_stmt = v_stmt||' INDEX ';
    SET v_stmt = v_stmt||p_task_name;

    SET p_return_msg = 'Index '||p_task_name||' analyzed';

    -- Execute the analyze
    SET v_step = 90;

    CALL DBC.SYSEXECSQL ( :v_stmt );

    SET v_step = 92;

  ELSE

    --=====================================================
    -- Table
    --=====================================================

    -- Get the database of the table.
    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                 , :p_obj_key, NULL
                                 , 'database'
                                 , :v_db_return_code, :v_db_return_msg
                                 , :v_db_result, :v_tablespace);

    -- If analyze
    IF ( p_action = v_ws_act_analyze ) THEN

      SET v_stmt = 'COLLECT STATISTICS ON ';
      SET v_stmt = v_stmt||v_tablespace||'.';
      SET v_stmt = v_stmt||p_task_name;

      SET p_return_msg = 'Table '||p_task_name||' analyzed ';

      -- Execute the analyze
      SET v_step = 94;

      BEGIN

        -- Ignore a Stats not defined error.
        DECLARE CONTINUE HANDLER
          FOR SQLEXCEPTION
          BEGIN

            GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
            SET v_sql_code = SQLCODE;

            IF ( v_sql_code = 3624 ) THEN

              SET p_result = -1;
              SET p_status_code = -1;
              SET p_return_msg = 'No Stats Defined for Table '||p_task_name;

            ELSE

              SET v_msgtext = 'Unhandled exception in Ws_Act_Analyze Version '||
                v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
                '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
              SET p_return_msg = v_msgtext;
              CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
                  , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
              SET p_status_code = -3;
              SET p_result = -3;
              SET v_continue = 1;

            END IF;

          END;

        CALL DBC.SYSEXECSQL ( :v_stmt );

      END;

      IF ( v_continue = 1 ) THEN

        LEAVE WS_ACT_ANALYZE;

      END IF;

      SET v_step = 96;

    -- Else If quick analyze (not supported for tables)
    ELSE

      SET p_result = -1;
      SET p_status_code = -1;
      SET p_return_msg = 'Quick Analyze (Sampling) not available for Teradata Tables';

    END IF;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Build 
CREATE PROCEDURE [METABASE].Ws_Act_Build (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, IN  p_parameter       varchar(4000)
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

WS_ACT_BUILD:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_drop
  -- Description  : Build any indexes due for rebuild
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 30/08/2001 Version 0.3.0.6  Added support for Primary Keys
  -- WMR 21/01/2002 Version 1.0.0.0  Added support for Partitioned indexes
  -- WMR 20/03/2002 Version 1.0.0.6  Added support for Parallel Index builds
  -- WMR 02/12/2002 Version 1.2.1.5  Fixed missing K in index build. Added PctUsed
  -- WMR 24/12/2003 Version 4.1.0.0  Added support for compressed indexes
  -- WMR 17/04/2004 Version 4.1.0.8  Added support for compute statistics during index build
  -- WMR 18/05/2004 Version 4.1.0.8  Added support fro buffer pool options
  -- WMR 25/05/2004 Version 4.1.0.8  Added support for pctfree column and function indexes
  -- WMR 23/07/2004 Version 4.1.0.8  Added support p_parameter being passed in
  -- WMR 24/06/2005 Version 4.1.2.11 Include the schema name in the create if flag set
  -- WMR 05/07/2005 Version 4.1.2.13 Changed user_tab_partitions to all_tab_partitions
  -- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
  --                                 Add call to wswrkerror for each index as built
  -- JML 24/01/2008 Version 5.6.3.1  Teradata version
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_stmt                     VARCHAR(1024); -- Used for dynamic SQL
  DECLARE v_obj_done                 INTEGER;       -- Used to flag successful drop
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar

  DECLARE v_IndexOnlyFetch           INTEGER;
  DECLARE v_IndexFetch               INTEGER;
  DECLARE v_IndColFetch              INTEGER;

  DECLARE v_ih_table                 VARCHAR(64);
  DECLARE v_ih_index_key             INTEGER;
  DECLARE v_ih_index_name            VARCHAR(64);
  DECLARE v_ih_index_type            VARCHAR(1);
  DECLARE v_ih_unique                VARCHAR(1);
  DECLARE v_ih_pre_drop_flag         VARCHAR(1);
  DECLARE v_ih_rebuild_freq          VARCHAR(12);
  DECLARE v_ih_tablespace            VARCHAR(64);
  DECLARE v_ic_column                VARCHAR(64);

  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   INTEGER;  -- return code
  DECLARE v_user_database            VARCHAR(64);
  DECLARE v_columns                  VARCHAR(8000);
  DECLARE v_col_number               INTEGER;
  DECLARE v_index_key                INTEGER;
  DECLARE v_day                      INTEGER;
  DECLARE v_day_name                 VARCHAR(3);
  DECLARE v_month_end                INTEGER;
  DECLARE v_month                    INTEGER;
  DECLARE v_tommorrow_month          INTEGER;
  DECLARE v_epos                     INTEGER;
  DECLARE v_spos                     INTEGER;

  --=====================================================
  -- Cursor for all indexes
  --=====================================================
  DECLARE c_Index CURSOR FOR
    SELECT ih_table
         , ih_index_key
         , ih_index_name
         , ih_index_type
         , ih_unique
         , ih_pre_drop_flag
         , ih_rebuild_freq
         , ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_obj_key = :p_obj_key
    AND    ih_index_type <> 'P'
    AND    ih_active = 'Y';

  --=====================================================
  -- Cursor for specified index
  --=====================================================
  DECLARE c_IndexOnly CURSOR FOR
    SELECT ih_table
         , ih_index_key
         , ih_index_name
         , ih_index_type
         , ih_unique
         , ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_index_key = :p_obj_key
    AND    ih_index_type <> 'P'
    AND    ih_active = 'Y';

  --=====================================================
  -- Cursor for index columns
  --=====================================================
  DECLARE c_IndCol CURSOR FOR
    SELECT   ic_column
    FROM     [METABASE].ws_index_col
    WHERE    ic_index_key = :v_index_key
    ORDER BY ic_column_no;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Act_Build. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================
  SET v_ws_pro_version = '(8.4.1.0)';
  SET v_ws_obj_fact = 5;
  SET v_ws_obj_dim = 6;
  SET v_ws_obj_stage = 7;
  SET v_ws_obj_load = 8;
  SET v_ws_obj_agg = 9;
  SET v_ws_obj_index = 10;
  SET v_ws_obj_export = 13;
  SET v_ws_obj_view = 18;
  SET v_ws_obj_join = 20;
  SET v_ws_obj_retro = 21;
  SET v_ws_obj_retro_copy = 22;

  SET v_ws_act_drop = 1;
  SET v_ws_act_create = 2;
  SET v_ws_act_drop_all = 3;
  SET v_ws_act_pre_drop = 4;
  SET v_ws_act_load = 5;
  SET v_ws_act_update = 6;
  SET v_ws_act_execute = 7;
  SET v_ws_act_process = 8;
  SET v_ws_act_build = 9;
  SET v_ws_act_build_all = 10;
  SET v_ws_act_analyze = 11;
  SET v_ws_act_quick_analyze = 12;
  SET v_ws_act_statistics = 13;
  SET v_ws_act_quick_statistics = 14;

  SET v_step = 100;

  SET v_count = 0;
  SET p_status_code = 1;
  SET v_result = 1;

  SET v_step = 200;

  --=====================================================
  -- See if a specific database was specified and if
  -- so use that tablespace
  --=====================================================
  SET v_user_database = NULL;

  IF ( p_parameter IS NOT NULL ) THEN

    SET v_spos = INDEX(UPPER(p_parameter),'TABLESPACE=');

    IF ( v_spos > 0 ) THEN

      SET v_epos = v_spos + INDEX(SUBSTR(p_parameter,v_spos,100),';');

      IF v_epos > v_spos THEN

        SET v_user_database = SUBSTR(p_parameter,v_spos+11,v_epos-(v_spos+12));

      ELSE

        SET v_user_database = SUBSTR(p_parameter,v_spos+11,30);

      END IF;

    END IF;

  END IF;

  SET v_step = 300;

  --=====================================================
  -- If this is an index task then just build that index
  -- Otherwise we have a table so build all required indexes
  --=====================================================
  IF ( p_obj_type = v_ws_obj_index ) THEN

    --=====================================================
    -- Loop through all the indexes looking for what to build
    --=====================================================
    OPEN c_IndexOnly;
    FETCH NEXT FROM c_IndexOnly INTO
        v_ih_table
      , v_ih_index_key
      , v_ih_index_name
      , v_ih_index_type
      , v_ih_unique
      , v_ih_tablespace;

    SET v_IndexOnlyFetch = SQLCODE;

    WHILE ( v_IndexOnlyFetch = 0 )
    DO

      --=====================================================
      -- First drop the index in case that step was not run
      -- Execute the drop
      --=====================================================
      SET v_step = 400;

      IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN

        SET v_step = 500;

        SET v_stmt = 'drop hash index ';
        SET v_stmt = v_stmt||v_ih_tablespace||'.';
        SET v_stmt = v_stmt||v_ih_index_name;

      ELSE

        SET v_step = 600;

        CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                       , 0, :v_ih_table
                                       , 'database'
                                       , :v_db_return_code, :v_db_return_msg
                                       , :v_db_result, :v_table_db);

        SET v_step = 700;

        SET v_stmt = 'drop index ';
        SET v_stmt = v_stmt||v_ih_index_name;
        SET v_stmt = v_stmt||' on ';
        SET v_stmt = v_stmt||v_table_db||'.';
        SET v_stmt = v_stmt||v_ih_table;

      END IF;

      SET v_step = 800;

      SET v_obj_done = 1;

      BEGIN

        DECLARE EXIT HANDLER
          FOR SQLEXCEPTION
          BEGIN
            SET v_obj_done = 0;
          END;

        SET v_step = 900;

        CALL DBC.SYSEXECSQL ( :v_stmt );

        SET v_step = 1000;

      END;

      --=====================================================
      -- Put detail message
      --=====================================================
      SET v_step = 1100;

      IF ( v_obj_done = 1 ) THEN

        SET v_step = 1200;

        SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
        CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

      END IF;

      --=====================================================
      -- Create the rebuild command
      --=====================================================
      SET v_step = 1300;

      SET v_stmt = 'Create ';

      SET v_step = 1400;

      IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN
        SET v_stmt = v_stmt||'Hash ';
      ELSEIF ( v_ih_unique = 'Y' ) THEN
        SET v_stmt = v_stmt||'Unique ';
      END IF;

      SET v_step = 1500;

      SET v_stmt = v_stmt||'Index ';
      SET v_stmt = v_stmt||v_ih_index_name||' (';

      SET v_step = 1600;

      -- Now add in all the columns
      SET v_index_key = v_ih_index_key;
      SET v_columns = '';
      SET v_col_number = 0;

      SET v_step = 1700;

      OPEN c_IndCol;
      FETCH NEXT FROM c_IndCol INTO
          v_ic_column;

      SET v_IndColFetch = SQLCODE;

      SET v_step = 1800;

      WHILE ( v_IndColFetch = 0 )
      DO

        SET v_step = 1900;

        SET v_col_number = v_col_number + 1;

        IF ( v_col_number > 1 ) THEN
          SET v_columns = v_columns||',';
        END IF;

        SET v_columns = v_columns||v_ic_column;

        -- Get the next index column
        SET v_IndColFetch = 0;

        SET v_step = 2000;

        FETCH NEXT FROM c_IndCol INTO
            v_ic_column;

        SET v_IndColFetch = SQLCODE;

      END WHILE; -- End of index columns loop

      SET v_step = 2100;

      CLOSE c_IndCol;

      SET v_step = 2200;

      SET v_stmt = v_stmt||v_columns||') On ';

      SET v_step = 2300;


      CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                     , 0, :v_ih_table
                                     , 'database'
                                     , :v_db_return_code, :v_db_return_msg
                                     , :v_db_result, :v_table_db);

      SET v_step = 2400;

      IF (( v_table_db IS NOT NULL ) AND ( v_table_db <> '' ) AND ( v_db_result = 1 )) THEN
        SET v_stmt = v_stmt||v_table_db||'.';
      END IF;

      SET v_step = 2500;

      SET v_stmt = v_stmt||v_ih_table;

      SET v_step = 2600;

      SET v_obj_done = 1;

      --=====================================================
      -- Rebuild the index
      --=====================================================
      BEGIN

        DECLARE EXIT HANDLER
          FOR SQLEXCEPTION
          BEGIN
            SET v_obj_done = 0;
            GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
            SET v_sql_code = SQLCODE;
            SET v_msgtext = SUBSTR('Exception in ws_act_build. ' || v_ws_pro_version ||
                ' Step ' || CAST(v_step AS VARCHAR(64)) ||
                ' Index Create for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
                ' SQL: '|| v_stmt ||
                ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
            SET p_return_msg = v_msgtext;
            CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
                , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
            SET p_status_code = -3;
            SET v_result = -3;
          END;

        SET v_step = 2700;

        CALL DBC.SYSEXECSQL ( :v_stmt );

        SET v_step = 2800;

      END;

      --=====================================================
      -- Put detail message
      --=====================================================
      SET v_step = 2900;

      IF ( v_obj_done = 1 ) THEN

        SET v_step = 3000;

        SET v_count = v_count + 1;

        SET v_step = 3100;

        SET v_msgtext = 'Index ' || v_ih_index_name || ' rebuilt';
        CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

      END IF;

      SET v_step = 3200;

      -- Get the next index
      SET v_IndexOnlyFetch = 0;

      SET v_step = 3300;

      FETCH NEXT FROM c_IndexOnly INTO
          v_ih_table
        , v_ih_index_key
        , v_ih_index_name
        , v_ih_index_type
        , v_ih_unique
        , v_ih_tablespace;

      SET v_IndexOnlyFetch = SQLCODE;

    END WHILE; -- End of log file checks for this parent

    SET v_step = 3400;

    CLOSE c_IndexOnly;

  ELSE

    SET v_step = 3500;

    --=====================================================
    -- Get the day of the week, and if at start or end of month
    --=====================================================
    SELECT CASE day_of_week
             WHEN 1 THEN 'SUN'
             WHEN 2 THEN 'MON'
             WHEN 3 THEN 'TUE'
             WHEN 4 THEN 'WED'
             WHEN 5 THEN 'THU'
             WHEN 6 THEN 'FRI'
             WHEN 7 THEN 'SAT'
           END
         , day_of_month
         , month_of_year
    INTO   :v_day_name
         , :v_day
         , :v_month
    FROM   sys_calendar.calendar
    WHERE  calendar_date = CURRENT_DATE
    ;

    SET v_step = 3600;

    SELECT  month_of_year
    INTO   :v_tommorrow_month
    FROM   sys_calendar.calendar
    WHERE  calendar_date = CURRENT_DATE + INTERVAL '1' DAY
    ;

    IF ( v_month <> v_tommorrow_month ) THEN
      SET v_month_end = 1;
    ELSE
      SET v_month_end = 0;
    END IF;

    --=====================================================
    -- Loop through all the indexes looking for what to build
    --=====================================================
    OPEN c_Index;
    FETCH NEXT FROM c_Index INTO
        v_ih_table
      , v_ih_index_key
      , v_ih_index_name
      , v_ih_index_type
      , v_ih_unique
      , v_ih_pre_drop_flag
      , v_ih_rebuild_freq
      , v_ih_tablespace;
    SET v_IndexFetch = SQLCODE;

    WHILE ( v_IndexFetch = 0 )
    DO

      IF (( UPPER(v_ih_pre_drop_flag) = 'Y' )
       OR ( UPPER(v_ih_rebuild_freq) = 'DAILY' )
       OR ( UPPER(SUBSTR(v_ih_rebuild_freq,1,3)) = UPPER(v_day_name) )
       OR ( UPPER(v_ih_rebuild_freq) = 'END MONTH' AND v_month_end = 1 )
       OR ( UPPER(v_ih_rebuild_freq) = 'START MONTH' AND v_day = 1 )) THEN

        --=====================================================
        -- First drop the index in case that step was not run
        -- Execute the drop
        --=====================================================
        SET v_step = 3700;

        IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN

          SET v_step = 3800;

          SET v_stmt = 'drop hash index ';
          SET v_stmt = v_stmt||v_ih_tablespace||'.';
          SET v_stmt = v_stmt||v_ih_index_name;

        ELSE

          SET v_step = 3900;

          CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                         , 0, :v_ih_table
                                         , 'database'
                                         , :v_db_return_code, :v_db_return_msg
                                         , :v_db_result, :v_table_db);

          SET v_step = 4000;

          SET v_stmt = 'drop index ';
          SET v_stmt = v_stmt||v_ih_index_name;
          SET v_stmt = v_stmt||' on ';
          SET v_stmt = v_stmt||v_table_db||'.';
          SET v_stmt = v_stmt||v_ih_table;

        END IF;

        SET v_step = 4100;

        SET v_obj_done = 1;

        BEGIN

          DECLARE EXIT HANDLER
            FOR SQLEXCEPTION
            BEGIN
              SET v_obj_done = 0;
            END;

          SET v_step = 4200;

          CALL DBC.SYSEXECSQL ( :v_stmt );

          SET v_step = 4300;

        END;

        --=====================================================
        -- Put detail message
        --=====================================================
        SET v_step = 4400;

        IF ( v_obj_done = 1 ) THEN

          SET v_step = 4500;

          SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
          CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

        END IF;

        --=====================================================
        -- Create the rebuild command
        --=====================================================
        SET v_step = 4600;

        SET v_stmt = 'Create ';

        SET v_step = 4700;

        IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN
          SET v_stmt = v_stmt||'Hash ';
        ELSEIF ( v_ih_unique = 'Y') THEN
          SET v_stmt = v_stmt||'Unique ';
        END IF;

        SET v_step = 4800;

        SET v_stmt = v_stmt||'Index ';
        SET v_stmt = v_stmt||v_ih_index_name||' (';

        SET v_step = 4900;

        -- Now add in all the columns
        SET v_index_key = v_ih_index_key;
        SET v_columns = '';
        SET v_col_number = 0;

        SET v_step = 5000;

        OPEN c_IndCol;
        FETCH NEXT FROM c_IndCol INTO
            v_ic_column;

        SET v_IndColFetch = SQLCODE;

        SET v_step = 5100;

        WHILE ( v_IndColFetch = 0 )
        DO

          SET v_step = 5200;

          SET v_col_number = v_col_number + 1;

          IF ( v_col_number > 1 ) THEN
            SET v_columns = v_columns||',';
          END IF;

          SET v_columns = v_columns||v_ic_column;

          -- Get the next index column
          SET v_IndColFetch = 0;

          SET v_step = 5300;

          FETCH NEXT FROM c_IndCol INTO
              v_ic_column;

          SET v_IndColFetch = SQLCODE;

        END WHILE; -- End of index columns loop

        SET v_step = 5400;

        CLOSE c_IndCol;

        SET v_step = 5500;

        SET v_stmt = v_stmt||v_columns||') On ';

        SET v_step = 5600;

        CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                       , 0, :v_ih_table
                                       , 'database'
                                       , :v_db_return_code, :v_db_return_msg
                                       , :v_db_result, :v_table_db);

        SET v_step = 5700;

        IF (( v_table_db IS NOT NULL ) AND ( v_table_db <> '' ) AND ( v_db_result = 1 )) THEN
          SET v_stmt = v_stmt||v_table_db||'.';
        END IF;

        SET v_step = 5800;

        SET v_stmt = v_stmt||v_ih_table;

        SET v_step = 5900;

        SET v_obj_done = 1;

        --=====================================================
        -- Rebuild the index
        --=====================================================
        BEGIN

          DECLARE EXIT HANDLER
            FOR SQLEXCEPTION
            BEGIN
              SET v_obj_done = 0;
              GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
              SET v_sql_code = SQLCODE;
              SET v_msgtext = SUBSTR('Exception in ws_act_build. ' || v_ws_pro_version ||
                  ' Step ' || CAST(v_step AS VARCHAR(64)) ||
                  ' Index Create for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
                  ' SQL: '|| v_stmt ||
                  ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
              SET p_return_msg = v_msgtext;
              CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
                  , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
              SET p_status_code = -3;
              SET v_result = -3;
            END;

          SET v_step = 6000;

          CALL DBC.SYSEXECSQL ( :v_stmt );

          SET v_step = 6100;

        END;

        --=====================================================
        -- Put detail message
        --=====================================================
        SET v_step = 6200;

        IF ( v_obj_done = 1 ) THEN

          SET v_step = 6300;

          SET v_count = v_count + 1;

          SET v_step = 6400;

          SET v_msgtext = 'Index ' || v_ih_index_name || ' rebuilt';
          CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

        END IF;

      END IF;

      SET v_step = 6500;

      -- Get the next index
      SET v_IndexFetch = 0;

      SET v_step = 6600;

      FETCH NEXT FROM c_Index INTO
          v_ih_table
        , v_ih_index_key
        , v_ih_index_name
        , v_ih_index_type
        , v_ih_unique
        , v_ih_pre_drop_flag
        , v_ih_rebuild_freq
        , v_ih_tablespace;
      SET v_IndexFetch = SQLCODE;

    END WHILE; -- End of log file checks for this parent

    SET v_step = 6700;

    CLOSE c_Index;

  END IF;

  SET v_step = 6800;

  -- tell them how many indexes we dropped
  IF ( v_count = 0 ) THEN

    SET v_msgtext = 'No indexes rebuilt';

  ELSEIF ( v_count = 1 ) THEN

    SET v_msgtext = CAST(v_count AS VARCHAR(18)) ||' index rebuilt';

  ELSE

    SET v_msgtext = CAST(v_count AS VARCHAR(18))  ||' indexes rebuilt';

  END IF;

  SET v_step = 6900;

  SET p_return_msg = v_msgtext;

  SET p_result = v_result;

END ws_act_build;
_PROCEDWSL_ Ws_Act_Build_All 
CREATE PROCEDURE [METABASE].Ws_Act_Build_All (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, IN  p_parameter       varchar(4000)
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

WS_ACT_BUILD_ALL:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_drop
  -- Description  : Build all indexes associated with an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 30/08/2001 Version 0.3.0.6  Added support for Primary Keys
  -- WMR 21/01/2002 Version 1.0.0.0  Added support for Partitioned indexes
  -- WMR 20/03/2002 Version 1.0.6.0  Added support for Parallel index builds
  -- WMR 02/12/2002 Version 1.2.1.5  Fixed missing K on extents and added support for pct free
  -- WMR 24/12/2003 Version 4.1.0.0  Added support for compressed indexes
  -- WMR 17/04/2004 Version 4.1.0.0  Added support for compute statistics in index create
  -- WMR 15/05/2004 Version 4.1.0.8  Added support for buffer pool options
  -- WMR 25/05/2004 Version 4.1.0.8  Added support for pctfree column and function indexes
  -- WMR 23/07/2004 Version 4.1.0.8  Added support p_parameter being passed in
  -- WMR 24/06/2005 Version 4.1.2.11 Include the schema name in the create if flag set
  -- WMR 05/07/2005 Version 4.1.2.13 Changed user_tab_partitions to all_tab_partitions
  -- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
  --                                 Add call to wswrkerror for each index as built
  -- JML 24/01/2008 Version 5.6.3.1  Teradata version
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_stmt                     VARCHAR(1024); -- Used for dynamic SQL
  DECLARE v_obj_done                 INTEGER;       -- Used to flag successful drop
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar

  DECLARE v_IndexOnlyFetch           INTEGER;
  DECLARE v_IndexFetch               INTEGER;
  DECLARE v_IndColFetch              INTEGER;

  DECLARE v_ih_table                 VARCHAR(64);
  DECLARE v_ih_index_key             INTEGER;
  DECLARE v_ih_index_name            VARCHAR(64);
  DECLARE v_ih_index_type            VARCHAR(1);
  DECLARE v_ih_unique                VARCHAR(1);
  DECLARE v_ih_tablespace            VARCHAR(64);
  DECLARE v_ic_column                VARCHAR(64);

  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   INTEGER;  -- return code
  DECLARE v_user_database            VARCHAR(64);
  DECLARE v_columns                  VARCHAR(8000);
  DECLARE v_col_number               INTEGER;
  DECLARE v_index_key                INTEGER;
  DECLARE v_epos                     INTEGER;
  DECLARE v_spos                     INTEGER;

  --=====================================================
  -- Cursor for all indexes
  --=====================================================
  DECLARE c_Index CURSOR FOR
    SELECT ih_table
         , ih_index_key
         , ih_index_name
         , ih_index_type
         , ih_unique
         , ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_obj_key = :p_obj_key
    AND    ih_index_type <> 'P'
    AND    ih_active = 'Y';

  --=====================================================
  -- Cursor for index columns
  --=====================================================
  DECLARE c_IndCol CURSOR FOR
    SELECT   ic_column
    FROM     [METABASE].ws_index_col
    WHERE    ic_index_key = :v_index_key
    ORDER BY ic_column_no;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Act_Build_All. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================
  SET v_ws_pro_version = '(8.4.1.0)';
  SET v_ws_obj_fact = 5;
  SET v_ws_obj_dim = 6;
  SET v_ws_obj_stage = 7;
  SET v_ws_obj_load = 8;
  SET v_ws_obj_agg = 9;
  SET v_ws_obj_index = 10;
  SET v_ws_obj_export = 13;
  SET v_ws_obj_view = 18;
  SET v_ws_obj_join = 20;
  SET v_ws_obj_retro = 21;
  SET v_ws_obj_retro_copy = 22;

  SET v_ws_act_drop = 1;
  SET v_ws_act_create = 2;
  SET v_ws_act_drop_all = 3;
  SET v_ws_act_pre_drop = 4;
  SET v_ws_act_load = 5;
  SET v_ws_act_update = 6;
  SET v_ws_act_execute = 7;
  SET v_ws_act_process = 8;
  SET v_ws_act_build = 9;
  SET v_ws_act_build_all = 10;
  SET v_ws_act_analyze = 11;
  SET v_ws_act_quick_analyze = 12;
  SET v_ws_act_statistics = 13;
  SET v_ws_act_quick_statistics = 14;

  SET v_step = 100;

  SET v_count = 0;
  SET p_status_code = 1;
  SET v_result = 1;

  SET v_step = 200;

  --=====================================================
  -- See if a specific database was specified and if
  -- so use that tablespace
  --=====================================================
  SET v_user_database = NULL;

  IF ( p_parameter IS NOT NULL ) THEN

    SET v_spos = INDEX(UPPER(p_parameter),'TABLESPACE=');

    IF ( v_spos > 0 ) THEN

      SET v_epos = v_spos + INDEX(SUBSTR(p_parameter,v_spos,100),';');

      IF v_epos > v_spos THEN

        SET v_user_database = SUBSTR(p_parameter,v_spos+11,v_epos-(v_spos+12));

      ELSE

        SET v_user_database = SUBSTR(p_parameter,v_spos+11,30);

      END IF;

    END IF;

  END IF;

  SET v_step = 300;

  --=====================================================
  -- Loop through all the indexes looking for what to build
  --=====================================================
  OPEN c_Index;
  FETCH NEXT FROM c_Index INTO
      v_ih_table
    , v_ih_index_key
    , v_ih_index_name
    , v_ih_index_type
    , v_ih_unique
    , v_ih_tablespace;
  SET v_IndexFetch = SQLCODE;

  WHILE ( v_IndexFetch = 0 )
  DO

    --=====================================================
    -- First drop the index in case that step was not run
    -- Execute the drop
    --=====================================================
    SET v_step = 400;

    IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN

      SET v_step = 500;

      SET v_stmt = 'drop hash index ';
      SET v_stmt = v_stmt||v_ih_tablespace||'.';
      SET v_stmt = v_stmt||v_ih_index_name;

    ELSE

      SET v_step = 600;

      CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                     , 0, :v_ih_table
                                     , 'database'
                                     , :v_db_return_code, :v_db_return_msg
                                     , :v_db_result, :v_table_db);

      SET v_step = 700;

      SET v_stmt = 'drop index ';
      SET v_stmt = v_stmt||v_ih_index_name;
      SET v_stmt = v_stmt||' on ';
      SET v_stmt = v_stmt||v_table_db||'.';
      SET v_stmt = v_stmt||v_ih_table;

    END IF;

    SET v_step = 800;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
        END;

      SET v_step = 900;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 1000;

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 1100;

    IF ( v_obj_done = 1 ) THEN

      SET v_step = 1200;

      SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

    --=====================================================
    -- Create the rebuild command
    --=====================================================
    SET v_step = 1300;

    SET v_stmt = 'Create ';

    SET v_step = 1400;

    IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN
      SET v_stmt = v_stmt||'Hash ';
    ELSEIF ( v_ih_unique = 'Y') THEN
      SET v_stmt = v_stmt||'Unique ';
    END IF;

    SET v_step = 1500;

    SET v_stmt = v_stmt||'Index ';
    SET v_stmt = v_stmt||v_ih_index_name||' (';

    SET v_step = 1600;

    -- Now add in all the columns
    SET v_index_key = v_ih_index_key;
    SET v_columns = '';
    SET v_col_number = 0;

    SET v_step = 1700;

    OPEN c_IndCol;
    FETCH NEXT FROM c_IndCol INTO
        v_ic_column;

    SET v_IndColFetch = SQLCODE;

    SET v_step = 1800;

    WHILE ( v_IndColFetch = 0 )
    DO

      SET v_step = 1900;

      SET v_col_number = v_col_number + 1;

      IF ( v_col_number > 1 ) THEN
        SET v_columns = v_columns||',';
      END IF;

      SET v_columns = v_columns||v_ic_column;

      -- Get the next index column
      SET v_IndColFetch = 0;

      SET v_step = 2000;

      FETCH NEXT FROM c_IndCol INTO
          v_ic_column;

      SET v_IndColFetch = SQLCODE;

    END WHILE; -- End of index columns loop

    SET v_step = 2100;

    CLOSE c_IndCol;

    SET v_step = 2200;

    SET v_stmt = v_stmt||v_columns||') On ';

    SET v_step = 2300;

    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                   , 0, :v_ih_table
                                   , 'database'
                                   , :v_db_return_code, :v_db_return_msg
                                   , :v_db_result, :v_table_db);

    SET v_step = 2400;

    IF (( v_table_db IS NOT NULL ) AND ( v_table_db <> '' ) AND ( v_db_result = 1 )) THEN
      SET v_stmt = v_stmt||v_table_db||'.';
    END IF;

    SET v_step = 2500;

    SET v_stmt = v_stmt||v_ih_table;

    SET v_step = 2600;

    SET v_obj_done = 1;

    --=====================================================
    -- Rebuild the index
    --=====================================================
    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in ws_act_build_all. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Index Create for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
              ' SQL: '|| v_stmt ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET v_result = -3;
        END;

      SET v_step = 2700;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 2800;

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 2900;

    IF ( v_obj_done = 1 ) THEN

      SET v_step = 3000;

      SET v_count = v_count + 1;

      SET v_step = 3100;

      SET v_msgtext = 'Index ' || v_ih_index_name || ' rebuilt';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

    SET v_step = 3200;

    -- Get the next index
    SET v_IndexFetch = 0;

    SET v_step = 3300;

    FETCH NEXT FROM c_Index INTO
        v_ih_table
      , v_ih_index_key
      , v_ih_index_name
      , v_ih_index_type
      , v_ih_unique
      , v_ih_tablespace;
    SET v_IndexFetch = SQLCODE;

  END WHILE; -- End of log file checks for this parent

  SET v_step = 3400;

  CLOSE c_Index;

  SET v_step = 3500;

  -- tell them how many indexes we dropped
  IF ( v_count = 0 ) THEN

    SET v_msgtext = 'No indexes rebuilt';

  ELSEIF ( v_count = 1 ) THEN

    SET v_msgtext = CAST(v_count AS VARCHAR(18)) ||' index rebuilt';

  ELSE

    SET v_msgtext = CAST(v_count AS VARCHAR(18))  ||' indexes rebuilt';

  END IF;

  SET v_step = 3600;

  SET p_return_msg = v_msgtext;

  SET p_result = v_result;

END ws_act_build_all;
_PROCEDWSL_ Ws_Act_Statistics 
CREATE PROCEDURE [METABASE].Ws_Act_Statistics (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_analyze
  -- Description  : Analyze a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 05/04/2002  Version 1.0.7   Added for all indexed columns to analyze
  -- WMR 25/10/2002  Version 1.2.1   Sql Server version
  -- WMR 22/11/2002  Version 5.0.0   Teradata version
  -- RS  16/06/2015  Version 6.8.4.2 Enabled targets for Teradata
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         integer;
  DECLARE v_ws_obj_fact_kpi          integer;
  DECLARE v_ws_obj_script            integer;
  DECLARE v_ws_obj_template          integer;
  DECLARE v_ws_obj_fact              integer;
  DECLARE v_ws_obj_dim               integer;
  DECLARE v_ws_obj_stage             integer;
  DECLARE v_ws_obj_load              integer;
  DECLARE v_ws_obj_agg               integer;
  DECLARE v_ws_obj_index             integer;
  DECLARE v_ws_obj_connect           integer;
  DECLARE v_ws_obj_dim_view          integer;
  DECLARE v_ws_obj_document          integer;
  DECLARE v_ws_obj_cube              integer;
  DECLARE v_ws_obj_cube_virtual      integer;
  DECLARE v_ws_obj_report            integer;
  DECLARE v_ws_obj_user1             integer;
  DECLARE v_ws_obj_user2             integer;
  DECLARE v_ws_obj_user3             integer;
  DECLARE v_ws_obj_user4             integer;
  DECLARE v_ws_obj_job               integer;

  DECLARE v_ws_act_drop              integer;
  DECLARE v_ws_act_create            integer;
  DECLARE v_ws_act_drop_all          integer;
  DECLARE v_ws_act_pre_drop          integer;
  DECLARE v_ws_act_load              integer;
  DECLARE v_ws_act_update            integer;
  DECLARE v_ws_act_execute           integer;
  DECLARE v_ws_act_process           integer;
  DECLARE v_ws_act_build             integer;
  DECLARE v_ws_act_build_all         integer;
  DECLARE v_ws_act_analyze           integer;
  DECLARE v_ws_act_quick_analyze     integer;
  DECLARE v_ws_act_statistics        integer;
  DECLARE v_ws_act_quick_statistics  integer;
  DECLARE v_ws_act_initial           integer;
  DECLARE v_ws_act_cube_dim          integer;
  DECLARE v_ws_act_db_dim            integer;
  DECLARE v_ws_act_custom            integer;
  DECLARE v_ws_act_truncate          integer;

  DECLARE v_step                     integer;       -- Step number
  DECLARE v_table_type               integer;       -- Object type of the table if an index
  DECLARE v_stmt                     varchar(8000); -- Dynamic SQL variable
  DECLARE v_table_name               varchar(64);   -- Table Name if an index
  DECLARE v_tablespace               varchar(64);   -- Database name
  DECLARE v_msgtext                  varchar(1024); -- Text for audit_trail
  DECLARE v_sql_code                 integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_obj_key                  integer;       -- Used for table object key if an index


  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Act_Statistics. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Initialize variables
  --=====================================================
  SET v_ws_pro_version             = '8.4.1.0';
  SET v_ws_obj_procedure           = 1;
  SET v_ws_obj_fact_kpi            = 2;
  SET v_ws_obj_script              = 3;
  SET v_ws_obj_template            = 4;
  SET v_ws_obj_fact                = 5;
  SET v_ws_obj_dim                 = 6;
  SET v_ws_obj_stage               = 7;
  SET v_ws_obj_load                = 8;
  SET v_ws_obj_agg                 = 9;
  SET v_ws_obj_index               = 10;
  SET v_ws_obj_connect             = 11;
  SET v_ws_obj_dim_view            = 12;
  SET v_ws_obj_document            = 13;
  SET v_ws_obj_cube                = 15;
  SET v_ws_obj_cube_virtual        = 16;
  SET v_ws_obj_report              = 17;
  SET v_ws_obj_user1               = 18;
  SET v_ws_obj_user2               = 19;
  SET v_ws_obj_user3               = 20;
  SET v_ws_obj_user4               = 21;
  SET v_ws_obj_job                 = 50;

  SET v_ws_act_drop                = 1;
  SET v_ws_act_create              = 2;
  SET v_ws_act_drop_all            = 3;
  SET v_ws_act_pre_drop            = 4;
  SET v_ws_act_load                = 5;
  SET v_ws_act_update              = 6;
  SET v_ws_act_execute             = 7;
  SET v_ws_act_process             = 8;
  SET v_ws_act_build               = 9;
  SET v_ws_act_build_all           = 10;
  SET v_ws_act_analyze             = 11;
  SET v_ws_act_quick_analyze       = 12;
  SET v_ws_act_statistics          = 13;
  SET v_ws_act_quick_statistics    = 14;
  SET v_ws_act_initial             = 15;
  SET v_ws_act_cube_dim            = 16;
  SET v_ws_act_db_dim              = 17;
  SET v_ws_act_custom              = 18;
  SET v_ws_act_truncate            = 19;

  SET v_step = 10;
  SET p_result = 1;
  SET p_status_code = 1;

  --=====================================================
  -- Handle either an Index or a Table
  --=====================================================

  IF ( p_obj_type = v_ws_obj_index ) THEN

    --=====================================================
    -- Index
    --=====================================================

    -- Get table object type.
    SELECT ih_obj_key
    INTO   :v_obj_key
    FROM   [METABASE].ws_index_header
    WHERE  ih_index_key = :p_obj_key;

    -- Get table object type.
    SELECT oo_type_key
         , oo_name
    INTO   :v_table_type
         , :v_table_name
    FROM   [METABASE].ws_obj_object
    WHERE  oo_obj_key = :v_obj_key;

    -- Get the tablespace of the table.
    IF ( v_table_type = v_ws_obj_load ) THEN
      SELECT COALESCE(dt_database, lt_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_load_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON lt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  lt_obj_key = :v_obj_key;
    ELSEIF ( v_table_type = v_ws_obj_stage ) THEN
      SELECT COALESCE(dt_database, st_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_stage_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON st_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  st_obj_key = :v_obj_key;
    ELSEIF ( v_table_type = v_ws_obj_dim ) THEN
      SELECT COALESCE(dt_database, dt_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_dim_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON dt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  dt_obj_key = :v_obj_key;
    ELSEIF ( v_table_type = v_ws_obj_agg ) THEN
      SELECT COALESCE(dt_database, at_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_agg_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON at_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  at_obj_key = :v_obj_key;
    END IF;

    -- If analyze
    IF ( p_action = v_ws_act_statistics ) THEN
      SET v_stmt = 'COLLECT STATISTICS ON ';
    -- Else If quick analyze
    ELSE
      SET v_stmt = 'COLLECT STATISTICS USING SAMPLE ON ';
    END IF;

    SET v_stmt = v_stmt||v_tablespace||'.';
    SET v_stmt = v_stmt||v_table_name;
    SET v_stmt = v_stmt||' INDEX ';
    SET v_stmt = v_stmt||p_task_name;

    SET p_return_msg = 'Index '||p_task_name||' analyzed';

    -- Execute the analyze
    SET v_step = 90;
    CALL DBC.SYSEXECSQL ( :v_stmt );
    SET v_step = 92;

  ELSE

    --=====================================================
    -- Table
    --=====================================================

    -- Get the tablespace of the table.
    IF ( p_obj_type = v_ws_obj_load ) THEN
      SELECT COALESCE(dt_database, lt_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_load_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON lt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  lt_obj_key = :p_obj_key;
    ELSEIF ( p_obj_type = v_ws_obj_stage ) THEN
      SELECT COALESCE(dt_database, st_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_stage_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON st_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  st_obj_key = :p_obj_key;
    ELSEIF ( p_obj_type = v_ws_obj_dim ) THEN
      SELECT COALESCE(dt_database, dt_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_dim_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON dt_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  dt_obj_key = :p_obj_key;
    ELSEIF ( p_obj_type = v_ws_obj_agg ) THEN
      SELECT COALESCE(dt_database, at_tablespace,'')
      INTO   :v_tablespace
      FROM   [METABASE].ws_agg_tab
      LEFT JOIN [METABASE].ws_obj_object ws_obj_object
      ON at_obj_key = oo_obj_key
      LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
      ON dt_target_key = oo_target_key
      LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
      ON dc_obj_key = dt_connect_key
      WHERE  at_obj_key = :p_obj_key;
    END IF;

    -- If analyze
    IF ( p_action = v_ws_act_statistics ) THEN

      SET v_stmt = 'COLLECT STATISTICS ON ';
      SET v_stmt = v_stmt||v_tablespace||'.';
      SET v_stmt = v_stmt||p_task_name;

      SET p_return_msg = 'Table '||p_task_name||' analyzed ';

      -- Execute the analyze
      SET v_step = 94;
      CALL DBC.SYSEXECSQL ( :v_stmt );
      SET v_step = 96;

    -- Else If quick analyze (not supported for tables)
    ELSE

      SET p_result = -2;
      SET p_status_code = -2;
      SET p_return_msg = 'Quick Stats (Sampling) not implemented for Teradata Tables';

    END IF;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Drop 
CREATE PROCEDURE [METABASE].Ws_Act_Drop (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

WS_ACT_DROP:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_drop
  -- Description  : Drop a table or Index
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002 Version 1.0.0
  -- WMR 10/02/2005 Version 4.1.1.3  added support for user views and version in errors
  -- WMR 24/06/2005 Version 4.1.2.11 include the schema name in the create if flag set
  -- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
  --                                 Add call to wswrkerror for each index as drop/built
  -- JML 24/01/2008 Version 5.6.3.1  Teradata version
  -- AP  29/04/2008 Version 6.0.0.0  ODS and Normal objects
  -- JML 01/09/2008 Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013 Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016 Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_stmt                     VARCHAR(1024); -- Used for dynamic SQL
  DECLARE v_obj_done                 INTEGER;       -- Used to flag successful drop
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_ih_index_type            VARCHAR(1);
  DECLARE v_ih_table                 VARCHAR(64);
  DECLARE v_ih_index_name            VARCHAR(64);
  DECLARE v_ih_tablespace            VARCHAR(64);
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Act_Drop. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================

  SET v_step = 100;

  SET p_status_code = 1;
  SET p_result = 1;

  --=====================================================
  -- Handle either an Index, Table, Join Index or View
  --=====================================================

  IF p_obj_type = v_ws_obj_index THEN

    SET v_step = 200;

    SELECT ih_table
         , ih_index_name
         , ih_index_type
         , ih_tablespace
    INTO   :v_ih_table
         , :v_ih_index_name
         , :v_ih_index_type
         , :v_ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_index_key = :p_obj_key
    ;

    SET v_step = 300;

    IF SUBSTR(v_ih_index_type,1,1) = 'H' THEN

      SET v_step = 400;

      SET v_stmt = 'drop hash index ';
      SET v_stmt = v_stmt||v_ih_tablespace||'.';
      SET v_stmt = v_stmt||v_ih_index_name;

    ELSE

      SET v_step = 500;

      CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                     , NULL, :v_ih_table
                                     , 'database'
                                     , :v_db_return_code, :v_db_return_msg
                                     , :v_db_result, :v_table_db);

      SET v_step = 600;

      SET v_stmt = 'drop index ';
      SET v_stmt = v_stmt||v_ih_index_name;
      SET v_stmt = v_stmt||' on ';
      SET v_stmt = v_stmt||v_table_db||'.';
      SET v_stmt = v_stmt||v_ih_table;

    END IF;

    SET v_step = 700;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in Ws_Act_Drop. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Index Drop for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET p_result = -3;
        END;

      SET v_step = 800;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 900;

      SET p_return_msg = 'Index ' || v_ih_index_name || ' dropped';

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 1000;

    IF v_obj_done = 1 THEN

      SET v_step = 1100;

      SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

  ELSEIF p_obj_type = v_ws_obj_view THEN

    SET v_step = 1200;

    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                   , NULL, :p_task_name
                                   , 'database'
                                   , :v_db_return_code, :v_db_return_msg
                                   , :v_db_result, :v_table_db);

    SET v_step = 1300;

    SET v_stmt = 'drop view ';
    SET v_stmt = v_stmt||v_table_db||'.';
    SET v_stmt = v_stmt||p_task_name;

    SET v_step = 1400;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in Ws_Act_Drop. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' View Drop for View ' || p_task_name ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET p_result = -3;
        END;

      SET v_step = 1500;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 1600;

      SET p_return_msg = 'View '||p_task_name||' dropped';

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 1700;

    IF v_obj_done = 1 THEN

      SET v_step = 1800;

      SET v_msgtext = 'View '||p_task_name||' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

  ELSEIF p_obj_type = v_ws_obj_join THEN

    SET v_step = 1900;

    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                   , NULL, :p_task_name
                                   , 'database'
                                   , :v_db_return_code, :v_db_return_msg
                                   , :v_db_result, :v_table_db);

    SET v_step = 2000;

    SET v_stmt = 'drop join index ';
    SET v_stmt = v_stmt||v_table_db||'.';
    SET v_stmt = v_stmt||p_task_name;

    SET v_step = 2100;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in Ws_Act_Drop. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Join Index Drop for Join Index ' || p_task_name ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET p_result = -3;
        END;

      SET v_step = 2200;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 2300;

      SET p_return_msg = 'Join Index '||p_task_name||' dropped';

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 2400;

    IF v_obj_done = 1 THEN

      SET v_step = 2500;

      SET v_msgtext = 'Join Index '||p_task_name||' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

  ELSE
    --=====================================================
    -- Table.
    --=====================================================

    SET v_step = 2600;

    CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                   , NULL, :p_task_name
                                   , 'database'
                                   , :v_db_return_code, :v_db_return_msg
                                   , :v_db_result, :v_table_db);

    SET v_step = 2700;

    SET v_stmt = 'drop table ';
    SET v_stmt = v_stmt||v_table_db||'.';
    SET v_stmt = v_stmt||p_task_name;

    SET v_step = 2800;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in Ws_Act_Drop. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Table Drop for Table ' || p_task_name ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET p_result = -3;
        END;

      SET v_step = 2900;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 3000;

      SET p_return_msg = 'Table '||p_task_name||' dropped';

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 3100;

    IF v_obj_done = 1 THEN

      SET v_step = 3200;

      SET v_msgtext = 'Table '||p_task_name||' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

  END IF;

END ws_act_drop;
_PROCEDWSL_ Ws_Act_Create_Join 
CREATE PROCEDURE [METABASE].Ws_Act_Create_Join
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_create          varchar(4000)
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
)
WS_ACT_CREATE_JOIN:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name             Teradata
  -- Script Name           ws_act_create_join
  -- Description           Generates DDL for a Join Index
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Split from Ws_Act_Create
  -- AP  19/10/2010  Version 6.5.1.1  RED-1835 Handle Table Properties (Partition) Clause.
  -- JML 20/10/2010  Version 6.5.1.1  RED-1878 Include missing Primary Index.
  --                                  RED-1891 Added logic to parse square brackets in from/where
  --                                    and add database names.
  --                                  RED-1892 Fixed bug in IF statement checking for existence of
  --                                    a FROM clause in the WHERE field.
  --                                  RED-1893 Primary index column cursor was using primary
  --                                    index metadata in ws_index_col, now using pi column
  --                                    indicator on ws_join_col.
  --                                  Several very minor cosmetic code formatting changes.
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_create                   VARCHAR(8000);
  DECLARE v_row                      INTEGER;
  DECLARE v_table_created            INTEGER;
  DECLARE v_alter_ind                INTEGER;
  DECLARE v_database                 VARCHAR(64);
  DECLARE v_post_fix                 VARCHAR(4000);
  DECLARE v_pct_free                 INTEGER;
  DECLARE v_primary_index_unique     VARCHAR(1);
  DECLARE v_table_name               VARCHAR(64);
  DECLARE v_column                   VARCHAR(4000);
  DECLARE v_col                      INTEGER;
  DECLARE v_where                    VARCHAR(4000);
  DECLARE v_group_col                VARCHAR(4000);
  DECLARE v_order_by                 INTEGER;
  DECLARE v_group_by                 VARCHAR(4000);
  DECLARE v_order_by_required        VARCHAR(1);
  DECLARE v_src_table                VARCHAR(64);
  DECLARE v_src_database             VARCHAR(64);
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(1024);
  DECLARE v_info_result              INTEGER;
  DECLARE v_log_ddl_cntr             INTEGER;
  DECLARE v_from_tab                 VARCHAR(4000);
  DECLARE v_cpos                     INTEGER;
  DECLARE v_tab_meta                 VARCHAR(32000);
  DECLARE v_meta_loop                INTEGER;
  DECLARE v_keys                     VARCHAR(4000);
  DECLARE v_primary_index_name       VARCHAR(64);
  DECLARE v_len                      INTEGER;

  --=====================================================
  -- Cursor to find the primary index columns
  --=====================================================
  DECLARE c_prim_ind_col CURSOR FOR
  SELECT   jc_col_name
  FROM     [METABASE].ws_join_col
  WHERE    jc_obj_key = p_obj_key
  AND      NULLIF(TRIM(jc_primary_index_ind),'') IS NOT NULL
  ORDER BY jc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find the primary index name
  --=====================================================
  -- RED-1893 now using correct metadata table as source.
  DECLARE c_prim_ind_name CURSOR FOR
  SELECT ih_index_name
  FROM   [METABASE].ws_index_header
  WHERE  ih_obj_key = p_obj_key
  AND    ih_index_type = 'P'
  ;

  --=====================================================
  -- Cursor to find all join columns
  --=====================================================
  DECLARE c_join_col CURSOR FOR
  SELECT   CASE WHEN NULLIF(TRIM(jc_transform_code),'') IS NOT NULL THEN jc_transform_code || ' ' || jc_col_name
                WHEN jc_sum_flag = 'Y' THEN 'SUM(' || jc_src_table || '.' || jc_src_column || ') ' || jc_col_name
                WHEN jc_count_flag = 'Y' THEN 'COUNT(' || jc_src_table || '.' || jc_src_column || ') ' || jc_col_name
                WHEN jc_src_column <> jc_col_name THEN jc_src_table || '.' || jc_src_column || ' ' || jc_col_name
                ELSE jc_src_table || '.' || jc_src_column
                END
         , CASE WHEN jc_group_flag = 'Y' AND NULLIF(TRIM(jc_transform_code),'') IS NOT NULL THEN jc_transform_code
                WHEN jc_group_flag = 'Y' AND NULLIF(TRIM(jc_transform_code),'') IS NULL THEN jc_src_table || '.' || jc_src_column
                ELSE ''
                END
         , jc_order_by
  FROM     [METABASE].ws_join_col
  WHERE    jc_obj_key = p_obj_key
  ORDER BY jc_order
  ;

  --=====================================================
  -- Cursor to find join source tables
  --=====================================================
  DECLARE c_join_src CURSOR FOR
  SELECT DISTINCT jc_src_table
  FROM   [METABASE].ws_join_col
  WHERE  jc_obj_key = p_obj_key
  AND    NULLIF(TRIM(jc_src_table),'') IS NOT NULL
  ;

  --=====================================================
  -- Cursor to find join order by columns
  --=====================================================
  DECLARE c_join_ord CURSOR FOR
  SELECT   jc_col_name
  FROM     [METABASE].ws_join_col
  WHERE    jc_obj_key = p_obj_key
  AND      jc_order_by > 0
  ORDER BY jc_order_by
  ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Create_Join Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_table_created            = 0;
  SET v_alter_ind                = 0;
  SET v_group_by                 = '';
  SET v_order_by_required        = 'N';
  SET v_log_ddl_cntr             = 0;
  SET v_from_tab                 = '';
  SET v_meta_loop                = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  SET v_step = 10;

  --=====================================================
  --=====================================================
  -- Get table metadata for each table type
  --=====================================================
  --=====================================================

  CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                               , p_obj_key, NULL
                               , 'ALL'
                               , v_info_return_code, v_info_return_msg
                               , v_info_result, v_tab_meta );

  WHILE ( v_meta_loop < 9 ) DO

    SET v_meta_loop = v_meta_loop + 1;

    SET v_cpos = INDEX(v_tab_meta,X'08');

    IF v_meta_loop = 1 THEN

      SET v_database = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 2 THEN

      SET v_post_fix = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 3 THEN

      SET v_pct_free = CAST(SUBSTR(v_tab_meta,1,v_cpos-1) AS INTEGER);

    ELSEIF v_meta_loop = 4 THEN

      SET v_primary_index_unique = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 8 THEN

      SET v_table_name = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 9 THEN

      SET v_where = SUBSTR(v_tab_meta,1,v_cpos-1);

    END IF;

    SET v_tab_meta = SUBSTR(v_tab_meta,v_cpos+1);

  END WHILE;

  --=====================================================
  --=====================================================
  -- Get the database for the table
  --=====================================================
  --=====================================================

  -- If the database is null, lookup the current users default database
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SELECT CASE WHEN DefaultDataBase IS NULL
                THEN UserName
                ELSE DefaultDataBase
                END
    INTO   v_database
    FROM   DBC.Users
    WHERE  UserName = USER
    ;

  END IF;

  -- If the database is still null, set it to the USER.
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SET v_database = USER;

  END IF;

  SET v_database = TRIM(v_database);

  SET v_create = 'CREATE JOIN INDEX ';

  -- Add in the database is specified
  IF NULLIF(TRIM(v_database),'') IS NOT NULL THEN

    SET v_create = v_create || v_database || '.';

  END IF;

  -- Add in the table name
  SET v_create = v_create || v_table_name;
  SET v_create = v_create || ' ' || X'0A' || 'AS ' || X'0A';

  -- If user defined
  IF SUBSTR(TRIM(LOWER(v_where)),1,6) = 'select' THEN

    SET v_create = v_create || v_where;

  -- Construct the SELECT
  ELSE

    SET v_create = v_create || 'SELECT ';

    -- Add in the column names and construct the group
    -- by (if any) to use later.
    SET v_no_more_data1 = 0;
    SET v_row = 0;
    SET v_col = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_join_col;

      FETCH FROM c_join_col INTO v_column, v_group_col, v_order_by;

      WHILE v_no_more_data1 = 0 DO

        SET v_row = v_row + 1;
        SET v_col = v_col + 1;

        IF v_row > 1 THEN

          SET v_create = v_create || ',';

          IF NULLIF(TRIM(v_group_col),'') IS NOT NULL THEN

            SET v_group_by = v_group_by || ',';

          END IF;

        END IF;

        SET v_create = v_create || v_column;

        SET v_group_by = v_group_by || v_group_col;

        IF v_col > 3 THEN

          SET v_col = 0;

          SET v_create = v_create || X'0A';

          IF NULLIF(TRIM(v_group_by),'') IS NOT NULL THEN

            SET v_group_by = v_group_by || X'0A';

          END IF;

        END IF;

        IF v_order_by > 0 THEN

          SET v_order_by_required = 'Y';

        END IF;

        FETCH FROM c_join_col INTO v_column, v_group_col, v_order_by;

      END WHILE;

      CLOSE c_join_col;

    END;

    -- Construct the FROM if it is not in the WHERE field.
    --   RED-1892 Fixed bug in IF statement checking for existence of
    --            a FROM clause in the WHERE field.
    --            Next line only has changed.
    IF SUBSTR(COALESCE(TRIM(LOWER(v_where)),''),1,4) <> 'from' THEN

      SET v_create = v_create || X'0A' || 'FROM ';
      SET v_no_more_data1 = 0;
      SET v_row = 0;

      BEGIN

        DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_no_more_data1 = 1;

        OPEN c_join_src;

        FETCH FROM c_join_src INTO v_src_table;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ', ';

          END IF;

          -- Get the database of the source table.
          CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                       , p_obj_key, NULL
                                       , 'database'
                                       , v_info_return_code, v_info_return_msg
                                       , v_info_result, v_src_database);

          IF NULLIF(TRIM(v_src_database),'') IS NOT NULL THEN

            SET v_create = v_create || v_src_database || '.';

          END IF;

          SET v_create = v_create || v_src_table;

          IF NULLIF(TRIM(v_src_database),'') IS NOT NULL THEN

            SET v_create = v_create || ' ' || v_src_table;

          END IF;

          SET v_create = v_create || X'0A';

          FETCH FROM c_join_src INTO v_src_table;

        END WHILE;

        CLOSE c_join_src;

      END;

    ELSE

      SET v_create = v_create || X'0A';

    END IF;

    -- Add in the WHERE field, if not empty after resolving table names in brackets to databases.
    IF NULLIF(TRIM(v_where),'') IS NOT NULL THEN

      -- =============================================================================
      -- RED-1891 Added logic to parse square brackets in from/where
      --          and add database names.
      -- =============================================================================
      SET v_cpos = INDEX((COALESCE(v_where,'')),X'5B');

      WHILE v_cpos <> 0 DO

        SET v_len = INDEX((COALESCE(v_where,'')),X'5D');

        SET v_src_table = SUBSTR(v_where,v_cpos+1,v_len-v_cpos-1);

        -- Get the database of the source table.
        CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                     , NULL, v_src_table
                                     , 'database'
                                     , v_info_return_code, v_info_return_msg
                                     , v_info_result, v_src_database);

        SET v_where = SUBSTR(v_where,1,v_cpos-1) || v_src_database || '.' || v_src_table || SUBSTR(v_where,v_len+1);

        SET v_cpos = INDEX((COALESCE(v_where,'')),X'5B');

      END WHILE;
      -- =============================================================================
      -- End of RED-1891
      -- =============================================================================

      SET v_create = v_create || v_where || X'0A';

    END IF;

    -- Add in the GROUP BY if built and not in the WHERE field.
    IF (( INDEX(LOWER((COALESCE(v_where,''))),'group by') = 0 ) AND ( NULLIF(TRIM(v_group_by),'') IS NOT NULL )) THEN

      SET v_create = v_create || 'GROUP BY ' || v_group_by;

    END IF;

    -- Add in the ORDER BY if set and not in the WHERE field.
    IF (( INDEX(LOWER(v_where),'order by') = 0 ) AND ( v_order_by_required = 'Y' )) THEN

      -- Get the first order by column and THERE CAN BE ONLY ONE.
      BEGIN

        DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_column = '';

        OPEN c_join_ord;

        FETCH FROM c_join_ord INTO v_column;

        CLOSE c_join_ord;

        SET v_create = v_create || 'ORDER BY ' || v_column || ' ' || X'0A';

      END;

    END IF;

  END IF;

  -- =============================================================================
  -- RED-1878 Include missing Primary Index
  -- =============================================================================
  -- Look for a defined primary index and key columns
  SET v_keys = '';
  SET v_no_more_data1 = 0;

  BEGIN

    DECLARE CONTINUE HANDLER FOR NOT FOUND
      SET v_no_more_data1 = 1;

    OPEN c_prim_ind_col;

    FETCH FROM c_prim_ind_col INTO v_column;

    WHILE v_no_more_data1 = 0 DO

      IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

        SET v_keys = v_keys || ',';

      END IF;

      SET v_keys = v_keys || v_column;

      FETCH FROM c_prim_ind_col INTO v_column;

    END WHILE;

    CLOSE c_prim_ind_col;

  END;

  -- Get the primary index name
  BEGIN

    DECLARE CONTINUE HANDLER FOR NOT FOUND
      SET v_primary_index_name = '';

    OPEN c_prim_ind_name;

    FETCH FROM c_prim_ind_name INTO v_primary_index_name;

    CLOSE c_prim_ind_name;

  END;

  -- Add the primary index statement if there is one defined
  IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

    IF v_primary_index_unique = 'Y' THEN

      SET v_create = v_create || 'UNIQUE PRIMARY INDEX ';

      IF NULLIF(TRIM(v_primary_index_name),'') IS NOT NULL THEN

        SET v_create = v_create || v_primary_index_name;

      END IF;

      SET v_create = v_create || ' (';
      SET v_create = v_create || v_keys;
      SET v_create = v_create || ')' || X'0A' || ' ';

    ELSE

      SET v_create = v_create || 'PRIMARY INDEX ';

      IF NULLIF(TRIM(v_primary_index_name),'') IS NOT NULL THEN

        SET v_create = v_create || v_primary_index_name;

      END IF;

      SET v_create = v_create || ' (';
      SET v_create = v_create || v_keys;
      SET v_create = v_create || ')' || X'0A' || ' ';

    END IF;

    SET v_create = TRIM(v_create);

  END IF;
  -- =============================================================================
  -- End of RED-1878
  -- =============================================================================

  -- RED-1835 Include Table Properties / Partition BY Clause
  IF NULLIF(TRIM(v_post_fix),'') IS NOT NULL THEN

    SET v_create = v_create || v_post_fix || ' ' || X'0A';


  END IF;

  SET p_create = v_create;

END;
_PROCEDWSL_ Ws_Act_Create_View 
CREATE PROCEDURE [METABASE].Ws_Act_Create_View
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_create          varchar(4000)
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
)
WS_ACT_CREATE_VIEW:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name             Teradata
  -- Script Name           ws_act_create_view
  -- Description           Generates DDL for a View
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Split from Ws_Act_Create
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- AP  16/10/2014  Version 6.8.1.2  Support DISTINCT on views.
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- DLC 21/01/2016  Version 6.8.5.2  \r characters added to \n characters to make \r\n pairs
  -- AP  09/05/2016  Version 6.8.6.1  Include Title for view column definition
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- AP  22/09/2016  Version 6.8.6.2  Fixed issue with single quotes in TITLE
  -- AP  22/09/2016  Version 6.8.6.2  Don't add TITLE if has transform, 'impossible' to identify if an alias occurs where it must be inserted before
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_create                   VARCHAR(8000);
  DECLARE v_row                      INTEGER;
  DECLARE v_table_created            INTEGER;
  DECLARE v_alter_ind                INTEGER;
  DECLARE v_database                 VARCHAR(64);
  DECLARE v_post_fix                 VARCHAR(4000);
  DECLARE v_table_name               VARCHAR(64);
  DECLARE v_column                   VARCHAR(4000);
  DECLARE v_where                    VARCHAR(4000);
  DECLARE v_view_where               VARCHAR(4000);
  DECLARE v_type_ind                 VARCHAR(1);
  DECLARE v_attributes               VARCHAR(4000);
  DECLARE v_gen_spec                 VARCHAR(4000);
  DECLARE v_lock_mode                VARCHAR(24);
  DECLARE v_group_by                 VARCHAR(4000);
  DECLARE v_order_by_required        VARCHAR(1);
  DECLARE v_title                    VARCHAR(300);
  DECLARE v_src_table                VARCHAR(64);
  DECLARE v_src_database             VARCHAR(64);
  DECLARE v_src_column               VARCHAR(64);
  DECLARE v_transform                VARCHAR(4000);
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(1024);
  DECLARE v_info_result              INTEGER;
  DECLARE v_log_ddl_cntr             INTEGER;
  DECLARE v_from_tab                 VARCHAR(4000);
  DECLARE v_user_view                INTEGER;
  DECLARE v_user_full                INTEGER;
  DECLARE v_cpos                     INTEGER;
  DECLARE v_lenA                     INTEGER;
  DECLARE v_lenC                     INTEGER;
  DECLARE v_as                       VARCHAR(4000);
  DECLARE v_tab_meta                 VARCHAR(32000);
  DECLARE v_meta_loop                INTEGER;
  DECLARE v_new_value                VARCHAR(8000);

  --=====================================================
  -- Cursor to find all view columns
  --=====================================================
  DECLARE c_view_col CURSOR FOR
  SELECT   vc_col_name
         , COALESCE(TRIM(vc_display_name),'')
         , vc_src_column
         , vc_src_table
         , vc_transform_code
  FROM     [METABASE].ws_view_col
  WHERE    vc_obj_key = p_obj_key
  ORDER BY vc_order
  ;

  --=====================================================
  -- Cursor to find view source tables
  --=====================================================
  DECLARE c_view_src CURSOR FOR
  SELECT DISTINCT vc_src_table
  FROM   [METABASE].ws_view_col
  WHERE  vc_obj_key = p_obj_key
  AND    NULLIF(TRIM(vc_src_table),'') IS NOT NULL
  ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Create_View Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_table_created            = 0;
  SET v_alter_ind                = 0;
  SET v_group_by                 = '';
  SET v_order_by_required        = 'N';
  SET v_log_ddl_cntr             = 0;
  SET v_from_tab                 = '';
  SET v_as                       = '';
  SET v_meta_loop                = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  SET v_step = 100;

  --=====================================================
  --=====================================================
  -- Get table metadata for each table type
  --=====================================================
  --=====================================================
  CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                               , p_obj_key, NULL
                               , 'ALL'
                               , v_info_return_code, v_info_return_msg
                               , v_info_result, v_tab_meta  );

  WHILE ( v_meta_loop < 14 ) DO

    SET v_meta_loop = v_meta_loop + 1;
    SET v_cpos = INDEX(v_tab_meta,X'08');

    IF v_meta_loop = 1 THEN

      SET v_database = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 2 THEN

      SET v_post_fix = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 8 THEN

      SET v_table_name = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 9 THEN

      SET v_where = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 10 THEN

      SET v_view_where = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 11 THEN

      SET v_type_ind = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 12 THEN

      SET v_attributes = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 13 THEN

      SET v_gen_spec = SUBSTR(v_tab_meta,1,v_cpos-1);

    ELSEIF v_meta_loop = 14 THEN

      SET v_lock_mode = SUBSTR(v_tab_meta,1,v_cpos-1);

    END IF;

    SET v_tab_meta = SUBSTR(v_tab_meta,v_cpos+1);

  END WHILE;

  --=====================================================
  --=====================================================
  -- Get the database for the table
  --=====================================================
  --=====================================================

  -- If the database is null, lookup the current users default database
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SELECT CASE WHEN DefaultDataBase IS NULL
                THEN UserName
                ELSE DefaultDataBase
                END
    INTO   v_database
    FROM   DBC.Users
    WHERE  UserName = USER
    ;

  END IF;

  -- If the database is still null, set it to the USER.
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SET v_database = USER;

  END IF;

  SET v_database = TRIM(v_database);
  SET v_user_view = 0;
  SET v_user_full = 0;

  IF v_type_ind = 'U' THEN

    SET v_user_view = 1;

    -- A user view is made up of  Genspec (4000), Where (4000),
    -- Attributes (4000), postfix(4000), and View Where (2048)
    SET v_cpos = INDEX(COALESCE(v_gen_spec,''),'~ENDGEN~;');

    IF v_cpos <> 0 THEN

      IF CHAR(v_gen_spec) > v_cpos+10 THEN

        SET v_gen_spec = SUBSTR(v_gen_spec,v_cpos+9);

      ELSE

        SET v_gen_spec = '';

      END IF;

    END IF;

    SET v_cpos = INDEX(COALESCE(v_where,''),'~ENDWHERE~;');

    IF v_cpos <> 0 THEN

      IF CHAR(COALESCE(v_where,'')) > v_cpos+12 THEN

        SET v_where = SUBSTR(COALESCE(v_where,0),v_cpos+11);

      ELSE

        SET v_where = '';

      END IF;

    END IF;

    SET v_create = COALESCE(v_gen_spec,'');
    SET v_create = v_create || (COALESCE(v_where,''));
    SET v_create = v_create || (COALESCE(v_attributes,''));
    SET v_create = v_create || (COALESCE(v_post_fix,''));
    SET v_create = v_create || (COALESCE(v_view_where,''));

    IF SUBSTR(UPPER(TRIM((COALESCE(v_gen_spec,'')))),1,6) = 'CREATE' THEN

      SET v_user_full = 1;

    END IF;

  END IF;

  IF v_user_full = 0 THEN

    SET v_create = 'CREATE VIEW ';

    -- Add in the database is specified
    IF NULLIF(TRIM(v_database),'') IS NOT NULL THEN

      SET v_create = v_create || v_database || '.';

    END IF;

    -- Add in the table name
    SET v_create = v_create || v_table_name;
    SET v_create = v_create || ' ' || X'0D' || X'0A' || '( ';

    SET v_no_more_data1 = 0;
    SET v_row = 0;
    SET v_lenA = 0;
    SET v_lenC = 0;

    -- Add in the column names.
    BEGIN
      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_view_col;

      FETCH FROM c_view_col INTO v_column, v_title, v_src_column, v_src_table, v_transform;

      WHILE v_no_more_data1 = 0 DO

        SET v_row = v_row + 1;

        IF v_row > 1 THEN

          SET v_create = v_create || X'0D' || X'0A' || ', ';
          SET v_as = v_as || X'0D' || X'0A' || ', ';
          SET v_lenA = 1;
          SET v_lenC = 1;

        END IF;

        IF v_lenA > 70 THEN

          SET v_as = v_as || X'0D' || X'0A';
          SET v_lenA = 0;

        END IF;

        IF v_lenC > 70 THEN

          SET v_create = v_create || X'0D' || X'0A';
          SET v_lenC = 0;

        END IF;

        IF NULLIF(TRIM(v_src_table),'') IS NOT NULL THEN

          IF NULLIF(TRIM(v_transform),'') IS NOT NULL THEN

            SET v_as = v_as || v_transform;
            SET v_lenA = v_lenA + CHAR(v_transform);

          ELSE

            SET v_as = v_as || v_src_table || '.' || v_src_column;
            SET v_lenA = v_lenA + CHAR(v_src_table || '.' || v_src_column);

          END IF;

        ELSE

          IF NULLIF(TRIM(v_transform),'') IS NOT NULL THEN

            SET v_as = v_as || v_transform;
            SET v_lenA = v_lenA + CHAR(v_transform);

          ELSE

            SET v_as = v_as || v_src_column;
            SET v_lenA = v_lenA + CHAR(v_src_column);
          END IF;

        END IF;

        IF NULLIF(TRIM(v_title),'') IS NOT NULL AND
           NULLIF(TRIM(v_transform),'') IS NULL THEN
            -- handle single quotes in title
            CALL [METABASE].Ws_String_Replace(v_title, '''', '''''',v_new_value);
            SET v_title = v_new_value;
            SET v_as = v_as || ' (TITLE ''' || v_title || ''') ';
            SET v_lenA = v_lenA + CHAR(v_title) + 12;
        END IF;

        SET v_create = v_create || v_column;
        SET v_lenC = v_lenC + CHAR(v_column);

        FETCH FROM c_view_col INTO v_column, v_title, v_src_column, v_src_table, v_transform;

      END WHILE;

      CLOSE c_view_col;

    END;

    -- If the view is a user defined view
    IF v_user_view = 1 THEN

      SET v_create = v_create || ') ' || X'0D' || X'0A' || 'AS';

      -- A user view is made up of  Genspec (4000), Where (4000),
      -- Attributes (4000), postfix(4000), and View Where (2048)
      SET v_create = v_create || (COALESCE(v_gen_spec,''));
      SET v_create = v_create || (COALESCE(v_where,''));
      SET v_create = v_create || (COALESCE(v_attributes,''));
      SET v_create = v_create || (COALESCE(v_post_fix,''));
      SET v_create = v_create || (COALESCE(v_view_where,''));

    -- If not a user defined view
    ELSE

      -- Construct the LOCK if the FROM is in the WHERE field.
      IF SUBSTR(LOWER(TRIM(COALESCE(v_view_where,''))),1,4) = 'from' THEN

        SET v_create = v_create || ') ' || X'0D' || X'0A' || 'AS ';
        SET v_create = v_create || 'FROM ';
        SET v_no_more_data1 = 0;
        SET v_row = 0;

        BEGIN

          DECLARE CONTINUE HANDLER FOR NOT FOUND
            SET v_no_more_data1 = 1;

          OPEN c_view_src;

          FETCH FROM c_view_src INTO v_src_table;

          WHILE v_no_more_data1 = 0 DO

            SET v_row = v_row + 1;

            IF COALESCE(v_lock_mode,'') = 'LOCK ROW FOR ACCESS' THEN

              IF v_row = 1 THEN

                SET v_create = v_create || X'0D' || X'0A' || v_lock_mode;

              END IF;

            ELSE

              CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                           , p_obj_key, NULL
                                           , 'database'
                                           , v_info_return_code, v_info_return_msg
                                           , v_info_result, v_src_database  );

              SET v_create = v_create || X'0D' || X'0A' || 'LOCK TABLE ';

              IF NULLIF(TRIM(v_src_database),'') IS NOT NULL THEN

                SET v_create = v_create || v_src_database || '.';

              END IF;

              SET v_create = v_create || v_src_table;
              SET v_create = v_create || ' FOR ';
              SET v_create = v_create || v_lock_mode;

            END IF;

            FETCH FROM c_view_src INTO v_src_table;

          END WHILE;

          CLOSE c_view_src;

        END;

        SET v_create = v_create || X'0D' || X'0A' || 'SELECT ' || v_as || ' ' || X'0D' || X'0A';
        SET v_cpos = 0;
        SET v_create = v_create || (COALESCE(v_view_where,''));

      -- Construct the FROM and LOCK if the FROM is NOT in the WHERE field.
      ELSE

        SET v_create = v_create || ') ' || X'0D' || X'0A' || 'AS ';
        SET v_no_more_data1 = 0;
        SET v_row = 0;

        BEGIN

          DECLARE CONTINUE HANDLER FOR NOT FOUND
            SET v_no_more_data1 = 1;

          OPEN c_view_src;

          FETCH FROM c_view_src INTO v_src_table;

          WHILE v_no_more_data1 = 0 DO

            SET v_row = v_row + 1;

            IF v_row > 1 THEN

              SET v_from_tab = v_from_tab || ', ';

            END IF;

            CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                         , p_obj_key, NULL
                                         , 'database'
                                         , v_info_return_code, v_info_return_msg
                                         , v_info_result, v_src_database);

            IF NULLIF(TRIM(v_src_database),'') IS NOT NULL THEN

              SET v_from_tab = v_from_tab || v_src_database || '.';

            END IF;

            SET v_from_tab = v_from_tab || v_src_table;

            IF NULLIF(TRIM(v_src_database),'') IS NOT NULL THEN

              SET v_from_tab = v_from_tab || ' ' || v_src_table;

            END IF;

            IF COALESCE(v_lock_mode,'') = 'LOCK ROW FOR ACCESS' THEN

              IF v_row = 1 THEN

                SET v_create = v_create || X'0D' || X'0A' || v_lock_mode;

              END IF;

            ELSEIF NULLIF(TRIM(v_lock_mode),'') IS NOT NULL THEN

              SET v_create = v_create || X'0D' || X'0A' || 'LOCK TABLE ';

              IF NULLIF(TRIM(v_database),'') IS NOT NULL THEN

                SET v_create = v_create || v_src_database || '.';

              END IF;

              SET v_create = v_create || v_src_table || ' FOR ' || v_lock_mode;

            END IF;

            FETCH FROM c_view_src INTO v_src_table;

          END WHILE;

          CLOSE c_view_src;

        END;

        IF  INDEX(UPPER(COALESCE(v_attributes,'')),'DISTINCT~;') = 0 THEN
          SET v_create = v_create || X'0D' || X'0A' || 'SELECT ' || v_as || ' ' || X'0D' || X'0A' || 'FROM ' || v_from_tab;
        ELSE
          SET v_create = v_create || X'0D' || X'0A' || 'SELECT DISTINCT ' || v_as || ' ' || X'0D' || X'0A' || 'FROM ' || v_from_tab;
        END IF;

        IF NULLIF(TRIM(v_view_where),'') IS NOT NULL THEN

          SET v_create = v_create || ' ' || v_view_where;

        END IF;

      END IF;

    END IF;

  END IF;

  SET v_create = v_create || X'0D' || X'0A';

  SET p_create = v_create;

END;
_PROCEDWSL_ Ws_Act_Dbms_Stats 
CREATE PROCEDURE [METABASE].Ws_Act_Dbms_Stats
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_percent         integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
)
WS_ACT_DBMS_STATS:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name     Teradata
  -- Script Name   ws_act_dbms_stats
  -- Description   Run database statistics on a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 05/04/2002  Version 1.0.7    Added for all indexed columns to analyze
  -- WMR 25/10/2002  Version 1.2.1    Sql Server version
  -- WMR 11/09/2007  Version 5.6.0    DB2 version
  -- AP  29/04/2008  Version 6.0.0.0  ODS and Normal Objects
  -- AP  11/06/2008  Version 6.0.0.0  Allow for table level stats override
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_stmt                     VARCHAR(8000); -- Dynamic SQL variable
  DECLARE v_table_name               VARCHAR(64);   -- Table Name if an index
  DECLARE v_tablespace               VARCHAR(64);   -- Database name
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_obj_key                  INTEGER;       -- Used for table object key if an index
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_continue                 INTEGER;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Dbms_Stats Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_continue                 = 0;

  SET v_step = 10;
  SET p_result = 1;
  SET p_status_code = 1;

  --=====================================================
  -- Handle either an Index or a Table
  --=====================================================

  IF p_obj_type = v_ws_obj_index THEN

    --=====================================================
    -- Index
    --=====================================================

    -- Get table object type.
    SELECT ih_obj_key
    INTO   v_obj_key
    FROM   [METABASE].ws_index_header
    WHERE  ih_index_key = p_obj_key;

    -- Get table table name.
    SELECT oo_name
    INTO   v_table_name
    FROM   [METABASE].ws_obj_object
    WHERE  oo_obj_key = v_obj_key;

    -- Get the database of the table.
    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , NULL, v_table_name
                                 , 'database'
                                 , v_db_return_code, v_db_return_msg
                                 , v_db_result, v_tablespace);

    -- If analyze
    IF p_action = v_ws_act_statistics THEN

      SET v_stmt = 'COLLECT STATISTICS ON ';

    -- Else If quick analyze
    ELSE

      SET v_stmt = 'COLLECT STATISTICS USING SAMPLE ON ';

    END IF;

    SET v_stmt = v_stmt||v_tablespace||'.';
    SET v_stmt = v_stmt||v_table_name;
    SET v_stmt = v_stmt||' INDEX ';
    SET v_stmt = v_stmt||p_task_name;

    SET p_return_msg = 'Index '||p_task_name||' analyzed';

    -- Execute the analyze
    SET v_step = 90;

    CALL DBC.SYSEXECSQL ( v_stmt );

    SET v_step = 92;

  ELSE

    --=====================================================
    -- Table
    --=====================================================

    -- Get the database of the table.
    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , p_obj_key, NULL
                                 , 'database'
                                 , v_db_return_code, v_db_return_msg
                                 , v_db_result, v_tablespace);

    -- If analyze
    IF p_action = v_ws_act_statistics THEN

      SET v_stmt = 'COLLECT STATISTICS ON ';
      SET v_stmt = v_stmt||v_tablespace||'.';
      SET v_stmt = v_stmt||p_task_name;

      SET p_return_msg = 'Table '||p_task_name||' analyzed ';

      -- Execute the analyze
      SET v_step = 94;

      BEGIN

        -- Ignore a Stats not defined error.
        DECLARE CONTINUE HANDLER
          FOR SQLEXCEPTION
          BEGIN

            GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
            SET v_sql_code = SQLCODE;

            IF v_sql_code = 3624 THEN

              SET p_result = -1;
              SET p_status_code = -1;
              SET p_return_msg = 'No Stats Defined for Table '||p_task_name;

            ELSE

              SET v_msgtext = 'Unhandled exception in Ws_Act_Dbms_Stats Version '||
                v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
                '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
              SET p_return_msg = v_msgtext;
              CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
                  , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
              SET p_status_code = -3;
              SET p_result = -3;
              SET v_continue = 1;

            END IF;

          END;

        CALL DBC.SYSEXECSQL ( v_stmt );

      END;

      IF v_continue = 1 THEN

        LEAVE WS_ACT_DBMS_STATS;

      END IF;

      SET v_step = 96;

    -- Else If quick analyze (not supported for tables)
    ELSE

      SET p_result = -1;
      SET p_status_code = -1;
      SET p_return_msg = 'Quick Stats (Sampling) not available for Teradata Tables';

    END IF;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Host_Script 
CREATE PROCEDURE [METABASE].Ws_Act_Host_Script
( IN  p_sequence        INTEGER
, IN  p_obj_type        INTEGER
, IN  p_action          INTEGER
, IN  p_obj_key         INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, OUT p_return_msg      VARCHAR(1024)
, OUT p_status_code     INTEGER
, OUT p_result          INTEGER
)
WS_ACT_HOST_SCRIPT:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- ===============================================================================
  -- DBMS Name                  Teradata
  -- Script Name                ws_act_host_script
  -- Description                Handles a host script, file or script based load
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- ===============================================================================
  -- WMR 22/01/2002   Version 1.0.0
  -- WMR 08/04/2002   Version 1.0.7    Added trailing nullcols to Windows load
  -- WMR 25/10/2002   Version 1.2.1    SQL Server version
  -- WMR 13/02/2004   Version 4.1.0.1  added support for XML based file loads
  -- WMR 22/05/2004   Version 4.1.0.8  Add support for wildcard file loads, fixed length
  -- WMR 22/02/2005   Version 4.1.1.3  Fixed problem with fixed length loads returning -1
  -- WMR 19/04/2005   Version 4.1.2.2  Changed dc_database_id length to 1024
  -- WMR 13/03/2006   Version 5.0.1.4  Clean out script line and header file before insert in case a restart.
  -- WMR 13/03/2006   Version 5.0.1.6  Moved the clean of the script files to the start of the procedure.
  -- AP  16/08/2006   Version 5.5.0.5  Added DSS parameter substitution for load file path and name
  --                                   Added call to WsParameterReplace for param substitution of
  --                                     script lines
  -- JML 17/04/2007   Version 5.6.0.0  support for Export Objects Added.
  -- AP  16/05/2007   Version 5.6.0.1  Added support for load options (lt_load_options)
  -- JML 11/07/2007   Version 5.6.1.1  Added support for ASCII delimiters in exports
  --                                   Now does COALESCE(x,'') to non-transformed fields in exports.
  --                                   BCP Exports now use queryout to allow column selection.
  --                                   Added support for where clause in exports.
  --                                   Added support for isql/sqlcmd options in exports.
  --                                   Error message including "Fast Export" removed.
  -- WMR 13/09/2007   Version 5.6.1.1  DB2 version
  -- WMR 20/03/2008   Version 5.6.3.1  Placed file name inside double quotes in case of spaces in name
  -- AP  09/04/2008   Version 6.0.0.0  Standardized constants
  -- AP  16/06/2008                    Remove invalid test that script must have a connection key
  --                                   WsParameterReplace changed to a procedure rather than function
  -- WMR 08/07/2008   Version 6.0.0.0  Added support for DB2 Unix exports and loads
  -- JML 01/09/2008   Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  24/09/2012   Version 6.6.2.2  Added Teradata Unix File Load Support
  -- RS  28/11/2012   Version 6.7.0.1  RED_2764 Support TPT ODBC Loads
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- AP  10/09/2013   Version 6.7.1.2  RED_3239 support min/max sessions for TPT
  -- RS  22/09/2013   Version 6.7.1.2  RED_3023 Added Transformation Support for Teradata Unix File Load
  -- AP  15/10/2013   Version 6.7.1.3  RED_3306 support instances for TPT
  -- AP  16/10/2013   Version 6.7.1.3  RED_3307 support memory size for TPT
  -- AP  20/02/2013   Version 6.7.2.1  RED_3517/RED_3310 support jobname and tbuild options for TPT
  -- AP  19/03/2014   Version 6.7.4.1  RED_3557 only do trig params if have prefix defined
  -- MXU 05/06/2014   Version 6.8.0.1  RED_2907 handle fixed width
  -- RS  26/05/2014   Version 6.8.0.1  Changed to reflect new WS_DB_Connect column sizes
  -- AP  07/07/2014   Version 6.8.0.2  Add variables for Load and Export scripts
  --                                    use tbuild -L option so don't need TWB_ROOT set
  -- MXU 05/08/2014   Version 6.8.1.2  RED_3683 support TPT file export in Unix/Linux
  -- RS  02/09/2014   Version 6.8.1.2  RED_3839 Give warning message and abort when routine "No Load" is specified
  -- MXU 07/11/2014   Version 6.8.1.2  RED_4034 Fix the return code with trigger file action
  -- RS  04/12/2014   Version 6.8.1.2  RED_4363 Fixed compile error for Teradata 13.x due to usage of function OREPLACE
  -- RS  12/12/2014   Version 6.8.1.3  RED_4406 Added factor to amend size of varchar/char datatypes dependent on charset ASCII, UTF8, UTF16
  -- AP  17/04/2015   Version 6.8.3.3  RED_4760 Add support of tlogview options
  -- AP  17/04/2015   Version 6.8.3.3  RED_4840 Added format for fixed width TPT loads
  -- TA  17/04/2015   Version 6.8.3.3  RED_4816 Use Script Shell configuration from connection
  -- RS  08/05/2015   Version 6.8.3.4  RED_4331 Removed extra comma if first column doesn't have a source for TPT File Loads
  -- BC  08/05/2015   Version 6.8.3.4  RED_4450 Fix work directory for Hadoop scheduler
  -- BC  12/05/2015   Version 6.8.3.4  RED_4450 Added initialisation of HADOOPHOST environment variable to generated load script.
  -- BC  21/05/2015   Version 6.8.3.4  RED_5022 Ensure the #! line is kept at the start of a generated script when inserting lines.
  -- RS  11/06/2015   Version 6.8.4.1  RED_4810 Move from schema to database information for load tables, export tables and introduction of schema
  -- RS  08/07/2015   Version 6.8.4.2  RED_4810 Changed variable name from v_lt_tablespace2 to v_lt_temp_database
  -- BC  12/11/2015   Version 6.8.4.4  RED_5798 Changed TPT loads to determine the job log filename from the audit file.
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM  17/03/2016   Version 6.8.5.4  RED_6497 Fixed bad keyword Replace in TPT Export script output
  -- KH  21/03/2016   Version 6.8.5.4  RED_6292 Added null handling in export metadata fetch.
  -- HM  22/03/2016   Version 6.8.5.4  Work directory path must have a trailing '/'
  -- BC  21/04/2016   Version 6.8.5.4  RED_6678 Change initialization of DSS_METABASE to use a placeholder which is replaced during deployment.
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  16/06/2016   Version 6.8.6.1  RED_4934 Inject JOB_NAME and TASK_NAME into the script.
  -- BC  29/08/2016   Version 6.8.6.2  RED-7032 Script based loads from Database/ODBC connections return host information for script connection
  -- RS  07/09/2016   Version 6.8.6.2  RED-7054 Fixed issue with wrong row count in TPT loads
  -- BC  10/11/2016   Version 6.8.6.3  RED-7444 Fixed issue with environment variable names blending with table name appended after them.
  -- HM  14/11/2016   Version 6.8.6.3  RED-6610 Added BTEQ Update procedure support
  -- BC  15/11/2016   Version 6.8.6.3  RED-7329 Initialise new environment variables for Script-based loads and exports.
  -- RS  25/11/2016   Version 6.8.6.3  RED-7530 Added delimiting braces to file name substitution variables
  -- BC  18/01/2017   Version 6.8.7.1  RED-3545 Change the value for wtsh_load_type to indicate a Powershell script.
  -- HM  23/03/2017   Version 6.9.1.0  RED-8028 Handle TPT loads into load tables with extra DV2.0 DSS columns
  -- HM  28/04/2017   Version 6.9.1.0  RED-8063 Better handling for TPT loads of date and timestamp data
  -- HM  16/05/2017   Version 6.9.1.0  RED-8063 Increase size of v_tpt_data_type to accommodate VARDATE
  -- HM  31/05/2017   Version 6.9.1.0  RED-8276 Remove VARDATE enhancement to preserve backwards compatibility
  -- HM  08/06/2017   Version 6.9.1.0  RED-8308 NULL only if no source and no During Load Transform.
  -- BC  14/02/2018   Version 8.1.1.0  RED-9113 Fix to set TGT_* variables for ODBC TPT script loads.
  -- MME 20/11/2018   Version 8.3.1.0  RED-10012 Fix incorrect $SEQUENCE$ replacement for Teradata Linux File Load.
  -- BC  21/11/2018   Version 8.3.1.0  RED-10014 Fix to archive all source files when Only Load Latest File load option is used.
  -- BC  21/11/2018   Version 8.3.1.0  RED-10014 Fix to only archive Trigger file once if loading multiple files.
  -- TA  23/11/2018   Version 8.3.1.0  RED-9975 Support arbitrary script interpreters for Unix scripts
  -- BC  28/11/2018   Version 8.3.1.0  RED-10014 Fix to ensure archived source file names are distinct when Only Load Latest File.
  -- BC  28/11/2018   Version 8.3.1.0  RED-10014 Fix to ensure all archived source files are compressed when Only Load Latest File.
  -- BC  28/11/2018   Version 8.3.1.0  RED-10014 Fix to ensure loaded source file name used in summary message when Only Load Latest File.
  -- BC  28/11/2018   Version 8.3.1.0  RED-10014 Fix to output the compress log message to the audit log.
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version              VARCHAR(15);
  DECLARE v_ws_obj_procedure            INTEGER;
  DECLARE v_ws_obj_fact_kpi             INTEGER;
  DECLARE v_ws_obj_script               INTEGER;
  DECLARE v_ws_obj_template             INTEGER;
  DECLARE v_ws_obj_fact                 INTEGER;
  DECLARE v_ws_obj_dim                  INTEGER;
  DECLARE v_ws_obj_stage                INTEGER;
  DECLARE v_ws_obj_load                 INTEGER;
  DECLARE v_ws_obj_agg                  INTEGER;
  DECLARE v_ws_obj_index                INTEGER;
  DECLARE v_ws_obj_connect              INTEGER;
  DECLARE v_ws_obj_dim_view             INTEGER;
  DECLARE v_ws_obj_export               INTEGER;
  DECLARE v_ws_obj_cube                 INTEGER;
  DECLARE v_ws_obj_cube_virtual         INTEGER;
  DECLARE v_ws_obj_report               INTEGER;
  DECLARE v_ws_obj_view                 INTEGER;
  DECLARE v_ws_obj_join                 INTEGER;
  DECLARE v_ws_obj_retro                INTEGER;
  DECLARE v_ws_obj_retro_copy           INTEGER;
  DECLARE v_ws_obj_olap_cube            INTEGER;
  DECLARE v_ws_obj_olap_dim             INTEGER;
  DECLARE v_ws_obj_olap_role            INTEGER;
  DECLARE v_ws_obj_ods                  INTEGER;
  DECLARE v_ws_obj_normal               INTEGER;
  DECLARE v_ws_obj_hub                  INTEGER;
  DECLARE v_ws_obj_satellite            INTEGER;
  DECLARE v_ws_obj_link                 INTEGER;
  DECLARE v_ws_obj_custom1              INTEGER;
  DECLARE v_ws_obj_custom2              INTEGER;
  DECLARE v_ws_obj_max                  INTEGER;


  DECLARE v_ws_act_drop                 INTEGER;
  DECLARE v_ws_act_create               INTEGER;
  DECLARE v_ws_act_drop_all             INTEGER;
  DECLARE v_ws_act_pre_drop             INTEGER;
  DECLARE v_ws_act_load                 INTEGER;
  DECLARE v_ws_act_update               INTEGER;
  DECLARE v_ws_act_execute              INTEGER;
  DECLARE v_ws_act_process              INTEGER;
  DECLARE v_ws_act_build                INTEGER;
  DECLARE v_ws_act_build_all            INTEGER;
  DECLARE v_ws_act_analyze              INTEGER;
  DECLARE v_ws_act_quick_analyze        INTEGER;
  DECLARE v_ws_act_statistics           INTEGER;
  DECLARE v_ws_act_quick_statistics     INTEGER;
  DECLARE v_ws_act_initial              INTEGER;
  DECLARE v_ws_act_cube_dim             INTEGER;
  DECLARE v_ws_act_db_dim               INTEGER;
  DECLARE v_ws_act_custom               INTEGER;
  DECLARE v_ws_act_truncate             INTEGER;
  DECLARE v_ws_act_compile              INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                     VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                        INTEGER;       -- return code
  DECLARE v_sql_code                    INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                   VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_new_value                   VARCHAR(8000);

  DECLARE v_script_line_no              INTEGER;       -- Script Line No for File Based Loads
  DECLARE v_comment_prefix              VARCHAR(10);   -- Prefix to comment out script lines
  DECLARE v_do_load_indent              VARCHAR(10);   -- Indent for file load commands
  DECLARE v_trig_file_base              VARCHAR(256);  -- File Name Base for Trigger

  DECLARE v_no_more_data1               INTEGER;
  DECLARE v_no_more_data2               INTEGER;
  DECLARE v_source_con_type             VARCHAR(1);
  DECLARE v_connect_key                 INTEGER;
  DECLARE v_script_key                  INTEGER;
  DECLARE v_load_key                    INTEGER;
  DECLARE v_script_type                 VARCHAR(1);
  DECLARE v_load_type                   VARCHAR(1);
  DECLARE v_script_row                  INTEGER;
  DECLARE v_work_dir                    VARCHAR(256);
  DECLARE v_hadoop_host                 VARCHAR(64);
  DECLARE v_pos                         INTEGER;
  DECLARE v_epos                        INTEGER;
  DECLARE v_spos                        INTEGER;
  DECLARE v_handled1                    INTEGER;
  DECLARE v_handled2                    INTEGER;
  DECLARE v_ws_script_execute           VARCHAR(1);
  DECLARE v_ws_script_update            VARCHAR(1);    -- RED-6610
  DECLARE v_ws_load_script              VARCHAR(1);
  DECLARE v_ws_load_file                VARCHAR(1);
  DECLARE v_ws_load_xml                 VARCHAR(1);
  DECLARE v_rec_delimiter               VARCHAR(256);
  DECLARE v_rec_options                 VARCHAR(4000);
  DECLARE v_rec_when                    VARCHAR(4000);
  DECLARE v_size                        INTEGER;
  DECLARE v_load_options                VARCHAR(4000);
  DECLARE v_work                        VARCHAR(4000);
  DECLARE v_work2                       VARCHAR(4000); -- RED_3683
  DECLARE v_work3                       VARCHAR(4000); -- RED_3683
  DECLARE v_date1                       VARCHAR(30);   -- RED_3683
  DECLARE v_date2                       VARCHAR(30);   -- RED_3683
  DECLARE v_date3                       VARCHAR(30);   -- RED_3683
  DECLARE v_date4                       VARCHAR(30);   -- RED_3683
  DECLARE v_date5                       VARCHAR(30);   -- RED_3683
  DECLARE v_date6                       VARCHAR(30);   -- RED_3683

  DECLARE v_lc_col_name                 VARCHAR(64);
  DECLARE v_lc_data_type                VARCHAR(256);
  DECLARE v_lc_transform_code           VARCHAR(4000);
  DECLARE v_lc_transform_type           VARCHAR(1);    -- RED-8028
  DECLARE v_b_table_and_file_may_differ INTEGER;       -- RED-8028 file may have less columns than table
  DECLARE v_lc_src_column               VARCHAR(1024);
  DECLARE v_lc_attributes               VARCHAR(4000);
  DECLARE v_lc_format                   VARCHAR(64);
  DECLARE v_tpt_data_type               VARCHAR(256);
  DECLARE v_col_comma                   VARCHAR(5);

  DECLARE v_work_string                 VARCHAR(4000);
  DECLARE v_orig_work_string            VARCHAR(4000);
  DECLARE v_b_file_rename               INTEGER;
  DECLARE v_b_trig_rename               INTEGER;

  DECLARE v_database                    VARCHAR(1024);  -- RED-6610
  DECLARE v_table_name                  VARCHAR(1024);  -- RED-6610
  DECLARE v_full_ref                    VARCHAR(1024);  -- RED-6610
  DECLARE v_object_name                 VARCHAR(1024);  -- RED-6610
  DECLARE v_object_database             VARCHAR(1024);  -- RED-6610
  DECLARE v_object_key                  INTEGER;        -- RED-6610
  DECLARE v_object_type                 INTEGER;        -- RED-6610

  DECLARE v_dc_attributes               VARCHAR(4000);
  DECLARE v_att_slice                   VARCHAR(4000);
  DECLARE v_att_pos                     INTEGER;
  DECLARE v_att_len                     INTEGER;

  DECLARE v_param_obj_name              VARCHAR(64);
  DECLARE v_param_name                  VARCHAR(4000);
  DECLARE v_param_value                 VARCHAR(4000);

  --=====================================================
  -- Cursor and table Variables
  --=====================================================
  DECLARE v_load_lt_type                VARCHAR(1);
  DECLARE v_load_lt_script_key          INTEGER;
  DECLARE v_load_lt_connect_key         INTEGER;
  DECLARE v_load_lt_file_header_line    VARCHAR(1);
  DECLARE v_load_lt_file_parsed         VARCHAR(1);
  DECLARE v_load_lt_file_path           VARCHAR(1024);
  DECLARE v_load_lt_file_name           VARCHAR(256);
  DECLARE v_load_lt_trig_path           VARCHAR(1024);
  DECLARE v_load_lt_trig_name           VARCHAR(256);
  DECLARE v_load_lt_file_path_rename    VARCHAR(1024);
  DECLARE v_load_lt_file_name_rename    VARCHAR(256);
  DECLARE v_load_lt_trig_path_rename    VARCHAR(1024);
  DECLARE v_load_lt_trig_name_rename    VARCHAR(256);
  DECLARE v_load_lt_trig_prefix         VARCHAR(64);
  DECLARE v_load_lt_trig_delimiter      VARCHAR(10);
  DECLARE v_load_lt_file_delimiter      VARCHAR(10);
  DECLARE v_load_lt_file_format         VARCHAR(100);
  DECLARE v_load_lt_file_wait           INTEGER;
  DECLARE v_load_lt_table_name          VARCHAR(64);
  DECLARE v_load_lt_load_options        VARCHAR(4000);
  DECLARE v_load_lt_database            VARCHAR(64);
  DECLARE v_load_lt_routine             VARCHAR(64);
  DECLARE v_load_lt_charset             VARCHAR(64);
  DECLARE v_load_lt_memorysize          VARCHAR(64);
  DECLARE v_load_lt_minsessions         VARCHAR(64);
  DECLARE v_load_lt_maxsessions         VARCHAR(64);
  DECLARE v_load_lt_LoadJobName         VARCHAR(1024);
  DECLARE v_load_lt_TBuildOptions       VARCHAR(1024);
  DECLARE v_load_lt_TLogViewOptions     VARCHAR(1024);
  DECLARE v_load_lt_readinstances       INTEGER;
  DECLARE v_load_lt_writeinstances      INTEGER;
  DECLARE v_load_lt_compress            INTEGER;
  DECLARE v_fail_incomplete             INTEGER;
  DECLARE v_load_lt_file_loop           INTEGER;
  DECLARE v_load_lt_file_newest         INTEGER;
  DECLARE v_load_lt_log_detail          INTEGER;
  DECLARE v_short_name                  VARCHAR(64);
  DECLARE v_lt_temp_database            VARCHAR(64);
  DECLARE v_load_lt_wait_action         VARCHAR(1);
  DECLARE v_load_table_fullname         VARCHAR(129);
  DECLARE v_load_target_dsn             VARCHAR(64);
  DECLARE v_load_target_server          VARCHAR(64);
  DECLARE v_load_target_dbport          VARCHAR(64);
  DECLARE v_load_target_dbid            VARCHAR(64);
  DECLARE v_load_source_dsn             VARCHAR(64);
  DECLARE v_load_source_server          VARCHAR(64);
  DECLARE v_load_source_dbport          VARCHAR(64);
  DECLARE v_load_source_dbid            VARCHAR(64);
  DECLARE v_load_source_db              VARCHAR(64);
  DECLARE v_load_source_schema          VARCHAR(64);
  DECLARE v_script_sh_connect_key       INTEGER;
  DECLARE v_script_sh_type              VARCHAR(1);
  DECLARE v_connect_dc_work_dir         VARCHAR(256);
  DECLARE v_connect_dc_type             VARCHAR(1);
  DECLARE v_connect_dc_extract_userid   VARCHAR(1024);
  DECLARE v_connect_dc_extract_pwd      VARCHAR(1024);
  DECLARE v_connect_dc_admin_userid     VARCHAR(1024);
  DECLARE v_connect_dc_admin_pwd        VARCHAR(1024);
  DECLARE v_connect_dc_name             VARCHAR(64);
  DECLARE v_connect_dc_database_id      VARCHAR(1024);
  DECLARE v_connect_dc_attributes       VARCHAR(4000);
  DECLARE v_connect_dc_host_id          VARCHAR(64);
  DECLARE v_ec_col_name                 VARCHAR(64);   -- RED_3683
  DECLARE v_ec_data_type                VARCHAR(256);  -- RED_3683
  DECLARE v_ec_src_table                VARCHAR(64);   -- RED_3683
  DECLARE v_ec_src_column               VARCHAR(64);   -- RED_3683
  DECLARE v_ec_display_name             VARCHAR(256);  -- RED_3683
  DECLARE v_ec_transform_code           VARCHAR(4000); -- RED_3683
  DECLARE v_et_type                     VARCHAR(1);
  DECLARE v_et_script_key               INTEGER;
  DECLARE v_et_file_name                VARCHAR(256);
  DECLARE v_et_file_path                VARCHAR(1024);
  DECLARE v_et_trig_name                VARCHAR(256);
  DECLARE v_et_trig_path                VARCHAR(1024);
  DECLARE v_et_connect_key              INTEGER;
  DECLARE v_et_header_row_ind           VARCHAR(1);
  DECLARE v_et_export_format            VARCHAR(64);
  DECLARE v_et_export_options           VARCHAR(4000);
  DECLARE v_et_export_routine           VARCHAR(64);
  DECLARE v_et_file_delimiter           VARCHAR(10);
  DECLARE v_et_compress_ind             VARCHAR(1);
  DECLARE v_et_compress_name            VARCHAR(256);
  DECLARE v_et_compress_path            VARCHAR(1024);
  DECLARE v_et_compress_param           VARCHAR(1024);
  DECLARE v_et_trig_param_1             VARCHAR(1024);
  DECLARE v_et_trig_param_2             VARCHAR(1024);
  DECLARE v_et_trig_param_3             VARCHAR(1024);
  DECLARE v_et_trig_delimiter           VARCHAR(10);
  DECLARE v_et_enclosed_by              VARCHAR(10);
  DECLARE v_et_where_clause             VARCHAR(4000);
  DECLARE v_et_tablespace               VARCHAR(64);
  DECLARE v_et_table_name               VARCHAR(64); -- RED_3683
  DECLARE v_et_short_name               VARCHAR(22); -- RED_3683
  DECLARE v_line                        VARCHAR(4000);
  DECLARE v_line_out                    VARCHAR(4000);
  DECLARE v_temp                        VARCHAR(4000); -- RED-6610
  DECLARE v_exp_source_schema           VARCHAR(64);
  DECLARE v_exp_source_table            VARCHAR(64);
  DECLARE v_exp_source_fullname         VARCHAR(129);
  DECLARE v_exp_source_type             INTEGER;
  DECLARE v_exp_source_key              INTEGER;
  DECLARE v_exp_source_dsn              VARCHAR(64);
  DECLARE v_exp_source_server           VARCHAR(64);
  DECLARE v_exp_source_dbport           VARCHAR(64);
  DECLARE v_exp_source_dbid             VARCHAR(64);
  DECLARE v_meta_dsn                    VARCHAR(64);
  DECLARE v_meta_server                 VARCHAR(64);
  DECLARE v_meta_dbid                   VARCHAR(64);
  DECLARE v_meta_db                     VARCHAR(64);
  DECLARE v_meta_schema                 VARCHAR(65);
  DECLARE v_db_return_code              VARCHAR(1);
  DECLARE v_db_return_msg               VARCHAR(256);
  DECLARE v_db_result                   INTEGER;

  --=====================================================
  -- Cursor for all script lines
  --=====================================================
  DECLARE c_Scr_Line CURSOR FOR
  SELECT sl_line_no,
         sl_line
  FROM   [METABASE].ws_scr_line
  WHERE  sl_obj_key = v_script_key
  ORDER BY sl_line_no
  ;

  --=====================================================
  -- Cursor for Update script lines
  --=====================================================
  DECLARE c_Update_Line CURSOR FOR
  SELECT pl_line_no,
         pl_line
  FROM   [METABASE].ws_pro_line
  WHERE  pl_obj_key = v_script_key
  ORDER BY pl_line_no
  ;

  --=====================================================
  -- Cursor for load table columns
  --=====================================================
  DECLARE c_Load_Col CURSOR FOR
  SELECT  lc_col_name,
          lc_data_type,
          lc_transform_code,
          lc_transform_type,
          lc_src_column,
          lc_attributes,
          lc_format,
          -- RED_2907
          CASE
            WHEN INDEX(lc_src_column, '_width_') > 0 THEN
                'CHAR(' || SUBSTR(lc_src_column, INDEX(lc_src_column, '_width_') + 7, CHARACTER_LENGTH(lc_src_column)) || ')'
            ELSE
                'VARCHAR(' ||
                CAST(
                    CASE
                        WHEN lc_data_type LIKE '%char(%' THEN
                            (CAST(SUBSTR(SUBSTR(lc_data_type,1,character_length(lc_data_type) -1), position('(' IN lc_data_type)+1, character_length(lc_data_type)) AS INTEGER) + 3)*charset_factor
                        ELSE
                            50*charset_factor
                    END
                AS VARCHAR(50)) ||
                ')'
          END tpt_data_type
  FROM   [METABASE].ws_load_col
  CROSS JOIN
  (SELECT
     CASE WHEN  lt_load_options LIKE '%;CHARSET=0004;UTF8;%'  THEN 3
          WHEN  lt_load_options LIKE '%;CHARSET=0005;UTF16;%' THEN 2
          ELSE 1
     END AS charset_factor FROM [METABASE].ws_load_tab WHERE lt_obj_key = v_load_key) CHARSET_FACT_INFO
  WHERE  lc_obj_key = v_load_key
  order by lc_order
  ;

  --=====================================================
  -- Cursor for export table columns -- RED_3683
  --=====================================================
  DECLARE c_Export_Col CURSOR FOR
  SELECT
    ec_col_name,
    ec_data_type,
    TRIM(COALESCE(ec_src_table,'')),
    TRIM(COALESCE(ec_src_column,'')),
    TRIM(COALESCE(ec_display_name,'')),
    TRIM(COALESCE(ec_transform_code,''))
  FROM [METABASE].ws_export_col
  WHERE ec_obj_key = v_load_key
  ORDER BY ec_order;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Host_Script Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_script_row               = 0;
  SET v_b_file_rename            = 0;
  SET v_b_trig_rename            = 0;
  SET v_load_lt_charset          = 'ASCII';
  SET v_fail_incomplete          = 0;
  SET v_load_lt_file_loop        = 0;
  SET v_load_lt_file_newest      = 0;
  SET v_load_lt_log_detail       = 0;
  SET v_load_lt_memorysize       = '';
  SET v_load_lt_LoadJobName      = '';
  SET v_load_lt_TBuildOptions    = '';
  SET v_load_lt_TLogViewOptions  = '';

  SET v_load_lt_minsessions      = '1';
  SET v_load_lt_maxsessions      = '4';
  SET v_load_lt_readinstances    = 1;
  SET v_load_lt_writeinstances   = 1;

  --=====================================================
  -- MAIN
  --=====================================================

  SET v_ws_script_execute = 'S';
  SET v_ws_script_update = 'U';
  SET v_ws_load_script = 'L';
  SET v_ws_load_file = 'F';
  SET v_ws_load_xml = 'X';

  SET v_step = 100;

  --=====================================================
  -- Handle
  -- (1) a straight script execution where we are just
  -- passed the script object
  -- (2) a script based load where we are passed the
  -- the load object and can lookup the script obj
  -- (3) a file based load where we have to build up
  -- the script to be used.
  --=====================================================
  SET v_script_key = 0;
  SET v_handled1 = 0;
  SET v_handled2 = 0;

  -- Clear any old script that may be present
  DELETE FROM [METABASE].ws_wrk_task_scr_line
  WHERE  wtsl_task_key = p_task_id
  AND    wtsl_job_key = p_job_id
  AND    wtsl_sequence = p_sequence
  ;

  DELETE FROM [METABASE].ws_wrk_task_scr_hdr
  WHERE  wtsh_task_key = p_task_id
  AND    wtsh_job_key = p_job_id
  AND    wtsh_sequence = p_sequence
  ;

  IF p_obj_type = v_ws_obj_script THEN

    SET v_handled1 = 1;
    SET v_script_key = p_obj_key;
    SET v_script_type = v_ws_script_execute;

  ELSEIF p_obj_type = v_ws_obj_stage THEN
    -- RED-6610
    SET v_handled1 = 1;
    SET v_script_type = v_ws_script_update;

    SELECT st_update_key
         , COALESCE(st_schema,'')
         , COALESCE(st_table_name,'')
    INTO   v_script_key
         , v_database
         , v_table_name
    FROM   [METABASE].ws_stage_tab
    WHERE  st_obj_key = p_obj_key
    ;

    -- If the database is null, lookup the current user's default database
    IF NULLIF(TRIM(v_database),'') IS NULL THEN
      SELECT CASE WHEN DefaultDataBase IS NULL
                  THEN UserName
                  ELSE DefaultDataBase
                  END
      INTO   v_database
      FROM   DBC.Users
      WHERE  UserName = USER
      ;

      -- If the database is still null, set it to the USER.
      IF NULLIF(TRIM(v_database),'') IS NULL THEN
        SET v_database = USER;
      END IF;
    END IF;

    SET v_database = TRIM(v_database);
    SET v_table_name = TRIM(v_table_name);

  ELSEIF p_obj_type = v_ws_obj_load THEN

    SET v_handled1 = 1;
    SET v_load_lt_type = NULL;

    SELECT lt_type
         , lt_script_key
         , lt_connect_key
         , lt_file_header_line
         , lt_file_parsed
         , lt_file_path
         , lt_file_name
         , lt_file_delimiter
         , lt_table_name
         , lt_load_options
         , COALESCE(dt_database, lt_schema)
         , lt_trig_path
         , lt_trig_name
         , lt_file_wait
         , lt_wait_action
         , lt_trig_prefix
         , lt_trig_delimiter
         , lt_trig_path_rename
         , lt_trig_name_rename
         , lt_file_path_rename
         , lt_file_name_rename
         , lt_short_name
         , COALESCE(dt_database,  lt_tablespace2)
         , ws_dbc_connect_src.dc_type
    INTO   v_load_lt_type
         , v_load_lt_script_key
         , v_load_lt_connect_key
         , v_load_lt_file_header_line
         , v_load_lt_file_parsed
         , v_load_lt_file_path
         , v_load_lt_file_name
         , v_load_lt_file_delimiter
         , v_load_lt_table_name
         , v_load_lt_load_options
         , v_load_lt_database
         , v_load_lt_trig_path
         , v_load_lt_trig_name
         , v_load_lt_file_wait
         , v_load_lt_wait_action
         , v_load_lt_trig_prefix
         , v_load_lt_trig_delimiter
         , v_load_lt_trig_path_rename
         , v_load_lt_trig_name_rename
         , v_load_lt_file_path_rename
         , v_load_lt_file_name_rename
         , v_short_name
         , v_lt_temp_database
         , v_source_con_type
    FROM   [METABASE].ws_load_tab
    LEFT JOIN [METABASE].ws_obj_object ws_obj_object
    ON lt_obj_key = oo_obj_key
    LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
    ON dt_target_key = oo_target_key
    LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect_tgt
    ON ws_dbc_connect_tgt.dc_obj_key = dt_connect_key
    LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect_src
    ON ws_dbc_connect_src.dc_obj_key = lt_connect_key
    WHERE  lt_obj_key = p_obj_key
    ;

    IF NULLIF(TRIM(v_load_lt_type),'') IS NULL THEN

      SET v_msgtext = 'Failure when reading load table metadata record, or load type not specified.';
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, NULL, NULL, p_task_id, p_job_id);

      SET p_return_msg = v_msgtext;
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    IF v_load_lt_type IN ('S', 'T') THEN
      SET v_load_table_fullname = COALESCE(TRIM(v_load_lt_database), '');
      IF v_load_table_fullname <> '' THEN
        SET v_load_table_fullname = v_load_table_fullname || '.';
      END IF;
      SET v_load_table_fullname = v_load_table_fullname || v_load_lt_table_name;

      SELECT dc_odbc_source
           , dc_database_id
           , dc_attributes
      INTO   v_load_target_dsn
           , v_load_target_dbid
           , v_dc_attributes
      FROM   [METABASE].ws_obj_object
      LEFT JOIN [METABASE].ws_dbc_target
      ON oo_target_key = dt_target_key
      LEFT JOIN [METABASE].ws_dbc_connect
      ON (oo_target_key <> 0 AND dt_connect_key = dc_obj_key) OR (oo_target_key = 0 AND dc_attributes LIKE '%DataWarehouse;%')
      WHERE  oo_obj_key = p_obj_key;

      IF v_dc_attributes IS NOT NULL THEN
        SET v_att_pos = POSITION('DBServer~=' IN v_dc_attributes);
        IF v_att_pos <> 0 THEN
          SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 10);
          SET v_att_pos = POSITION(';' IN v_att_slice);
          IF v_att_pos <> 0 THEN
            SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
            SET v_load_target_server = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
          END IF;
        END IF;

        SET v_att_pos = POSITION('DBPort~=' IN v_dc_attributes);
        IF v_att_pos <> 0 THEN
          SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 8);
          SET v_att_pos = POSITION(';' IN v_att_slice);
          IF v_att_pos <> 0 THEN
            SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
            SET v_load_target_dbport = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
          END IF;
        END IF;
      END IF;

      IF v_source_con_type = 'D' OR v_source_con_type = 'O' OR v_source_con_type = 'Z' THEN
        SELECT lt_source_schema
        INTO   v_load_source_schema
        FROM   [METABASE].ws_load_tab
        WHERE  lt_obj_key = p_obj_key;

        SELECT dc_odbc_source
             , dc_database_id
             , dc_attributes
        INTO   v_load_source_dsn
             , v_load_source_dbid
             , v_dc_attributes
        FROM   [METABASE].ws_dbc_connect
        WHERE  dc_obj_key = v_load_lt_connect_key;

        IF v_dc_attributes IS NOT NULL THEN
          SET v_att_pos = POSITION('DBServer~=' IN v_dc_attributes);
          IF v_att_pos <> 0 THEN
            SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 10);
            SET v_att_pos = POSITION(';' IN v_att_slice);
            IF v_att_pos <> 0 THEN
              SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
              SET v_load_source_server = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
            END IF;
          END IF;

          SET v_att_pos = POSITION('DBPort~=' IN v_dc_attributes);
          IF v_att_pos <> 0 THEN
            SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 8);
            SET v_att_pos = POSITION(';' IN v_att_slice);
            IF v_att_pos <> 0 THEN
              SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
              SET v_load_source_dbport = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
            END IF;
          END IF;
        END IF;

        SET v_load_source_db = v_load_source_dbid;
      END IF;

      SET v_param_obj_name = v_load_lt_table_name;
    END IF;

    -- ===============================================================================
    -- replace any parameters with their current values for columns of load_tab_cursor
    -- ===============================================================================
    -- 1. v_load_lt_file_path
    CALL [METABASE].WsParameterReplace(v_load_lt_file_path, 8000, v_new_value);

    SET v_load_lt_file_path = v_new_value;

    -- 2. v_load_lt_file_name
    CALL [METABASE].WsParameterReplace(v_load_lt_file_name, 8000, v_new_value);

    SET v_load_lt_file_name = v_new_value;

    -- 3. v_load_lt_trig_path
    CALL [METABASE].WsParameterReplace(v_load_lt_trig_path, 8000, v_new_value);

    SET v_load_lt_trig_path = v_new_value;

    -- 4. v_load_lt_trig_name
    CALL [METABASE].WsParameterReplace(v_load_lt_trig_name, 8000, v_new_value);

    SET v_load_lt_trig_name = v_new_value;

    SET v_step = 200;

    SET v_load_type = v_load_lt_type;

    IF v_load_lt_type = 'S' THEN

      SET v_handled2 = 1;
      SET v_script_key = v_load_lt_script_key;
      SET v_script_type = v_ws_load_script;
      SET v_load_type = '';

    END IF;

    -- RED_2764 Treat ODBC Script Loads like scripts
    IF v_load_lt_type = 'T' THEN

      SET v_handled2 = 1;
      SET v_script_key = v_load_lt_script_key;
      SET v_script_type = v_ws_load_script;
      SET v_load_type = '';

    -- We need the information for the TPT ODBC script connection and not from the ODBC connection

    SELECT sh_connect_key
    INTO   v_load_lt_connect_key
    FROM  [METABASE].ws_scr_header
    WHERE  sh_obj_key = v_script_key;

    END IF;
    IF v_load_lt_type = 'F' THEN

 --     SET p_return_msg = 'UNIX File Loads not supported at this stage.';

 --     SET p_status_code = -2;
 --     SET p_result = -2;

--      LEAVE WS_ACT_HOST_SCRIPT;

      SET v_handled2 = 1;
      SET v_script_key = 0;
      SET v_script_type = v_ws_load_file;
      SET v_load_type = 'U';

    END IF;

    IF v_load_lt_type = 'X' THEN

      SET v_handled2 = 1;
      SET v_script_key = 0;
      SET v_script_type = v_ws_load_xml;

    END IF;

    IF v_handled2 = 0 THEN

      SET p_return_msg = 'Unsupported host script method. Not a File, XML or Script Load. Load Type is ' || v_load_lt_type;
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

  -- END OF LOAD
  ELSEIF p_obj_type = v_ws_obj_export THEN

    SET v_handled1 = 1;
    SET v_et_type = NULL;

    SELECT TRIM(COALESCE(et_type,''))
         , et_script_key
         , TRIM(COALESCE(et_file_name,''))
         , TRIM(COALESCE(et_file_path,''))
         , TRIM(COALESCE(et_trig_name,''))
         , TRIM(COALESCE(et_trig_path,''))
         , et_connect_key
         , TRIM(COALESCE(et_header_row_ind,''))
         , TRIM(COALESCE(et_export_format,''))
         , TRIM(COALESCE(et_export_routine,''))
         , TRIM(COALESCE(et_export_options,''))
         , TRIM(COALESCE(et_file_delimiter,''))
         , TRIM(COALESCE(et_compress_ind,''))
         , TRIM(COALESCE(et_compress_name,''))
         , TRIM(COALESCE(et_compress_path,''))
         , TRIM(COALESCE(et_compress_param,''))
         , TRIM(COALESCE(et_trig_param_1,''))
         , TRIM(COALESCE(et_trig_param_2,''))
         , TRIM(COALESCE(et_trig_param_3,''))
         , TRIM(COALESCE(et_trig_delimiter,''))
         , TRIM(COALESCE(et_enclosed_by,''))
         , TRIM(COALESCE(et_where_clause,''))
         , TRIM(COALESCE(et_tablespace,''))
         , et_table_name -- RED_3683
         , et_short_name -- RED_3683
    INTO   v_et_type
         , v_et_script_key
         , v_et_file_name
         , v_et_file_path
         , v_et_trig_name
         , v_et_trig_path
         , v_et_connect_key
         , v_et_header_row_ind
         , v_et_export_format
         , v_et_export_routine
         , v_et_export_options
         , v_et_file_delimiter
         , v_et_compress_ind
         , v_et_compress_name
         , v_et_compress_path
         , v_et_compress_param
         , v_et_trig_param_1
         , v_et_trig_param_2
         , v_et_trig_param_3
         , v_et_trig_delimiter
         , v_et_enclosed_by
         , v_et_where_clause
         , v_et_tablespace
         , v_et_table_name -- RED_3683
         , v_et_short_name -- RED_3683
    FROM   [METABASE].ws_export_tab
    WHERE  et_obj_key = p_obj_key;

    IF NULLIF(TRIM(v_et_type),'') IS NULL THEN

      SET v_msgtext = 'Failure when reading export table metadata record, or export type not specified.';

      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, NULL, NULL, p_task_id, p_job_id);

      SET p_return_msg = v_msgtext;
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    --=====================================================
    -- Work out the source table and schema for the export
    --=====================================================
    SET v_exp_source_table = '';

    SELECT MAX(ec_src_table)
    INTO   v_exp_source_table
    FROM   [METABASE].ws_export_col
    WHERE  ec_obj_key = p_obj_key;

    IF NULLIF(TRIM(v_exp_source_table),'') IS NULL THEN

      SET p_return_msg = 'Unable to locate source table for export.';
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    SET v_exp_source_type = 0;
    SET v_exp_source_key = 0;

    SELECT oo_obj_key
         , oo_type_key
    INTO   v_exp_source_key
         , v_exp_source_type
    FROM   [METABASE].ws_obj_object
    WHERE  oo_name = v_exp_source_table;

    IF v_exp_source_type < 1 OR v_exp_source_key < 1 THEN

      SET p_return_msg = 'Unable to locate source table object type for export.';
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , v_exp_source_key, ''
                                 , 'database'
                                 , v_db_return_code, v_db_return_msg
                                 , v_db_result, v_exp_source_schema);

    IF NULLIF(TRIM(v_exp_source_schema),'') IS NULL THEN

      SET v_exp_source_schema = '[METABASE]';

    END IF;

    IF v_et_type = 'S' THEN
      SET v_exp_source_fullname = v_exp_source_schema || '.' || v_exp_source_table;

      SELECT dc_odbc_source
           , dc_database_id
           , dc_attributes
      INTO   v_exp_source_dsn
           , v_exp_source_dbid
           , v_dc_attributes
      FROM   [METABASE].ws_obj_object
      LEFT JOIN [METABASE].ws_dbc_target
      ON oo_target_key = dt_target_key
      LEFT JOIN [METABASE].ws_dbc_connect
      ON (oo_target_key <> 0 AND dt_connect_key = dc_obj_key) OR (oo_target_key = 0 AND dc_attributes LIKE '%DataWarehouse;%')
      WHERE  oo_obj_key = v_exp_source_key;

      IF v_dc_attributes IS NOT NULL THEN
        SET v_att_pos = POSITION('DBServer~=' IN v_dc_attributes);
        IF v_att_pos <> 0 THEN
          SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 10);
          SET v_att_pos = POSITION(';' IN v_att_slice);
          IF v_att_pos <> 0 THEN
            SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
            SET v_exp_source_server = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
          END IF;
        END IF;

        SET v_att_pos = POSITION('DBPort~=' IN v_dc_attributes);
        IF v_att_pos <> 0 THEN
          SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 8);
          SET v_att_pos = POSITION(';' IN v_att_slice);
          IF v_att_pos <> 0 THEN
            SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
            SET v_exp_source_dbport = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
          END IF;
        END IF;
      END IF;

      SET v_param_obj_name = v_et_table_name;
    END IF;

    -- Convert et_file_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
    SET v_work = UPPER(v_et_file_delimiter);

    IF INDEX(v_work,'CHAR(') > 0 THEN

      CALL [METABASE].Ws_String_Replace(v_work,'CHAR(','',v_new_value);

      SET v_work = v_new_value;

      IF INDEX(v_work,')') > 0 THEN

        CALL [METABASE].Ws_String_Replace(v_work,')','',v_new_value);

        SET v_work = v_new_value;
        SET v_work = CHAR(v_work);
        SET v_et_file_delimiter = v_work;

      END IF;

    END IF;

    -- Convert et_trig_delimiter to literal ASCII value if it contains CHAR(AsciiVal)
    SET v_work = UPPER(v_et_trig_delimiter);

    IF INDEX(v_work,'CHAR(') > 0 THEN

      CALL [METABASE].Ws_String_Replace(v_work,'CHAR(','',v_new_value);

      SET v_work = v_new_value;

      IF INDEX(v_work,')') > 0 THEN

        CALL [METABASE].Ws_String_Replace(v_work,')','',v_new_value);

        SET v_work = v_new_value;
        SET v_work = CHAR(v_work);
        SET v_et_trig_delimiter = v_work;

      END IF;

    END IF;

    -- ===============================================================================
    -- replace any parameters with their current values for columns of export_tab_cursor
    -- ===============================================================================
    -- 1. v_et_file_path
    CALL [METABASE].WsParameterReplace(v_et_file_path, 8000, v_new_value);

    SET v_et_file_path = v_new_value;

    -- 2. v_et_file_name
    CALL [METABASE].WsParameterReplace(v_et_file_name, 8000, v_new_value);

    SET v_et_file_name = v_new_value;

    -- 3. v_et_trig_path
    CALL [METABASE].WsParameterReplace(v_et_trig_path, 8000, v_new_value);

    SET v_et_trig_path = v_new_value; -- RED_3683

    -- 4. v_et_trig_name
    CALL [METABASE].WsParameterReplace(v_et_trig_name, 8000, v_new_value);

    SET v_et_trig_name = v_new_value; -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_enclosed_by, '''', '''''',v_new_value);
    SET v_et_enclosed_by = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_enclosed_by,  '"', '\"',v_new_value);
    SET v_et_enclosed_by = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_file_delimiter, '''', '''''',v_new_value);
    SET v_et_file_delimiter = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_file_delimiter,  '"', '\"',v_new_value);
    SET v_et_file_delimiter = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_trig_delimiter, '''', '''''',v_new_value);
    SET v_et_trig_delimiter = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_trig_delimiter,  '"', '\"',v_new_value);
    SET v_et_trig_delimiter = v_new_value;       -- RED_3683

    CALL [METABASE].Ws_String_Replace(v_et_where_clause,  '\r', '',v_new_value);
    SET v_et_where_clause = v_new_value;       -- RED_3683

    SET v_step = 300;

    SET v_load_type = v_et_type;

    IF v_et_type = 'S' THEN

      SET v_handled2 = 1;
      SET v_script_key = v_et_script_key;
      SET v_script_type = v_ws_load_script;
      SET v_load_type = '';

    END IF;

    IF v_et_type = 'F' THEN

      -- RED_3683: comment old statements to support TPT file export in Unix/Linux now
      --SET p_return_msg = 'UNIX File Exports 2222 not supported at this stage.';

      --SET p_status_code = -2;
      --SET p_result = -2;

      --LEAVE WS_ACT_HOST_SCRIPT;

      SET v_handled2 = 1;
      SET v_script_key = 0;
      SET v_script_type = v_ws_load_file;

    END IF;

    IF v_handled2 = 0 THEN

      SET p_return_msg = 'Unsupported host script method. Not a File or Script Export. Export Type is ' || v_et_type;
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

  END IF;
  -- END OF EXPORT

  IF (p_obj_type = v_ws_obj_load AND v_load_lt_type = 'S')
  OR (p_obj_type = v_ws_obj_export AND v_et_type = 'S')
  THEN
    SELECT dc_odbc_source
         , dc_database_id
         , dc_attributes
    INTO   v_meta_dsn
         , v_meta_dbid
         , v_dc_attributes
    FROM   [METABASE].ws_dbc_connect
    WHERE  dc_attributes LIKE '%DataWarehouse;%';

    IF v_dc_attributes IS NOT NULL THEN
      SET v_att_pos = POSITION('DBServer~=' IN v_dc_attributes);
      IF v_att_pos <> 0 THEN
        SET v_att_slice = SUBSTR(v_dc_attributes, v_att_pos + 10);
        SET v_att_pos = POSITION(';' IN v_att_slice);
        IF v_att_pos <> 0 THEN
          SET v_att_len = CAST(SUBSTR(v_att_slice, 1, v_att_pos - 1) AS INT);
          SET v_meta_server = SUBSTR(v_att_slice, v_att_pos + 1, v_att_len);
        END IF;
      END IF;
    END IF;

    SET v_meta_db = '[METABASE]';
    SET v_meta_schema = '[METABASE].';
  END IF;

  IF v_handled1 = 0 THEN

    SET p_return_msg = 'Unsupported host script method. Not a script or a load. Type is ' || TRIM(CAST(p_obj_type AS VARCHAR(18)));
    SET p_status_code = -2;
    SET p_result = -2;

    LEAVE WS_ACT_HOST_SCRIPT;

  END IF;

  SET v_step = 400;

  --=====================================================
  -- See if we have a record delimiter set
  --=====================================================
  SET v_rec_delimiter = NULL;
  SET v_load_options = NULL;
  SET v_load_lt_file_format = 'Text';

  IF NULLIF(TRIM(v_load_lt_load_options),'') IS NOT NULL THEN

    SET v_pos = INDEX(v_load_lt_load_options,'REC_DELIM=');

    IF COALESCE(v_pos,0) >= 1 THEN

      SET v_size = CAST(SUBSTR(v_load_lt_load_options,v_pos+10,4) AS VARCHAR(18));

      IF v_size > 0 THEN

        SET v_rec_delimiter = SUBSTR(v_load_lt_load_options,v_pos+15,v_size);

      END IF;

    END IF;

    -- Check for load options
    SET v_pos = INDEX(v_load_lt_load_options,'OPTIONS=');

    IF COALESCE(v_pos,0) >= 1 THEN

      SET v_size = CAST(SUBSTR(v_load_lt_load_options,v_pos+8,4) AS VARCHAR(18));

      IF v_size > 0 THEN

        SET v_load_options = SUBSTR(v_load_lt_load_options,v_pos+13,v_size);

      END IF;

    END IF;

    --Check for file format
    SET v_pos = INDEX(v_load_lt_load_options,'FILEFMT=');

    IF COALESCE(v_pos,0) >= 1 THEN

      SET v_size = CAST(SUBSTR(v_load_lt_load_options,v_pos+8,3) AS VARCHAR(18));

      IF v_size > 0 THEN

        SET v_load_lt_file_format = SUBSTR(v_load_lt_load_options,v_pos+12,v_size);

      END IF;

    END IF;

  END IF;

  --=====================================================
  -- IF a script key copy over the script
  --=====================================================
  IF v_script_type = v_ws_script_execute
  OR v_script_type = v_ws_script_update -- RED-6610
  OR v_script_type = v_ws_load_script
  THEN

    -- Get the Connection key
    SET v_script_sh_connect_key = 0;
    SET v_script_sh_type = '';

    IF v_script_type = v_ws_script_update THEN
      SELECT ph_template_key          -- BTEQ connection key
      INTO   v_script_sh_connect_key
      FROM   [METABASE].ws_pro_header
      WHERE  ph_obj_key = v_script_key;
    ELSE
      SELECT sh_connect_key
           , sh_type
      INTO   v_script_sh_connect_key
           , v_script_sh_type
      FROM   [METABASE].ws_scr_header
      WHERE  sh_obj_key = v_script_key;
    END IF;

    IF v_script_type = v_ws_script_execute OR v_script_type = v_ws_script_update THEN

      SET v_connect_key = v_script_sh_connect_key;
      SET v_load_key = 0;

    ELSEIF p_obj_type = v_ws_obj_load THEN

      IF v_source_con_type = 'D' OR v_source_con_type = 'O' OR v_source_con_type = 'Z' THEN
        SET v_connect_key = v_script_sh_connect_key;
      ELSE
        SET v_connect_key = v_load_lt_connect_key;
      END IF;
      SET v_load_key = p_obj_key;

    ELSE

      SET v_connect_key = v_et_connect_key;
      SET v_load_key = p_obj_key;

    END IF;

    -- Change the value for wtsh_load_type to indicate a Powershell script
    IF v_script_sh_type = 'P'
    THEN
      SET v_load_type = 'P';
    END IF;

    --=====================================================
    -- Get the work directory from the connection
    -- If no Connection we have a problem
    --=====================================================
    IF v_connect_key > 0 THEN

      SET v_connect_dc_type = NULL;

      SELECT dc_work_dir
           , dc_type
           , dc_admin_userid
           , dc_admin_pwd
           , dc_database_id
           , dc_name
           , dc_host_id
           , dc_attributes
      INTO   v_connect_dc_work_dir
           , v_connect_dc_type
           , v_connect_dc_admin_userid
           , v_connect_dc_admin_pwd
           , v_connect_dc_database_id
           , v_connect_dc_name
           , v_connect_dc_host_id
           , v_connect_dc_attributes
      FROM   [METABASE].ws_dbc_connect
      WHERE  dc_obj_key = v_connect_key;

      IF NULLIF(TRIM(v_connect_dc_type),'') IS NULL THEN

        SET v_msgtext = 'Failure when reading connect record ';
        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
          , v_msgtext, NULL, NULL, p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_status_code = -2;
        SET p_result = -2;

        LEAVE WS_ACT_HOST_SCRIPT;

      END IF;

    ELSE

      IF v_script_type = v_ws_script_execute OR v_script_type = v_ws_script_update THEN

        SET p_return_msg = 'No connection defined. Unable to execute script';

      ELSE

        SET p_return_msg = 'No connection defined. Unable to perform load';

      END IF;

      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    --=====================================================
    -- Build up the work directory for Unix and Windows
    --=====================================================
    IF v_connect_dc_type = 'U' OR v_connect_dc_type = 'H' THEN

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '/' THEN

        SET v_work_dir = v_work_dir || '/';

      END IF;

    ELSE

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '\' THEN

        SET v_work_dir = v_work_dir || '\';

      END IF;

    END IF;

    --=====================================================
    -- Determine Hadoop host, if required
    --=====================================================

    SET v_hadoop_host = NULL;

    IF v_script_type = v_ws_load_script AND v_connect_dc_type = 'H' THEN

      SET v_hadoop_host = v_connect_dc_host_id;

      SET v_pos = INDEX(v_connect_dc_attributes, 'TPTHadoopHost~=');

      IF v_pos >= 1 THEN

        SET v_pos = v_pos + 15;
        SET v_epos = INDEX(SUBSTR(v_connect_dc_attributes, v_pos), ';') + v_pos - 1;

        IF v_epos >= 1 THEN

          SET v_work = SUBSTR(v_connect_dc_attributes, v_pos, v_epos-v_pos);
          SET v_hadoop_host = SUBSTR(v_connect_dc_attributes, v_epos + 1, CAST(v_work AS INTEGER));

        END IF;

      END IF;

    END IF;

    SET v_step = 500;

    SET v_script_line_no = 1;

    --=====================================================
    -- Add lines to set EXPorted table source database and TEMP database
    --          and set load table database and TEMP database
    --=====================================================
    IF v_connect_dc_type = 'U' OR v_connect_dc_type = 'H' THEN

      -- Use the shell configured in the connection, otherwise guess
      -- based on the name of the connection
      SET v_line_out = NULL;
      SET v_pos = INDEX(v_connect_dc_attributes, 'ScriptShell~=');
      IF v_pos >= 1 THEN
          SET v_pos = v_pos + 13;
          SET v_epos = INDEX(SUBSTR(v_connect_dc_attributes, v_pos), ';') + v_pos - 1;
          IF v_epos >= 1 THEN
              SET v_work = SUBSTR(v_connect_dc_attributes, v_pos, v_epos-v_pos);
              SET v_line_out = '#!' || SUBSTR(v_connect_dc_attributes, v_epos + 1, CAST(v_work AS INTEGER));
          END IF;
      END IF;

      IF v_line_out IS NULL THEN
          IF INDEX(UPPER(v_connect_dc_name),'UNIX') > 0 THEN -- RED_4034
              SET v_line_out = '#!/bin/ksh';                 -- RED_4034
          ELSE                                               -- RED_4034
              SET v_line_out = '#!/bin/sh';                  -- RED_4034
          END IF;                                            -- RED_4034
      END IF;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , v_line_out
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'set -a' -- automatically export assigned variables
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'JOB_NAME=''' || OREPLACE(COALESCE(TRIM(p_job_name),''),'''','''\''''') || ''''
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'TASK_NAME=''' || OREPLACE(COALESCE(TRIM(p_task_name),''),'''','''\''''') || ''''
      );
      SET v_script_line_no = v_script_line_no + 1;

      IF p_obj_type = v_ws_obj_export THEN

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'EXP_NAME=''' || OREPLACE(COALESCE(TRIM(v_et_table_name),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'EXP_FULLNAME=''' || OREPLACE(COALESCE(TRIM(v_exp_source_fullname),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'EXP_TABLE=''' || OREPLACE(COALESCE(TRIM(v_exp_source_table),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'EXP_SCHEMA='''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'EXP_DB=''' || OREPLACE(COALESCE(TRIM(v_exp_source_schema),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'TEMP_DB=''' || OREPLACE(COALESCE(TRIM(v_et_tablespace),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'SRC_DSN=''' || OREPLACE(COALESCE(TRIM(v_exp_source_dsn),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'SRC_SERVER=''' || OREPLACE(COALESCE(TRIM(v_exp_source_server),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'SRC_DBPORT=''' || OREPLACE(COALESCE(TRIM(v_exp_source_dbport),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'SRC_DBID=''' || OREPLACE(COALESCE(TRIM(v_exp_source_dbid),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

      ELSE
        IF v_load_lt_type IN ('S', 'T') THEN
          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'LOAD_FULLNAME=''' || OREPLACE(COALESCE(TRIM(v_load_table_fullname),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'LOAD_TABLE=''' || OREPLACE(COALESCE(TRIM(v_load_lt_table_name),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'LOAD_SCHEMA='''''
          );
          SET v_script_line_no = v_script_line_no + 1;
        END IF;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'LOAD_DB=''' || OREPLACE(COALESCE(TRIM(v_load_lt_database),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , 'TEMP_DB=''' || OREPLACE(COALESCE(TRIM(v_lt_temp_database),''),'''','''\''''') || ''''
        );
        SET v_script_line_no = v_script_line_no + 1;

        IF v_load_lt_type IN ('S', 'T') THEN
          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'TGT_DSN=''' || OREPLACE(COALESCE(TRIM(v_load_target_dsn),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'TGT_SERVER=''' || OREPLACE(COALESCE(TRIM(v_load_target_server),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'TGT_DBPORT=''' || OREPLACE(COALESCE(TRIM(v_load_target_dbport),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'TGT_DBID=''' || OREPLACE(COALESCE(TRIM(v_load_target_dbid),''),'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;

          IF v_source_con_type = 'D' OR v_source_con_type = 'O' OR v_source_con_type = 'Z' THEN
            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_DSN=''' || OREPLACE(COALESCE(TRIM(v_load_source_dsn),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_SERVER=''' || OREPLACE(COALESCE(TRIM(v_load_source_server),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_DBPORT=''' || OREPLACE(COALESCE(TRIM(v_load_source_dbport),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_DBID=''' || OREPLACE(COALESCE(TRIM(v_load_source_dbid),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_DB=''' || OREPLACE(COALESCE(TRIM(v_load_source_db),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'SRC_SCHEMA=''' || OREPLACE(COALESCE(TRIM(v_load_source_schema),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;
          END IF;
        END IF;

        IF v_hadoop_host IS NOT NULL THEN
          INSERT INTO [METABASE].ws_wrk_task_scr_line
          ( wtsl_task_key
          , wtsl_job_key
          , wtsl_sequence
          , wtsl_line_no
          , wtsl_line)
          VALUES
          ( p_task_id
          , p_job_id
          , p_sequence
          , v_script_line_no
          , 'HADOOPHOST=''' || OREPLACE(v_hadoop_host,'''','''\''''') || ''''
          );
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
      END IF;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'META_DSN=${META_DSN-''' || OREPLACE(COALESCE(TRIM(v_meta_dsn),''),'''','''\''''') || '''}'
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'META_SERVER=${META_SERVER-''' || OREPLACE(COALESCE(TRIM(v_meta_server),''),'''','''\''''') || '''}'
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'META_DBID=${META_DBID-${DSS_TDPID-''' || OREPLACE(COALESCE(TRIM(v_meta_dbid),''),'''','''\''''') || '''}}'
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'META_DB=${META_DB-${DSS_METABASE-''' || OREPLACE(COALESCE(TRIM(v_meta_db),''),'''','''\''''') || '''}}'
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'META_SCHEMA=${META_SCHEMA-$(test "${DSS_METABASE+X}" && echo "${DSS_METABASE:+${DSS_METABASE}.}" || echo ''' || OREPLACE(COALESCE(TRIM(v_meta_schema),''),'''','''\''''') || ''')}'
      );
      SET v_script_line_no = v_script_line_no + 1;

      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'WORKDIR=''' || OREPLACE(COALESCE(TRIM(v_work_dir),''),'''','''\''''') || ''''
      );
      SET v_script_line_no = v_script_line_no + 1;

      IF v_param_obj_name IS NOT NULL THEN
        BEGIN
          DECLARE c_Parameter CURSOR FOR
          SELECT
            dss_parameter_name,
            dss_parameter_value
          FROM [METABASE].dss_parameter
          WHERE UPPER(dss_parameter_name) LIKE UPPER(v_param_obj_name || '%')
          ORDER BY dss_parameter_name;

          DECLARE CONTINUE HANDLER FOR NOT FOUND
            SET v_no_more_data1 = 1;

          SET v_no_more_data1 = 0;

          OPEN c_Parameter;

          FETCH FROM c_Parameter INTO
            v_param_name
          , v_param_value;

          WHILE v_no_more_data1 = 0 DO
            INSERT INTO [METABASE].ws_wrk_task_scr_line
            ( wtsl_task_key
            , wtsl_job_key
            , wtsl_sequence
            , wtsl_line_no
            , wtsl_line)
            VALUES
            ( p_task_id
            , p_job_id
            , p_sequence
            , v_script_line_no
            , 'PARAM' || SUBSTR(v_param_name, LENGTH(v_param_obj_name) + 1) || '=''' || OREPLACE(COALESCE(TRIM(v_param_value),''),'''','''\''''') || ''''
            );
            SET v_script_line_no = v_script_line_no + 1;

            FETCH FROM c_Parameter INTO
              v_param_name
            , v_param_value;
          END WHILE;

          CLOSE c_Parameter;
        END;
      END IF;

      -- Write a line to delimit the environment variable setting code from the body of the script
      INSERT INTO [METABASE].ws_wrk_task_scr_line
      ( wtsl_task_key
      , wtsl_job_key
      , wtsl_sequence
      , wtsl_line_no
      , wtsl_line)
      VALUES
      ( p_task_id
      , p_job_id
      , p_sequence
      , v_script_line_no
      , 'exit 1 # ~~WSL_CUT_HERE~~'
      );
      SET v_script_line_no = v_script_line_no + 1;

    END IF;

    --=====================================================
    -- Cursor for all script lines
    --=====================================================
    SET v_no_more_data1 = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      IF v_script_type = v_ws_script_update THEN
        OPEN c_Update_Line;

        FETCH FROM c_Update_Line INTO
          v_script_row
        , v_line;
      ELSE
        OPEN c_Scr_Line;

        FETCH FROM c_Scr_Line INTO
          v_script_row
        , v_line;
      END IF;

      WHILE v_no_more_data1 = 0 DO

        SET v_step = 600;

        SET v_temp = v_line;
        -- RED-6610
        IF v_script_type = v_ws_script_update THEN
          CALL [METABASE].Ws_String_Replace(v_line, '$SCHEMA$', v_database, v_temp);
          CALL [METABASE].Ws_String_Replace(v_temp, '$TABLE$', v_table_name, v_line_out);
          CALL [METABASE].Ws_String_Replace(v_line_out, '$DATABASE$', v_database, v_temp);
          CALL [METABASE].Ws_String_Replace(v_temp, '$OBJECT$', v_database || '.' || v_table_name, v_line_out);
          CALL [METABASE].Ws_String_Replace(v_line_out, '$INDEX$', v_table_name, v_temp);

          SET v_line_out = v_temp;
          SET v_temp = '';
          SET v_spos = INDEX(v_line_out,'[TABLEOWNER].[');
          SET v_step = 650;
          WHILE v_spos > 0
          DO
            -- append up to the [TABLEOWNER].[
            SET v_temp = v_temp || SUBSTR(v_line_out,1,v_spos-1);
            -- remove up to and including the [TABLEOWNER]. from the search string
            SET v_line_out = SUBSTR(v_line_out,v_spos+14,LENGTH(v_line_out)-v_spos-1);
            -- find terminating ]
            SET v_epos = INDEX(v_line_out,']');

            IF v_epos = 0
            THEN
              SET v_spos = 0;
              -- leave the string alone
              SET v_temp = v_temp || '[TABLEOWNER].[';
            ELSE
              -- determine the parameter name
              SET v_object_name = SUBSTR(v_line_out,1,v_epos-1);

              -- determine TABLEOWNER value
              SELECT MAX(oo_obj_key)
                   , MAX(oo_type_key)
              INTO   v_object_key
                   , v_object_type
              FROM   [METABASE].ws_obj_object
              WHERE  LOWER(oo_name) = LOWER(v_object_name);

              IF v_object_type = v_ws_obj_load THEN
                SELECT lt_schema INTO v_object_database FROM [METABASE].ws_load_tab
                WHERE lt_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_dim THEN
                SELECT dt_schema INTO v_object_database FROM [METABASE].ws_dim_tab
                WHERE dt_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_view THEN
                SELECT vt_schema INTO v_object_database FROM [METABASE].ws_view_tab
                WHERE vt_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_fact THEN
                SELECT ft_schema INTO v_object_database FROM [METABASE].ws_fact_tab
                WHERE ft_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_stage THEN
                SELECT st_schema INTO v_object_database FROM [METABASE].ws_stage_tab
                WHERE st_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_agg THEN
                SELECT at_schema INTO v_object_database FROM [METABASE].ws_agg_tab
                WHERE at_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_ods THEN
                SELECT ot_schema INTO v_object_database FROM [METABASE].ws_ods_tab
                WHERE ot_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_normal
                  OR v_object_type = v_ws_obj_hub
                  OR v_object_type = v_ws_obj_satellite
                  OR v_object_type = v_ws_obj_link
                  OR v_object_type = v_ws_obj_custom1
                  OR v_object_type = v_ws_obj_custom2
              THEN
                SELECT nt_schema INTO v_object_database FROM [METABASE].ws_normal_tab
                WHERE nt_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_index THEN
                SELECT ih_schema INTO v_object_database FROM [METABASE].ws_index_header
                WHERE ih_index_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_join THEN
                SELECT jt_schema INTO v_object_database FROM [METABASE].ws_join_tab
                WHERE jt_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_export THEN
                SELECT et_schema INTO v_object_database FROM [METABASE].ws_export_tab
                WHERE et_obj_key = v_object_key;
              ELSEIF v_object_type = v_ws_obj_retro OR v_object_type = v_ws_obj_retro_copy THEN
                SELECT rt_schema INTO v_object_database FROM [METABASE].ws_retro_tab
                WHERE rt_obj_key = v_object_key;
              END IF;

              SET v_object_database = TRIM(v_object_database);
              IF NULLIF(v_object_database,'') IS NULL THEN
                SET v_full_ref = '[TABLEOWNER].['|| v_object_name ||']';
                SET v_msgtext = 'Could not find schema for ' || v_full_ref;
                CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                  v_msgtext, NULL, NULL, p_task_id, p_job_id);
              ELSE
                SET v_full_ref = v_object_database ||'.'|| v_object_name;
              END IF;

              -- append the parameter value
              SET v_temp = v_temp || v_full_ref;
              -- remove up to terminating ] from the search string
              SET v_line_out = SUBSTR(v_line_out,v_epos+1,LENGTH(v_line_out)-v_epos);
            END IF;

            -- look for more '[TABLEOWNER].'
            SET v_spos = INDEX(v_line_out,'[TABLEOWNER].[');
          END WHILE;
          -- Append the rest of the string
          SET v_temp = v_temp || v_line_out;
        END IF;
        CALL [METABASE].WsParameterReplace(v_temp, 4000, v_line_out);

        IF NULLIF(TRIM(v_line_out),'') IS NULL THEN
          SET v_line_out = v_line;
        END IF;

        INSERT INTO [METABASE].ws_wrk_task_scr_line
        ( wtsl_task_key
        , wtsl_job_key
        , wtsl_sequence
        , wtsl_line_no
        , wtsl_line)
        VALUES
        ( p_task_id
        , p_job_id
        , p_sequence
        , v_script_line_no
        , v_line_out);

        SET v_script_line_no = v_script_line_no + 1;

        SET v_step = 700;

        IF v_script_type = v_ws_script_update THEN
          FETCH FROM c_Update_Line INTO
            v_script_row
          , v_line;
        ELSE
          FETCH FROM c_Scr_Line INTO
            v_script_row
          , v_line;
        END IF;

      END WHILE; -- End of script line loop

      SET v_step = 800;

      IF v_script_type = v_ws_script_update THEN
        CLOSE c_Update_Line;
      ELSE
        CLOSE c_Scr_Line;
      END IF;

    END;

    --=====================================================
    -- Write out the task script header
    --=====================================================
    INSERT into [METABASE].ws_wrk_task_scr_hdr
    ( wtsh_task_key
    , wtsh_job_key
    , wtsh_name
    , wtsh_sequence
    , wtsh_host_type
    , wtsh_script_type
    , wtsh_load_type
    , wtsh_work_dir
    , wtsh_connect_key
    , wtsh_load_key
    , wtsh_script_key)
    VALUES
    ( p_task_id
    , p_job_id
    , p_task_name
    , p_sequence
    , v_connect_dc_type
    , v_script_type
    , v_load_type
    , v_work_dir
    , v_connect_key
    , v_load_key
    , v_script_key);

  END IF;

  --=====================================================
  -- XML based Load. Null script is generated
  --=====================================================
  IF v_script_type = v_ws_load_xml THEN

    SET v_connect_key = v_load_lt_connect_key;
    SET v_load_key = p_obj_key;
    SET v_script_key = 0;

    --=====================================================
    -- Get the work directory from the connection
    -- IF no Connection we have a problem
    --=====================================================
    IF v_connect_key > 0 THEN

      SELECT dc_work_dir
           , dc_type
           , dc_admin_userid
           , dc_admin_pwd
           , dc_database_id
           , dc_name
      INTO   v_connect_dc_work_dir
           , v_connect_dc_type
           , v_connect_dc_admin_userid
           , v_connect_dc_admin_pwd
           , v_connect_dc_database_id
           , v_connect_dc_name
      FROM   [METABASE].ws_dbc_connect
      WHERE  dc_obj_key = v_connect_key;

    ELSE

      IF v_script_type = v_ws_script_execute THEN

        SET p_return_msg = 'No connection defined. Unable to execute script';

      ELSE

        SET p_return_msg = 'No connection defined. Unable to perform load';

      END IF;

      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    SET v_work_dir = v_connect_dc_work_dir;

    IF SUBSTR(v_work_dir,CHAR(v_work_dir)-1,1) <> '\' THEN

      SET v_work_dir = v_work_dir || '\';
--'
    END IF;

    --=====================================================
    -- Unix file based load. Build a Unix script
    --=====================================================
    IF v_connect_dc_type = 'U' THEN

      SET p_return_msg = 'Unix XML loads not supported';
      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    --=====================================================
    -- Windows XML based load. Build a dummy windows script
    --=====================================================
    IF v_connect_dc_type = 'W' THEN
      --=====================================================
      -- Write out the task script header
      --=====================================================
      INSERT into [METABASE].ws_wrk_task_scr_hdr
      ( wtsh_task_key
      , wtsh_job_key
      , wtsh_name
      , wtsh_sequence
      , wtsh_host_type
      , wtsh_script_type
      , wtsh_load_type
      , wtsh_work_dir
      , wtsh_connect_key
      , wtsh_load_key
      , wtsh_script_key)
      VALUES
      ( p_task_id
      , p_job_id
      , p_task_name
      , p_sequence
      , v_connect_dc_type
      , v_script_type
      , v_load_type
      , v_work_dir
      , v_connect_key
      , v_load_key
      , v_script_key);

      SET v_step = 900;
      SET p_status_code = 1;
      SET p_result = 1;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF; -- End of Windows XML

  END IF; -- End of XML load

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --   L  O  A  D
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================

  --=====================================================
  -- File based Load. Build the script below once we work
  -- out IF a Unix or Windows connection
  --=====================================================
  IF p_obj_type = v_ws_obj_load AND v_script_type = v_ws_load_file THEN

    SET v_connect_key = v_load_lt_connect_key;
    SET v_load_key = p_obj_key;
    SET v_script_key = 0;

    --=====================================================
    -- Get the work directory from the connection
    -- IF no Connection we have a problem
    --=====================================================
    IF v_connect_key > 0 THEN

      SELECT dc_work_dir
           , dc_type
           , dc_extract_userid
           , dc_extract_pwd
           , dc_admin_userid
           , dc_admin_pwd
           , dc_database_id
           , dc_name
           , dc_attributes
      INTO   v_connect_dc_work_dir
           , v_connect_dc_type
           , v_connect_dc_extract_userid
           , v_connect_dc_extract_pwd
           , v_connect_dc_admin_userid
           , v_connect_dc_admin_pwd
           , v_connect_dc_database_id
           , v_connect_dc_name
           , v_connect_dc_attributes
      FROM   [METABASE].ws_dbc_connect
      WHERE  dc_obj_key = v_connect_key;

    ELSE

      IF v_script_type = v_ws_script_execute THEN

        SET p_return_msg = 'No connection defined. Unable to execute script';

      ELSE

        SET p_return_msg = 'No connection defined. Unable to perform load';

      END IF;

      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    --=====================================================
    -- Build up the work directory for Unix and Windows
    --=====================================================
    IF v_connect_dc_type = 'U' THEN

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '/' THEN

        SET v_work_dir = v_work_dir || '/';

      END IF;

    ELSE

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '\' THEN

        SET v_work_dir = v_work_dir || '\';
--'
      END IF;

    END IF;

    --=====================================================
    -- See if we have a record delimiter in the load_option field
    --=====================================================
    SET v_step = 1000;
    SET v_rec_delimiter = '';
    SET v_rec_options = '';
    SET v_rec_when = '';

    IF NULLIF(TRIM(v_load_lt_load_options),'') IS NOT NULL THEN

      SET v_epos = INDEX(v_load_lt_load_options,'REC_DELIM=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+10,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_rec_delimiter = SUBSTR(v_load_lt_load_options,v_epos+15,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'OPTIONS=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+8,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_rec_options = SUBSTR(v_load_lt_load_options,v_epos+13,v_spos);

        END IF;

      END IF;


     SET v_epos = INDEX(v_load_lt_load_options,'ROUTINE=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+8,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_routine = SUBSTR(v_load_lt_load_options,v_epos+13,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'CHARSET=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+8,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_charset = SUBSTR(v_load_lt_load_options,v_epos+13,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'MINSESSION=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+11,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_minsessions = SUBSTR(v_load_lt_load_options,v_epos+16,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'MAXSESSION=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+11,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_maxsessions = SUBSTR(v_load_lt_load_options,v_epos+16,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'INST_READ=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+10,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_readinstances = v_spos;

        END IF;

      END IF;
      SET v_epos = INDEX(v_load_lt_load_options,'INST_WRITE=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+11,4) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_writeinstances = v_spos;

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'MEM_SIZE=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+9,2) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_memorysize = SUBSTR(v_load_lt_load_options,v_epos+12,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'LJNAME=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+7,2) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_LoadJobName = SUBSTR(v_load_lt_load_options,v_epos+10,v_spos);

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'TBOPT=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+6,3) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_TBuildOptions = SUBSTR(v_load_lt_load_options,v_epos+10,v_spos);

      SET v_line = v_load_lt_TBuildOptions;

      CALL [METABASE].WsParameterReplace(v_line, 1024, v_load_lt_TBuildOptions);

          IF NULLIF(TRIM(v_load_lt_TBuildOptions),'') IS NULL THEN
            SET v_load_lt_TBuildOptions = v_line;
          END IF;

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'TLOPT=');

      IF v_epos > 0 THEN

        SET v_spos = CAST(SUBSTR(v_load_lt_load_options,v_epos+6,3) AS INTEGER);

        IF v_spos > 0 THEN

          SET v_load_lt_TLogViewOptions = SUBSTR(v_load_lt_load_options,v_epos+10,v_spos);

      SET v_line = v_load_lt_TLogViewOptions;

      CALL [METABASE].WsParameterReplace(v_line, 1024, v_load_lt_TLogViewOptions);

          IF NULLIF(TRIM(v_load_lt_TLogViewOptions),'') IS NULL THEN
            SET v_load_lt_TLogViewOptions = v_line;
          END IF;

        END IF;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'COMPRESS_ON_RENAME;');

      IF v_epos > 0 THEN

        SET v_load_lt_compress = 1;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'FAIL_INCOMPLETE_LOAD;');

      IF v_epos > 0 THEN

        SET v_fail_incomplete = 1;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'FILE_LOOP;');

      IF v_epos > 0 THEN

        SET v_load_lt_file_loop = 1;

      END IF;

      SET v_epos = INDEX(v_load_lt_load_options,'LOG_DETAIL;');

      IF v_epos > 0 THEN

        SET v_load_lt_log_detail = 1;

      END IF;


      SET v_epos = INDEX(v_load_lt_load_options,'LOAD_NEWEST;');

      IF v_epos > 0 THEN

        SET v_load_lt_file_newest = 1;

      END IF;

      IF NULLIF(TRIM(v_rec_options),'') IS NOT NULL THEN

        SET v_work = UPPER(v_rec_options);
        SET v_epos = INDEX(v_work,'WHEN');

        IF v_epos > 0 THEN

          CALL [METABASE].Ws_String_Replace(SUBSTR(v_rec_options,v_epos,CHAR(v_rec_options)),'>','^>',v_new_value);

          SET v_rec_when = v_new_value;
          SET v_rec_options = SUBSTR(v_rec_options,1,v_epos-1);

        END IF;

      END IF;

    END IF;

    --=====================================================
    -- Unix file based load. Build a Unix script
    -- RED_3839 Give warning and abort when routine "No Load" is specified
    IF v_load_lt_routine = 'No Load' THEN


      SET v_msgtext = 'File load routine ''No Load'' is specified. No data loaded';
      CALL [METABASE].WsWrkAudit('W', p_job_name, p_task_name, p_sequence
        , v_msgtext, NULL, NULL, p_task_id, p_job_id);

      SET p_return_msg = v_msgtext;
      SET p_status_code = -1;
      SET p_result = -1;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    IF v_connect_dc_type = 'U' THEN

    SET v_script_line_no = 1;

    -- Use the shell configured in the connection, otherwise guess
    -- based on the name of the connection
    SET v_line_out = NULL;
    SET v_pos = INDEX(v_connect_dc_attributes, 'ScriptShell~=');
    IF v_pos >= 1 THEN
        SET v_pos = v_pos + 13;
        SET v_epos = INDEX(SUBSTR(v_connect_dc_attributes, v_pos), ';') + v_pos - 1;
        IF v_epos >= 1 THEN
            SET v_work = SUBSTR(v_connect_dc_attributes, v_pos, v_epos-v_pos);
            SET v_line_out = '#!' || SUBSTR(v_connect_dc_attributes, v_epos + 1, CAST(v_work AS INTEGER));
        END IF;
    END IF;

    IF v_line_out IS NULL THEN
        IF INDEX(UPPER(v_connect_dc_name),'UNIX') > 0 THEN -- RED_4034
            SET v_line_out = '#!/bin/ksh';                 -- RED_4034
        ELSE                                               -- RED_4034
            SET v_line_out = '#!/bin/sh';                  -- RED_4034
        END IF;                                            -- RED_4034
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***** DBMS Name      :    Teradata';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***** Description    :    File Load/Movement for ' || v_load_lt_file_path || v_load_lt_file_name ||  CAST(' into ' AS VARCHAR(10)) || v_load_lt_table_name;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'LOAD_FILE=' || v_load_lt_file_path || v_load_lt_file_name;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF SUBSTR(v_load_lt_trig_path,CHAR(v_load_lt_trig_path),1) <> '/' THEN
        SET v_load_lt_trig_path = v_load_lt_trig_path || '/';
    END IF;

    IF v_load_lt_trig_path <> '' THEN
        SET v_line_out = 'TRIG_FILE=' || v_load_lt_trig_path || v_load_lt_trig_name;
    ELSE
        SET v_line_out = 'TRIG_FILE=' || v_load_lt_file_path || v_load_lt_file_name;
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'LOAD_DB=' || v_load_lt_database;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'TEMP_DB=' || v_lt_temp_database;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'LOAD_TABLE=' || v_load_lt_table_name;

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# *****';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***** Set default values if any variable have not been set';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# *****';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'DSS_TDPID=${DSS_TDPID:=' || v_connect_dc_database_id || '}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'DSS_METABASE=${DSS_METABASE:=[METABASE]}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'DSS_USER=${DSS_USER:=' || v_connect_dc_extract_userid || '}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'DSS_WORKDIR=${DSS_WORKDIR:=' || v_connect_dc_work_dir || '}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'SEQUENCE=${SEQ:=' || trim(p_sequence) || '}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# *****';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***** Set derived file names';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# *****';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'CTL_FILE=$DSS_WORKDIR${DSS_USER}' || v_load_lt_table_name || '$SEQUENCE.ctl';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'AUD_FILE=$DSS_WORKDIR${DSS_USER}' || v_load_lt_table_name || '$SEQUENCE.aud';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'TRG_FILE=$DSS_WORKDIR${DSS_USER}' || v_load_lt_table_name || '$SEQUENCE.trg';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ************************* W A I T     T I M E R ***********************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# If a wait time specified then loop looking for the file or trigger'; -- RED_4034

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# to arrive until the wait period expires.';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'WAITSECS=' || CAST(v_load_lt_file_wait AS VARCHAR(10));

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'if [ "$WAITSECS" -gt "0" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  # Get the current time and work out the end of the wait';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  # pipe through bc to remove lead 0';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  NOW_HH=`date +%H | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  NOW_MM=`date +%M | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  NOW_SS=`date +%S | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  let NOW_HH="$NOW_HH * 3600"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  let NOW_MM="$NOW_MM * 60"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  let NOW_TIME="$NOW_HH + $NOW_MM + $NOW_SS"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  let TILL_TIME="$NOW_TIME + $WAITSECS"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  let START_TIME="$NOW_TIME"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  # Loop checking for the file until the wait is complete';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  while [ "$NOW_TIME" -lt "$TILL_TIME" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  do';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '    FCOUNT=`find $TRIG_FILE -print 2>/dev/null | wc -l`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '    if [ "$FCOUNT" -gt "0" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '    then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      let NOW_TIME="$TILL_TIME"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '    else';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      # if the file is not present sleep 30 seconds';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      # and recalculate the time. If less than the start';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      # then we have gone past midnight so add 86400';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      sleep 30';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      NOW_HH=`date +%H | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      NOW_MM=`date +%M | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      NOW_SS=`date +%S | bc`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      let NOW_HH="$NOW_HH * 3600"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      let NOW_MM="$NOW_MM * 60"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      let NOW_TIME="$NOW_HH + $NOW_MM + $NOW_SS"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      if [ "$NOW_TIME" -lt "$START_TIME" ] ';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '        let NOW_TIME="$NOW_TIME + 86400"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '      fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '    fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  done';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# Finished our wait loop. See if we have the file';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_trig_name = '' THEN -- RED_4034
        SET v_comment_prefix = '### ';
    ELSE
        SET v_comment_prefix = '';
    END IF;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ************************* T R I G   C H E C K  ************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;


    SET v_line_out = v_comment_prefix || 'FCOUNT=`find $TRIG_FILE -print 2>/dev/null | wc -l`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'if [ "$FCOUNT" -eq "0" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '  # file not present so exit with the requested return code';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_wait_action = 'S' THEN                              -- RED_4034
        SET v_line_out =  v_comment_prefix || '  echo "1"';          -- RED_4034
    ELSE                                                             -- RED_4034
        IF v_load_lt_wait_action = 'E' THEN                          -- RED_4034
            SET v_line_out =  v_comment_prefix || '  echo "-2"';     -- RED_4034
        ELSE                                                         -- RED_4034
            IF v_load_lt_wait_action = 'F' THEN                      -- RED_4034
                SET v_line_out =  v_comment_prefix || '  echo "-3"'; -- RED_4034
            ELSE                                                     -- RED_4034
                SET v_line_out =  v_comment_prefix || '  echo "-1"'; -- RED_4034
            END IF;                                                  -- RED_4034
        END IF;                                                      -- RED_4034
    END IF;                                                          -- RED_4034

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  echo "Trigger file $TRIG_FILE was not found"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  exit';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ************************* F I L E   C H E C K  ************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'FCOUNT=`find $LOAD_FILE -print 2>/dev/null | wc -l`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'if [ "$FCOUNT" -eq "0" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  # file not present so exit with the requested return code';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  #';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_wait_action = 'S' THEN                              -- RED_4034
        SET v_line_out =  v_comment_prefix || '  echo "1"';          -- RED_4034
    ELSE                                                             -- RED_4034
        IF v_load_lt_wait_action = 'E' THEN                          -- RED_4034
            SET v_line_out =  v_comment_prefix || '  echo "-2"';     -- RED_4034
        ELSE                                                         -- RED_4034
            IF v_load_lt_wait_action = 'F' THEN                      -- RED_4034
                SET v_line_out =  v_comment_prefix || '  echo "-3"'; -- RED_4034
            ELSE                                                     -- RED_4034
                SET v_line_out =  v_comment_prefix || '  echo "-1"'; -- RED_4034
            END IF;                                                  -- RED_4034
        END IF;                                                      -- RED_4034
    END IF;                                                          -- RED_4034

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  echo "File $LOAD_FILE was not found"';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '  exit';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = 'fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_trig_name = '' THEN
        SET v_comment_prefix = '### ';
    ELSE
        SET v_comment_prefix = '';
    END IF;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ******************* G E T    T R I G   N A M E ************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;


    SET v_line_out = v_comment_prefix || 'TLIST=`find $TRIG_FILE -print`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'for TACTFILE in $TLIST';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'do';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '  TRIG_ACTFILE=$TACTFILE';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '  break';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'done';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_trig_name = '' OR v_load_lt_trig_prefix = '' THEN -- RED_4034
        SET v_comment_prefix = '### ';
    ELSE
        SET v_comment_prefix = '';
    END IF;


    -- Ignore pathological file names with more than 3 dots and take the first substring with maximal 2 dots as prefix
    select CASE  WHEN pos1 > 0 THEN substr(word,1, pos1+pos2+position('.' in stub2) -1) ELSE word END
    into v_trig_file_base
    from (select word, pos1, stub1,  CASE WHEN  position('.' in stub1) > 0 THEN substr(stub1, position('.' in stub1)+1, character_length(stub1)) ELSE '' END stub2, position('.' in stub1) pos2
              from (select word, substr(word, position('.' in word)+1, character_length(word)) stub1, position('.' in word) pos1 from  (select v_load_lt_trig_name word ) trigger_name
          ) stubtab
    ) stubtab2;

    SET v_line_out = '# ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line)    VALUES    ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ************************* T R I G G E R  ******************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# ***********************************************************************';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '# Clear any existing Trigger file parameters';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = '#';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'BRES1=`bteq <<BTEQEOF1  2>&1';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '.logon ${DSS_TDPID}/${DSS_USER},${DSS_PWD}';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '.set width 254';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'DELETE FROM ${DSS_METABASE}.dss_parameter';

    INSERT INTO [METABASE].ws_wrk_task_scr_line
    ( wtsl_task_key
    , wtsl_job_key
    , wtsl_sequence
    , wtsl_line_no
    , wtsl_line)
    VALUES
    ( p_task_id
    , p_job_id
    , p_sequence
    , v_script_line_no
    , v_line_out);

    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'WHERE dss_parameter_name like ''' || v_load_lt_trig_prefix || '__%''';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'OR    dss_parameter_name like ''' || v_load_lt_trig_prefix || '___%'';'; -- RED_4034

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '.exit';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'BTEQEOF1`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'BRES2=$?';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =v_comment_prefix ||  'if [ "$BRES2" -ne "0" ]';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'then';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '   echo "WARNING:Parameter clear BTEQ returned a non standard return code of $BRES2" >>$AUD_FILE';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || 'fi';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '# Load the contents of the trigger file into parameters';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_trig_name <> '' THEN -- RED_4034
    SET v_line_out =  v_comment_prefix || 'cat $TRIG_ACTFILE';
    ELSE
    SET v_line_out =  v_comment_prefix || 'cat ' || v_load_lt_trig_path || v_trig_file_base || '.trg' ;
    END IF;

    SET v_line_out = v_line_out || ' | tr "';

    IF v_load_lt_trig_delimiter <> '' THEN
        SET v_line_out =  v_line_out || v_load_lt_trig_delimiter;
    ELSE
        SET v_line_out =  v_line_out || '\012' ;
    END IF;

    SET v_line_out =  v_line_out || '" "\012" > $TRG_FILE' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'TRIGNO=`cat $TRG_FILE';
    SET v_line_out = v_line_out || ' | wc -l | tr -d " "`';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'if [ "$TRIGNO" != "0" ] ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'then';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  ROWNUM=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  while [ "$ROWNUM" -lt "$TRIGNO" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  do';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_trig_prefix <> '' THEN
        SET v_line_out =  v_comment_prefix || '    TRIG_NO="' || v_load_lt_trig_prefix;
    ELSE
        SET v_line_out =  v_comment_prefix || '    TRIG_NO="' || v_load_lt_file_name;
    END IF;

    SET v_line_out = v_line_out || '_$ROWNUM"';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    let ROWNUM="$ROWNUM+1"';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    TRIG_MSG=`cat $TRG_FILE';
    SET v_line_out = v_line_out || ' | head -$ROWNUM | tail -1 | sed "s/''/''''/g"`';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    BRES3=`bteq <<BTEQACT2  2>&1';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    .logon ${DSS_TDPID}/${DSS_USER},${DSS_PWD}';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    .set width 254';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    CALL ${DSS_METABASE}.WsParameterWrite(''${TRIG_NO}'',''${TRIG_MSG}'',''load of ' || v_load_lt_file_path || v_load_lt_file_name; -- RED_4034
    SET v_line_out = v_line_out || '''); ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    .exit';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    BTEQEOF2`';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    BRES4=$?';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    if [ "$BRES4" -ne "0" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    then';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '       echo "WARNING: Parameter write BTEQ returned a non standard return code of $BRES2" >>$AUD_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '    fi';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '  done';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || 'fi';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '# ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '# ************************* D A T A   L O A D   S T A R T ***************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '# ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'ROWS_INSERTED=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'ROWS_UPDATED=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'ROWS_DELETED=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'ROWS_APPLIED=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'ROWS_SENT=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'MAX_RETCODE=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'TRIG_MOVE_DONE=0';
    INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;



    IF v_load_lt_file_newest = 1 THEN
        SET v_line_out =  '# Find the actual file name that we will be loading';
    ELSEIF v_load_lt_file_loop = 1 THEN
        SET v_line_out =  '# Loop through all files found loading them into the table';
    ELSE
        SET v_line_out =  '# Loop through the possible file names to find the first file to load';
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '#';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out = 'DO_LOAD=1';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out =  'FLIST=`ls -t $LOAD_FILE`';
    ELSE
        SET v_line_out =  'FLIST=`find $LOAD_FILE -print`';
    END IF;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'for ACTFILE in $FLIST';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'do';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out = '  if [ "$DO_LOAD" -ne "0" ] ';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out = '  then';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_do_load_indent = '  ';
    ELSE
        SET v_do_load_indent = '';
    END IF;

    SET v_line_out = v_do_load_indent || '  # Build the ' || v_load_lt_routine || ' Loader Script'; -- RED_4034
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo USING CHARACTER SET ' || v_load_lt_charset || ' > $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "DEFINE JOB ${LOAD_TABLE}';
    SET v_line_out = v_line_out || '_TABLE_FROM_FILE" >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "DESCRIPTION ''LOAD $LOAD_TABLE';
    SET v_line_out = v_line_out || ' TABLE FROM A FILE'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DEFINE SCHEMA ';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_SCHEMA " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DESCRIPTION ''TABLE $LOAD_TABLE';
    SET v_line_out = v_line_out || ' SCHEMA'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    --=====================================================
    -- Cursor for all columns
    --=====================================================
    SET v_no_more_data1 = 0;
    SET v_col_comma = '   ';
    SET v_b_table_and_file_may_differ = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_Load_Col;

      FETCH FROM c_Load_Col INTO
        v_lc_col_name,
        v_lc_data_type,
        v_lc_transform_code,
        v_lc_transform_type,
        v_lc_src_column,
        v_lc_attributes,
        v_lc_format,
        v_tpt_data_type;

      WHILE v_no_more_data1 = 0 DO

        SET v_step = 1100;

        -- RED_2850 TODO: TAKE OUT COMMENTED LINES in v_lc_transform_code???????????!!!!!!
        IF TRIM(v_lc_src_column) || TRIM(v_lc_transform_code) = '' THEN
            SET v_line_out =  '';
        -- RED_3023, RED-8028
        ELSEIF TRIM(v_lc_src_column) = '' THEN
            SET v_line_out =  '';
            SET v_b_table_and_file_may_differ = 1;
        ELSE
            SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || '\"' || TRIM(v_lc_col_name) || '\" ' || v_tpt_data_type || '" >> $CTL_FILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_col_comma = '  , ';
        END IF;


        SET v_step = 1200;

        FETCH FROM c_Load_Col INTO
            v_lc_col_name,
            v_lc_data_type,
            v_lc_transform_code,
            v_lc_transform_type,
            v_lc_src_column,
            v_lc_attributes,
            v_lc_format,
            v_tpt_data_type;

      END WHILE; -- End of script line loop

      SET v_step = 1300;

      CLOSE c_Load_Col;

    END;

    SET v_line_out = v_do_load_indent || '  echo ");" >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DEFINE OPERATOR DDL_OPERATOR() " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DESCRIPTION ''TERADATA PARALLEL TRANSPORTER DDL OPERATOR'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'TYPE DDL " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'ATTRIBUTES " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR PrivateLogName = ''';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_DDL'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR TdpId = ''$DSS_TDPID'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR UserName = ''$DSS_USER'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR UserPassword = @TDPassword, " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR AccountID, " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR ErrorList = ''3807'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "DEFINE OPERATOR ';
    SET v_line_out = v_line_out || SUBSTR(v_load_lt_routine,1,index(v_load_lt_routine,' ')-1); --EXTRACT sTPTType from ROUTINE
    SET v_line_out = v_line_out || '_OPERATOR() " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DESCRIPTION ''TERADATA PARALLEL TRANSPORTER ';
    SET v_line_out = v_line_out || SUBSTR(v_load_lt_routine,1,index(v_load_lt_routine,' ')-1); --EXTRACT sTPTType from ROUTINE
    SET v_line_out = v_line_out || ' OPERATOR'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'TYPE ';
    SET v_line_out = v_line_out || SUBSTR(v_load_lt_routine,1,index(v_load_lt_routine,' ')-1); --EXTRACT sTPTType from ROUTINE
    SET v_line_out = v_line_out || '  " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'SCHEMA ';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_SCHEMA " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'ATTRIBUTES " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    --SET v_line_out = v_line_out || 'INTEGER MaxSessions = 4, " >> $CTL_FILE';
    SET v_line_out = v_line_out || 'INTEGER MaxSessions = ' || v_load_lt_maxsessions || ', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    --SET v_line_out = v_line_out || 'INTEGER MinSessions = 1, " >> $CTL_FILE';
    SET v_line_out = v_line_out || 'INTEGER MinSessions = ' || v_load_lt_minsessions || ', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR TargetTable = ''$LOAD_DB.$LOAD_TABLE';
    SET v_line_out = v_line_out || ''', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR TdpId = ''$DSS_TDPID'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR UserName = ''$DSS_USER'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR UserPassword = @TDPassword, " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR AccountId, " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR ErrorTable1 = ''';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_E1'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR ErrorTable2 = ''';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_E2'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR WorkTable = ''';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_WT'', " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'VARCHAR LogTable = ''';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_LT'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DEFINE OPERATOR FILE_READER() " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'DESCRIPTION ''TERADATA PARALLEL TRANSPORTER DATA CONNECTOR OPERATOR'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'TYPE DATACONNECTOR PRODUCER " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'SCHEMA ';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_SCHEMA " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'ATTRIBUTES " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;



    SET v_work_string = TRIM(COALESCE(v_load_options,''));

    WHILE v_work_string <> '' DO

        SET v_line_out = v_do_load_indent || '  echo "';

        IF position (',' in v_work_string) = 0 THEN
            SET v_line_out = v_line_out || v_work_string;
            SET v_work_string = '';
        ELSEIF POSITION(',' IN v_work_string) >  POSITION('[' IN v_work_string) THEN
            SET v_line_out = v_line_out || SUBSTR( v_work_string , 1,  POSITION(']' IN v_work_string) + POSITION(',' IN  SUBSTR( v_work_string, POSITION (']' IN v_work_string) + 1 ,CHARACTER_LENGTH( v_work_string))));
            SET v_work_string = SUBSTR( v_work_string ,POSITION (']' in v_work_string) + POSITION (',' in  SUBSTR( v_work_string, POSITION (']' in v_work_string) + 1 ,CHARACTER_LENGTH( v_work_string))) + 1);
        ELSE
            SET v_line_out = v_line_out || SUBSTR( v_work_string , 1, POSITION(',' IN v_work_string));
            SET v_work_string = SUBSTR( v_work_string , POSITION (',' in  v_work_string) + 1);
        END IF;

        SET v_line_out = v_line_out || '" >> $CTL_FILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

    END WHILE;

    IF v_load_lt_file_delimiter <> '' THEN
        IF POSITION('FORMAT' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
            SET v_line_out = v_do_load_indent || '  echo "VARCHAR Format = ''Delimited'', " >> $CTL_FILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
        END IF;

        -- Mask some delimiters
        IF v_load_lt_file_delimiter = '"' THEN
            SET v_load_lt_file_delimiter = '\' || v_load_lt_file_delimiter; --' For readablitiy in a text file
        END IF;

        IF v_load_lt_file_delimiter = '''' THEN
            SET v_load_lt_file_delimiter = v_load_lt_file_delimiter || v_load_lt_file_delimiter;
        END IF;

        IF POSITION('TEXTDELIMITER' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
            SET v_line_out = v_do_load_indent || '  echo "VARCHAR TextDelimiter = ''' || v_load_lt_file_delimiter || ''', " >> $CTL_FILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
        END IF;
    ELSE
        IF UPPER(TRIM(v_load_lt_file_parsed)) = 'Y' THEN
            IF POSITION('FORMAT' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
                SET v_line_out = v_do_load_indent || '  echo "VARCHAR Format = '''||v_load_lt_file_format||''', " >> $CTL_FILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
            END IF;
        ELSE
            IF POSITION('FORMAT' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
                SET v_line_out = v_do_load_indent || '  echo "VARCHAR Format = ''Delimited'', " >> $CTL_FILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
            END IF;

            IF POSITION('TEXTDELIMITER' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
                SET v_line_out = v_do_load_indent || '  echo "VARCHAR TextDelimiter = ''\\n'', " >> $CTL_FILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
            END IF;
        END IF;
    END IF;



    IF UPPER(v_load_lt_file_header_line) = 'Y' THEN
        IF POSITION('SKIPROWS' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
            SET v_line_out = v_do_load_indent || '  echo "INTEGER SkipRows = 1, " >> $CTL_FILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
        END IF;
    END IF;


    IF POSITION('INDICATORMODE' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
        SET v_line_out = v_do_load_indent || '  echo "VARCHAR IndicatorMode = ''N'', " >> $CTL_FILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    IF POSITION('OPENMODE' IN UPPER(COALESCE(v_load_options,''))) = 0 THEN
        SET v_line_out = v_do_load_indent || '  echo "VARCHAR OpenMode = ''Read'', " >> $CTL_FILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out = v_do_load_indent || '  echo "VARCHAR FileName = ''$ACTFILE'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'STEP setup_tables " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'APPLY " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '(''DROP TABLE ';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_E1;''), " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '(''DROP TABLE ';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_E2;''), " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '(''DROP TABLE ';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_WT;''), " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '(''DROP TABLE ';
    SET v_line_out = v_line_out || '$TEMP_DB.';
    SET v_line_out = v_line_out || v_short_name;
    SET v_line_out = v_line_out || '_LT;'') " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'TO OPERATOR (DDL_OPERATOR () ); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;


    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'STEP load_data_to_table " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'APPLY " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '''INSERT INTO ';
    SET v_line_out = v_line_out || '$LOAD_DB.$LOAD_TABLE';
    SET v_line_out = v_line_out || ' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '( " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    --=====================================================
    -- Cursor for all columns
    --=====================================================
    SET v_no_more_data1 = 0;
    SET v_col_comma = '   ';

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_Load_Col;

      FETCH FROM c_Load_Col INTO
        v_lc_col_name,
        v_lc_data_type,
        v_lc_transform_code,
        v_lc_transform_type,
        v_lc_src_column,
        v_lc_attributes,
        v_lc_format,
        v_tpt_data_type;

      WHILE v_no_more_data1 = 0 DO


        IF TRIM(v_lc_src_column) || TRIM(v_lc_transform_code) = '' THEN
            SET v_line_out =  '';
        ELSE
            -- RED-3023, RED-8028, RED-8276
            IF (1 = v_b_table_and_file_may_differ) OR ('Update TPT' = v_load_lt_routine) THEN
                SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || '\"' || TRIM(v_lc_col_name) || '\" " >> $CTL_FILE';
            ELSE
                SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || ':\"' || TRIM(v_lc_col_name) || '\" " >> $CTL_FILE';
            END IF;

            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_col_comma = '  , ';
        END IF;

        FETCH FROM c_Load_Col INTO
            v_lc_col_name,
            v_lc_data_type,
            v_lc_transform_code,
            v_lc_transform_type,
            v_lc_src_column,
            v_lc_attributes,
            v_lc_format,
            v_tpt_data_type;

      END WHILE; -- End of script line loop

      CLOSE c_Load_Col;

    END;

    -- RED-3023, RED-8028, RED-8276
    IF (1 = v_b_table_and_file_may_differ) OR ('Update TPT' = v_load_lt_routine) THEN

        SET v_line_out = v_do_load_indent || '  echo "';
        SET v_line_out = v_line_out || ') VALUES ( " >> $CTL_FILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        --=====================================================
        -- Cursor for all columns
        --=====================================================
        SET v_no_more_data1 = 0;
        SET v_col_comma = '   ';

        BEGIN

          DECLARE CONTINUE HANDLER FOR NOT FOUND
            SET v_no_more_data1 = 1;

          OPEN c_Load_Col;

          FETCH FROM c_Load_Col INTO
            v_lc_col_name,
            v_lc_data_type,
            v_lc_transform_code,
            v_lc_transform_type,
            v_lc_src_column,
            v_lc_attributes,
            v_lc_format,
            v_tpt_data_type;

          WHILE v_no_more_data1 = 0 DO

            IF TRIM(v_lc_src_column) || TRIM(v_lc_transform_code) = '' THEN
                SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || 'NULL" >> $CTL_FILE';
            ELSE
                IF v_lc_transform_code <> '' THEN
                    -- RED-8276 During Load Transforms are allowed for TPT Update only (historical reasons)
                    IF (v_lc_transform_type = 'D') AND ('Update TPT' = v_load_lt_routine) THEN
                        CALL [METABASE].Ws_String_Replace(v_lc_transform_code,'''','''''',v_new_value);
                        SET v_lc_transform_code = v_new_value;

                        SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || TRIM(v_lc_transform_code) || '" >> $CTL_FILE';
                    ELSEIF TRIM(v_lc_src_column) = '' THEN
                        SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || 'NULL" >> $CTL_FILE';
                    ELSE
                        SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || ':\"' || TRIM(v_lc_col_name) || '\" " >> $CTL_FILE';
                    END IF;
                ELSE
                    SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || ':\"' || TRIM(v_lc_col_name) || '\" " >> $CTL_FILE';
                END IF;
            END IF;

            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_col_comma = '  , ';

            FETCH FROM c_Load_Col INTO
                v_lc_col_name,
                v_lc_data_type,
                v_lc_transform_code,
                v_lc_transform_type,
                v_lc_src_column,
                v_lc_attributes,
                v_lc_format,
                v_tpt_data_type;

          END WHILE; -- End of script line loop

          CLOSE c_Load_Col;

        END;

    END IF;
    --END RED_3023

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || ');'' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || ') " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'TO OPERATOR ( ';
    SET v_line_out = v_line_out || SUBSTR(v_load_lt_routine,1,index(v_load_lt_routine,' ')-1); --EXTRACT sTPTType from ROUTINE
    SET v_line_out = v_line_out || '_OPERATOR () [' || CAST(v_load_lt_writeinstances AS VARCHAR(4)) ||'] ) " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    -- RED-3023, RED-8028, RED-8276
    IF (1 = v_b_table_and_file_may_differ) OR ('Update TPT' = v_load_lt_routine) THEN
        SET v_line_out = v_line_out || 'SELECT * " >> $CTL_FILE';
    ELSE
        SET v_line_out = v_line_out || 'SELECT  " >> $CTL_FILE';
    END IF;


    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    -- RED-3023, RED-8028, RED-8276
    IF (0 = v_b_table_and_file_may_differ) AND ('Update TPT' <> v_load_lt_routine) THEN
        --=====================================================
        -- Cursor for all columns
        --=====================================================
        SET v_no_more_data1 = 0;
        SET v_col_comma = '   ';

        BEGIN

          DECLARE CONTINUE HANDLER FOR NOT FOUND
            SET v_no_more_data1 = 1;

          OPEN c_Load_Col;

          FETCH FROM c_Load_Col INTO
            v_lc_col_name,
            v_lc_data_type,
            v_lc_transform_code,
            v_lc_transform_type,
            v_lc_src_column,
            v_lc_attributes,
            v_lc_format,
            v_tpt_data_type;

          WHILE v_no_more_data1 = 0 DO

            IF TRIM(v_lc_src_column) || TRIM(v_lc_transform_code) = '' THEN
                SET v_line_out =  '';
            ELSE
                SET v_line_out = v_do_load_indent || '  echo "' || v_col_comma || '\"' || TRIM(v_lc_col_name) || '\" " >> $CTL_FILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;

                SET v_col_comma = '  , ';
            END IF;

            FETCH FROM c_Load_Col INTO
                v_lc_col_name,
                v_lc_data_type,
                v_lc_transform_code,
                v_lc_transform_type,
                v_lc_src_column,
                v_lc_attributes,
                v_lc_format,
                v_tpt_data_type;

          END WHILE; -- End of script line loop

          CLOSE c_Load_Col;

        END;
    END IF;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || 'FROM OPERATOR (FILE_READER() [' ||  CAST(v_load_lt_readinstances AS VARCHAR(4)) ||'] ); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || '); " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  echo "';
    SET v_line_out = v_line_out || ' " >> $CTL_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;


    SET v_line_out = v_do_load_indent || '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # *********** C A L L   T B U I L D   T O   L O A D   D A T A ***********';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  tbuild -f $CTL_FILE -L ${DSS_WORKDIR%?} ';
    if v_load_lt_memorysize <> '' THEN
        SET v_line_out = v_line_out || '-h ' || v_load_lt_memorysize || ' ';
    END IF;

    SET v_line_out = v_line_out || '-u "TDPassword = ''$DSS_PWD''" \';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    if v_load_lt_TBuildOptions <> '' THEN
        SET v_line_out = v_do_load_indent || v_load_lt_TBuildOptions || ' \';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    if v_load_lt_LoadJobName <> '' THEN
        SET v_line_out = v_do_load_indent || ' -j ' ||v_load_lt_LoadJobName;
    ELSE
        SET v_line_out = v_do_load_indent || ' -j wsl-$LOAD_TABLE-$SEQUENCE '; -- RED_4034
    END IF;

    SET v_line_out = v_line_out || '>> $AUD_FILE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  RETCODE=$?';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  # Keep the highest return code for the success message at the end of the file loop';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  if [ "$RETCODE" -lt "$MAX_RETCODE" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  then';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '    RETCODE=$MAX_RETCODE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  else';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '    MAX_RETCODE=$RETCODE';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_do_load_indent || '  fi';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out = '    LOADED_FILE=$ACTFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out = '  fi';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF TRIM(v_load_lt_trig_name_rename) || TRIM(v_load_lt_trig_path_rename) <> '' THEN
        SET v_b_trig_rename = 1;
    END IF;

    IF TRIM(v_load_lt_file_name_rename) || TRIM(v_load_lt_file_path_rename) <> '' THEN
        SET v_b_file_rename = 1;
    END IF;

    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ************************* R E N A M E *********************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # If we had a success or a warning then do a rename';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_b_trig_rename + v_b_file_rename > 0 THEN
        SET v_line_out =  '  if [ "$RETCODE" -eq "0" -o "$RETCODE" -eq "2" ]';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  then';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '  ### if [ "$RETCODE" -eq "0" -o "$RETCODE" -eq "2" ]';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  ### then';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    IF v_b_trig_rename = 1    THEN
        SET v_comment_prefix = '';
    ELSE
        SET v_comment_prefix = '### ';
    END IF;

    IF TRIM(v_load_lt_trig_path_rename) = '' THEN
        SET v_load_lt_trig_path_rename = v_load_lt_trig_path;
    END IF;

    IF TRIM(v_load_lt_trig_path_rename) = '' THEN
        SET v_load_lt_trig_path_rename = v_load_lt_file_path;
    END IF;

    IF   INDEX(v_load_lt_trig_name_rename, '$SEQUENCE$') > 0 THEN
     SET v_load_lt_trig_name_rename = SUBSTR( v_load_lt_trig_name_rename, 1, INDEX(v_load_lt_trig_name_rename, '$SEQUENCE$') - 1) || '_{SEQUENCE}' || SUBSTR(v_load_lt_trig_name_rename, INDEX(v_load_lt_trig_name_rename, '$SEQUENCE$') + 10, 4000);
    END IF;

    IF position('$' IN v_load_lt_trig_name_rename) > 1 THEN
        SET v_work_string = SUBSTR(v_load_lt_trig_name_rename, position('$' IN v_load_lt_trig_name_rename) + 1,position ('$' IN SUBSTR(v_load_lt_trig_name_rename, position('$' IN v_load_lt_trig_name_rename) + 1, 400) ) -1);
        SET v_orig_work_string = SUBSTR(v_load_lt_trig_name_rename, position('$' IN v_load_lt_trig_name_rename) + 1,position ('$' IN SUBSTR(v_load_lt_trig_name_rename, position('$' IN v_load_lt_trig_name_rename) + 1, 400) ) -1);
    ELSE
        SET v_work_string = '';
    END IF;

    IF   INDEX( v_work_string, 'YYYY') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'YYYY') - 1) || '%Y' || SUBSTR( v_work_string, INDEX( v_work_string, 'YYYY') + 4, 4000);
    END IF;

    IF   INDEX( v_work_string, 'YY') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'YY') - 1) || '%y' || SUBSTR( v_work_string, INDEX( v_work_string, 'YY') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'MM') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'MM') - 1) || '%m' || SUBSTR( v_work_string, INDEX( v_work_string, 'MM') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'DD') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'DD') - 1) || '%d' || SUBSTR( v_work_string, INDEX( v_work_string, 'DD') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'HH') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'HH') - 1) || '%H' || SUBSTR( v_work_string, INDEX( v_work_string, 'HH') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'MI') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'MI') - 1) || '%M' || SUBSTR( v_work_string, INDEX( v_work_string, 'MI') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'SS') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'SS') - 1) || '%S' || SUBSTR( v_work_string, INDEX( v_work_string, 'SS') + 2, 4000);
    END IF;

    SET v_line_out =  '    #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    # Rename the trigger';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '    if [ "$TRIG_MOVE_DONE" -eq "0" ] ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '    then';
    INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_work_string <> '' THEN
        SET v_load_lt_trig_name_rename = SUBSTR( v_load_lt_trig_name_rename, 1, INDEX(v_load_lt_trig_name_rename, v_orig_work_string) - 2) ||
                                         '$RETRIG' ||
                                         SUBSTR(v_load_lt_trig_name_rename, INDEX(v_load_lt_trig_name_rename, v_orig_work_string) + CHARACTER_LENGTH(v_orig_work_string) + 1, 4000);

        SET v_line_out =  v_comment_prefix || '      RETRIG=`date +' || v_work_string  || '`;';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    IF   INDEX(v_load_lt_trig_name_rename, '_{SEQUENCE}') > 0 THEN
        SET v_load_lt_trig_name_rename = SUBSTR( v_load_lt_trig_name_rename, 1, INDEX(v_load_lt_trig_name_rename, '_{SEQUENCE}') - 1) ||
                                         '${SEQUENCE}' ||
                                         SUBSTR(v_load_lt_trig_name_rename, INDEX(v_load_lt_trig_name_rename, '_{SEQUENCE}') + 11, 4000);
    END IF;

    IF SUBSTR(v_load_lt_trig_path_rename,CHARACTER_LENGTH(v_load_lt_trig_path_rename), CHARACTER_LENGTH(v_load_lt_trig_path_rename)) <> '/' THEN
        SET v_load_lt_trig_path_rename = v_load_lt_trig_path_rename || '/';
    END IF;

    SET v_line_out =  v_comment_prefix || '      mv  $TRIG_ACTFILE ' || v_load_lt_trig_path_rename || v_load_lt_trig_name_rename;
    SET v_line_out = v_line_out || ' ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '      if [ "$?" -ne "0" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '      then ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '         echo "-3" ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '         echo "$TRIG_ACTFILE could not be renamed to ' || v_load_lt_trig_path_rename || v_load_lt_trig_name_rename || '"';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '      fi ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || '      echo "$TRIG_ACTFILE renamed to ' || v_load_lt_trig_path_rename || v_load_lt_trig_name_rename;
    SET v_line_out = v_line_out || '" >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '      TRIG_MOVE_DONE=1';
    INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out = v_comment_prefix || '    fi';
    INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF   INDEX(v_load_lt_file_name_rename, '$SEQUENCE$') > 0 THEN
     SET v_load_lt_file_name_rename = SUBSTR( v_load_lt_file_name_rename, 1, INDEX(v_load_lt_file_name_rename, '$SEQUENCE$') - 1) || '_{SEQUENCE}' || SUBSTR(v_load_lt_file_name_rename, INDEX(v_load_lt_file_name_rename, '$SEQUENCE$') + 10, 4000);
    END IF;

    IF position('$' IN v_load_lt_file_name_rename) > 0 THEN
        SET v_work_string = SUBSTR(v_load_lt_file_name_rename, position('$' IN v_load_lt_file_name_rename) + 1,position ('$' IN SUBSTR(v_load_lt_file_name_rename, position('$' IN v_load_lt_file_name_rename) + 1, 400) ) -1);
        SET v_orig_work_string = SUBSTR(v_load_lt_file_name_rename, position('$' IN v_load_lt_file_name_rename) + 1,position ('$' IN SUBSTR(v_load_lt_file_name_rename, position('$' IN v_load_lt_file_name_rename) + 1, 400) ) -1);
    ELSE
        SET v_work_string = '';
    END IF;

    IF   INDEX( v_work_string, 'YYYY') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'YYYY') - 1) || '%Y' || SUBSTR( v_work_string, INDEX( v_work_string, 'YYYY') + 4, 4000);
    END IF;

    IF   INDEX( v_work_string, 'YY') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'YY') - 1) || '%y' || SUBSTR( v_work_string, INDEX( v_work_string, 'YY') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'MM') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'MM') - 1) || '%m' || SUBSTR( v_work_string, INDEX( v_work_string, 'MM') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'DD') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'DD') - 1) || '%d' || SUBSTR( v_work_string, INDEX( v_work_string, 'DD') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'HH') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'HH') - 1) || '%H' || SUBSTR( v_work_string, INDEX( v_work_string, 'HH') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'MI') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'MI') - 1) || '%M' || SUBSTR( v_work_string, INDEX( v_work_string, 'MI') + 2, 4000);
    END IF;

    IF   INDEX( v_work_string, 'SS') > 0 THEN
     SET v_work_string = SUBSTR( v_work_string, 1, INDEX( v_work_string, 'SS') - 1) || '%S' || SUBSTR( v_work_string, INDEX( v_work_string, 'SS') + 2, 4000);
    END IF;

    IF v_b_file_rename = 1 THEN
        SET v_comment_prefix = '';
    ELSE
        SET v_comment_prefix = '### ';
    END IF;

    SET v_line_out =  '    #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    # Rename the file';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_work_string <> '' THEN
        SET v_load_lt_file_name_rename = SUBSTR( v_load_lt_file_name_rename, 1, INDEX(v_load_lt_file_name_rename, v_orig_work_string) - 2) ||
                                         '$RETRIG' ||
                                         SUBSTR(v_load_lt_file_name_rename, INDEX(v_load_lt_file_name_rename, v_orig_work_string) + CHARACTER_LENGTH(v_orig_work_string) + 1, 4000);

        SET v_line_out =  v_comment_prefix || '    RETRIG=`date +' || v_work_string || '`;';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    IF   INDEX(v_load_lt_file_name_rename, '_{SEQUENCE}') > 0 THEN
        SET v_load_lt_file_name_rename = SUBSTR( v_load_lt_file_name_rename, 1, INDEX(v_load_lt_file_name_rename, '_{SEQUENCE}') - 1) ||
                                         '${SEQUENCE}' ||
                                         SUBSTR(v_load_lt_file_name_rename, INDEX(v_load_lt_file_name_rename, '_{SEQUENCE}') + 11, 4000);
    END IF;

    IF v_load_lt_file_name_rename <> '' THEN
        IF v_load_lt_file_path_rename = '' THEN
           SET v_load_lt_file_path_rename = v_load_lt_file_path;
        END IF;
    END IF;

    IF SUBSTR(v_load_lt_file_path_rename,CHARACTER_LENGTH(v_load_lt_file_path_rename), 1) <> '/' THEN
        SET v_load_lt_file_path_rename = v_load_lt_file_path_rename || '/';
    END IF;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out = v_comment_prefix || '    if [ "$DO_LOAD" -ne "0" ] ';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out = v_comment_prefix || '    then';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '    mv  $ACTFILE ' || v_load_lt_file_path_rename || v_load_lt_file_name_rename;
    SET v_line_out = v_line_out || ' ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '    if [ "$?" -ne "0" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '    then ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '       echo "-3" ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '       echo "$ACTFILE could not be renamed to ' || v_load_lt_file_path_rename || v_load_lt_file_name_rename || '"';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '    fi ' ;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  v_comment_prefix || v_do_load_indent || '    echo "$ACTFILE renamed to ' || v_load_lt_file_path_rename || v_load_lt_file_name_rename;
    SET v_line_out = v_line_out || '" >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out = v_comment_prefix || '    else';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '      mv  $ACTFILE ' || v_load_lt_file_path_rename || '$(basename $ACTFILE)_' || v_load_lt_file_name_rename;
        SET v_line_out = v_line_out || ' ';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '      if [ "$?" -ne "0" ]';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '      then ' ;
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '         echo "-3" ' ;
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '         echo "$ACTFILE could not be renamed to ' || v_load_lt_file_path_rename || '$(basename $ACTFILE)_' || v_load_lt_file_name_rename || '"';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '      fi ' ;
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || '      echo "$ACTFILE renamed to ' || v_load_lt_file_path_rename || '$(basename $ACTFILE)_' || v_load_lt_file_name_rename;
        SET v_line_out = v_line_out || '" >&2';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out = v_comment_prefix || '    fi';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;


    IF v_load_lt_compress = 1 THEN
        IF v_load_lt_file_newest > 0 THEN
            SET v_line_out = v_comment_prefix || '    if [ "$DO_LOAD" -ne "0" ] ';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_line_out = v_comment_prefix || '    then';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
        END IF;

        SET v_line_out =  v_comment_prefix || v_do_load_indent || '  ';
        SET v_line_out = v_line_out || '  compress ';
        SET v_line_out = v_line_out || v_load_lt_file_path_rename;

        IF TRIM(v_load_lt_file_name_rename) = '' THEN
            SET v_line_out = v_line_out || v_load_lt_file_name;
        ELSE
            SET v_line_out = v_line_out || v_load_lt_file_name_rename;
        END IF;

        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  v_comment_prefix || v_do_load_indent || '    echo "';
        SET v_line_out = v_line_out || v_load_lt_file_path_rename;

        IF TRIM(v_load_lt_file_name_rename) = '' THEN
            SET v_line_out = v_line_out || v_load_lt_file_name;
        ELSE
            SET v_line_out = v_line_out || v_load_lt_file_name_rename;
        END IF;

        SET v_line_out = v_line_out || ' compressed.';
        SET v_line_out = v_line_out || '" >&2';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        IF v_load_lt_file_newest > 0 THEN
            SET v_line_out = v_comment_prefix || '    else';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_line_out =  v_comment_prefix || '    ';
            SET v_line_out = v_line_out || '  compress ';
            SET v_line_out = v_line_out || v_load_lt_file_path_rename;
            SET v_line_out = v_line_out || '$(basename $ACTFILE)_';

            IF TRIM(v_load_lt_file_name_rename) = '' THEN
                SET v_line_out = v_line_out || v_load_lt_file_name;
            ELSE
                SET v_line_out = v_line_out || v_load_lt_file_name_rename;
            END IF;

            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_line_out =  v_comment_prefix || '      echo "';
            SET v_line_out = v_line_out || v_load_lt_file_path_rename;
            SET v_line_out = v_line_out || '$(basename $ACTFILE)_';

            IF TRIM(v_load_lt_file_name_rename) = '' THEN
                SET v_line_out = v_line_out || v_load_lt_file_name;
            ELSE
                SET v_line_out = v_line_out || v_load_lt_file_name_rename;
            END IF;

            SET v_line_out = v_line_out || ' compressed.';
            SET v_line_out = v_line_out || '" >&2';
            INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;

            SET v_line_out = v_comment_prefix || '    fi';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
        END IF;
    END IF;

    IF v_b_trig_rename + v_b_file_rename > 0 THEN
        SET v_line_out =  '  fi';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '  ### fi';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_loop = 1 THEN
        SET v_line_out =  '  # ************************* E N D    F I L E   L O O P  *****************';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '  # ************************* E N D    D A T A   L O A D  *****************';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;


    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_file_loop = 1 THEN
        SET v_line_out =  '  # Uncomment the break statement if you only wish to process one file at';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  # a time in a wildcard file load. The break will cause the script to finish';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  # after the first file that matches the wildcard has been loaded';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  #';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '  # ************************* E N D    D A T A   L O A D  *****************';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;


    IF v_load_lt_file_newest > 0 THEN
        SET v_line_out =  '  DO_LOAD=0';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out = '  ACTFILE=$LOADED_FILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

    ELSEIF SUBSTR(v_load_lt_routine,1,index(v_load_lt_routine,' ')-1) = 'Load' THEN
        SET v_line_out =  '  # WARNING: Load TPT can not handle a multi file load.';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  #          Update TPT must be used if multiple files are to be loaded.';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  # The break statement will cause the script to finish after the';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  # first file that matches the file name has been loaded';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  #';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '  break';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

    ELSEIF  v_load_lt_file_loop = 0 THEN
        SET v_line_out =  '  break';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '  #break';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  'done ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ******************* C H E C K    D E T A I L   L O G ******************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ***********************************************************************';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  # Call tlogview to get the full log';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    --SET v_line_out =  '  cd $TWB_ROOT/logs';
    SET v_line_out =  '  cd ${DSS_WORKDIR%?}';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  LOGLIST=`grep "^Job log: " $AUD_FILE | cut -c10-';

       if v_load_lt_LoadJobName <> '' THEN
        SET v_line_out = v_line_out || ' | grep ' || v_load_lt_LoadJobName;
    ELSE
        SET v_line_out = v_line_out || ' | grep wsl-$LOAD_TABLE-$SEQUENCE ';
    END IF;

    SET v_line_out = v_line_out || '`';

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  for LOGFILE in $LOGLIST';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  do';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_routine = 'Stream TPT' THEN
        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "STREAM_OPERATOR: Rows Inserted:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_INSERTED=`expr $ROW_COUNT + $ROWS_INSERTED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "Checkpoint complete. Rows sent:"| awk ''END{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_SENT=`expr $ROW_COUNT + $ROWS_SENT`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    #';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_APPLIED=$ROWS_INSERTED';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        ELSEIF v_load_lt_routine = 'Update TPT' THEN
        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "              Rows Inserted:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_INSERTED=`expr $ROW_COUNT + $ROWS_INSERTED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "              Rows Updated:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_UPDATED=`expr $ROW_COUNT + $ROWS_UPDATED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "              Rows Deleted:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_DELETED=`expr $ROW_COUNT + $ROWS_DELETED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep "Checkpoint complete. Rows sent:"| awk ''END{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_SENT=`expr $ROW_COUNT + $ROWS_SENT`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    #';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_APPLIED=`expr $ROWS_INSERTED + $ROWS_UPDATED + $ROWS_DELETED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "LOAD_OPERATOR: Total Rows Sent To RDBMS:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_SENT=`expr $ROW_COUNT + $ROWS_SENT`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    ELSE
        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "LOAD_OPERATOR: Total Rows Sent To RDBMS:"| awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_SENT=`expr $ROW_COUNT + $ROWS_SENT`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROW_COUNT=`tlogview -l "$LOGFILE" | grep -i "LOAD_OPERATOR: Total Rows Applied:" | awk ''{ print $NF }''`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    ROWS_APPLIED=`expr $ROW_COUNT + $ROWS_APPLIED`';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;

        SET v_line_out =  '    #';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  '    if [ "$ROWS_SENT" -gt "$ROWS_APPLIED" ]';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    then';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_fail_incomplete = 1 THEN
        SET v_line_out =  '    RETCODE=99';
    ELSE
        SET v_line_out =  '    RETCODE=98';
    END IF;
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    fi';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '    #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    IF v_load_lt_log_detail = 1 THEN
        SET v_line_out =  '    tlogview -l "$LOGFILE" ';
        IF NULLIF(TRIM(v_load_lt_TLogViewOptions),'') IS NOT NULL THEN
            SET v_line_out = v_line_out || v_load_lt_TLogViewOptions;
        END IF;
        SET v_line_out = v_line_out || ' >&2';
        INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
    END IF;

    SET v_line_out =  '  done';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  #';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  rows=`cat $AUD_FILE | grep Rows | grep success`';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  case "$RETCODE" in';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  0) echo "1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "';
    IF v_load_lt_routine = 'Stream TPT' THEN
        SET v_line_out = v_line_out || '$LOAD_TABLE loaded from $ACTFILE. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED."';
    ELSEIF v_load_lt_routine = 'Update TPT' THEN
        SET v_line_out = v_line_out || '$LOAD_TABLE loaded from $ACTFILE. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED. Rows Updated: $ROWS_UPDATED. Rows Deleted: $ROWS_DELETED."';
    ELSE
        SET v_line_out = v_line_out || '$LOAD_TABLE loaded from $ACTFILE. Rows sent: $ROWS_SENT. Rows applied: $ROWS_APPLIED."';
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  1) echo "-1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Completed Normally, with warnings from TPT." ;';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE | grep Total';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  2) echo "-1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Completed Normally, with warnings from TPT." ;';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE | grep Total';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  3) echo "-1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Completed Normally, with warnings from TPT." ;';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE | grep Total';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  4) echo "-1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Completed Normally, with warnings from TPT." ;';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE | grep Total';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  8) echo "-3";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Failed.  A user error occurred in TPT."';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  12) echo "-2";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Failed.  A fatal error occurred in TPT.";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '      ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  16) echo "-3";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "Load Failed.  No message destination available from TPT."';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  98) echo "-1";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "';
    IF v_load_lt_routine = 'Stream TPT' THEN
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED."';
    ELSEIF v_load_lt_routine = 'Update TPT' THEN
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED. Rows Updated: $ROWS_UPDATED. Rows Deleted: $ROWS_DELETED."';
    ELSE
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows applied: $ROWS_APPLIED."';
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  99) echo "-3";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "';
    IF v_load_lt_routine = 'Stream TPT' THEN
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED."';
    ELSEIF v_load_lt_routine = 'Update TPT' THEN
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows Inserted: $ROWS_INSERTED. Rows Updated: $ROWS_UPDATED. Rows Deleted: $ROWS_DELETED."';
    ELSE
        SET v_line_out = v_line_out || 'Load Completed Normally, but not all rows loaded. Rows sent: $ROWS_SENT. Rows applied: $ROWS_APPLIED."';
    END IF;

    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  *) echo "-3";';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     echo "LOAD unknown return code"';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     cat $AUD_FILE >&2';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '     ;; ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  '  esac ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

    SET v_line_out =  'exit ';
    INSERT INTO [METABASE].ws_wrk_task_scr_line ( wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES ( p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
    SET v_script_line_no = v_script_line_no + 1;

       --=====================================================
    -- Write out the task script header
    --=====================================================
    INSERT into [METABASE].ws_wrk_task_scr_hdr
    ( wtsh_task_key
    , wtsh_job_key
    , wtsh_name
    , wtsh_sequence
    , wtsh_host_type
    , wtsh_script_type
    , wtsh_load_type
    , wtsh_work_dir
    , wtsh_connect_key
    , wtsh_load_key
    , wtsh_script_key)
    VALUES
    ( p_task_id
    , p_job_id
    , p_task_name
    , p_sequence
    , v_connect_dc_type
    , v_script_type
    , v_load_type
    , v_work_dir
    , v_connect_key
    , v_load_key
    , v_script_key);


    END IF; -- End of Unix file load


    --=====================================================
    -- Windows file based load. Build a windows script
    --=====================================================
    IF v_connect_dc_type = 'W' THEN


      --  Ws_Act_Host_WinFileLoad
      LEAVE WS_ACT_HOST_SCRIPT;


    END IF;  -- end of windows file


  END IF;  -- end of file based load

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --   E  X  P  O  R  T
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================

  -- File based Export. Build the script below once we work
  -- out if a Unix or Windows connection
  --=====================================================
  IF p_obj_type = v_ws_obj_export AND v_script_type = v_ws_load_file THEN

    -- RED_3683: See if we have some settings in the export_option field
    IF NULLIF(TRIM(v_et_export_options),'') IS NOT NULL THEN
      SET v_epos = INDEX(v_et_export_options,'CHARSET=');
      IF v_epos > 0 THEN
        SET v_spos = CAST(SUBSTR(v_et_export_options,v_epos+8,4) AS INTEGER);
        IF v_spos > 0 THEN
          SET v_load_lt_charset = SUBSTR(v_et_export_options,v_epos+13,v_spos);
        END IF;
      END IF;
    END IF;
    -- RED_3683
    SET v_connect_key = v_et_connect_key;
    SET v_load_key = p_obj_key;
    SET v_script_key = 0;

    --=====================================================
    -- Get the work directory from the connection
    -- IF no Connection we have a problem
    --=====================================================
    IF v_connect_key > 0 THEN

      SELECT dc_work_dir
           , dc_type
           , dc_admin_userid
           , dc_admin_pwd
           , dc_database_id
           , dc_name
           , dc_attributes
      INTO   v_connect_dc_work_dir
           , v_connect_dc_type
           , v_connect_dc_admin_userid
           , v_connect_dc_admin_pwd
           , v_connect_dc_database_id
           , v_connect_dc_name
           , v_connect_dc_attributes
      FROM   [METABASE].ws_dbc_connect
      WHERE  dc_obj_key = v_connect_key;

    ELSE

      IF v_script_type = v_ws_script_execute THEN

        SET p_return_msg = 'No connection defined. Unable to execute script';

      ELSE

        SET p_return_msg = 'No connection defined. Unable to perform export';

      END IF;

      SET p_status_code = -2;
      SET p_result = -2;

      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;

    --=====================================================
    -- Build up the work directory for Unix and Windows
    --=====================================================
    IF v_connect_dc_type = 'U' THEN

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '/' THEN

        SET v_work_dir = v_work_dir || '/';

      END IF;

    ELSE

      SET v_work_dir = v_connect_dc_work_dir;

      IF SUBSTR(v_work_dir,CHAR(v_work_dir),1) <> '\' THEN

        SET v_work_dir = v_work_dir || '\';

      END IF;

    END IF;

    --=====================================================
    -- Unix file based export. Build a Unix script
    --=====================================================
    IF v_connect_dc_type = 'U' THEN

      -- Ws_Act_Host_UnixFileExp
      --LEAVE WS_ACT_HOST_SCRIPT;
      -- RED_3683: support TPT file export in Unix/Linux now
      SET v_script_line_no = 1;
      -- Use the shell configured in the connection, otherwise guess
      -- based on the name of the connection
      SET v_line_out = NULL;
      SET v_pos = INDEX(v_connect_dc_attributes, 'ScriptShell~=');
      IF v_pos >= 1 THEN
        SET v_pos = v_pos + 13;
        SET v_epos = INDEX(SUBSTR(v_connect_dc_attributes, v_pos), ';') + v_pos - 1;
        IF v_epos >= 1 THEN
          SET v_work = SUBSTR(v_connect_dc_attributes, v_pos, v_epos-v_pos);
          SET v_line_out = '#!' || SUBSTR(v_connect_dc_attributes, v_epos + 1, CAST(v_work AS INTEGER));
        END IF;
      END IF;

      IF v_line_out IS NULL THEN
        IF INDEX(UPPER(v_connect_dc_name),'UNIX') > 0 THEN
          SET v_line_out = '#!/bin/ksh';
        ELSE
          SET v_line_out = '#!/bin/sh';
        END IF;
      END IF;
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# ***********************************************************************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# ***** DBMS Name      :    Teradata';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# ***** Description    :    TPT Export Shell Script for ' || v_exp_source_table;
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# ***********************************************************************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'DSS_TDPID=${DSS_TDPID:=' || v_connect_dc_database_id || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'DSS_METABASE=${DSS_METABASE:=[METABASE]}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'DSS_USER=${DSS_USER:=' || v_connect_dc_admin_userid || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'DSS_WORKDIR=${DSS_WORKDIR:=' || v_work_dir || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'DSS_WORKDIR=${DSS_WORKDIR%/}/';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'SEQUENCE=${SEQ:=' || trim(p_sequence) || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'THREAD=${THREAD:=0}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'EXP_NAME=${EXP_NAME:=' || v_et_table_name || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'EXP_DB=${EXP_DB:=' || v_exp_source_schema || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'EXP_TABLE=${EXP_TABLE:=' || v_exp_source_table || '}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'ROWS_EXPORTED=${ROWS_EXPORTED:=0}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# **********    S E T   D E R I V E D   F I L E   N A M E S    **********';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'CTLFILE=$DSS_WORKDIR$DSS_USER$SEQUENCE$THREAD.ctl';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'AUDFILE=$DSS_WORKDIR$DSS_USER$SEQUENCE$THREAD.aud';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'ERRFILE=$DSS_WORKDIR$DSS_USER$SEQUENCE$THREAD.err';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'TRGFILE=$DSS_WORKDIR$DSS_USER$SEQUENCE$THREAD.trg';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      -- date and time variables
      SET v_date1 = '';
      SET v_date2 = '';
      SET v_date3 = '';
      SET v_date4 = '';
      SET v_date5 = '';
      SET v_date6 = '';
      -- export file name
      IF v_et_file_name <> '' THEN
        SET v_work = '';
        SET v_work2 = '';
        SET v_work3 = '';
        SET v_spos = POSITION('$' IN v_et_file_name);
        SET v_epos = CHAR_LENGTH(v_et_file_name);
        SET v_pos = 1;
        WHILE v_spos > 0 AND v_spos < (v_epos - 1) AND v_pos > 0 DO
          SET v_pos = POSITION('$' IN SUBSTR(v_et_file_name, v_spos + 1));
          IF v_spos > 0 AND v_pos > 0 THEN
            SET v_work_string = SUBSTR(v_et_file_name, v_spos + 1, v_pos - 1);
            SET v_work = SUBSTR(v_et_file_name, v_spos + 1, v_pos - 1);
            SET v_work2= SUBSTR(v_et_file_name, 1, v_spos - 1);
            IF v_spos + v_pos + 1 >= v_epos THEN
              SET v_work3 = '';
            ELSE
              SET v_work3 = SUBSTR(v_et_file_name, v_spos + v_pos + 1);
            END IF;
            IF INDEX(v_work_string, 'SEQUENCE') > 0 THEN
              CALL [METABASE].Ws_String_Replace(v_work,'SEQUENCE', '%%{SEQUENCE}',v_new_value);
              SET v_work = v_new_value;
            ELSE
              IF INDEX(v_work_string, 'YYYY') > 0 THEN
                SET v_date1 = 'YYYY=${YYYY:=`date +%Y`}';
                CALL [METABASE].Ws_String_Replace(v_work,'YYYY', '%%{YYYY}',v_new_value);
                SET v_work = v_new_value;
              ELSE
                IF INDEX(v_work_string, 'YY') > 0 THEN
                  SET v_date1 = 'YY=${YY:=`date +%y`}';
                  CALL [METABASE].Ws_String_Replace(v_work,'YY', '%%{YY}',v_new_value);
                  SET v_work = v_new_value;
                END IF;
              END IF;
              IF INDEX(v_work_string, 'MM') > 0 THEN
                SET v_date2 = 'MM=${MM:=`date +%m`}';
                CALL [METABASE].Ws_String_Replace(v_work,'MM', '%%{MM}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'DD') > 0 THEN
                SET v_date3 = 'DD=${DD:=`date +%d`}';
                CALL [METABASE].Ws_String_Replace(v_work, 'DD', '%%{DD}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'HH') > 0 THEN
                SET v_date4 = 'HH=${HH:=`date +%H`}';
                CALL [METABASE].Ws_String_Replace(v_work,'HH', '%%{HH}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'MI') > 0 THEN
                SET v_date5 = 'MI=${MI:=`date +%M`}';
                CALL [METABASE].Ws_String_Replace(v_work,'MI', '%%{MI}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'SS') > 0 THEN
                SET v_date6 = 'SS=${SS:=`date +%S`}';
                CALL [METABASE].Ws_String_Replace(v_work,'SS', '%%{SS}',v_new_value);
                SET v_work = v_new_value;
              END IF;
            END IF;
          END IF;
          SET v_et_file_name = v_work2 || v_work || v_work3;
          SET v_spos = POSITION('$' IN SUBSTR(v_et_file_name, CHAR_LENGTH(v_work2) + CHAR_LENGTH(v_work) + 1));
          IF v_spos > 0 THEN
            SET v_spos = v_spos + CHAR_LENGTH(v_work2) + CHAR_LENGTH(v_work);
          END IF;
          SET v_epos = CHAR_LENGTH(v_et_file_name);
        END WHILE;
        CALL [METABASE].Ws_String_Replace(v_et_file_name,'%%', '$',v_new_value);
        SET v_et_file_name = v_new_value;
      END IF;
      -- export trigger name
      IF v_et_trig_name <> '' THEN
        SET v_work = '';
        SET v_work2 = '';
        SET v_work3 = '';
        SET v_spos = POSITION('$' IN v_et_trig_name);
        SET v_epos = CHAR_LENGTH(v_et_trig_name);
        SET v_pos = 1;
        WHILE v_spos > 0 AND v_spos < (v_epos - 1) AND v_pos > 0 DO
          SET v_pos = POSITION('$' IN SUBSTR(v_et_trig_name, v_spos + 1));
          IF v_spos > 0 AND v_pos > 0 THEN
            SET v_work_string = SUBSTR(v_et_trig_name, v_spos + 1, v_pos - 1);
            SET v_work = SUBSTR(v_et_trig_name, v_spos + 1, v_pos - 1);
            SET v_work2= SUBSTR(v_et_trig_name, 1, v_spos - 1);
            IF v_spos + v_pos + 1 >= v_epos THEN
              SET v_work3 = '';
            ELSE
              SET v_work3 = SUBSTR(v_et_trig_name, v_spos + v_pos + 1);
            END IF;
            IF INDEX(v_work_string, 'SEQUENCE') > 0 THEN
              CALL [METABASE].Ws_String_Replace(v_work,'SEQUENCE', '%%{SEQUENCE}',v_new_value);
              SET v_work = v_new_value;
            ELSE
              IF INDEX(v_work_string, 'YYYY') > 0 THEN
                SET v_date1 = 'YYYY=${YYYY:=`date +%Y`}';
                CALL [METABASE].Ws_String_Replace(v_work,'YYYY', '%%{YYYY}',v_new_value);
                SET v_work = v_new_value;
              ELSE
                IF INDEX(v_work_string, 'YY') > 0 THEN
                  SET v_date1 = 'YY=${YY:=`date +%y`}';
                  CALL [METABASE].Ws_String_Replace(v_work,'YY', '%%{YY}',v_new_value);
                  SET v_work = v_new_value;
                END IF;
              END IF;
              IF INDEX(v_work_string, 'MM') > 0 THEN
                SET v_date2 = 'MM=${MM:=`date +%m`}';
                CALL [METABASE].Ws_String_Replace(v_work,'MM', '%%{MM}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'DD') > 0 THEN
                SET v_date3 = 'DD=${DD:=`date +%d`}';
                CALL [METABASE].Ws_String_Replace(v_work,'DD', '%%{DD}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'HH') > 0 THEN
                SET v_date4 = 'HH=${HH:=`date +%H`}';
                CALL [METABASE].Ws_String_Replace(v_work,'HH', '%%{HH}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'MI') > 0 THEN
                SET v_date5 = 'MI=${MI:=`date +%M`}';
                CALL [METABASE].Ws_String_Replace(v_work,'MI', '%%{MI}',v_new_value);
                SET v_work = v_new_value;
              END IF;
              IF INDEX(v_work_string, 'SS') > 0 THEN
                SET v_date6 = 'SS=${SS:=`date +%S`}';
                CALL [METABASE].Ws_String_Replace(v_work,'SS', '%%{SS}',v_new_value);
                SET v_work = v_new_value;
              END IF;
            END IF;
          END IF;
          SET v_et_trig_name = v_work2 || v_work || v_work3;
          SET v_spos = POSITION('$' IN SUBSTR(v_et_trig_name, CHAR_LENGTH(v_work2) + CHAR_LENGTH(v_work) + 1));
          IF v_spos > 0 THEN
            SET v_spos = v_spos + CHAR_LENGTH(v_work2) + CHAR_LENGTH(v_work);
          END IF;
          SET v_epos = CHAR_LENGTH(v_et_trig_name);
        END WHILE;
        CALL [METABASE].Ws_String_Replace(v_et_trig_name, '%%', '$',v_new_value);
        SET v_et_trig_name = v_new_value;
      END IF;
      IF v_date1 || v_date2 || v_date3 || v_date4 || v_date5 || v_date6 <> '' THEN
        SET v_line_out = '# **********   S E T   D A T E   T I M E   V A R I A B L E S   **********';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF v_date1 <> '' THEN
          SET v_line_out = v_date1;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_date2 <> '' THEN
          SET v_line_out = v_date2;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_date3 <> '' THEN
          SET v_line_out = v_date3;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_date4 <> '' THEN
          SET v_line_out = v_date4;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_date5 <> '' THEN
          SET v_line_out = v_date5;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_date6 <> '' THEN
          SET v_line_out = v_date6;
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
      END IF;
      SET v_line_out = '# *************    D E F I N E    J O B    C O N T R O L    *************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "USING CHARACTER SET ' || v_load_lt_charset || '" > $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "DEFINE JOB ${EXP_TABLE}_EXPORT" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "DESCRIPTION ''EXPORT ${EXP_TABLE} TABLE''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "(" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# *************    D E F I N E               S C H E M A    *************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_export_format = 'Delimited' AND (v_et_header_row_ind = 'B' OR v_et_header_row_ind = 'C') THEN
        SET v_line_out = 'echo "DEFINE SCHEMA ${EXP_TABLE}_SCHEMA_HDR" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "DESCRIPTION ''HEADER ${EXP_TABLE} SCHEMA''" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "(" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        --=====================================================
        -- Cursor for all columns
        --=====================================================
        SET v_no_more_data1 = 0;
        SET v_col_comma = ' ';
        BEGIN
          DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_no_more_data1 = 1;
          OPEN c_Export_Col;
          FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
          WHILE v_no_more_data1 = 0 DO
            IF v_et_header_row_ind = 'B' THEN
              SET v_line_out = 'echo "' || v_col_comma || '\"' || v_ec_col_name || '\" char(' || CAST(CHAR_LENGTH(v_ec_display_name) AS VARCHAR(3)) || ')" >> $CTLFILE';
            ELSE
              SET v_line_out = 'echo "' || v_col_comma || '\"' || v_ec_col_name || '\" char(' || CAST(CHAR_LENGTH(v_ec_col_name) AS VARCHAR(3)) || ')" >> $CTLFILE';
            END IF;
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
            SET v_col_comma = ',';
            FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
          END WHILE;
          CLOSE c_Export_Col;
        END;
        SET v_line_out = 'echo ");" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "DEFINE SCHEMA ${EXP_TABLE}_SCHEMA" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "DESCRIPTION ''TABLE ${EXP_TABLE} SCHEMA''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "(" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      --=====================================================
      -- Cursor for all columns
      --=====================================================
      SET v_no_more_data1 = 0;
      SET v_col_comma = ' ';
      BEGIN
        DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;
        OPEN c_Export_Col;
        FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
        WHILE v_no_more_data1 = 0 DO
          SET v_work = UPPER(v_ec_data_type);
          IF v_work = 'DATE' THEN
            SET v_work = 'ANSIDATE';
          ELSE
            IF SUBSTR(v_et_export_format, 1, 1) = 'T' THEN
              IF POSITION('VARCHAR' IN v_work) > 0 THEN
                CALL [METABASE].Ws_String_Replace(v_work, 'VARCHAR', 'CHAR',v_new_value);
                SET v_work = v_new_value;
              ELSE
                IF POSITION('TIME' IN v_work) > 0 THEN
                  SET v_work = 'CHAR(34)';
                ELSE
                  IF POSITION('CHAR' IN v_work) = 0 THEN
                    SET v_work = 'CHAR(20)';
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
          SET v_line_out = 'echo "' || v_col_comma || '\"' || v_ec_col_name || '\" ' || v_work || '" >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
          SET v_col_comma = ',';
          FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
        END WHILE;
        CLOSE c_Export_Col;
      END;
      SET v_line_out = 'echo ");" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# *************    D E F I N E    F I L E    W R I T E R    *************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF TRIM(v_et_file_name) = '' THEN
        IF TRIM(v_et_file_path) = '' THEN
          SET v_work_string = '${DSS_WORKDIR}wsl${SEQUENCE}.dat';
        ELSE
          IF SUBSTR(v_et_file_path,CHAR(v_et_file_path),1) <> '/' THEN
            SET v_work_string = v_et_file_path || '/wsl${SEQUENCE}.dat';
          ELSE
            SET v_work_string = v_et_file_path || 'wsl${SEQUENCE}.dat';
          END IF;
        END IF;
      ELSE
        IF TRIM(v_et_file_path) = '' THEN
          SET v_work_string = '${DSS_WORKDIR}' || v_et_file_name;
        ELSE
          IF SUBSTR(v_et_file_path,CHAR(v_et_file_path),1) <> '/' THEN
            SET v_work_string = v_et_file_path || '/' || v_et_file_name;
          ELSE
            SET v_work_string = v_et_file_path || v_et_file_name;
          END IF;
        END IF;
      END IF;
      IF v_et_export_format = 'Delimited' AND (v_et_header_row_ind = 'B' OR v_et_header_row_ind = 'C') THEN
        SET v_line_out = 'echo "DEFINE OPERATOR FILE_WRITER_HDR()" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "DESCRIPTION ''TPT DATA CONNECTOR OPERATOR''" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "TYPE DATACONNECTOR CONSUMER" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "SCHEMA *" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "ATTRIBUTES" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "(" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR PrivateLogName = ''' || v_et_short_name || '_CONNECTOR_HDR''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR OpenMode = ''Write''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR Format = ''' || v_et_export_format || '''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR TextDelimiter = ''' || v_et_file_delimiter || '''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF v_et_enclosed_by <> '' THEN
          SET v_line_out = 'echo "VARCHAR QuotedData = ''Y''," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
          SET v_line_out = 'echo "VARCHAR OpenQuoteMark = ''' || v_et_enclosed_by || '''," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
          SET v_line_out = 'echo "VARCHAR CloseQuoteMark = ''' || v_et_enclosed_by || '''," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        SET v_line_out = 'echo "VARCHAR FileName = ''' || v_work_string || '''" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ");" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "DEFINE OPERATOR FILE_WRITER()" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "DESCRIPTION ''TPT DATA CONNECTOR OPERATOR''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "TYPE DATACONNECTOR CONSUMER" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "SCHEMA *" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "ATTRIBUTES" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "(" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "VARCHAR PrivateLogName = ''' || v_et_short_name || '_CONNECTOR''," >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_export_format = 'Delimited' AND (v_et_header_row_ind = 'B' OR v_et_header_row_ind = 'C') THEN
        SET v_line_out = 'echo "VARCHAR OpenMode = ''WriteAppend''," >> $CTLFILE';
      ELSE
        SET v_line_out = 'echo "VARCHAR OpenMode = ''Write''," >> $CTLFILE';
      END IF;
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "VARCHAR Format = ''' || v_et_export_format || '''," >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "VARCHAR TextDelimiter = ''' || v_et_file_delimiter || '''," >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_enclosed_by <> '' THEN
        SET v_line_out = 'echo "VARCHAR QuotedData = ''Y''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR OpenQuoteMark = ''' || v_et_enclosed_by || '''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR CloseQuoteMark = ''' || v_et_enclosed_by || '''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "VARCHAR FileName = ''' || v_work_string || '''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo ");" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# *************    D E F I N E               E X P O R T    *************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_export_format = 'Delimited' AND (v_et_header_row_ind = 'B' OR v_et_header_row_ind = 'C') THEN
        SET v_line_out = 'echo "DEFINE OPERATOR EXPORT_OPERATOR_HDR()" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "DESCRIPTION ''TPT EXPORT OPERATOR''" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "TYPE EXPORT" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "SCHEMA ${EXP_TABLE}_SCHEMA_HDR" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "ATTRIBUTES" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "(" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "VARCHAR PrivateLogName = ''' || v_et_short_name || '_EXPORT_HDR''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF POSITION('MAXSESSIONS' IN v_et_export_options) = 0 THEN
          SET v_line_out = 'echo "INTEGER MaxSessions = ' || v_load_lt_maxsessions || '," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF POSITION('MINSESSIONS' IN v_et_export_options) = 0 THEN
          SET v_line_out = 'echo "INTEGER MinSessions = ' || v_load_lt_minsessions || '," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF POSITION('TDPID' IN v_et_export_options) = 0 THEN
          SET v_line_out = 'echo "VARCHAR TdpId = ''${DSS_TDPID}''," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF POSITION('USERNAME' IN v_et_export_options) = 0 THEN
          SET v_line_out = 'echo "VARCHAR UserName = ''${DSS_USER}''," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF POSITION('USERPASSWORD' IN v_et_export_options) = 0 THEN
          SET v_line_out = 'echo "VARCHAR UserPassword = @TDPassword," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        SET v_line_out = 'echo "VARCHAR SelectStmt = ''SELECT TOP 1" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        --=====================================================
        -- Cursor for all columns
        --=====================================================
        SET v_no_more_data1 = 0;
        SET v_col_comma = ' ';
        BEGIN
          DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_no_more_data1 = 1;
          OPEN c_Export_Col;
          FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
          WHILE v_no_more_data1 = 0 DO
            IF v_et_header_row_ind = 'B' THEN
              SET v_line_out = 'echo "' || v_col_comma || ' CAST(''''' || v_ec_display_name || ''''' AS char(' || CAST(CHAR_LENGTH(v_ec_display_name) AS VARCHAR(3)) || '))" >> $CTLFILE';
            ELSE
              SET v_line_out = 'echo "' || v_col_comma || ' CAST(''''' || v_ec_col_name || ''''' AS char(' || CAST(CHAR_LENGTH(v_ec_col_name) AS VARCHAR(3)) || '))" >> $CTLFILE';
            END IF;
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
            SET v_col_comma = ',';
            FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
          END WHILE;
          CLOSE c_Export_Col;
        END;
        SET v_line_out = 'echo " FROM ${DSS_METABASE}.ws_export_tab AS ws_export_tab" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo " WHERE UPPER(ws_export_tab.et_table_name) = UPPER(''''${EXP_NAME}'''');" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "''" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ");" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "DEFINE OPERATOR EXPORT_OPERATOR()" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "DESCRIPTION ''TPT EXPORT OPERATOR''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "TYPE EXPORT" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "SCHEMA ${EXP_TABLE}_SCHEMA" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "ATTRIBUTES" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "(" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_export_options <> '' THEN
        SET v_work = v_et_export_options;
        WHILE v_work <> '' DO
          SET v_spos = POSITION('[' IN v_work);
          SET v_epos = POSITION(',' IN v_work);
          WHILE v_spos > 0 AND v_epos > 0 AND (v_spos < v_epos) DO
            SET v_pos = POSITION(']' IN SUBSTR(v_work, v_spos + 1, 4000));
            IF v_pos > 0 THEN
              SET v_spos = v_spos + v_pos;
            ELSE
              SET v_spos = 0;
            END IF;
            IF v_spos > v_epos THEN
              SET v_pos = POSITION(',' IN SUBSTR(v_work, v_spos + 1));
              IF v_pos > 0 THEN
                SET v_epos = v_epos + v_pos;
              ELSE
                SET v_epos = 0;
              END IF;
            END IF;
            IF v_spos > 0 THEN
              SET v_pos = POSITION('[' IN SUBSTR(v_work, v_spos + 1));
              IF v_pos > 0 THEN
                SET v_spos = v_spos + v_pos;
              ELSE
                SET v_spos = 0;
              END IF;
            END IF;
          END WHILE;
          IF v_epos > 0 THEN
            SET v_work2 = SUBSTR(v_work, 1, v_epos - 1);
            SET v_work = SUBSTR(v_work, v_epos + 1, 4000);
          ELSE
            SET v_work2 = v_work;
            SET v_work = '';
          END IF;
          SET v_line_out = 'echo "' || TRIM(v_work2) || '," >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END WHILE;
      END IF;
      IF POSITION('PRIVATELOGNAME' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "VARCHAR PrivateLogName = ''' || v_et_short_name || '_EXPORT''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF POSITION('MAXSESSIONS' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "INTEGER MaxSessions = ' || v_load_lt_maxsessions || '," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF POSITION('MINSESSIONS' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "INTEGER MinSessions = ' || v_load_lt_minsessions || '," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF POSITION('TDPID' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "VARCHAR TdpId = ''${DSS_TDPID}''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF POSITION('USERNAME' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "VARCHAR UserName = ''${DSS_USER}''," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF POSITION('USERPASSWORD' IN v_et_export_options) = 0 THEN
        SET v_line_out = 'echo "VARCHAR UserPassword = @TDPassword," >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "VARCHAR SelectStmt = ''SELECT" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      --=====================================================
      -- Cursor for all columns
      --=====================================================
      SET v_no_more_data1 = 0;
      SET v_col_comma = '  ';
      BEGIN
        DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;
        OPEN c_Export_Col;
        FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
        WHILE v_no_more_data1 = 0 DO
          IF SUBSTR(v_et_export_format, 1, 1) = 'T' THEN
            IF v_ec_transform_code = '' THEN
              SET v_work = UPPER(v_ec_data_type);
              IF POSITION('VARCHAR' IN v_work) > 0 THEN
                CALL [METABASE].Ws_String_Replace(v_work,'VARCHAR','CHAR',v_new_value);
                SET v_work = 'CAST(' || v_ec_src_column || ' AS ' || v_new_value || ')';
              ELSE
                IF POSITION('TIME' IN v_work) > 0 THEN
                  SET v_work = 'CAST(' || v_ec_src_column ||  ' AS CHAR(34)' || ')';
                ELSE
                  IF POSITION('CHAR' IN v_work) = 0 AND POSITION('DATE' IN v_work) = 0 THEN
                    SET v_work = 'CAST(' || v_ec_src_column || ' AS CHAR(20)' || ')';
                  ELSE
                    SET v_work = v_ec_src_column;
                  END IF;
                END IF;
              END IF;
              IF v_work <> '' THEN
                SET v_line_out = 'echo "' || v_col_comma || v_work || '" >> $CTLFILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
              END IF;
            ELSE
              CALL [METABASE].Ws_String_Replace(v_ec_transform_code, '''', '''''',v_work);
              SET v_pos = POSITION('\n' IN v_work);
              WHILE v_pos > 0 DO
                IF SUBSTR(v_work, 1, v_pos - 1) <> '' THEN
                  SET v_line_out = 'echo "' || v_col_comma || SUBSTR(v_work, 1, v_pos - 1) || '" >> $CTLFILE';
                  INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                  SET v_script_line_no = v_script_line_no + 1;
                END IF;
                IF CHAR_LENGTH(v_work) > v_pos THEN
                  SET v_work = SUBSTR(v_work, v_pos + 1, 4000);
                ELSE
                  SET v_work = '';
                END IF;
              END WHILE;
              IF v_work <> '' THEN
                SET v_line_out = 'echo "' || v_col_comma || v_work || '" >> $CTLFILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
              END IF;
            END IF;
          ELSE
            IF v_ec_transform_code = '' THEN
              CALL [METABASE].Ws_String_Replace(v_ec_src_column, '''', '''''',v_work);
            ELSE
              CALL [METABASE].Ws_String_Replace(v_ec_transform_code, '''', '''''',v_work);
            END IF;
            SET v_pos = POSITION('\n' IN v_work);
            WHILE v_pos > 0 DO
              IF SUBSTR(v_work, 1, v_pos - 1) <> '' THEN
                SET v_line_out = 'echo "' || v_col_comma || SUBSTR(v_work, 1, v_pos - 1) || '" >> $CTLFILE';
                INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
                SET v_script_line_no = v_script_line_no + 1;
              END IF;
              IF CHAR_LENGTH(v_work) > v_pos THEN
                SET v_work = SUBSTR(v_work, v_pos + 1, 4000);
              ELSE
                SET v_work = '';
              END IF;
            END WHILE;
            IF v_work <> '' THEN
              SET v_line_out = 'echo "' || v_col_comma || v_work || '" >> $CTLFILE';
              INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
              SET v_script_line_no = v_script_line_no + 1;
            END IF;
          END IF;
          SET v_col_comma = ', ';
          FETCH FROM c_Export_Col INTO v_ec_col_name, v_ec_data_type, v_ec_src_table, v_ec_src_column, v_ec_display_name, v_ec_transform_code;
        END WHILE;
        CLOSE c_Export_Col;
      END;
      SET v_line_out = 'echo " FROM ${EXP_DB}.${EXP_TABLE} AS ${EXP_TABLE}" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF TRIM(v_et_where_clause) <> '' THEN
        CALL [METABASE].Ws_String_Replace(v_et_where_clause, '''', '''''',v_work);
        SET v_pos = POSITION('\n' IN v_work);
        WHILE v_pos > 0 DO
          IF SUBSTR(v_work, 1, v_pos - 1) <> '' THEN
            SET v_line_out = 'echo " ' || SUBSTR(v_work, 1, v_pos - 1) || '" >> $CTLFILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
          END IF;
          IF CHAR_LENGTH(v_work) > v_pos THEN
            SET v_work = SUBSTR(v_work, v_pos + 1, 4000);
          ELSE
            SET v_work = '';
          END IF;
        END WHILE;
        IF v_work <> '' THEN
          SET v_line_out = 'echo " ' || v_work || '" >> $CTLFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
      END IF;
      SET v_line_out = 'echo ";" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "''" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo ");" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# *************    D E F I N E                   S T E P    *************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_export_format = 'Delimited' AND (v_et_header_row_ind = 'B' OR v_et_header_row_ind = 'C') THEN
        SET v_line_out = 'echo "STEP export_header_to_file" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "(" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "APPLY TO OPERATOR (FILE_WRITER_HDR())" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo "SELECT * FROM OPERATOR (EXPORT_OPERATOR_HDR());" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ");" >> $CTLFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = 'echo "STEP export_data_to_file" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "(" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "APPLY TO OPERATOR (FILE_WRITER())" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "SELECT * FROM OPERATOR (EXPORT_OPERATOR());" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo ");" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo ");" >> $CTLFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# ********  C A L L   T B U I L D   T O   E X P O R T   D A T A  ********';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'tbuild -f $CTLFILE -L ${DSS_WORKDIR%?} -u "TDPassword = ''$DSS_PWD''" -j wsl-$EXP_TABLE-$SEQUENCE > $AUDFILE 2> $ERRFILE';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'RETCODE=$?';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# *******   C H E C K    T P T    E X P O R T    J O B    L O G   *******';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '# Call tlogview to get the full log';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cd ${DSS_WORKDIR%?}';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'LOGLIST=`ls -t wsl-$EXP_TABLE-$SEQUENCE*.out | head -1`';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'for LOGFILE in $LOGLIST';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'do';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'ROWS_EXPORTED=`tlogview -l "$LOGFILE" | grep "Total Rows Exported:" | tail -1 | awk ''{ print $NF }''`';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'done';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'rows=`cat $AUDFILE | grep Rows | grep success`';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'case "$RETCODE" in';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '0) echo "1";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "$EXP_TABLE export completed. Rows exported: $ROWS_EXPORTED."';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '1) echo "-1";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Completed Normally, with warnings from TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE | grep Total';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '2) echo "-1";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Completed Normally, with warnings from TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE | grep Total';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '3) echo "-1";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Completed Normally, with warnings from TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE | grep Total';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '4) echo "-1";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Completed Normally, with warnings from TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE | grep Total';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '8) echo "-3";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Failed.  A user error occurred in TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '12) echo "-2";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Failed.  A fatal error occurred in TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '16) echo "-3";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export Failed.  No message destination available from TPT.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = '*) echo "-3";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo "Export unknown return code.";';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'cat $AUDFILE >&2';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = ';;';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'esac';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      IF v_et_compress_ind ='Y' AND v_et_compress_param <> '' THEN
        SET v_line_out = '# ***** C O M P R E S S   O U T P U T   F I L E  ***********';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF SUBSTR(v_et_compress_path,CHAR(v_et_compress_path),1) <> '/' THEN
          SET v_line_out = '"' || v_et_compress_path || '/' || v_et_compress_name || '"' || v_et_compress_param;
        ELSE
          SET v_line_out = '"' || v_et_compress_path || v_et_compress_name || '"' || v_et_compress_param;
        END IF;
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      IF TRIM(v_et_trig_name) = '' THEN
        IF TRIM(v_et_trig_path) = '' THEN
          SET v_work_string = '';
        ELSE
          IF SUBSTR(v_et_trig_path,CHAR(v_et_trig_path),1) <> '/' THEN
            SET v_work_string = v_et_trig_path || '/wsl${SEQUENCE}.dat';
          ELSE
            SET v_work_string = v_et_trig_path || 'wsl${SEQUENCE}.dat';
          END IF;
        END IF;
      ELSE
        IF TRIM(v_et_trig_path) = '' THEN
          SET v_work_string = '${DSS_WORKDIR}' || v_et_trig_name;
        ELSE
          IF SUBSTR(v_et_trig_path,CHAR(v_et_trig_path),1) <> '/' THEN
            SET v_work_string = v_et_trig_path || '/' || v_et_trig_name;
          ELSE
            SET v_work_string = v_et_trig_path || v_et_trig_name;
          END IF;
        END IF;
      END IF;
      IF v_work_string <> '' AND v_et_trig_param_1 <> '' THEN
        SET v_line_out = '# ***** B U I L D   B T E Q   T R I G G E R   C T L  *******';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".export report file=' || v_work_string || '" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".set quiet on" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".set format off" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".set heading '' ''" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF SUBSTR(v_et_trig_param_1,1,1) = 'R' THEN
          SET v_work = 'TRIM(CAST(COUNT(*) AS VARCHAR(100)))';
        ELSE
          IF v_et_trig_param_1 <> '' THEN
            SET v_work = 'TRIM(CAST(' || v_et_trig_param_1 || ' AS VARCHAR(100)))';
          ELSE
            SET v_work = 'NULL';
          END IF;
        END IF;
        IF SUBSTR(v_et_trig_param_2,1,1) = 'R' THEN
          SET v_work2 = 'TRIM(CAST(COUNT(*) AS VARCHAR(100)))';
        ELSE
          IF v_et_trig_param_2 <> '' THEN
            SET v_work2 = 'TRIM(CAST(' || v_et_trig_param_2 || ' AS VARCHAR(100)))';
          ELSE
            SET v_work2 = '';
          END IF;
        END IF;
        IF SUBSTR(v_et_trig_param_3,1,1) = 'R' THEN
          SET v_work3 = 'TRIM(CAST(COUNT(*) AS VARCHAR(100)))';
        ELSE
          IF v_et_trig_param_3 <> '' THEN
            SET v_work3 = 'TRIM(CAST(' || v_et_trig_param_3 || ' AS VARCHAR(100)))';
          ELSE
            SET v_work3 = '';
          END IF;
        END IF;
        IF v_work3 <> '' THEN
          SET v_work3 = v_work3 || ' (TITLE '''')';
        ELSE
          IF v_work2 <> '' THEN
            SET v_work2 = v_work2 || ' (TITLE '''')';
          ELSE
            SET v_work = v_work || ' (TITLE '''')';
          END IF;
        END IF;
        SET v_line_out = 'echo "SELECT ' || v_work || '" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF v_et_trig_delimiter = '' THEN
          SET v_work = '||'' ''||';
        ELSE
          IF v_et_trig_delimiter = '|' THEN
            SET v_work = '||''|''||';
          ELSE
            SET v_work = '||''' || v_et_trig_delimiter || '''||';
          END IF;
        END IF;
        IF v_work2 <> '' THEN
          SET v_line_out = 'echo "' || v_work || v_work2 || '" >> $TRGFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        IF v_work3 <> '' THEN
          SET v_line_out = 'echo "' || v_work || v_work3 || '" >> $TRGFILE';
          INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
          SET v_script_line_no = v_script_line_no + 1;
        END IF;
        SET v_line_out = 'echo " FROM ${EXP_DB}.${EXP_TABLE} AS ${EXP_TABLE}" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        IF TRIM(v_et_where_clause) <> '' THEN
          SET v_work = v_et_where_clause;
          SET v_pos = POSITION('\n' IN v_work);
          WHILE v_pos > 0 DO
            IF SUBSTR(v_work, 1, v_pos - 1) <> '' THEN
              SET v_line_out = 'echo " ' || SUBSTR(v_work, 1, v_pos - 1) || '" >> $TRGFILE';
              INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
              SET v_script_line_no = v_script_line_no + 1;
            END IF;
            IF CHAR_LENGTH(v_work) > v_pos THEN
              SET v_work = SUBSTR(v_work, v_pos + 1, 4000);
            ELSE
              SET v_work = '';
            END IF;
          END WHILE;
          IF v_work <> '' THEN
            SET v_line_out = 'echo " ' || v_work || '" >> $TRGFILE';
            INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
            SET v_script_line_no = v_script_line_no + 1;
          END IF;
        END IF;
        SET v_line_out = 'echo ";" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".set format off" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".export reset" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".logoff" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = 'echo ".exit" >> $TRGFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = '# ******* B U I L D   T R I G G E R   F I L E  *************';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
        SET v_line_out = '(echo ".logon $DSS_TDPID/$DSS_USER,$DSS_PWD;"; cat $TRGFILE) | bteq >> $AUDFILE';
        INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
        SET v_script_line_no = v_script_line_no + 1;
      END IF;
      SET v_line_out = '# ************* E X I T ************************************';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'echo TPT Export of ${EXP_DB}.${EXP_TABLE} Completed';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      SET v_line_out = 'exit';
      INSERT INTO [METABASE].ws_wrk_task_scr_line(wtsl_task_key, wtsl_job_key, wtsl_sequence, wtsl_line_no, wtsl_line) VALUES(p_task_id, p_job_id, p_sequence, v_script_line_no, v_line_out);
      SET v_script_line_no = v_script_line_no + 1;
      --=====================================================
      -- Write out the task script header
      --=====================================================
      INSERT into [METABASE].ws_wrk_task_scr_hdr
      ( wtsh_task_key
      , wtsh_job_key
      , wtsh_name
      , wtsh_sequence
      , wtsh_host_type
      , wtsh_script_type
      , wtsh_load_type
      , wtsh_work_dir
      , wtsh_connect_key
      , wtsh_load_key
      , wtsh_script_key)
      VALUES
      ( p_task_id
      , p_job_id
      , p_task_name
      , p_sequence
      , v_connect_dc_type
      , v_script_type
      , v_load_type
      , v_work_dir
      , v_connect_key
      , v_load_key
      , v_script_key);
      -- RED_3683
    END IF; -- End of Unix file export

    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    -- Windows file based export. Build a windows script
    --=====================================================
    --=====================================================
    --=====================================================
    --=====================================================
    IF v_connect_dc_type = 'W' THEN

      -- Ws_Act_Host_WinFileExp
      LEAVE WS_ACT_HOST_SCRIPT;

    END IF;  -- end of windows file export

  END IF; -- end of file based export

  SET p_status_code = 1;
  SET p_return_msg = 'Script prepared';
  SET p_result = 1;

END;
_PROCEDWSL_ Ws_Act_Initial_Build 
    CREATE PROCEDURE [METABASE].Ws_Act_Initial_Build
    ( IN  p_sequence        integer
    , IN  p_obj_type        integer
    , IN  p_action          integer
    , IN  p_obj_key         integer
    , IN  p_job_name        varchar(64)
    , IN  p_task_name       varchar(64)
    , IN  p_job_id          integer
    , IN  p_task_id         integer
    , OUT p_return_msg      varchar(1024)
    , OUT p_status_code     integer
    , OUT p_result          integer
    , OUT p_stmt            varchar(4000)
    )
    WS_ACT_INITIAL_BUILD:
    BEGIN

      -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

      -- =============================================================================
      -- DBMS Name        Teradata
      -- Script Name      ws_act_initial_build
      -- Description      Execute the build procedure associated with
      --                      a table
      -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
      -- =============================================================================
      -- WMR 24/09/2001                  Added support for aggregates
      -- WMR 22/01/2002 Version 1.0.0
      -- WMR 25/10/2002 Version 1.2.1    Sql Server version
      -- WMR 10/05/2004                  Changed to custom procedure
      -- WMR 26/03/2006                  Added support for retro copy v5.6.0.0
      -- WMR 13/09/2007 Version 5.6.0    DB2 version
      -- AP  09/04/2008 Version 6.0.0.0  Added support for ODS/Normal
      -- JML 01/09/2008 Version 6.0.2.0  Teradata Linux Scheduler Changes
      -- RS  14/02/2013 Version 6.7.0.1  Changed Default Declaration to Variable Assignment
      -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
      -- RS  10/06/2016 Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
      -- HM  16/01/2018 Version 8.1.1.0  Adding support for Source Mapping
      -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

      --=====================================================
      -- Constants Declared
      --=====================================================
      DECLARE v_ws_pro_version           VARCHAR(15);
      DECLARE v_ws_obj_procedure         INTEGER;
      DECLARE v_ws_obj_fact_kpi          INTEGER;
      DECLARE v_ws_obj_script            INTEGER;
      DECLARE v_ws_obj_template          INTEGER;
      DECLARE v_ws_obj_fact              INTEGER;
      DECLARE v_ws_obj_dim               INTEGER;
      DECLARE v_ws_obj_stage             INTEGER;
      DECLARE v_ws_obj_load              INTEGER;
      DECLARE v_ws_obj_agg               INTEGER;
      DECLARE v_ws_obj_index             INTEGER;
      DECLARE v_ws_obj_connect           INTEGER;
      DECLARE v_ws_obj_dim_view          INTEGER;
      DECLARE v_ws_obj_export            INTEGER;
      DECLARE v_ws_obj_cube              INTEGER;
      DECLARE v_ws_obj_cube_virtual      INTEGER;
      DECLARE v_ws_obj_report            INTEGER;
      DECLARE v_ws_obj_view              INTEGER;
      DECLARE v_ws_obj_join              INTEGER;
      DECLARE v_ws_obj_retro             INTEGER;
      DECLARE v_ws_obj_retro_copy        INTEGER;
      DECLARE v_ws_obj_olap_cube         INTEGER;
      DECLARE v_ws_obj_olap_dim          INTEGER;
      DECLARE v_ws_obj_olap_role         INTEGER;
      DECLARE v_ws_obj_ods               INTEGER;
      DECLARE v_ws_obj_normal            INTEGER;
      DECLARE v_ws_obj_hub               INTEGER;
      DECLARE v_ws_obj_satellite         INTEGER;
      DECLARE v_ws_obj_link              INTEGER;
      DECLARE v_ws_obj_custom1           INTEGER;
      DECLARE v_ws_obj_custom2           INTEGER;

      DECLARE v_ws_obj_source_mapping    INTEGER;

      DECLARE v_ws_act_drop              INTEGER;
      DECLARE v_ws_act_create            INTEGER;
      DECLARE v_ws_act_drop_all          INTEGER;
      DECLARE v_ws_act_pre_drop          INTEGER;
      DECLARE v_ws_act_load              INTEGER;
      DECLARE v_ws_act_update            INTEGER;
      DECLARE v_ws_act_execute           INTEGER;
      DECLARE v_ws_act_process           INTEGER;
      DECLARE v_ws_act_build             INTEGER;
      DECLARE v_ws_act_build_all         INTEGER;
      DECLARE v_ws_act_analyze           INTEGER;
      DECLARE v_ws_act_quick_analyze     INTEGER;
      DECLARE v_ws_act_statistics        INTEGER;
      DECLARE v_ws_act_quick_statistics  INTEGER;
      DECLARE v_ws_act_initial           INTEGER;
      DECLARE v_ws_act_cube_dim          INTEGER;
      DECLARE v_ws_act_db_dim            INTEGER;
      DECLARE v_ws_act_custom            INTEGER;
      DECLARE v_ws_act_truncate          INTEGER;
      DECLARE v_ws_act_compile           INTEGER;

      --=====================================================
      -- Variables
      --=====================================================
      DECLARE v_sql_code                 INTEGER;        -- SQL Error Code for Audit Trail
      DECLARE v_sql_error                VARCHAR(1024);  -- SQL Error Code for Audit Trail as varchar
      DECLARE v_step                     INTEGER;        -- step
      DECLARE v_no_more_data1            INTEGER;
      DECLARE v_no_more_data2            INTEGER;
      DECLARE v_msgtext                  VARCHAR(1024);  -- Text in audit_trail
      DECLARE v_stmt                     VARCHAR(4000);
      DECLARE v_procedure_key            INTEGER;
      DECLARE v_procedure                VARCHAR(64);
      DECLARE v_info_return_code         VARCHAR(1);
      DECLARE v_info_return_msg          VARCHAR(256);
      DECLARE v_info_result              INTEGER;
      DECLARE v_info_value               VARCHAR(32000);

      --=====================================================
      -- Default Exception Handler
      --=====================================================
      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = 'Unhandled exception in Ws_Act_Initial_Build '||
          v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
        SET p_return_msg = v_msgtext;
        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
        SET p_status_code = -2;
        SET p_result = -2;
        END;

      --=====================================================
      -- Set Values for Constants
      --=====================================================
      SET v_ws_pro_version           = '8.4.1.0';
      SET v_ws_obj_procedure         = 1;
      SET v_ws_obj_fact_kpi          = 2;
      SET v_ws_obj_script            = 3;
      SET v_ws_obj_template          = 4;
      SET v_ws_obj_fact              = 5;
      SET v_ws_obj_dim               = 6;
      SET v_ws_obj_stage             = 7;
      SET v_ws_obj_load              = 8;
      SET v_ws_obj_agg               = 9;
      SET v_ws_obj_index             = 10;
      SET v_ws_obj_connect           = 11;
      SET v_ws_obj_dim_view          = 12;
      SET v_ws_obj_export            = 13;
      SET v_ws_obj_cube              = 15;
      SET v_ws_obj_cube_virtual      = 16;
      SET v_ws_obj_report            = 17;
      SET v_ws_obj_view              = 18;
      SET v_ws_obj_join              = 20;
      SET v_ws_obj_retro             = 21;
      SET v_ws_obj_retro_copy        = 22;
      SET v_ws_obj_olap_cube         = 23;
      SET v_ws_obj_olap_dim          = 24;
      SET v_ws_obj_olap_role         = 25;
      SET v_ws_obj_ods               = 26;
      SET v_ws_obj_normal            = 27;
      SET v_ws_obj_hub               = 28;
      SET v_ws_obj_satellite         = 29;
      SET v_ws_obj_link              = 30;
      SET v_ws_obj_custom1           = 31;
      SET v_ws_obj_custom2           = 32;

      SET v_ws_obj_source_mapping    = 69;

      SET v_ws_act_drop              = 1;
      SET v_ws_act_create            = 2;
      SET v_ws_act_drop_all          = 3;
      SET v_ws_act_pre_drop          = 4;
      SET v_ws_act_load              = 5;
      SET v_ws_act_update            = 6;
      SET v_ws_act_execute           = 7;
      SET v_ws_act_process           = 8;
      SET v_ws_act_build             = 9;
      SET v_ws_act_build_all         = 10;
      SET v_ws_act_analyze           = 11;
      SET v_ws_act_quick_analyze     = 12;
      SET v_ws_act_statistics        = 13;
      SET v_ws_act_quick_statistics  = 14;
      SET v_ws_act_initial           = 15;
      SET v_ws_act_cube_dim          = 16;
      SET v_ws_act_db_dim            = 17;
      SET v_ws_act_custom            = 18;
      SET v_ws_act_truncate          = 19;
      SET v_ws_act_compile           = 20;
      SET v_no_more_data1            = 0;
      SET v_no_more_data2            = 0;

      --=====================================================
      -- MAIN
      --=====================================================
      -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
      SET v_step = 1;

      --=====================================================
      -- Check that we have a valid table type
      --=====================================================
      IF  p_obj_type <> v_ws_obj_dim
      AND p_obj_type <> v_ws_obj_dim_view
      AND p_obj_type <> v_ws_obj_fact
      AND p_obj_type <> v_ws_obj_fact
      AND p_obj_type <> v_ws_obj_fact_kpi
      AND p_obj_type <> v_ws_obj_stage
      AND p_obj_type <> v_ws_obj_agg
      AND p_obj_type <> v_ws_obj_retro_copy
      AND p_obj_type <> v_ws_obj_ods
      AND p_obj_type <> v_ws_obj_normal
      AND p_obj_type <> v_ws_obj_hub
      AND p_obj_type <> v_ws_obj_satellite
      AND p_obj_type <> v_ws_obj_link
      AND p_obj_type <> v_ws_obj_custom1
      AND p_obj_type <> v_ws_obj_custom2
      AND p_obj_type <> v_ws_obj_source_mapping
      THEN

        SET v_msgtext = 'Initial Build (Custom) is not a valid action for table ' || p_task_name ||
                        '. Table type was ' || TRIM(CAST((COALESCE(p_obj_type,-1)) AS VARCHAR(18)));

        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                                 , v_msgtext,NULL,NULL, p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_status_code = -2;
        SET p_result = -2;

        LEAVE WS_ACT_INITIAL_BUILD;

      END IF;

      --=====================================================
      -- See what table we have and get the build procedure
      --=====================================================
      SET v_step = 10;
      SET p_result = 1;
      SET v_procedure_key = 0;

      IF p_obj_type = v_ws_obj_source_mapping THEN

        -- Source Mappings are not first class objects so can't use Ws_Object_Info
        SELECT smt_build_key
        INTO   :v_procedure_key
        FROM   [METABASE].ws_source_mapping_tab
        WHERE  smt_source_mapping_key = :p_obj_key
        ;

      ELSE

          CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                       , p_obj_key, NULL
                                       , 'BUILD_KEY'
                                       , v_info_return_code, v_info_return_msg
                                       , v_info_result, v_info_value );

          SET v_procedure_key = CAST(v_info_value AS INTEGER);

      END IF;

      IF v_procedure_key = 0 OR v_procedure_key IS NULL THEN

        SET v_msgtext = 'No custom (build) procedure defined for ' || p_task_name;

        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                                 , v_msgtext,NULL,NULL, p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_status_code = -2;
        SET p_result = -2;

        LEAVE WS_ACT_INITIAL_BUILD;

      END IF;

      --=====================================================
      -- Get the procedure name
      --=====================================================
      SET v_step = 40;
      SET v_procedure = NULL;

      SELECT ph_name
      INTO   v_procedure
      FROM   [METABASE].ws_pro_header
      WHERE  ph_obj_key = v_procedure_key;

      IF NULLIF(TRIM(v_procedure),'') IS NULL THEN

        SET v_msgtext = 'Unable to acquire custom (build) procedure name for ' || p_task_name;

        CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
                                 , v_msgtext, NULL, NULL, p_task_id, p_job_id);

        SET p_return_msg = v_msgtext;
        SET p_status_code = -3;
        SET p_result = -3;

        LEAVE WS_ACT_INITIAL_BUILD;

      END IF;

      --=====================================================
      -- Execute the procedure
      --=====================================================
      SET v_stmt = 'CALL [METABASE].' || v_procedure || '(' || TRIM(CAST(p_sequence AS VARCHAR(18)));
      SET v_stmt = v_stmt || ',''' || p_job_name ||''',''' || p_task_name || ''',' || TRIM(CAST(p_job_id AS VARCHAR(18)));
      SET v_stmt = v_stmt || ',' || TRIM(CAST(p_task_id AS VARCHAR(18))) || ',?,?);';

      SET v_step = 92;

      SET p_return_msg = 'Statement prepared';
      SET p_result = 1;
      SET p_status_code = 1;
      SET p_stmt = v_stmt;

    END;
_PROCEDWSL_ Ws_Act_Truncate 
CREATE PROCEDURE [METABASE].Ws_Act_Truncate
( IN  p_sequence        INTEGER
, IN  p_obj_type        INTEGER
, IN  p_action          INTEGER
, IN  p_obj_key         INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, OUT p_return_msg      VARCHAR(1024)
, OUT p_status_code     INTEGER
, OUT p_result          INTEGER
)
WS_ACT_TRUNCATE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    		Teradata
  -- Script Name 			ws_act_truncate
  -- Description 			Truncate a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 01/03/2005 Version 4.1.1.3
  -- WMR 13/09/2007 Version 5.6.0.0  DB2 version
  -- AP  09/04/2008 Version 6.0.0.0  Added support for ODS/Normal
  --     20/05/2008                  Altered method of truncate to load from nul
  -- JML 01/09/2008 Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013 Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016 Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;


  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_truncate                 VARCHAR(4000);
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(256);
  DECLARE v_info_result              INTEGER;
  DECLARE v_cpos                     INTEGER;
  DECLARE v_tab_meta                 VARCHAR(32000);
  DECLARE v_meta_loop                INTEGER;

  --=====================================================
  -- Variables for Tables and cursors
  --=====================================================
  DECLARE v_table_name               VARCHAR(64);
  DECLARE v_tablespace               VARCHAR(64);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Truncate Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_meta_loop                = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  SET v_step = 100;
  SET v_table_name = NULL;

  --=====================================================
  -- Handle all the table types
  --=====================================================
  IF p_obj_type = v_ws_obj_load
  OR p_obj_type = v_ws_obj_dim
  OR p_obj_type = v_ws_obj_fact
  OR p_obj_type = v_ws_obj_fact_kpi
  OR p_obj_type = v_ws_obj_stage
  OR p_obj_type = v_ws_obj_agg
  OR p_obj_type = v_ws_obj_view
  OR p_obj_type = v_ws_obj_retro_copy
  OR p_obj_type = v_ws_obj_normal
  OR p_obj_type = v_ws_obj_hub
  OR p_obj_type = v_ws_obj_satellite
  OR p_obj_type = v_ws_obj_link
  OR p_obj_type = v_ws_obj_custom1
  OR p_obj_type = v_ws_obj_custom2
  OR p_obj_type = v_ws_obj_ods THEN

    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , p_obj_key, NULL
                                 , 'all'
                                 , v_info_return_code, v_info_return_msg
                                 , v_info_result, v_tab_meta);

    WHILE ( v_meta_loop < 9 ) DO

      SET v_meta_loop = v_meta_loop + 1;
      SET v_cpos = INDEX(v_tab_meta,X'08');

      IF v_meta_loop = 1 THEN

        SET v_tablespace = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 8 THEN

        SET v_table_name = SUBSTR(v_tab_meta,1,v_cpos-1);

      END IF;

      SET v_tab_meta = SUBSTR(v_tab_meta,v_cpos+1);

    END WHILE;

  ELSE

    --=====================================================
    -- Unsupported object type
    --=====================================================
    SET v_msgtext = 'Unsupported object type ' || TRIM(CAST((COALESCE(p_obj_type,-1)) AS VARCHAR(18))) ||
      ' in Ws_Act_Truncate';
    SET p_status_code = -2;
    SET p_return_msg = v_msgtext;
    SET p_result = -2;

    LEAVE WS_ACT_TRUNCATE;

  END IF;

  --=====================================================
  -- Table name is null
  --=====================================================
  IF NULLIF(TRIM(v_table_name),'') IS NULL THEN

    SET v_msgtext = 'Unable to locate the metadata for object key ' || TRIM(CAST((COALESCE(p_obj_key,-1)) AS VARCHAR(18))) ||
      ', object type ' || TRIM(CAST((COALESCE(p_obj_type,-1)) AS VARCHAR(18))) || ' in Ws_Act_Truncate';
    SET p_status_code = -2;
    SET p_return_msg = v_msgtext;
    SET p_result = -2;

    LEAVE WS_ACT_TRUNCATE;

  END IF;

  SET v_step = 200;

  --=====================================================
  -- Build the truncate string
  --=====================================================
  SET v_truncate = 'DELETE FROM ';

  IF NULLIF(TRIM(v_tablespace),'') IS NOT NULL THEN

    SET v_truncate = v_truncate || v_tablespace || '.';
    SET v_msgtext = 'Table truncated ' || v_tablespace || '.' || v_table_name;

  ELSE

    SET v_msgtext = 'Table truncated ' || v_table_name;

  END IF;

  SET v_truncate = v_truncate || v_table_name;

  SET v_step = 300;

  --=====================================================
  -- Execute the truncate statement
  --=====================================================
  CALL DBC.SYSEXECSQL ( v_truncate );

  SET v_step = 400;

  SET p_status_code = 1;
  SET p_return_msg = v_msgtext;
  SET p_result = 1;

END;
_PROCEDWSL_ Ws_Maintain_Table 
CREATE PROCEDURE [METABASE].Ws_Maintain_Table (
  IN  p_sequence        INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, IN  p_table_name      VARCHAR(64)
, IN  p_option          VARCHAR(20)
, IN  p_parameter       VARCHAR(4000)
, OUT p_result          INTEGER
)
WS_MAINTAIN_TABLE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name            Teradata
  -- Script Name          Ws_Maintain_Table
  -- Description          Perform Actions on a Table
  -- Author               Aaron Parvin
  -- Date                 20th May 2008
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_table             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_exists                   INTEGER;
  DECLARE v_status_code              INTEGER;
  DECLARE v_status                   INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Load Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_table             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_obj_type                 = -1;
  SET v_obj_key                  = -1;
  SET v_exists                   = 1;
  SET v_status_code              = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET p_result = 1;

  SET v_step = 200;

  --=====================================================
  -- See if an table name has been specified
  -- and if so look up the object key for that table
  -- If we can't find it then we have an error
  --=====================================================

  IF NULLIF(TRIM(p_table_name),'') IS NOT NULL THEN

    SET v_step = 300;

    BEGIN

      DECLARE CONTINUE HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = 'Failure getting table '|| p_table_name ||' in call to Ws_Maintain_Table';
          CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
          SET p_result = -3;
          SET v_exists = 0;
        END;

      SET v_step = 400;

      SELECT oo_obj_key
           , oo_type_key
      INTO   v_obj_key
           , v_obj_type
      FROM   [METABASE].ws_obj_object
      WHERE  UPPER(oo_name) = UPPER(p_table_name)
      ;

      IF v_obj_key < 1 THEN

        SET v_msgtext = 'Invalid table name '|| p_table_name ||' in call to Ws_Maintain_Table';
        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
          v_msgtext, NULL, NULL, p_task_id, p_job_id);

        SET p_result = -3;
        SET v_exists = 0;

      END IF;

    END;

  ELSE

    SET v_step = 700;

    SET v_MsgText = 'The name of an table must be specified '||
                    ' in a call to Ws_Maintain_Table.';

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
              , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_result = -2;

    LEAVE WS_MAINTAIN_TABLE;

  END IF;

  SET v_step = 800;

  --=====================================================
  -- table exists, then
  -- Process depending on the option selected.
  -- TRUNCATE
  --=====================================================
  IF v_exists = 1 THEN

    IF UPPER(p_option) = 'TRUNCATE' THEN

      SET v_step = 900;

      CALL [METABASE].Ws_Act_Truncate(
                        p_sequence
                      , v_obj_type
                      , NULL --p_action
                      , v_obj_key
                      , p_job_name
                      , p_task_name
                      , p_job_id
                      , p_task_id
                      , v_msgtext
                      , v_status_code
                      , v_status
                      );

    ELSE

      SET v_step = 1400;


      SET v_MsgText = 'Invalid option '|| p_option ||
                      ' in call to Ws_Maintain_Table. '||
                      'Valid options are TRUNCATE';

      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                , v_msgtext, NULL, NULL, p_task_id, p_job_id);

      SET p_result = -2;

      LEAVE WS_MAINTAIN_TABLE;

    END IF;

    SET v_step = 1500;

    IF v_status_code < 1 THEN

      SET v_step = 1600;

      CALL [METABASE].WsWrkAudit('W', p_job_name, p_task_name, p_sequence
            , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    END IF;

    SET p_result = 1;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Update 
CREATE PROCEDURE [METABASE].Ws_Act_Update
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
, OUT p_stmt            varchar(4000)
)
WS_ACT_UPDATE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name        Teradata
  -- Script Name      ws_act_update
  -- Description      Execute the update procedure associated with
  --                          a table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 23/09/2001 added aggregate support
  -- WMR 22/01/2002 Version 1.0.0
  -- WMR 25/10/2002 Version 1.2.1    Sql Server version
  -- WMR 26/03/2006 Version 5.6.0.0  Added support for retro copy
  -- WMR 13/09/2007 Version 5.6.0    DB2 version
  -- AP  09/04/2008 Version 6.0.0.0  Added support for ODS/Normal
  -- JML 01/09/2008 Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013 Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016 Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  14/11/2016 Version 6.8.6.3  Added support for BTEQ scripts
  -- HM  03/10/2017 Version 8.1.1.0  Added support for Source Mapping
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_source_mapping    INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_stmt                     VARCHAR(4000);
  DECLARE v_procedure_key            INTEGER;
  DECLARE v_procedure                VARCHAR(64);        -- Procedure name
  DECLARE v_procedure_type           VARCHAR(1);
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(1024);
  DECLARE v_info_result              INTEGER;
  DECLARE v_info_value               VARCHAR(32000);

  DECLARE v_result                   INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Truncate Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;

  SET v_ws_obj_source_mapping    = 69;

  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2017

  SET v_step = 1;

  SET v_obj_type = p_obj_type;

  --=====================================================
  -- Check that we have a valid table type
  --=====================================================
  IF  p_obj_type <> v_ws_obj_dim
  AND p_obj_type <> v_ws_obj_dim_view
  AND p_obj_type <> v_ws_obj_fact
  AND p_obj_type <> v_ws_obj_fact
  AND p_obj_type <> v_ws_obj_fact_kpi
  AND p_obj_type <> v_ws_obj_stage
  AND p_obj_type <> v_ws_obj_agg
  AND p_obj_type <> v_ws_obj_retro_copy
  AND p_obj_type <> v_ws_obj_cube
  AND p_obj_type <> v_ws_obj_cube_virtual
  AND p_obj_type <> v_ws_obj_ods
  AND p_obj_type <> v_ws_obj_normal
  AND p_obj_type <> v_ws_obj_hub
  AND p_obj_type <> v_ws_obj_satellite
  AND p_obj_type <> v_ws_obj_link
  AND p_obj_type <> v_ws_obj_custom1
  AND p_obj_type <> v_ws_obj_custom2
  AND p_obj_type <> v_ws_obj_source_mapping
  THEN

    SET v_msgtext = 'Update is not a valid action for table ' || p_task_name ||
      '. Table type was ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                             , v_msgtext,NULL,NULL, p_task_id, p_job_id);

    SET p_status_code = -2;
    SET p_result = -2;

    LEAVE WS_ACT_UPDATE;

  END IF;

  --**********************************
  -- CUBE and CUBE Virtual processing
  --**********************************
  IF p_obj_type = v_ws_obj_cube
  OR p_obj_type = v_ws_obj_cube_virtual
  THEN

    -- run a Cube process by returning a result of 5
    SET p_result = 5;
    SET p_status_code = 5;

    LEAVE WS_ACT_UPDATE;

  END IF;

  --=====================================================
  -- See what table we have and get the build procedure
  --=====================================================
  SET v_step = 10;
  SET p_result = 1;
  SET v_procedure_key = 0;

  IF p_obj_type = v_ws_obj_source_mapping THEN

    -- Source Mappings are not first class objects so can't use Ws_Object_Info
    SELECT smt_update_key
    INTO   :v_procedure_key
    FROM   [METABASE].ws_source_mapping_tab
    WHERE  smt_source_mapping_key = :p_obj_key
    ;

  ELSE

    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , p_obj_key, NULL
                                 , 'UPDATE_KEY'
                                 , v_info_return_code, v_info_return_msg
                                 , v_info_result, v_info_value );
    SET v_procedure_key = CAST(v_info_value AS INTEGER);

  END IF;

  IF v_procedure_key = 0 OR v_procedure_key IS NULL THEN

    SET v_msgtext = 'Unable to acquire update procedure for ' || p_task_name;
    SET p_return_msg = v_msgtext;

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
                             , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_status_code = -2;
    SET p_result = -2;

    LEAVE WS_ACT_UPDATE;

  END IF;

  --=====================================================
  -- Get the procedure name and type
  --=====================================================
  SET v_step = 40;
  SET v_procedure = NULL;

  SELECT NULLIF(TRIM(ph_name),'')
       , NULLIF(TRIM(ph_type),'')
  INTO   :v_procedure
       , :v_procedure_type
  FROM   [METABASE].ws_pro_header
  WHERE  ph_obj_key = v_procedure_key;

  IF v_procedure IS NULL OR v_procedure_type IS NULL THEN

    SET v_msgtext = 'Unable to acquire update procedure ';
    IF v_procedure IS NULL THEN
      SET v_msgtext = v_msgtext || 'name ';
      IF v_procedure_type IS NULL THEN
        SET v_msgtext = v_msgtext || 'and type ';
      END IF;
    ELSEIF v_procedure_type IS NULL THEN
      SET v_msgtext = v_msgtext || 'type ';
    END IF;
    SET v_msgtext = v_msgtext || 'for ' || p_task_name;

    SET p_return_msg = v_msgtext;

    CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
                             , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_status_code = -3;
    SET p_result = -3;

    LEAVE WS_ACT_UPDATE;

  END IF;

  --=====================================================
  -- Execute the procedure
  --=====================================================
  -- Execute the procedure
  IF v_procedure_type = 'T' THEN
    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key
      , p_job_name, p_task_name, p_job_id, p_task_id
      , p_return_msg, p_status_code, v_result);

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF v_result = 1 THEN
      SET p_result = 2;
      SET p_status_code = 2;
    ELSE
      SET p_result = v_result;
      --SET p_status_code = v_status_code;
    END IF;

  ELSE
    SET v_stmt = 'CALL [METABASE].' || v_procedure || '(' || TRIM(CAST(p_sequence AS VARCHAR(18)));
    SET v_stmt = v_stmt || ',''' || p_job_name ||''',''' || p_task_name || ''',' || TRIM(CAST(p_job_id AS VARCHAR(18)));
    SET v_stmt = v_stmt || ',' || TRIM(CAST(p_task_id AS VARCHAR(18))) || ',?,?);';

    SET p_result = 1;
    SET p_status_code = 1;
  END IF;

  SET v_step = 92;

  SET p_return_msg = 'Statement prepared';
  SET p_stmt = v_stmt;

END;
_PROCEDWSL_ Ws_Database_Replace 
CREATE PROCEDURE [METABASE].Ws_Database_Replace
( IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_instr            varchar(8000)
, OUT p_outstr           varchar(8000)
)
WS_DBASE_REPLACE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    		Teradata
  -- Script Name 			Ws_Database_Replace
  -- Description 			Resolves database name square brackets by
  --                          - replacing METABASE in brackets with the METABASE name
  --                          - replacing object_name in brackets with database.object_name
  --                          Returns the new string in p_outstr.
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- JML 01/09/2008   Version 6.0.2.0
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_work                     VARCHAR(8000);
  DECLARE v_step                     INTEGER;
  DECLARE v_spos                     INTEGER;
  DECLARE v_epos                     INTEGER;
  DECLARE v_new_value                VARCHAR(8000);
  DECLARE v_table                    VARCHAR(4000);
  DECLARE v_from                     VARCHAR(4000);
  DECLARE v_to                       VARCHAR(4000);
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      SET p_outstr = p_instr;
    END;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_work = p_instr;

  CALL [METABASE].Ws_String_Replace(v_work, '5B'XC||'META'||'BASE'||'5D'XC, '[METABASE]', v_new_value);

  SET v_work = v_new_value;

  SET v_step = 200;

  SET v_spos = INDEX(v_work,'5B'XC);

  SET v_step = 300;

  WHILE  v_spos > 0 DO

    SET v_step = 400;

    SET v_spos = INDEX(v_work,'5B'XC);

    SET v_step = 500;

    IF v_spos > 0 THEN

      SET v_step = 600;

      SET v_epos = INDEX(SUBSTR(v_work,v_spos+1,CHAR(v_work)-v_spos),'5D'XC);

      SET v_step = 700;

      IF v_epos = 0 THEN

        SET v_step = 800;

        SET v_spos = 0;

      ELSE

        SET v_step = 900;

        SET v_table = SUBSTR(v_work,v_spos+1,v_epos-1);

        SET v_step = 1000;

        CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                      , 0, v_table
                                      , 'database'
                                      , v_db_return_code, v_db_return_msg
                                      , v_db_result, v_table_db);

        SET v_step = 1100;

        SET v_from = '5B'XC || v_table || '5D'XC;
        SET v_to = v_table_db || '.' || v_table;

        SET v_step = 1200;

        CALL [METABASE].Ws_String_Replace(v_work, v_from, v_to, v_new_value);

        SET v_work = v_new_value;

      END IF;

    END IF;

  END WHILE;

  SET p_outstr = v_work;

END;
_PROCEDWSL_ Ws_Job_Exec_Rejoin 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_Rejoin
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_action           VARCHAR(12)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_task_status      INTEGER
, IN  pi_task_msg         VARCHAR(256)
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
, OUT po_proc_stmt        VARCHAR(8000)
)
WS_JOB_EXEC_REJOIN:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_rejoin
  -- Description  Establishes a new Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- RS  14/02/2013     Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016     Version 6.8.5.2  Changed error handler
  -- BC  10/02/2016     Version 6.8.5.3  Added support for BDA Server operations
  -- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  -- HM  01/03/2019     Version 8.3.1.1  RED-10221 Ensure primary index is used when updating ws_wrk_task_run to prevent deadlock.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_task_msg                 VARCHAR(1024);
  DECLARE v_task_status              INTEGER;
  DECLARE v_result_2                 INTEGER;
  DECLARE v_task_msg_2               VARCHAR(1024);
  DECLARE v_task_status_2            INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_run_status               VARCHAR(1);
  DECLARE v_audit_status             VARCHAR(1);
  DECLARE v_FailMsg                  VARCHAR(255); -- Failure result command
  DECLARE v_action_type              INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_proc_stmt                VARCHAR(4000);
  DECLARE v_rec_count                INTEGER;
  DECLARE v_status_code              INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in WS_JOB_EXEC_REJOIN Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_job_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_task_status = pi_task_status;
  SET v_task_msg = pi_task_msg;

  --=====================================================
  -- Make sure we have a valid return status
  -- Otherwise make this a failure
  -- Update the status of the task we have completed.
  --=====================================================
  SET v_handled = 0;

  IF v_task_status = 1 THEN

    SET v_audit_status = 'S';
    SET v_run_status = 'C';
    SET v_handled = 1;

  ELSEIF v_task_status = -1 THEN

    SET v_audit_status = 'W';
    SET v_run_status = 'C';
    SET v_handled = 1;

  ELSEIF v_task_status = -2 THEN

    SET v_audit_status = 'E';
    SET v_run_status = 'F';
    SET v_handled = 1;

  ELSEIF v_task_status = -3 THEN

    SET v_audit_status = 'F';
    SET v_run_status = 'F';
    SET v_handled = 1;

  END IF;

  IF v_handled = 0 THEN

    SET v_audit_status = 'U';
    SET v_run_status = 'U';
    SET v_task_status = -3;
    SET v_task_msg = 'Invalid return code ' || TRIM(CAST(v_task_status AS VARCHAR(18))) ||'. Msg was ' || SUBSTR(v_task_msg,1,900) ||'. Expecting return code of 1,-1,-2, or -3';

  END IF;

  --=====================================================
  -- Record this thread as being active
  --=====================================================
  CALL [METABASE].Ws_Job_Exec_Thread('ADD', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

  -- If the rejoin is due to an exit to run script load
  -- then delete the temporary script we have created for this
  -- task to use.
  IF UPPER(pi_action) = 'REJOIN' THEN

    DELETE FROM [METABASE].ws_wrk_task_scr_line
    WHERE  wtsl_task_key = pi_task_key
    AND    wtsl_job_key = pi_job_key
    AND    wtsl_sequence = pi_sequence;

    DELETE FROM [METABASE].ws_wrk_task_scr_hdr
    WHERE  wtsh_task_key = pi_task_key
    AND    wtsh_job_key = pi_job_key
    AND    wtsh_sequence = pi_sequence;

  END IF;

  -- Make sure we are in run tables (i.e. have a job_run record)
  -- And have a waiting state
  -- Otherwise a fatal problem.
  SELECT COUNT(*)
  INTO   v_rec_count
  FROM   [METABASE].ws_wrk_job_run
  WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(pi_job_name))
  AND    wjr_sequence = pi_sequence;

  IF v_rec_count = 0 THEN

    SET v_MsgText = 'Ws_Job_Exec_Rejoin'|| v_ws_pro_version || ' Job ' || pi_job_name || ' sequence ' ||
                     TRIM(CAST(pi_sequence AS VARCHAR(18))) ||
                     ' cannot rejoin. '||
                     ' no such job exists. No Action !!!';

    CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                               v_MsgText, NULL, NULL, 0, pi_job_key);

    -- See if we can work out what has happened to the job
    -- and let them know
    SELECT wjl_status
         , wjl_publish_fail
    INTO   v_run_status
         , v_FailMsg
    FROM   [METABASE].ws_wrk_job_log
    WHERE  TRIM(UPPER(wjl_name)) = TRIM(UPPER(pi_job_name))
    AND    wjl_sequence = pi_sequence;

    SET v_handled = 0;

    IF v_task_status = 1 THEN

      SET v_audit_status = 'S';
      SET v_run_status = 'C';
      SET v_handled = 1;

    ELSEIF v_task_status = -1 THEN

      SET v_audit_status = 'W';
      SET v_run_status = 'C';
      SET v_handled = 1;

    ELSEIF v_task_status = -2 THEN

      SET v_audit_status = 'E';
      SET v_run_status = 'F';
      SET v_handled = 1;

    ELSEIF v_task_status = -3 THEN

      SET v_audit_status = 'F';
      SET v_run_status = 'F';
      SET v_handled = 1;

    END IF;

    IF v_handled = 0 THEN

      SET v_audit_status = 'U';
      SET v_run_status = 'U';
      SET v_task_status = -3;

    END IF;

    CALL [METABASE].WsWrkAudit(v_audit_status, pi_job_name, pi_task_name, pi_sequence,
             v_task_msg, NULL, NULL, pi_task_key, pi_job_key);

    SET po_result_code = -2;
    SET po_result_msg = v_MsgText;
    SET po_proc_stmt = 'no statement';

    LEAVE WS_JOB_EXEC_REJOIN;

  ELSE

    SELECT wjr_status
         , wjr_publish_fail
    INTO   v_run_status
         , v_FailMsg
    FROM   [METABASE].ws_wrk_job_run
    WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(pi_job_name))
    AND    wjr_sequence = pi_sequence;

  END IF;

  -- Setup to default for a failure if a Fail command has been provided
  IF NULLIF(TRIM(v_FailMsg),'') IS NOT NULL THEN

    SET po_action_key = 2;
    SET po_action_msg = v_FailMsg;

  ELSE

    SET po_action_key = 0;
    SET po_action_msg = 'no action';

  END IF;

  -- Get some info about the task we have just completed
  SET v_obj_key = 0;

  SELECT wtr_obj_key
       , wtr_obj_type
       , wtr_action_type
  INTO   v_obj_key
       , v_obj_type
       , v_action_type
  FROM   [METABASE].ws_wrk_task_run
  WHERE  wtr_job_key = pi_job_key
  AND    wtr_task_key = pi_task_key
  AND    wtr_sequence = pi_sequence;

  IF NULLIF(v_obj_key,0) IS NULL THEN

    SET v_MsgText = 'Ws_Job_Exec_Rejoin'|| v_ws_pro_version || ' Job ' || pi_job_name || ' sequence ' ||
                     TRIM(CAST(pi_sequence AS VARCHAR(18))) ||
                     ' Task ' || pi_task_name || ' not running. ' ||
                     'Cannot rejoin. No Action !!!';

    CALL [METABASE].WsWrkAudit('E',pi_job_name, pi_task_name, pi_sequence,
                                             v_MsgText,NULL,NULL,pi_task_key,pi_job_key);

    SET v_handled = 0;

    IF v_task_status = 1 THEN

      SET v_audit_status = 'S';
      SET v_run_status = 'C';
      SET v_handled = 1;

    ELSEIF v_task_status = -1 THEN

      SET v_audit_status = 'W';
      SET v_handled = 1;
      SET v_run_status = 'C';

    ELSEIF v_task_status = -2 THEN

      SET v_audit_status = 'E';
      SET v_run_status = 'F';
      SET v_handled = 1;

    ELSEIF v_task_status = -3 THEN

      SET v_audit_status = 'F';
      SET v_run_status = 'F';
      SET v_handled = 1;

    END IF;

    IF v_handled = 0 THEN

      SET v_audit_status = 'U';
      SET v_run_status = 'U';
      SET v_task_status = -3;

    END IF;

    CALL [METABASE].WsWrkAudit(v_audit_status, pi_job_name, pi_task_name, pi_sequence,
             v_task_msg, NULL, NULL, pi_task_key, pi_job_key);

    SET po_result_code = -2;
    SET po_result_msg = v_task_msg;
    SET po_proc_stmt = 'no statement';

    LEAVE WS_JOB_EXEC_REJOIN;

  END IF;

  --=====================================================
  -- If the action is a script rejoin.
  --=====================================================
  IF UPPER(pi_action) = 'REJOIN' OR UPPER(pi_action) = 'REJOIN91' THEN

    --=====================================================
    -- If a Load then we have just completed the load phase
    -- And now need to run any post load procedure if the
    -- load was a success
    -- If a Load and the action is a process then we need
    -- to do any index builds as well
    --=====================================================
    SET v_step = 2301;

    IF v_obj_type = v_ws_obj_load THEN

      IF v_task_status >= -1 THEN     -- Successful load

        CALL [METABASE].Ws_Act_Post_Load(pi_sequence,v_obj_type,v_action_type
                                       , v_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                       , v_task_msg_2
                                       , v_task_status_2
                                       , v_result_2, v_proc_stmt);

        IF v_task_status_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        ELSEIF v_task_status_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        -- If our post load procedure failed and the load worked then
        -- record the post load failure
        IF v_task_status_2 < v_task_status THEN

          SET v_task_status = v_task_status_2;

        END IF;

        -- If a post load procedure could be found
        -- The result will be 2 if no post load was found
        IF v_result_2 = 1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_task_msg_2;
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

          LEAVE WS_JOB_EXEC_REJOIN;

        END IF;

      END IF;-- end of successful load

    END IF;-- end of load

    --=====================================================
    -- If an Export then we have just completed the export phase
    -- And now need to run any post export procedure if the
    -- export was a success
    --=====================================================
    SET v_step = 2301;

    IF v_obj_type = v_ws_obj_export THEN

      IF v_task_status >= -1 THEN    -- Successful export

        CALL [METABASE].Ws_Act_Post_Export(pi_sequence,v_obj_type,v_action_type
                                         , v_obj_key
                                         , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                         , v_task_msg_2
                                         , v_task_status_2
                                         , v_result_2, v_proc_stmt);

        IF v_task_status_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_task_status_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        -- If our post export procedure failed and the export worked then
        -- record the post export failure
        IF v_task_status_2 < v_task_status THEN

          SET v_task_status = v_task_status_2;

        END IF;

        -- If a post export procedure could be found
        -- The result will be 2 if no post load was found
        IF v_result_2 = 1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_task_msg_2;
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, 0, v_status_code);

          LEAVE WS_JOB_EXEC_REJOIN;

        END IF;

      END IF;-- end of successful export

    END IF;-- end of export

    --=====================================================
    -- If a Retro Initial load then we have just completed
    -- the load phase
    -- And now need to run any index creates if the
    -- load was a success
    --=====================================================
    SET v_step = 2301;

    IF v_obj_type = v_ws_obj_retro_copy AND v_action_type = v_ws_act_initial THEN

      IF v_task_status >= -1 THEN    -- Successful load

        CALL [METABASE].Ws_Act_Build_All(pi_sequence,v_obj_type,v_action_type
                                       , v_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                                       , v_task_msg_2, v_task_status_2
                                       , v_result_2);

        IF v_task_status_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_task_status_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        -- If our post load procedure failed and the load worked then
        -- record the post load failure
        IF v_task_status_2 < v_task_status THEN

          SET v_task_status = v_task_status_2;

        END IF;

      END IF;-- end of successful retro_copy load

    END IF;-- end of retro_copy

  -- end of REJOIN

  --=====================================================
  -- If the action is a procedure run rejoin.
  --=====================================================
  ELSEIF UPPER(pi_action) = 'PROCJOIN' THEN

    IF v_action_type = v_ws_act_process THEN

      IF v_task_status >= -1 THEN     -- Successful post load

        IF v_task_status = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_task_msg,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_task_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        CALL [METABASE].Ws_Act_Build(pi_sequence,v_obj_type,v_action_type
                                   , v_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                                   , v_task_msg_2
                                   , v_task_status_2
                                   , v_result_2);

        IF v_task_status_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                   v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        ELSEIF v_task_status_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                   v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

      ELSE

        SET v_task_status_2 = 1;

      END IF;

      -- If our post load procedure worked and the build failed then
      -- record the build failure
      IF v_task_status_2 < v_task_status THEN

        SET v_task_status = v_task_status_2;

      END IF;

      -- End of process post procedure run rejoin

    ELSEIF v_action_type = v_ws_act_initial THEN

      IF v_obj_type <> v_ws_obj_retro_copy THEN

        IF v_task_status >= -1 THEN    -- Successful initial build

          IF v_task_status = 1 THEN

            CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                   v_task_msg,NULL,NULL,pi_task_key,pi_job_key);

          ELSE

            CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                   v_task_msg,NULL,NULL,pi_task_key,pi_job_key);

          END IF;

          CALL [METABASE].Ws_Act_Build_All(pi_sequence,v_obj_type,v_action_type
                                         , v_obj_key
                                         , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                                         , v_task_msg_2, v_task_status_2
                                         , v_result_2);

          IF v_task_status_2 = 1 THEN

            CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                  v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

          END IF;

          IF v_task_status_2 < 1 THEN

            CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                  v_task_msg_2,NULL,NULL,pi_task_key,pi_job_key);

          END IF;

          -- If our build all failed and the initial build worked then
          -- record the build all failure
          IF v_task_status_2 < v_task_status THEN

            SET v_task_status = v_task_status_2;

          END IF;

        END IF;  -- end of successful initial build

      END IF;  -- end of non retro_copy

    END IF;  -- end of initial build post procedure run rejoin

  END IF; -- end of PROCJOIN

  --=====================================================
  -- Log the results in the audit trail
  --=====================================================
  SET v_step = 2302;

  SET v_handled = 0;

  IF v_task_status = 1 THEN

    SET v_audit_status = 'S';
    SET v_run_status = 'C';
    SET v_handled = 1;

  ELSEIF v_task_status = -1 THEN

    SET v_audit_status = 'W';
    SET v_run_status = 'C';
    SET v_handled = 1;

  ELSEIF v_task_status = -2 THEN

    SET v_audit_status = 'E';
    SET v_run_status = 'F';
    SET v_handled = 1;

  ELSEIF v_task_status = -3 THEN

    SET v_audit_status = 'F';
    SET v_run_status = 'F';
    SET v_handled = 1;

  END IF;

  IF v_handled = 0 THEN

    SET v_audit_status = 'U';
    SET v_run_status = 'U';
    SET v_task_status = -3;

  END IF;

  CALL [METABASE].WsWrkAudit(v_audit_status, pi_job_name, pi_task_name, pi_sequence,
           v_task_msg, NULL, NULL, pi_task_key, pi_job_key);

  --=====================================================
  -- Update the run record to indicate our final status
  --=====================================================
  SET v_step = 2303;

  UPDATE [METABASE].ws_wrk_task_run
  SET    wtr_run_status = v_run_status
       , wtr_audit_status = v_audit_status
       , wtr_return_msg = v_task_msg
       , wtr_elapsed_hh = EXTRACT(HOUR FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
       , wtr_elapsed_mi = EXTRACT(MINUTE FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
       , wtr_completed = CURRENT_TIMESTAMP
  WHERE  wtr_task_key = pi_task_key
  AND    wtr_job_key = pi_job_key
  AND    wtr_sequence = pi_sequence;

  SET po_result_code = 1;
  SET po_result_msg = v_task_msg;
  SET po_proc_stmt = 'no statement';

END;
_PROCEDWSL_ Ws_Act_Drop_All 
CREATE PROCEDURE [METABASE].Ws_Act_Drop_All (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

WS_ACT_DROP_ALL:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_drop_all
  -- Description  : Drop all indexes associated with an object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 30/08/2001 Version 0.3.0.6  Added support for Primary Keys
  -- WMR 21/01/2002 Version 1.0.0.0  Added support for Partitioned indexes
  -- WMR 24/06/2005 Version 4.1.2.11 include the schema name in the drop if flag set
  -- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
  --                                 Add call to wswrkerror for each index as drop/built
  --                                 Correct message count number
  -- JML 24/01/2008 Version 5.6.3.1  Teradata version
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_result                   INTEGER;       -- Return code
  DECLARE v_stmt                     VARCHAR(1024); -- Used for dynamic SQL
  DECLARE v_obj_done                 INTEGER;       -- Used to flag successful drop
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_ih_index_type            VARCHAR(1);
  DECLARE v_ih_table                 VARCHAR(64);
  DECLARE v_ih_index_name            VARCHAR(64);
  DECLARE v_ih_tablespace            VARCHAR(64);
  DECLARE v_IndexFetch               INTEGER;
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);
  DECLARE v_count                    INTEGER;

  --=====================================================
  -- Cursor for all pre_drop indexes
  --=====================================================
  DECLARE c_Index CURSOR FOR
    SELECT ih_table
         , ih_index_name
         , ih_index_type
         , ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_obj_key = :p_obj_key
    AND    ih_index_type <> 'P'
    AND    ih_active = 'Y';

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in ws_act_drop_all. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET v_result = -3;
    END;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================
  SET v_ws_pro_version = '(8.4.1.0)';
  SET v_ws_obj_fact = 5;
  SET v_ws_obj_dim = 6;
  SET v_ws_obj_stage = 7;
  SET v_ws_obj_load = 8;
  SET v_ws_obj_agg = 9;
  SET v_ws_obj_index = 10;
  SET v_ws_obj_export = 13;
  SET v_ws_obj_view = 18;
  SET v_ws_obj_join = 20;
  SET v_ws_obj_retro = 21;
  SET v_ws_obj_retro_copy = 22;

  SET v_ws_act_drop = 1;
  SET v_ws_act_create = 2;
  SET v_ws_act_drop_all = 3;
  SET v_ws_act_pre_drop = 4;
  SET v_ws_act_load = 5;
  SET v_ws_act_update = 6;
  SET v_ws_act_execute = 7;
  SET v_ws_act_process = 8;
  SET v_ws_act_build = 9;
  SET v_ws_act_build_all = 10;
  SET v_ws_act_analyze = 11;
  SET v_ws_act_quick_analyze = 12;
  SET v_ws_act_statistics = 13;
  SET v_ws_act_quick_statistics = 14;

  SET v_step = 100;

  SET v_count = 0;
  SET p_status_code = 1;
  SET v_result = 1;

  --=====================================================
  -- Loop through all the indexes to drop
  -- May not be any
  --=====================================================
  OPEN c_Index;
  FETCH NEXT FROM c_Index INTO
      v_ih_table
    , v_ih_index_name
    , v_ih_index_type
    , v_ih_tablespace;

  SET v_IndexFetch = SQLCODE;

  WHILE ( v_IndexFetch = 0 )
  DO

    SET v_step = 200;

    IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN

      SET v_step = 300;

      SET v_stmt = 'drop hash index ';
      SET v_stmt = v_stmt||v_ih_tablespace||'.';
      SET v_stmt = v_stmt||v_ih_index_name;

    ELSE

      SET v_step = 400;

      CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                     , 0, :v_ih_table
                                     , 'database'
                                     , :v_db_return_code, :v_db_return_msg
                                     , :v_db_result, :v_table_db);

      SET v_step = 500;

      SET v_stmt = 'drop index ';
      SET v_stmt = v_stmt||v_ih_index_name;
      SET v_stmt = v_stmt||' on ';
      SET v_stmt = v_stmt||v_table_db||'.';
      SET v_stmt = v_stmt||v_ih_table;

    END IF;

    SET v_step = 600;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in ws_act_drop_all. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Index Drop for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
              ' SQL: '|| v_stmt ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET v_result = -3;
        END;

      SET v_step = 700;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 800;

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 900;

    IF ( v_obj_done = 1 ) THEN

      SET v_step = 1000;

      SET v_count = v_count + 1;

      SET v_step = 1100;

      SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

    SET v_step = 1200;

    -- Get the next index
    SET v_IndexFetch = 0;

    SET v_step = 1300;

    FETCH NEXT FROM c_Index INTO
        v_ih_table
      , v_ih_index_name
      , v_ih_index_type
      , v_ih_tablespace;

    SET v_IndexFetch = SQLCODE;

  END WHILE; -- End of log file checks for this parent

  SET v_step = 1400;

  CLOSE c_Index;

  SET v_step = 1500;

  -- tell them how many indexes we dropped
  IF ( v_count = 0 ) THEN

    SET v_msgtext = 'No indexes to drop';

  ELSEIF ( v_count = 1 ) THEN

    SET v_msgtext = CAST(v_count AS VARCHAR(18)) ||' index dropped';

  ELSE

    SET v_msgtext = CAST(v_count AS VARCHAR(18))  ||' indexes dropped';

  END IF;

  SET v_step = 1600;

  SET p_return_msg = v_msgtext;

  SET p_result = v_result;

END ws_act_drop_all;
_PROCEDWSL_ Ws_Act_Pre_Drop 
CREATE PROCEDURE [METABASE].Ws_Act_Pre_Drop (
  IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer)

WS_ACT_PRE_DROP:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_act_pre_drop
  -- Description  : Drop any indexes specified as being dropped
  --                before an update occurs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 30/08/2001 Version 0.3.0.6  Added support for Primary Keys
  -- WMR 21/01/2002 Version 1.0.0.0  Added support for Partitioned indexes
  -- WMR 24/06/2005 Version 4.1.2.11 include the schema name in the drop if flag set
  -- AP  01/08/2006 Version 5.5.0.5  Add Version Number as constant to all out messages
  --                                 Add call to wswrkerror for each index as drop/built
  --                                 Corrected counts for when actually indexes dropped
  -- JML 24/01/2008 Version 5.6.3.1  Teradata version
  -- RS  18/01/2016 Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_result                   INTEGER;       -- Return code
  DECLARE v_stmt                     VARCHAR(1024); -- Used for dynamic SQL
  DECLARE v_obj_done                 INTEGER;       -- Used to flag successful drop
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_ih_index_type            VARCHAR(1);
  DECLARE v_ih_table                 VARCHAR(64);
  DECLARE v_ih_index_name            VARCHAR(64);
  DECLARE v_ih_tablespace            VARCHAR(64);
  DECLARE v_IndexFetch               INTEGER;
  DECLARE v_db_return_code           VARCHAR(1);
  DECLARE v_db_return_msg            VARCHAR(1024);
  DECLARE v_db_result                INTEGER;
  DECLARE v_table_db                 VARCHAR(4000);
  DECLARE v_count                    INTEGER;

  --=====================================================
  -- Cursor for all pre_drop indexes
  --=====================================================
  DECLARE c_Index CURSOR FOR
    SELECT ih_table
         , ih_index_name
         , ih_index_type
         , ih_tablespace
    FROM   [METABASE].ws_index_header
    WHERE  ih_obj_key = :p_obj_key
    AND    ih_index_type <> 'P'
    AND    ih_active = 'Y'
    AND    ih_pre_drop_flag = 'Y';

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in ws_act_pre_drop. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_status_code = -3;
      SET v_result = -3;
    END;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================
  SET v_ws_pro_version = '(8.4.1.0)';
  SET v_ws_obj_fact = 5;
  SET v_ws_obj_dim = 6;
  SET v_ws_obj_stage = 7;
  SET v_ws_obj_load = 8;
  SET v_ws_obj_agg = 9;
  SET v_ws_obj_index = 10;
  SET v_ws_obj_export = 13;
  SET v_ws_obj_view = 18;
  SET v_ws_obj_join = 20;
  SET v_ws_obj_retro = 21;
  SET v_ws_obj_retro_copy = 22;

  SET v_ws_act_drop = 1;
  SET v_ws_act_create = 2;
  SET v_ws_act_pre_drop = 3;
  SET v_ws_act_pre_drop = 4;
  SET v_ws_act_load = 5;
  SET v_ws_act_update = 6;
  SET v_ws_act_execute = 7;
  SET v_ws_act_process = 8;
  SET v_ws_act_build = 9;
  SET v_ws_act_build_all = 10;
  SET v_ws_act_analyze = 11;
  SET v_ws_act_quick_analyze = 12;
  SET v_ws_act_statistics = 13;
  SET v_ws_act_quick_statistics = 14;

  SET v_step = 100;

  SET v_count = 0;
  SET p_status_code = 1;
  SET v_result = 1;

  --=====================================================
  -- Loop through all the indexes to drop
  -- May not be any
  --=====================================================
  OPEN c_Index;
  FETCH NEXT FROM c_Index INTO
      v_ih_table
    , v_ih_index_name
    , v_ih_index_type
    , v_ih_tablespace;

  SET v_IndexFetch = SQLCODE;

  WHILE ( v_IndexFetch = 0 )
  DO

    SET v_step = 200;

    IF ( SUBSTR(v_ih_index_type,1,1) = 'H' ) THEN

      SET v_step = 300;

      SET v_stmt = 'drop hash index ';
      SET v_stmt = v_stmt||v_ih_tablespace||'.';
      SET v_stmt = v_stmt||v_ih_index_name;

    ELSE

      SET v_step = 400;

      CALL [METABASE].Ws_Object_Info(:p_sequence, :p_job_name, :p_task_name, :p_job_id, :p_task_id
                                     , 0, :v_ih_table
                                     , 'database'
                                     , :v_db_return_code, :v_db_return_msg
                                     , :v_db_result, :v_table_db);

      SET v_step = 500;

      SET v_stmt = 'drop index ';
      SET v_stmt = v_stmt||v_ih_index_name;
      SET v_stmt = v_stmt||' on ';
      SET v_stmt = v_stmt||v_table_db||'.';
      SET v_stmt = v_stmt||v_ih_table;

    END IF;

    SET v_step = 600;

    SET v_obj_done = 1;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          SET v_obj_done = 0;
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = SUBSTR('Exception in ws_act_pre_drop. ' || v_ws_pro_version ||
              ' Step ' || CAST(v_step AS VARCHAR(64)) ||
              ' Index Drop for Index ' || CAST(p_obj_key AS VARCHAR(18)) ||
              ' SQL: '|| v_stmt ||
              ' SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_status_code = -3;
          SET v_result = -3;
        END;

      SET v_step = 700;

      CALL DBC.SYSEXECSQL ( :v_stmt );

      SET v_step = 800;

    END;

    --=====================================================
    -- Put detail message
    --=====================================================
    SET v_step = 900;

    IF ( v_obj_done = 1 ) THEN

      SET v_step = 1000;

      SET v_count = v_count + 1;

      SET v_step = 1100;

      SET v_msgtext = 'Index ' || v_ih_index_name || ' dropped';
      CALL [METABASE].WsWrkError('I', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, '', '', :p_task_id, :p_job_id, NULL);

    END IF;

    SET v_step = 1200;

    -- Get the next index
    SET v_IndexFetch = 0;

    SET v_step = 1300;

    FETCH NEXT FROM c_Index INTO
        v_ih_table
      , v_ih_index_name
      , v_ih_index_type
      , v_ih_tablespace;

    SET v_IndexFetch = SQLCODE;

  END WHILE; -- End of log file checks for this parent

  SET v_step = 1400;

  CLOSE c_Index;

  SET v_step = 1500;

  -- tell them how many indexes we dropped
  IF ( v_count = 0 ) THEN

    SET v_msgtext = 'No indexes to drop';

  ELSEIF ( v_count = 1 ) THEN

    SET v_msgtext = CAST(v_count AS VARCHAR(18)) ||' index dropped';

  ELSE

    SET v_msgtext = CAST(v_count AS VARCHAR(18))  ||' indexes dropped';

  END IF;

  SET v_step = 1600;

  SET p_return_msg = v_msgtext;

  SET p_result = v_result;

END ws_act_pre_drop;
_PROCEDWSL_ Ws_Job_Wait 
REPLACE PROCEDURE [METABASE].Ws_Job_Wait(
  IN  p_sched_type    varchar(12)
, IN  p_sched_name    varchar(64)
, OUT p_job_name      varchar(64)
, OUT p_task_name     varchar(64)
, OUT p_restart_flag  varchar(12)
, OUT p_thread        integer
, OUT p_sequence      integer
, OUT p_result        integer
)

WS_JOB_WAIT:
BEGIN

-- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

-- =============================================================================
-- DBMS Name    :  Teradata
-- Script Name  :  ws_job_wait
-- Description  :  Look for a job to execute
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
-- =============================================================================
-- Notes / History
--
-- WMR 05/11/2001 Change status to pending when running a job
-- WMR 22/01/2002 Version 1.0.0
-- WMR 05/04/2002 Version 1.0.7 check for the appropriate scheduler type
-- WMR 25/10/2002 Convert to SQL Server
-- WMR 23/07/2004 Added job dependencies
-- WMR 16/10/2005 Version 5.0.0 Teradata port
-- WMR 30/11/2005 Handle time differences of more than minute(4)
-- AP  07/05/2007 Check that dependent jobs completed okay.
-- JML 29/06/2009 Added call to Ws_Job_Get_Start to replace start date/time logic.
-- AP  02/02/2010 New Field on ws_wrk_job_run/ctrl
-- AP  14/04/2010 Identify and try again for jobs stuck in pending state over 10 minutes
-- AP  24/08/2011 RED-2293 Corrected setting of wjc_submitted such that test for pending jobs works as expected
-- RS  19/02/2015 RED-4571 Fixed job scheduler dependency issue
-- RS  18/01/2016 Version 6.8.5.2  Changed error handler
-- BC  30/03/2016 Version 6.8.5.4 RED-881 Support added to execute Failure Command when job fails due
--                                 to job dependency failure.
--                                        Also moved the delete of a failed Once-only Job Control record
--                                 down to occur last before exiting, so that a Job Run record can be
--                                 added for the failed job.
-- RS  09/08/2016 Version 6.8.6.2 RED-5624 Changed to report first failed job in parent-job dependency
-- FS  05/12/2017 Version 8.0.2.0 RED-9068 resolve deadlock issues
-- FS  27/12/2017 Version 8.0.2.0 RED-8649 scheduler performance issue
-- HM  13/02/2019 Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.
-- HM  01/03/2019 Version 8.3.1.1 RED-10221 Ensure primary index is used when updating status in ws_wrk_job_run to prevent deadlock.

  DECLARE v_MsgText         varchar(1024); -- Text for audit_trail
  DECLARE v_set             integer;       -- commit set
  DECLARE v_analyze_flag    integer;       -- analyze flag
  DECLARE v_step            integer;       -- return code
  DECLARE v_update_count    integer;       -- no of records updated
  DECLARE v_insert_count    integer;       -- no of records inserted
  DECLARE v_count           integer;       -- General counter
  DECLARE v_db_code         varchar(10);   -- Database error code
  DECLARE v_db_msg          varchar(1024); -- Database error message

  --=====================================================
  -- General Variables
  --=====================================================

  DECLARE v_return_status   integer;  -- Update result status
  DECLARE v_row_count       integer;  -- General row count
  DECLARE v_thread_count    integer;  -- thread count
  DECLARE v_unix            integer;  -- UNIX scheduler flag
  DECLARE v_windows         integer;  -- win scheduler flag
  DECLARE v_poll            integer;  -- status poll request
  DECLARE v_shut            integer;  -- shutdown request
  DECLARE v_more            integer;
  DECLARE v_AddDays         integer;
  DECLARE v_wait_HH         integer;
  DECLARE v_wait_MM         integer;
  DECLARE v_cur_HH          integer;
  DECLARE v_cur_MM          integer;
  DECLARE v_cur_HHMM        integer;
  DECLARE v_cur_day_name    varchar(3);
  DECLARE v_Monday          integer;
  DECLARE v_Tuesday         integer;
  DECLARE v_Wednesday       integer;
  DECLARE v_Thursday        integer;
  DECLARE v_Friday          integer;
  DECLARE v_Saturday        integer;
  DECLARE v_Sunday          integer;
  DECLARE v_okay            integer;
  DECLARE v_parent_okay     integer;
  DECLARE v_fail_job        integer;
  DECLARE v_fail_cmd        integer;
  DECLARE v_waited          integer;
  DECLARE v_job_id          integer;
  DECLARE v_child_job_name  varchar(64);
  DECLARE v_parent_job_name varchar(64);
  DECLARE v_handled         integer;
  DECLARE v_all_status      integer;
  DECLARE v_rec_count       integer;
  DECLARE v_cust_sb         integer;
  DECLARE v_cust_sa         integer;
  DECLARE v_result          integer;
  DECLARE v_JobFetch        integer;
  DECLARE v_TaskFetch       integer;
  DECLARE v_LogFetch        integer;
  DECLARE v_RestartFetch    integer;
  DECLARE v_DepFetch        integer;
  DECLARE v_sequence        integer;

  --=====================================================
  -- Cursor Variables
  --=====================================================
  DECLARE v_wjc_name            varchar(64);
  DECLARE v_wjc_max_threads     integer;
  DECLARE v_wjc_job_key         integer;
  DECLARE v_wjc_sequence        integer;
  DECLARE v_wjc_start_after     timestamp;
  DECLARE v_now_timel           timestamp;
  DECLARE v_wjc_scheduler       varchar(12);
  DECLARE v_wjr_name            varchar(64);
  DECLARE v_wjr_max_threads     integer;
  DECLARE v_wjr_sequence        integer;
  DECLARE v_wjr_job_key         integer;
  DECLARE v_wjr_scheduler       varchar(12);
  DECLARE v_wjc_type            varchar(1);
  DECLARE v_wjc_start_hour      integer;
  DECLARE v_wjc_start_minute    integer;
  DECLARE v_cust_sa_hh          integer;
  DECLARE v_cust_sa_mm          integer;
  DECLARE v_cust_sb_hh          integer;
  DECLARE v_cust_sb_mm          integer;
  DECLARE v_cust_min            integer;
  DECLARE v_cust_days           integer;
  DECLARE v_wjd_parent_job_name varchar(64);
  DECLARE v_wjd_child_job_name  varchar(64);
  DECLARE v_wjd_first_check_lag integer;
  DECLARE v_wjd_wait_interval   integer;
  DECLARE v_wjd_require_parent  varchar(1);
  DECLARE v_wjl_minutes         integer;
  DECLARE v_wjl_status          varchar(1);
  DECLARE v_wjl_completed       timestamp;

  --=====================================================
  -- Variables for Task Ctrl cursor
  --=====================================================
  DECLARE v_wtc_task_key        integer;
  DECLARE v_wtc_job_key         integer;
  DECLARE v_wtc_obj_key         integer;
  DECLARE v_wtc_name            varchar(64);
  DECLARE v_wtc_type            varchar(1);
  DECLARE v_wtc_sequence        integer;
  DECLARE v_wtc_obj_type        integer;
  DECLARE v_wtc_action_type     integer;
  DECLARE v_wtc_order           integer;
  DECLARE v_wtc_order_a         integer;
  DECLARE v_wtc_order_b         integer;
  DECLARE v_wtc_order_c         integer;
  DECLARE v_wtc_run_status      varchar(1);
  DECLARE v_wtc_audit_status    varchar(1);
  DECLARE v_wtc_started         timestamp;
  DECLARE v_wtc_completed       timestamp;
  DECLARE v_wtc_avg_elapsed     integer;
  DECLARE v_wtc_avg_count       integer;
  DECLARE v_wtc_task_fatal      integer;
  DECLARE v_wtc_task_error      integer;
  DECLARE v_wtc_task_warning    integer;
  DECLARE v_wtc_task_info       integer;
  DECLARE v_wtc_task_okay       integer;
  DECLARE v_wtc_chkp_number     integer;
  DECLARE v_wtc_abort_level     integer;
  DECLARE v_wtc_action_ind      varchar(1);

  --=====================================================
  -- Variables for Task Run cursor
  --=====================================================
  DECLARE v_wtr_task_key        integer;
  DECLARE v_wtr_job_key         integer;
  DECLARE v_wtr_obj_key         integer;
  DECLARE v_wtr_name            varchar(64);
  DECLARE v_wtr_sequence        integer;
  DECLARE v_wtr_restart         integer;
  DECLARE v_wtr_run_status      varchar(1);
  DECLARE v_wtr_audit_status    varchar(1);
  DECLARE v_wtr_started         timestamp;
  DECLARE v_wtr_completed       timestamp;
  DECLARE v_wtr_elapsed_hh      integer;
  DECLARE v_wtr_elapsed_mi      integer;
  DECLARE v_wtr_info_count      integer;
  DECLARE v_wtr_warning_count   integer;
  DECLARE v_wtr_detail_count    integer;
  DECLARE v_wtr_return_msg      varchar(1024);
  DECLARE v_wtr_type            varchar(1);
  DECLARE v_wtr_obj_type        integer;
  DECLARE v_wtr_action_type     integer;
  DECLARE v_wtr_chkp_number     integer;
  DECLARE v_wtr_abort_level     integer;
  DECLARE v_wtr_thread          integer;
  DECLARE v_wtr_inserted        integer;
  DECLARE v_wtr_updated         integer;
  DECLARE v_wtr_replaced        integer;
  DECLARE v_wtr_deleted         integer;
  DECLARE v_wtr_discarded       integer;
  DECLARE v_wtr_rejected        integer;
  DECLARE v_wtr_errored         integer;
  DECLARE v_start_after         timestamp;
  DECLARE v_start_status        char(1);

  --=====================================================
  -- Cursor for all ready jobs
  --=====================================================
  DECLARE c_Job CURSOR FOR
    SELECT wjc_name, wjc_max_threads, wjc_job_key, wjc_sequence,
        wjc_start_after, current_timestamp now_time, wjc_scheduler, wjc_type,
        wjc_start_hour, wjc_start_minute,
        COALESCE(wjc_cust_sa_hh,0) cust_sa_hh,
        COALESCE(wjc_cust_sa_mm,0) cust_sa_mm,
        COALESCE(wjc_cust_sb_hh,0) cust_sb_hh,
        COALESCE(wjc_cust_sb_mm,0) cust_sb_mm,
        COALESCE(wjc_cust_min,0)   cust_min,
        COALESCE(wjc_cust_days,0)  cust_days
    FROM  [METABASE].ws_wrk_job_ctrl
    WHERE ( wjc_status = 'W' AND   wjc_start_after < current_timestamp )

    -- job got 'lost' in pending state for over 10 minutes
    OR     ( wjc_status = 'P' AND    wjc_start_after < current_timestamp  AND    (wjc_submitted + INTERVAL '10' MINUTE) < current_timestamp   )

    ORDER BY wjc_priority, wjc_start_after;

  --=====================================================
  -- Cursor for dependent jobs
  --=====================================================
  DECLARE c_DepJob CURSOR FOR
    select wjd_parent_job_name, wjd_child_job_name,
      wjd_first_check_lag, wjd_wait_interval, wjd_require_parent
    from [METABASE].ws_wrk_job_dependency
    where wjd_child_job_name = :v_child_job_name;

  --=====================================================
  -- Check the logs for the job to see if it has finished
  -- Cursor for job logs
  --=====================================================
  DECLARE c_JobLog CURSOR FOR
    SELECT
           CASE WHEN wjl_completed < CAST(CURRENT_DATE AS TIMESTAMP) - INTERVAL '1' DAY
           THEN 9999
           ELSE CAST ((CURRENT_TIMESTAMP - wjl_completed MINUTE(4)) AS INTEGER)
           END,
           wjl_status, wjl_completed
    FROM  [METABASE].ws_wrk_job_log
    WHERE wjl_name = :v_parent_job_name
    AND   wjl_status = 'C'
    ORDER BY wjl_completed DESC;

  --=====================================================
  -- Cursor for all the task control records to be added to task run
  --=====================================================
  DECLARE c_TaskCtrl CURSOR FOR
    Select * from [METABASE].ws_wrk_task_ctrl
    Where wtc_job_key = :v_wjc_job_key;

  --=====================================================
  -- Cursor for all restarted jobs
  --=====================================================
  DECLARE c_Restart CURSOR  FOR
    Select wjr_name, wjr_max_threads, wjr_sequence, wjr_job_key,
           wjr_scheduler
    from [METABASE].ws_wrk_job_run
    where wjr_status = 'W';

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- See what schedulers we have available
  --=====================================================
  Select COALESCE(COUNT(*),0)
  INTO   :v_unix
  From [METABASE].ws_wrk_scheduler
  Where ws_type_ind = 'U'
  And ws_stop_date is null
  AND CASE WHEN ws_active_date < CAST(CURRENT_DATE AS TIMESTAMP) - INTERVAL '1' DAY
           THEN 16
           ELSE CAST ((CURRENT_TIMESTAMP - ws_active_date MINUTE(4)) AS INTEGER)
      END < 15;

  Select COALESCE(COUNT(*),0)
  INTO :v_windows
  From [METABASE].ws_wrk_scheduler
  Where ws_type_ind = 'W'
  And ws_stop_date is null
  AND CASE WHEN ws_active_date < CAST(CURRENT_DATE AS TIMESTAMP) - INTERVAL '1' DAY
           THEN 16
           ELSE CAST ((CURRENT_TIMESTAMP - ws_active_date MINUTE(4)) AS INTEGER)
      END < 15;


  --=====================================================
  -- See if a poll or shutdown requested for this scheduler
  --=====================================================
  Select ws_poll_flag
        ,ws_shut_flag
  Into   :v_poll
        ,:v_shut
  From [METABASE].ws_wrk_scheduler
  Where ws_name = :p_sched_name;

  --=====================================================
  -- If a shutdown or poll then the appropriate codes
  -- to tell the scheduler to action
  --=====================================================
  SET p_result = 2;
  IF v_poll <> 0 OR v_shut <> 0 THEN
    IF v_poll <> 0 THEN
      SET p_result = 5;
    END IF;

    IF v_shut <> 0 THEN
      SET p_result = 9;
      Update [METABASE].ws_wrk_scheduler
      set ws_shut_flag = 0
      Where ws_name = :p_sched_name;
    END IF;
    LEAVE WS_JOB_WAIT; -- exit
  END IF;

  --=====================================================
  -- Loop through the ready jobs
  -- We will just take the first one
  --=====================================================
  OPEN c_Job;
  FETCH NEXT FROM c_Job INTO
    v_wjc_name
  , v_wjc_max_threads
  , v_wjc_job_key
  , v_wjc_sequence
  , v_wjc_start_after
  , v_now_timel
  , v_wjc_scheduler
  , v_wjc_type
  , v_wjc_start_hour
  , v_wjc_start_minute
  , v_cust_sa_hh
  , v_cust_sa_mm
  , v_cust_sb_hh
  , v_cust_sb_mm
  , v_cust_min
  , v_cust_days;

  SET v_JobFetch = SQLCODE;

  WHILE ( v_JobFetch = 0 )
  DO

    --=====================================================
    -- See if we match on the requested scheduler
    --=====================================================
    IF ( v_wjc_scheduler is NULL )
    OR ( v_wjc_scheduler = p_sched_type )
    OR ( v_wjc_scheduler = p_sched_name )
    OR ( v_wjc_scheduler = 'WANY' And p_sched_type = 'WIN' )
    OR ( v_wjc_scheduler = 'UANY' And p_sched_type = 'UNIX' )
    OR ( v_wjc_scheduler = 'WANY' And v_windows = 0 )
    OR ( v_wjc_scheduler = 'UANY' And v_unix = 0 )
    THEN
      SET p_job_name = v_wjc_name;
      SET p_task_name = 'NO+JOB';
      SET p_restart_flag = 'NEW';
      SET p_thread = v_wjc_max_threads;

      SET v_okay = 1;


      --=====================================================
      -- See if the job has any job dependencies
      --=====================================================
      SET v_child_job_name = v_wjc_name;
      SET v_fail_job = 0;
      SET v_fail_cmd = 0;

      SELECT
             Extract(day from ((CURRENT_TIMESTAMP - :v_wjc_start_after) day(4) to minute)) * 24 * 60 +
             Extract(hour from ((CURRENT_TIMESTAMP - :v_wjc_start_after) day(4) to minute)) * 60 +
             Extract(minute from ((CURRENT_TIMESTAMP - :v_wjc_start_after) day(4) to minute)) as Total_Minutes
             INTO :v_waited;

      --=====================================================
      -- Loop through the dependent jobs
      --=====================================================
      OPEN c_DepJob;
      FETCH NEXT FROM c_DepJob INTO
        v_wjd_parent_job_name
      , v_wjd_child_job_name
      , v_wjd_first_check_lag
      , v_wjd_wait_interval
      , v_wjd_require_parent;

      SET v_DepFetch = SQLCODE;

      DEPENDENCY_LOOP:
      WHILE ( v_DepFetch = 0 )
      DO

        SET v_parent_job_name = v_wjd_parent_job_name;
        SET v_parent_okay = 0;

        --=====================================================
        -- Loop through the job logs
        -- If one has finished within our lookback period then all okay.
        --=====================================================
        OPEN c_JobLog;
        FETCH NEXT FROM c_JobLog INTO
          v_wjl_minutes
        , v_wjl_status
        , v_wjl_completed;

        SET v_LogFetch = SQLCODE;

        WHILE ( v_LogFetch = 0 )
        DO

          -- If job finished in required look back period then all okay
          -- for this parent
          IF v_wjl_minutes < v_wjd_first_check_lag
          THEN
            SET v_parent_okay = 1;
          END IF;

          -- get next job log
          SELECT 0 into :v_LogFetch;
          FETCH NEXT FROM c_JobLog INTO
            v_wjl_minutes
          , v_wjl_status
          , v_wjl_completed;

          SET v_LogFetch = SQLCODE;

        END WHILE; -- End of log file checks for this parent
        CLOSE c_JobLog;

        -- If parent not okay then see if we are past our wait time
        -- limit. If not past the limit then keep waiting
        -- If the parent is not required and past the wait limit
        -- then we will accept it as okay else fail it
        IF v_parent_okay = 0 THEN
          IF v_waited > v_wjd_wait_interval THEN
            IF v_wjd_require_parent IN ('Y','F') THEN
              SET v_fail_job = 1;
              SET v_okay = 0;
              IF v_wjd_require_parent = 'F' THEN
                SET v_fail_cmd = 1;
              END IF;
              LEAVE DEPENDENCY_LOOP; -- Stop here to report the first failed parent job
            END IF;
          ELSE
            SET v_okay = 0;
          END IF;
        END IF;-- end of parent not okay


        -- get next parent job
        SELECT 0 into :v_DepFetch;
        FETCH NEXT FROM c_DepJob INTO
          v_wjd_parent_job_name
        , v_wjd_child_job_name
        , v_wjd_first_check_lag
        , v_wjd_wait_interval
        , v_wjd_require_parent;

        SET v_DepFetch = SQLCODE;

      END WHILE ;-- End of dependent job checks

      CLOSE c_DepJob;


      --=====================================================
      -- OKAY to Run get the sequence
      --=====================================================
      IF v_okay = 1 THEN

        Insert into [METABASE].ws_wrk_sequence(ws_sequence,ws_date, ws_session)
        values (NULL, CURRENT_TIMESTAMP, SESSION );

        SELECT MAX(ws_sequence)
        INTO :v_sequence
        FROM [METABASE].ws_wrk_sequence where ws_session = SESSION;
        SET p_sequence = v_sequence;

        -- Set the job to pending if we plan to run it
        UPDATE [METABASE].ws_wrk_job_ctrl
        SET    wjc_status = 'P'
             , wjc_submitted = current_timestamp --RED-2293
        WHERE wjc_job_key = :v_wjc_job_key;

        SET p_result = 1;
        CLOSE c_Job;

        LEAVE WS_JOB_WAIT; -- exit
      END IF;

      SET v_return_status = 0;
      --=====================================================
      -- JOB needs to be FAILED
      --=====================================================
      IF v_fail_job = 1 THEN

        Insert into [METABASE].ws_wrk_sequence(ws_sequence,ws_date, ws_session)
        values (NULL, CURRENT_TIMESTAMP, SESSION );

        SELECT MAX(ws_sequence)
        INTO :v_sequence
        FROM [METABASE].ws_wrk_sequence where ws_session = SESSION;
        SET p_sequence = v_sequence;

        -- Now either modify or delete the control record
        -- and if required delete the task records
        -- If it is a once only job then delete it from job control
        -- If a once and hold then set its status to Hold
        -- In all other cases work out when it will next run
        -- and put it in a wait state.
        SET v_handled = 0;

        IF v_wjc_type = 'O' THEN

          SET v_handled = 1;

          -- The delete of the Once-only Job Control record
          -- has been moved down to occur last before exiting, so that
          -- a Job Run record can be added for this failed job.

        ELSE

          SET v_handled = 1;

          CALL [METABASE].Ws_Job_Get_Start(:v_wjc_job_key, :v_start_after, :v_start_status, :v_return_status, :v_MsgText);

          IF ( v_return_status <> 0 ) THEN

            CALL [METABASE].WsWrkAudit('F', :v_wjc_name, :v_wjc_name, :v_sequence
                , :v_MsgText, NULL, NULL, 0, :v_wjc_job_key);

          END IF;

          UPDATE [METABASE].ws_wrk_job_ctrl
          SET    wjc_status = :v_start_status
               , wjc_start_after = :v_start_after
          WHERE  wjc_job_key = :v_wjc_job_key;

          SET v_return_status = SQLCODE;

        END IF;

        IF v_return_status = 0 THEN
          SET v_return_status = 0;
        ELSE
          SET v_MsgText = 'Failure to re-appoint scheduled job ' || v_wjc_name;
          GET DIAGNOSTICS EXCEPTION 1 v_db_msg = MESSAGE_TEXT;
          SET v_db_code = SQLCODE;
          CALL [METABASE].WsWrkAudit('F', :v_wjc_name, :v_wjc_name, :v_sequence
              , :v_MsgText, :v_db_code, :v_db_msg, 0, :v_wjc_job_key);
          CLOSE c_Job;
          LEAVE WS_JOB_WAIT;
        END IF;

        -- Create the failed Job run record
        Insert into [METABASE].ws_wrk_job_run (
              wjr_job_key, wjr_sequence, wjr_restart, wjr_status, wjr_scheduled,
              wjr_started, wjr_completed, wjr_elapsed_hh, wjr_elapsed_mi,
              wjr_okay_count, wjr_info_count, wjr_warning_count, wjr_error_count,
              wjr_detail_count, wjr_chkp_count, wjr_chkp_number, wjr_name, wjr_user_key,
              wjr_max_threads, wjr_publish_okay, wjr_publish_fail, wjr_scheduler)
        Select
              wjc_job_key, :v_sequence, 0, 'F', current_timestamp, current_timestamp, current_timestamp, 0,0,
              0,0,0,0,0,wjc_chkp_count,0, wjc_name, wjc_user_key, wjc_max_threads,
              wjc_publish_okay, wjc_publish_fail, wjc_scheduler
        from [METABASE].ws_wrk_job_ctrl
        where wjc_job_key = :v_wjc_job_key;

        SET v_return_status = SQLCODE;

        IF v_return_status <> 0 THEN
          SET v_MsgText = 'Job ' || v_wjc_name ||
            ' unable to create record in ws_wrk_job_run table. ' ||
                                             ' No Action !!!';
          GET DIAGNOSTICS EXCEPTION 1 v_db_msg = MESSAGE_TEXT;
          SET v_db_code = SQLCODE;
          CALL [METABASE].WsWrkAudit('F', :v_wjc_name, :v_wjc_name, :v_sequence
              , :v_MsgText, :v_db_code, :v_db_msg, 0, :v_wjc_job_key);
          CLOSE c_Job;
          LEAVE WS_JOB_WAIT;
        END IF;

        --=====================================================
        -- Create All the Task records.
        -- Loop through all the tasks and add them. Initial state is Waiting.
        OPEN c_TaskCtrl;
        FETCH NEXT FROM c_TaskCtrl INTO
          v_wtc_task_key
        , v_wtc_job_key
        , v_wtc_obj_key
        , v_wtc_name
        , v_wtc_type
        , v_wtc_sequence
        , v_wtc_obj_type
        , v_wtc_action_type
        , v_wtc_order
        , v_wtc_order_a
        , v_wtc_order_b
        , v_wtc_order_c
        , v_wtc_run_status
        , v_wtc_audit_status
        , v_wtc_started
        , v_wtc_completed
        , v_wtc_avg_elapsed
        , v_wtc_avg_count
        , v_wtc_task_fatal
        , v_wtc_task_error
        , v_wtc_task_warning
        , v_wtc_task_info
        , v_wtc_task_okay
        , v_wtc_chkp_number
        , v_wtc_abort_level
        , v_wtc_action_ind;

        SET v_TaskFetch = SQLCODE;

        WHILE ( v_TaskFetch = 0 )
        DO

          Insert into [METABASE].ws_wrk_task_run (
                wtr_task_key, wtr_job_key, wtr_sequence, wtr_restart, wtr_run_status,
                wtr_audit_status, wtr_started, wtr_completed, wtr_elapsed_hh, wtr_elapsed_mi,
                wtr_info_count, wtr_warning_count, wtr_detail_count, wtr_return_msg, wtr_type,
                wtr_abort_level, wtr_chkp_number, wtr_name, wtr_obj_type, wtr_action_type,
                wtr_obj_key)
          Values (
                :v_wtc_task_key,
                :v_wtc_job_key,
                :v_sequence,0,'H',NULL,NULL,NULL,0,0,
                0,0,0,
                'Job dependency failure on job '||:v_parent_job_name,
                :v_wtc_type,
                :v_wtc_abort_level,
                :v_wtc_chkp_number,
                :v_wtc_name,
                :v_wtc_obj_type,
                :v_wtc_action_type,
                :v_wtc_obj_key
                );

          SET v_return_status = SQLCODE;

          IF v_return_status <> 0 THEN
            SET v_MsgText = 'Job ' ||v_wjc_name ||
              ' failed creating records in ws_wrk_task_run table. ' ||
              ' No Action !!!';
            GET DIAGNOSTICS EXCEPTION 1 v_db_msg = MESSAGE_TEXT;
            SET v_db_code = SQLCODE;
            CALL [METABASE].WsWrkAudit('F', :v_wjc_name, :v_wjc_name, :v_sequence
                , :v_MsgText, :v_db_code, :v_db_msg, 0, :v_wjc_job_key);
            CLOSE c_TaskCtrl;
            CLOSE c_Job;
            LEAVE WS_JOB_WAIT;
          END IF;


         SELECT 0 into :v_TaskFetch;
         FETCH NEXT FROM c_TaskCtrl INTO
            v_wtc_task_key
          , v_wtc_job_key
          , v_wtc_obj_key
          , v_wtc_name
          , v_wtc_type
          , v_wtc_sequence
          , v_wtc_obj_type
          , v_wtc_action_type
          , v_wtc_order
          , v_wtc_order_a
          , v_wtc_order_b
          , v_wtc_order_c
          , v_wtc_run_status
          , v_wtc_audit_status
          , v_wtc_started
          , v_wtc_completed
          , v_wtc_avg_elapsed
          , v_wtc_avg_count
          , v_wtc_task_fatal
          , v_wtc_task_error
          , v_wtc_task_warning
          , v_wtc_task_info
          , v_wtc_task_okay
          , v_wtc_chkp_number
          , v_wtc_abort_level
          , v_wtc_action_ind;

          SET v_TaskFetch = SQLCODE;
        END WHILE; -- End of Task ctrl cursor

        CLOSE c_TaskCtrl;

        IF v_wjc_type = 'O' THEN

          DELETE FROM [METABASE].ws_wrk_job_ctrl
          WHERE  wjc_job_key = :v_wjc_job_key;

          SET v_return_status = SQLCODE;

          DELETE FROM [METABASE].ws_wrk_task_ctrl
          WHERE  wtc_job_key = :v_wjc_job_key;

          SET v_return_status = SQLCODE;

        END IF;

        -- Provide a failure message
        SET v_MsgText = 'Job ' ||v_wjc_name ||
          ' failed dependency on job ' || v_parent_job_name;
        GET DIAGNOSTICS EXCEPTION 1 v_db_msg = MESSAGE_TEXT;
        SET v_db_code = SQLCODE;
        CALL [METABASE].WsWrkAudit('F', :v_wjc_name, :v_wjc_name, :v_sequence
            , :v_MsgText, :v_db_code, :v_db_msg, 0, :v_wjc_job_key);

        IF v_fail_cmd = 1 THEN
          SET p_result = -98;
        END IF;

        CLOSE c_Job;
        LEAVE WS_JOB_WAIT;

      END IF; -- End of fail a job

    END IF;

    SELECT 0 into :v_JobFetch;
    -- get the next job to consider for scheduling
    FETCH NEXT FROM c_Job INTO
      v_wjc_name
    , v_wjc_max_threads
    , v_wjc_job_key
    , v_wjc_sequence
    , v_wjc_start_after
    , v_now_timel
    , v_wjc_scheduler
    , v_wjc_type
    , v_wjc_start_hour
    , v_wjc_start_minute
    , v_cust_sa_hh
    , v_cust_sa_mm
    , v_cust_sb_hh
    , v_cust_sb_mm
    , v_cust_min
    , v_cust_days;

    SET v_JobFetch = SQLCODE;

  END WHILE; -- end of Jobs potentially available to process

  CLOSE c_Job;


  --=====================================================
  -- Loop through any potential restart jobs
  -- We will just take the first one
  --=====================================================
  OPEN c_Restart;
  FETCH NEXT FROM c_Restart INTO
    v_wjr_name
  , v_wjr_max_threads
  , v_wjr_sequence
  , v_wjr_job_key
  , v_wjr_scheduler;

  SET v_RestartFetch = SQLCODE;

  WHILE ( v_RestartFetch = 0 )
  DO

    --=====================================================
    -- See if we match on the requested scheduler
    --=====================================================
    IF ( v_wjr_scheduler is NULL )
    OR ( v_wjr_scheduler = p_sched_type )
    OR ( v_wjr_scheduler = p_sched_name )
    OR ( v_wjr_scheduler = 'WANY' And p_sched_type = 'WIN' )
    OR ( v_wjr_scheduler = 'UANY' And p_sched_type = 'UNIX' )
    OR ( v_wjr_scheduler = 'WANY' And v_windows = 0 )
    OR ( v_wjr_scheduler = 'UANY' And v_unix = 0 )
    THEN

      SELECT count(*)
      INTO :v_thread_count
      FROM [METABASE].ws_wrk_job_thread
      WHERE wjt_job_key = :v_wjr_job_key
      AND wjt_sequence = :v_wjr_sequence;

      IF v_thread_count = 0 THEN

        SET p_job_name = v_wjr_name;
        SET p_task_name = 'NO+JOB';
        SET p_restart_flag = 'RESTART';
        SET p_thread = v_wjr_max_threads;
        SET p_sequence = v_wjr_sequence;


        -- Set the job to pending if we plan to run it
        UPDATE [METABASE].ws_wrk_job_run
        SET    wjr_status = 'P'
        WHERE  wjr_job_key = :v_wjr_job_key
        AND    wjr_sequence = :v_wjr_sequence;

        SET p_result = 1;
        CLOSE c_Restart;
        LEAVE WS_JOB_WAIT;
      END IF;
    END IF;

    SELECT 0 into :v_RestartFetch;
    FETCH NEXT FROM c_Restart INTO
      v_wjr_name
    , v_wjr_max_threads
    , v_wjr_sequence
    , v_wjr_job_key
    , v_wjr_scheduler;

    SET v_RestartFetch = SQLCODE;

  END WHILE;

  CLOSE c_Restart;

END;
_PROCEDWSL_ Ws_Maintain_Indexes 
CREATE PROCEDURE [METABASE].Ws_Maintain_Indexes (
  IN  p_sequence        integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, IN  p_table_name      varchar(64)
, IN  p_parameter       varchar(4000)
, IN  p_index_name      varchar(64)
, IN  p_option          varchar(20)
, OUT p_result          integer)

WS_MAINTAIN_INDEXES:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    : Teradata
  -- Script Name  : ws_maintain_indexes
  -- Description  : Drop or create one or a group of indexes
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- WMR 30/08/2001 Ver 0.3.0.6  Added support for Primary Keys
  -- WMR 21/01/2002 Ver 1.0.0.0  Added support for Partitioned indexes
  -- WMR 20/03/2002 Ver 1.0.6.0  Added support for Parallel index builds
  -- WMR 02/12/2002 Ver 1.2.1.5  Fixed missing K on extents and added support for pct free
  -- WMR 24/12/2003 Ver 4.1.0.0  Added support for compressed indexes
  -- WMR 17/04/2004 Ver 4.1.0.0  Added support for compute statistics in index create
  -- WMR 15/05/2004 Ver 4.1.0.8  Added support for buffer pool options
  -- WMR 25/05/2004 Ver 4.1.0.8  Added support for pctfree column and function indexes
  -- WMR 23/07/2004 Ver 4.1.0.8  Added support p_parameter being passed in
  -- WMR 24/06/2005 Ver 4.1.2.11 Include the schema name in the create if flag set
  -- WMR 05/07/2005 Ver 4.1.2.13 Changed user_tab_partitions to all_tab_partitions
  -- AP  01/08/2006 Ver 5.5.0.5  Add Version Number as constant to all out messages
  --                             Add call to wswrkerror for each index as built
  -- JML 24/01/2008 Ver 5.6.3.1  Teradata version
  -- JML 05/11/2008 Ver 6.0.2.2  Missing METABASE database names added.
  -- RS  18/01/2016 Ver 6.8.5.2  Changed error handler
  -- HM  13/02/2019 Ver 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;       -- Step number
  DECLARE v_status_code              INTEGER;
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status                   INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_exists                   INTEGER;

  --=====================================================
  -- Exceptions
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Maintain_Indexes. ' || v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_result = -3;
    END;

  --=====================================================
  -- Initialize Variables and Constants
  --=====================================================
  SET v_ws_pro_version = '(8.4.1.0)';
  SET v_ws_obj_fact = 5;
  SET v_ws_obj_dim = 6;
  SET v_ws_obj_stage = 7;
  SET v_ws_obj_load = 8;
  SET v_ws_obj_agg = 9;
  SET v_ws_obj_index = 10;
  SET v_ws_obj_export = 13;
  SET v_ws_obj_view = 18;
  SET v_ws_obj_join = 20;
  SET v_ws_obj_retro = 21;
  SET v_ws_obj_retro_copy = 22;

  SET v_ws_act_drop = 1;
  SET v_ws_act_create = 2;
  SET v_ws_act_drop_all = 3;
  SET v_ws_act_pre_drop = 4;
  SET v_ws_act_load = 5;
  SET v_ws_act_update = 6;
  SET v_ws_act_execute = 7;
  SET v_ws_act_process = 8;
  SET v_ws_act_build = 9;
  SET v_ws_act_build_all = 10;
  SET v_ws_act_analyze = 11;
  SET v_ws_act_quick_analyze = 12;
  SET v_ws_act_statistics = 13;
  SET v_ws_act_quick_statistics = 14;

  SET v_step = 100;

  SET p_result = 1;
  SET v_status_code = 0;
  SET v_exists = 1;

  SET v_step = 200;

  --=====================================================
  -- See if an index name has been specified
  -- and if so look up the object key for that index
  -- otherwise Look up the object key for our table
  -- If we can't find it then we have an error
  --=====================================================

  IF (( p_index_name IS NOT NULL ) AND ( p_index_name  <> '' )) THEN

    SET v_step = 300;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = 'Invalid index name '|| p_index_name ||' in call to Ws_Maintain_Index';
          CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_result = -2;
          SET v_exists = 0;
        END;

      SET v_step = 400;

      SELECT oo_obj_key
           , oo_type_key
      INTO   :v_obj_key
           , :v_obj_type
      FROM   [METABASE].ws_obj_object
      WHERE  UPPER(oo_name) = UPPER(:p_index_name)
      ;

    END;

  ELSEIF (( p_table_name IS NOT NULL ) AND ( p_table_name <> '' )) THEN

    SET v_step = 500;

    BEGIN

      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = 'Invalid table name '|| p_table_name ||' in call to Ws_Maintain_Index';
          CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
          SET p_result = -2;
          SET v_exists = 0;
        END;

      SET v_step = 600;

      SELECT oo_obj_key
           , oo_type_key
      INTO   :v_obj_key
           , :v_obj_type
      FROM   [METABASE].ws_obj_object
      WHERE  UPPER(oo_name) = UPPER(:p_table_name)
      ;

    END;

  ELSE

    SET v_step = 700;

    SET v_MsgText = 'Either the name of an index or table must be specified '||
                    ' in a call to Ws_Maintain_Index.';

    CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
              , :v_msgtext, '', '', :p_task_id, :p_job_id);

    SET p_result = -2;
    LEAVE WS_MAINTAIN_INDEXES;

  END IF;

  SET v_step = 800;

  --=====================================================
  -- If index or table exists, then
  -- Process depending on the option selected.
  -- DROP, DROP ALL, BUILD, BUILD ALL
  --=====================================================
  IF ( v_exists = 1 ) THEN

    IF (( UPPER(p_option) = 'DROP' ) AND ( v_obj_type = v_ws_obj_index )) THEN

      SET v_step = 900;

      CALL [METABASE].Ws_Act_Drop(:p_sequence
                                , :v_obj_type
                                , :v_ws_act_drop
                                , :v_obj_key
                                , :p_job_name
                                , :p_task_name
                                , :p_job_id
                                , :p_task_id
                                , :v_return_msg
                                , :v_status_code
                                , :v_status);

    ELSEIF ( UPPER(p_option) = 'DROP ALL' ) THEN

      SET v_step = 1000;

      CALL [METABASE].Ws_Act_Drop_All(:p_sequence
                                    , :v_obj_type
                                    , :v_ws_act_drop
                                    , :v_obj_key
                                    , :p_job_name
                                    , :p_task_name
                                    , :p_job_id
                                    , :p_task_id
                                    , :v_return_msg
                                    , :v_status_code
                                    , :v_status);

    ELSEIF ( UPPER(p_option) = 'PRE DROP' ) THEN

      SET v_step = 1100;

      CALL [METABASE].Ws_Act_Pre_Drop(:p_sequence
                                    , :v_obj_type
                                    , :v_ws_act_drop
                                    , :v_obj_key
                                    , :p_job_name
                                    , :p_task_name
                                    , :p_job_id
                                    , :p_task_id
                                    , :v_return_msg
                                    , :v_status_code
                                    , :v_status);

    ELSEIF ( UPPER(p_option) = 'BUILD' ) THEN

      SET v_step = 1200;

      CALL [METABASE].Ws_Act_Build(:p_sequence
                                 , :v_obj_type
                                 , :v_ws_act_drop
                                 , :v_obj_key
                                 , :p_job_name
                                 , :p_task_name
                                 , :p_job_id
                                 , :p_task_id
                                 , :p_parameter
                                 , :v_return_msg
                                 , :v_status_code
                                 , :v_status);

    ELSEIF ( UPPER(p_option) = 'BUILD ALL' ) THEN

      SET v_step = 1300;

      CALL [METABASE].Ws_Act_Build_All(:p_sequence
                                     , :v_obj_type
                                     , :v_ws_act_drop
                                     , :v_obj_key
                                     , :p_job_name
                                     , :p_task_name
                                     , :p_job_id
                                     , :p_task_id
                                     , :p_parameter
                                     , :v_return_msg
                                     , :v_status_code
                                     , :v_status);

    ELSE

      SET v_step = 1400;

      SET v_MsgText = 'Invalid option '|| p_option ||
                      ' in call to Ws_Maintain_Index. '||
                      'Valid options are DROP (index specified), DROP ALL, PRE DROP, BUILD, and BUILD ALL';

      CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
                , :v_msgtext, '', '', :p_task_id, :p_job_id);

      SET p_result = -2;
      LEAVE WS_MAINTAIN_INDEXES;

    END IF;

    SET v_step = 1500;

    IF ( v_status_code < 1 ) THEN

      SET v_step = 1600;

      CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, '', '', :p_task_id, :p_job_id);

    END IF;

    SET p_result = 1;

  END IF;

END ws_maintain_indexes;
_PROCEDWSL_ Ws_Job_Restart 
CREATE PROCEDURE [METABASE].Ws_Job_Restart (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_restart_job      varchar(64)
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

Ws_Job_Restart:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Job_Restart
  -- Description         : Restarts a scheduled job
  -- Author              : Wayne Richmond
  -- Date                : 20/03/2002
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  20/03/2002   Version 1.0.6.0
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_sequence             INTEGER;
  DECLARE v_job_key                  INTEGER;
  DECLARE v_job_status               VARCHAR(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Restart. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************

  BEGIN

    DECLARE CONTINUE HANDLER
    FOR SQLEXCEPTION
    BEGIN

      SET v_job_key = 0;

    END;

    SELECT wjr_job_key
         , wjr_sequence
         , wjr_status
    INTO   :v_job_key
         , :v_job_sequence
         , :v_job_status
    FROM   [METABASE].ws_wrk_job_run
    WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(:p_restart_job))
    ;

  END;

  SET v_step = 200;

  --***********************************************************************
  -- If not running exit with that information
  --***********************************************************************
  IF ( COALESCE(v_job_key,0) = 0 ) THEN

    SET p_return_msg = 'Job '||p_restart_job||' is not in a running or Failed state. Cannot restart';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE Ws_Job_Restart;

  END IF;

  SET v_step = 300;

  --***********************************************************************
  -- If running then no need to restart
  --***********************************************************************
  IF ( v_job_status = 'R' ) THEN

    SET p_return_msg = 'Job '||p_restart_job||' is currently Running. Cannot restart';
    SET p_return_code = 'R';
    SET p_result = -1;

    LEAVE Ws_Job_Restart;

  END IF;

  SET v_step = 400;

  --***********************************************************************
  -- If not failed then no need to restart
  --***********************************************************************
  IF ( v_job_status NOT IN ('F','H') ) THEN

    SET p_return_msg = 'Job '||p_restart_job||' is currently in state '||v_job_status||'. Cannot restart';
    SET p_return_code = 'U';
    SET p_result = -2;

    LEAVE Ws_Job_Restart;

  END IF;

  SET v_step = 500;

  --***********************************************************************
  -- First remove any threads that failed and didn't clean up
  -- the restart won't work if it thinks threads are still active
  --***********************************************************************
  BEGIN

    DECLARE CONTINUE HANDLER
    FOR SQLEXCEPTION
    BEGIN

      SET v_step = 600;

    END;

    DELETE FROM [METABASE].ws_wrk_job_thread
    WHERE  wjt_job_key = :v_job_key
    AND    wjt_sequence = :v_job_sequence
    ;

  END;

  SET v_step = 700;

  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************
  BEGIN

    DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN

      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Failed to restart Job '||p_restart_job||' sequence '||CAST(v_job_sequence AS VARCHAR(10))||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);

      SET p_return_code = 'E';
      SET p_return_msg = v_msgtext;
      SET p_result = -2;

    END;

    UPDATE [METABASE].ws_wrk_job_run
    SET    wjr_status = 'W'
    WHERE  wjr_job_key = :v_job_key
    AND    wjr_sequence = :v_job_sequence
    AND    wjr_status IN ('H','F')
    ;

    SET p_return_code = 'S';
    SET p_return_msg = 'Job '||p_restart_job||' sequence '||CAST(v_job_sequence AS VARCHAR(10))||' restarted.';
    SET p_result = 1;

  END;

END;
_PROCEDWSL_ Ws_Sched_Status 
CREATE PROCEDURE [METABASE].Ws_Sched_Status(
  IN p_action          varchar(12)
, IN p_sched_type      varchar(12)
, IN p_sched_name      varchar(12)
, IN p_sched_host      varchar(64)
, IN p_sched_msg       varchar(256)
, IN p_sched_username  varchar(64)
, IN p_sched_interval  integer
, IN p_sched_version   integer
, IN p_sched_job_count integer
, OUT p_status         integer )

BEGIN

-- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

-- =============================================================================
-- DBMS Name 	      :	Teradata
-- Script Name 		:	ws_sched_status
-- Description 		:	Reports a schedulers status
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016
-- =============================================================================
-- Notes / History
--
-- WMR 05/04/2002 Version 1.0.7
-- WMR 29/10/2002 Version 1.2.1 Sql Server
-- WMR 16/10/2005 Version 5.0.0 Teradata port

  --=====================================================
  -- Variables
  --=====================================================

  DECLARE v_MsgText         varchar(256); -- Text in audit_trail
  DECLARE v_step            integer;  -- return code
  DECLARE v_result          integer;  -- return code
  DECLARE v_found           integer;  -- return code
  DECLARE v_return_status   integer;
  DECLARE v_row_count       integer;
  DECLARE v_db_code         varchar(10);   -- Database error code
  DECLARE v_db_msg          varchar(100);  -- Database error message

  DECLARE v_ws_stop_date    timestamp;
  DECLARE v_ws_active_date  timestamp;
-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  --=====================================================
  -- Read in any existing record for this scheduler.
  --=====================================================
  SET v_step = 10;
  SET p_status = -2;
  SELECT
    ws_active_date
  , ws_stop_date
  INTO
    :v_ws_active_date
  , :v_ws_stop_date
  From [METABASE].ws_wrk_scheduler
  Where ws_name = :p_sched_name;

  SET v_row_count = ACTIVITY_COUNT;

  --=====================================================
  -- See what our action is
  --=====================================================
  SET v_step = 15;

  --=====================================================
  -- If the scheduler record did not exist then create it
  --=====================================================
  IF v_row_count = 0 THEN
    SET v_step = 20;
    INSERT into [METABASE].ws_wrk_scheduler (
        ws_type_ind,
        ws_name,
        ws_host,
        ws_username,
        ws_start_date,
        ws_active_date,
        ws_stop_date,
        ws_stop_msg,
        ws_job_count,
        ws_interval,
        ws_version,
        ws_poll_flag,
        ws_shut_flag
        ) values (
        upper(substr(:p_sched_type,1,1)),
        :p_sched_name,
        :p_sched_host,
        :p_sched_username,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        NULL,
        :p_sched_msg,
        NULL,
        :p_sched_interval,
        :p_sched_version,
        0,
        0
        );
      SET p_status = 1;

    --=====================================================
    -- Scheduler record exists.
    -- See if we are updating the active time or are
    -- a new iteration for this scheduler
    --=====================================================
    ELSE
      SET v_step = 30;
      --=====================================================
      -- If we have a stop date or more than .01 of a day (14.4 minutes)
      -- since the last active date then assume a new version
      --=====================================================
      IF v_ws_stop_date IS NOT NULL
--      OR DATEDIFF(mi,@v_ws_active_date,GETDATE()) > 15
      THEN
        SET v_step = 40;
        IF p_action = 'STOP' THEN

          UPDATE [METABASE].ws_wrk_scheduler Set
              ws_stop_date = CURRENT_TIMESTAMP,
              ws_stop_msg = :p_sched_msg,
              ws_start_date = CURRENT_TIMESTAMP,
              ws_active_date = CURRENT_TIMESTAMP,
              ws_type_ind = upper(substr(:p_sched_type,1,1)),
              ws_host = :p_sched_host,
              ws_username = :p_sched_username,
              ws_version = :p_sched_version,
              ws_job_count = 0,
              ws_interval = :p_sched_interval,
              ws_poll_flag = 0,
              ws_shut_flag = 0
          Where ws_name = :p_sched_name;
        ELSE
           UPDATE [METABASE].ws_wrk_scheduler Set
              ws_stop_date = NULL,
              ws_stop_msg = :p_sched_msg,
              ws_start_date = CURRENT_TIMESTAMP,
              ws_active_date = CURRENT_TIMESTAMP,
              ws_type_ind = upper(substr(:p_sched_type,1,1)),
              ws_host = :p_sched_host,
              ws_username = :p_sched_username,
              ws_version = :p_sched_version,
              ws_job_count = 0,
              ws_interval = :p_sched_interval,
              ws_poll_flag = 0,
              ws_shut_flag = 0
          Where ws_name = :p_sched_name;
       END IF;

        SET p_status = 1;
      ELSE
        IF p_action = 'STOP' THEN
          UPDATE [METABASE].ws_wrk_scheduler Set
              ws_stop_date = CURRENT_TIMESTAMP,
              ws_stop_msg = :p_sched_msg,
              ws_active_date = CURRENT_TIMESTAMP,
              ws_type_ind = upper(substr(:p_sched_type,1,1)),
              ws_host = :p_sched_host,
              ws_username = :p_sched_username,
              ws_version = :p_sched_version,
              ws_job_count = 0,
              ws_interval = :p_sched_interval,
              ws_poll_flag = 0
          Where ws_name = :p_sched_name;
        ELSE
          UPDATE [METABASE].ws_wrk_scheduler Set
              ws_stop_date = NULL,
              ws_stop_msg = :p_sched_msg,
              ws_active_date = CURRENT_TIMESTAMP,
              ws_type_ind = upper(substr(:p_sched_type,1,1)),
              ws_host = :p_sched_host,
              ws_username = :p_sched_username,
              ws_version = :p_sched_version,
              ws_job_count = 0,
              ws_interval = :p_sched_interval,
              ws_poll_flag = 0
          Where ws_name = :p_sched_name;
        END IF;
        SET p_status = 1;
      END IF;
    END IF;



END;

_PROCEDWSL_ Ws_Api_Glossary 
CREATE PROCEDURE [METABASE].Ws_Api_Glossary
( IN  p_object_name  VARCHAR(64)
, IN  p_term         VARCHAR(256)
, IN  p_comments     VARCHAR(4000)
, IN  p_option       VARCHAR(64)
, OUT p_result       VARCHAR(1024))

Ws_Api_Glossary:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Api_Glossary
  -- Description         : Add elements to the ws_doc_glossary table
  -- Author              : Wayne Richmond
  -- Date                : 25/06/2002
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  25/06/2002   Version 1.2.0.0
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================


  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Api_Glossary. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_result = v_msgtext;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  -- =========================================================================
  -- Options are to insert or delete
  -- =========================================================================
  IF ( UPPER(p_option) = 'ADD' ) THEN

    SET v_step = 200;

    INSERT INTO [METABASE].ws_doc_glossary
    ( dg_object_name
    , dg_term
    , dg_comments )
    VALUES
    ( SUBSTR(:p_object_name,1,64)
    , SUBSTR(:p_term,1,256)
    , SUBSTR(:p_comments,1,4000))
    ;

    SET v_step = 300;

    SET v_result = p_object_name || ' element inserted';

  ELSEIF ( UPPER(p_option) = 'DELETE' ) THEN

    SET v_step = 400;

    DELETE FROM [METABASE].ws_doc_glossary
    WHERE  dg_object_name = SUBSTR(:p_object_name,1,64)
    AND    dg_term = SUBSTR(:p_term,1,256)
    ;

    SET v_step = 500;

    SET v_result = p_object_name || ' element deleted';

  ELSE

    SET v_step = 600;

    SET v_result = 'Invalid option ' || p_option || '. Valid options are ADD or DELETE';

  END IF;

  SET v_step = 700;

  SET p_result = v_result;

END;
_PROCEDWSL_ Ws_Job_Schedule 
CREATE PROCEDURE [METABASE].Ws_Job_Schedule (
  IN  p_sequence         INTEGER
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, IN  p_release_job      VARCHAR(64)
, IN  p_release_time     TIMESTAMP
, OUT p_return_code      VARCHAR(1)
, OUT p_return_msg       VARCHAR(1024)
, OUT p_result           INTEGER)

Ws_Job_Schedule:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Job_Schedule
  -- Description         : Releases a held or waiting job to run at a specified time
  -- Author              : Wayne Richmond
  -- Date                : 18/10/2004
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  18/10/2004   Version 4.1.1.2  Created from Ws_Job_Release
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_sequence             INTEGER ;
  DECLARE v_job_key                  INTEGER ;
  DECLARE v_job_status               VARCHAR(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Schedule. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************

  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_job_key = 0;

      END;

    SELECT wjc_job_key
         , wjc_sequence
         , wjc_status
    INTO   :v_job_key
         , :v_job_sequence
         , :v_job_status
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_release_job));

  END;

  SET v_step = 200;

  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************

  IF ( COALESCE(v_job_key,0) = 0 ) THEN

    SET p_return_msg = 'Job ' || p_release_job || ' is not in a holding or waiting state. Cannot reschedule';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE Ws_Job_Schedule;

  END IF;

  SET v_step = 300;

  --***********************************************************************
  -- Set the flag to indicate that the job is waiting so the
  -- scheduler will restart it
  --***********************************************************************

  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = SUBSTR('Failed to reschedule Job ' || p_release_job ||
            '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
        CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
        SET p_return_msg = v_msgtext;
        SET p_return_code = 'E';
        SET p_result = -2;
      END;

    UPDATE [METABASE].ws_wrk_job_ctrl
    SET    wjc_status = 'W'
         , wjc_start_after = :p_release_time
    WHERE  wjc_job_key = :v_job_key
    AND    wjc_status in ('H','W');

    SET p_return_code = 'S';
    SET p_return_msg = 'Job ' || p_release_job || ' rescheduled. It Will start at ' || CAST(p_release_time AS VARCHAR(18));
    SET p_result = 1;

  END;

END;
_PROCEDWSL_ Ws_Job_Release 
CREATE PROCEDURE [METABASE].Ws_Job_Release (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_release_job      varchar(64)
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

Ws_Job_Release:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Job_Release
  -- Description         : Releases a held or waiting job
  -- Author              : Wayne Richmond
  -- Date                : 20/03/2002
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  20/03/2002   Version 1.0.6.0
  -- WMR  06/11/2002   Version 1.2.1.5  SQL Server port
  -- JML  17/11/2005   Version 5.0.0.0  Teradata port
  -- JML  09/04/2008   Version 6.0.0.0  Standardized Header, Variables, Exception
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_sequence             INTEGER;
  DECLARE v_job_key                  INTEGER;
  DECLARE v_job_status               VARCHAR(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Release. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = -3;
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 10;

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************

  BEGIN

    DECLARE CONTINUE HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Failure when reading job record';
      CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET v_job_key = 0;
    END;

    SELECT wjc_job_key
         , wjc_sequence
         , wjc_status
    INTO   :v_job_key
         , :v_job_sequence
         , :v_job_status
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_release_job));

  END;

  SET v_step = 20;
  --***********************************************************************
  -- IF not running exit with that information
  --***********************************************************************
  IF COALESCE(v_job_key,0) = 0 THEN

    SET p_return_msg = 'Job ' || p_release_job || ' is not in a holding or waiting state. Cannot release';
    SET p_return_code = 'N';
    SET p_result = -1;

  ELSE

    SET v_step = 60;
    --***********************************************************************
    -- Set the flag to indicate that the job is waiting so the
    -- scheduler will restart it
    --***********************************************************************

    BEGIN

      DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = 'Failure when releasing job';
        CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
        SET p_return_code = 'E';
        SET v_msgtext = SUBSTR('Failed to release Job ' || p_release_job || ' ' || v_sql_error,1,1023);
        SET p_return_msg = v_msgtext;
        SET p_result = -2;
      END;

      UPDATE [METABASE].ws_wrk_job_ctrl
      SET    wjc_status = 'W'
           , wjc_start_after = CURRENT_TIMESTAMP
      WHERE  wjc_job_key = :v_job_key
      AND    wjc_status in ('H','W');

      SET p_return_code = 'S';
      SET p_return_msg = 'Job ' || p_release_job || ' released.';
      SET p_result = 1;

    END;

  END IF;

END;
_PROCEDWSL_ Ws_Job_Create 
CREATE PROCEDURE [METABASE].Ws_Job_Create (
  IN  p_sequence         INTEGER
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, IN  p_template_job     VARCHAR(64)
, IN  p_new_job          VARCHAR(64)
, IN  p_description      VARCHAR(256)
, IN  p_state            VARCHAR(10)
, IN  p_threads          INTEGER
, IN  p_scheduler        VARCHAR(8)
, IN  p_logs             INTEGER
, IN  p_okay             VARCHAR(256)
, IN  p_fail             VARCHAR(256)
, IN  p_att1             VARCHAR(4000)
, IN  p_att2             VARCHAR(4000)
, IN  p_att3             VARCHAR(4000)
, IN  p_att4             VARCHAR(4000)
, IN  p_att5             VARCHAR(4000)
, IN  p_att6             VARCHAR(4000)
, IN  p_att7             VARCHAR(4000)
, IN  p_att8             VARCHAR(4000)
, OUT p_return_code      VARCHAR(1)
, OUT p_return_msg       VARCHAR(1024)
, OUT p_result           INTEGER)

Ws_Job_Create:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Job_Create
  -- Description         : Releases a held or waiting job
  -- Author              : Wayne Richmond
  -- Date                : 23/04/2004
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  23/04/2004   Version 4.1.0.8
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- KH    1/11/2018   Version 8.3.1.0  RED-9838 wtc_action_ind added to task copy row.
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_sequence             INTEGER;
  DECLARE v_job_key                  INTEGER;
  DECLARE v_job_status               VARCHAR(1);
  DECLARE v_old_key                  INTEGER;
  DECLARE v_old_sequence             INTEGER;
  DECLARE v_old_status               VARCHAR(1);
  DECLARE v_new_key                  INTEGER;
  DECLARE v_new_sequence             INTEGER;
  DECLARE v_wjc_status               VARCHAR(1);
  DECLARE v_wjc_type                 VARCHAR(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Create. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET p_return_msg = 'Unhandled Exception in Ws_Job_Create.';
  SET p_return_code = 'F';
  SET p_result = -3;

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_old_key = 0;

      END;

    SET v_step = 200;

    SELECT wjc_job_key
         , wjc_sequence
         , wjc_status
    INTO   :v_old_key
         , :v_old_sequence
         , :v_old_status
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_template_job))
    ;

  END;

  SET v_step = 300;

  --***********************************************************************
  -- If not scheduled exit with that information
  --***********************************************************************

  IF ( COALESCE(v_old_key,0) = 0 ) THEN

    SET p_return_msg = 'Job ' || p_template_job || ' is not in a holding or waiting state. Cannot create new job';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE Ws_Job_Create;

  END IF;

  SET v_step = 400;

  --***********************************************************************
  -- Make sure we have no job that matches our new job name
  --***********************************************************************

  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_count = 1;

      END;

      SET v_step = 500;

      SELECT COUNT(*)
      INTO   :v_count
      FROM   [METABASE].ws_wrk_job_ctrl
      WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_new_job))
      ;

  END;

  SET v_step = 600;

  IF ( v_count > 0 ) THEN

    SET p_return_msg = 'Job ' || p_new_job || ' already exists. Cannot create a new job of the same name';
    SET p_return_code = 'P';
    SET p_result = -1;

    LEAVE Ws_Job_Create;

  END IF;

  SET v_step = 700;

  --***********************************************************************
  -- Get the right state for the new job and the sequence
  --***********************************************************************

  IF ( TRIM(UPPER(p_state)) = 'ONCE' ) THEN

    SET v_wjc_status = 'W';
    SET v_wjc_type = 'O';

  ELSEIF ( TRIM(UPPER(p_state)) = 'ONCE+HOLD' ) THEN

    SET v_wjc_status = 'W';
    SET v_wjc_type = 'S';

  ELSE

    SET v_wjc_status = 'H';
    SET v_wjc_type = 'H';

  END IF;

  SET v_step = 800;

  --***********************************************************************
  -- Get the job sequence for the new job
  --***********************************************************************

  INSERT INTO [METABASE].ws_wrk_sequence
  ( ws_sequence
  , ws_date
  , ws_session)
  VALUES
  ( NULL
  , CURRENT_TIMESTAMP
  , SESSION)
  ;

  SET v_step = 900;

  SELECT MAX(ws_sequence)
  INTO   :v_new_sequence
  FROM   [METABASE].ws_wrk_sequence
  WHERE  ws_session = SESSION
  ;

  SET v_step = 1000;

  --***********************************************************************
  -- Add the new job in a held state, so that we can add the tasks/dependencies
  --***********************************************************************

  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = SUBSTR('Failed to create Job ' || p_new_job ||
            '. Step ' || CAST(v_step AS VARCHAR(64)) ||
            '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
        SET p_return_msg = v_msgtext;
        SET p_return_code = 'E';
        SET p_result = -2;
      END;

    SET v_step = 1100;

    BT;

    INSERT INTO [METABASE].ws_wrk_job_ctrl
    ( wjc_job_key
    , wjc_name
    , wjc_description
    , wjc_sequence
    , wjc_group_key
    , wjc_project_key
    , wjc_status
    , wjc_last_status
    , wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , wjc_start_after
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , wjc_avg_count
    , wjc_publish_okay
    , wjc_publish_fail
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , wjc_max_threads
    , wjc_priority
    , wjc_publish_flag
    , wjc_scheduler
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    )
    SELECT :v_new_sequence
         , :p_new_job
         , COALESCE(:p_description,wjc_description)
         , :v_new_sequence
         , wjc_group_key
         , wjc_project_key
         , 'H'
         , wjc_last_status
         , :v_wjc_type
         , wjc_submitted
         , wjc_first_schedule
         , wjc_start_hour
         , wjc_start_minute
         , wjc_start_day
         , wjc_user_key
         , CURRENT_TIMESTAMP
         , wjc_started
         , wjc_completed
         , wjc_max_elapsed
         , wjc_task_elapsed
         , wjc_avg_elapsed
         , COALESCE(:p_logs,wjc_avg_count)
         , COALESCE(:p_okay,wjc_publish_okay)
         , COALESCE(:p_fail,wjc_publish_fail)
         , wjc_task_fatal
         , wjc_task_error
         , wjc_task_warning
         , wjc_task_info
         , wjc_task_okay
         , wjc_chkp_count
         , COALESCE(:p_threads,wjc_max_threads)
         , wjc_priority
         , wjc_publish_flag
         , COALESCE(:p_scheduler,wjc_scheduler)
         , wjc_cust_sa_hh
         , wjc_cust_sa_mm
         , wjc_cust_sb_hh
         , wjc_cust_sb_mm
         , wjc_cust_min
         , wjc_cust_days
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  wjc_job_key = :v_old_key
    AND    wjc_status IN ('H','W')
    ;

    SET v_step = 1200;

    --***********************************************************************
    -- Add all the tasks
    --***********************************************************************
    INSERT INTO [METABASE].ws_wrk_task_ctrl
    ( wtc_task_key
    , wtc_job_key
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , wtc_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , wtc_action_ind
    )
    SELECT NULL
         , :v_new_sequence
         , wtc_obj_key
         , wtc_name
         , wtc_type
         , :v_new_sequence
         , wtc_obj_type
         , wtc_action_type
         , wtc_order
         , wtc_order_a
         , wtc_order_b
         , wtc_order_c
         , wtc_run_status
         , wtc_audit_status
         , wtc_started
         , wtc_completed
         , wtc_avg_elapsed
         , wtc_avg_count
         , wtc_task_fatal
         , wtc_task_error
         , wtc_task_warning
         , wtc_task_info
         , wtc_task_okay
         , wtc_chkp_number
         , wtc_abort_level
         , wtc_action_ind
    FROM   [METABASE].ws_wrk_task_ctrl
    WHERE  wtc_job_key = :v_old_key
    ;

    SET v_step = 1300;

    --***********************************************************************
    -- Add all the dependencies
    --***********************************************************************

    INSERT INTO [METABASE].ws_wrk_dependency
    ( wdp_job_key
    , wdp_parent_task_key
    , wdp_child_task_key
    )
    SELECT :v_new_sequence
         , b_new.wtc_task_key
         , c_new.wtc_task_key
    FROM   [METABASE].ws_wrk_dependency a
    JOIN   [METABASE].ws_wrk_task_ctrl b_old
    ON     a.wdp_parent_task_key = b_old.wtc_task_key
    JOIN   [METABASE].ws_wrk_task_ctrl c_old
    ON     a.wdp_child_task_key = c_old.wtc_task_key
    JOIN   [METABASE].ws_wrk_task_ctrl b_new
    ON     b_old.wtc_order = b_new.wtc_order
    JOIN   [METABASE].ws_wrk_task_ctrl c_new
    ON     c_old.wtc_order = c_new.wtc_order
    WHERE  a.wdp_job_key = :v_old_key
    AND    b_new.wtc_job_key = :v_new_sequence
    AND    c_new.wtc_job_key = :v_new_sequence
    ;

    SET v_step = 1400;

    --***********************************************************************
    -- Set the job to the request state
    --***********************************************************************

    UPDATE [METABASE].ws_wrk_job_ctrl
    SET    wjc_status = :v_wjc_status
    WHERE  wjc_job_key = :v_new_sequence
    AND    wjc_sequence = :v_new_sequence
    ;

    ET;

    SET p_return_code = 'S';
    SET p_return_msg = 'Job ' || p_new_job || ' created.';
    SET p_result = 1;

    LEAVE Ws_Job_Create;

  END;

  SET v_step = 1500;

END;
_PROCEDWSL_ Ws_Load_Change 
CREATE PROCEDURE [METABASE].Ws_Load_Change (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_action           varchar(64)
, IN  p_table            varchar(64)
, IN  p_new_value        varchar(255)
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer
)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		:	Teradata
  -- Script Name 	:	ws_load_change
  -- Description 	:	Changes the connection or database/schema of a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- JML 12/07/2007   Version 5.6.0.7
  -- MXU 02/04/2014   Version 6.8.1.1  RED-1242 Add source table alias
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext         varchar(1024); -- Text in audit_trail
  DECLARE v_step            integer;       -- return code
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar

  DECLARE v_result          integer;       -- return code
  DECLARE v_action          integer;
  DECLARE v_load_obj_key    integer;
  DECLARE v_source_table    varchar(4000);
  DECLARE v_from_tables     varchar(4000);
  DECLARE v_work            varchar(4000);
  DECLARE v_tables          integer;
  DECLARE v_spos            integer;
  DECLARE v_cpos            integer;
  DECLARE v_ppos            integer;

  DECLARE v_old_connect     varchar(256);
  DECLARE v_old_connect_key integer;
  DECLARE v_old_database    varchar(256);
  DECLARE v_old_host        varchar(256);
  DECLARE v_old_load_type   varchar(1);
  DECLARE v_old_schema      varchar(256);
  DECLARE v_old_transform   varchar(1);
  DECLARE v_old_value       varchar(256);

  DECLARE v_new_connect_key integer;
  DECLARE v_new_database    varchar(256);
  DECLARE v_new_host        varchar(256);
  DECLARE v_new_load_type   varchar(1);
  DECLARE v_new_schema      varchar(256);
  DECLARE v_new_transform   varchar(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Load_Change. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      SET p_return_code = -3;
      SET p_result = -3;
    END;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2016

  SET v_step = 100;

  --***********************************************************************
  -- Initialize Variables
  --***********************************************************************
  SET v_load_obj_key = 0;
  SET v_old_connect_key = 0;
  SET v_new_connect_key = 0;
  SET v_tables = 0;
  SET v_spos = 0;
  SET v_cpos = 0;
  SET v_ppos = 0;

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************

  SET v_step = 200;

  IF (( UPPER(p_action) <> 'SCHEMA' )
       AND ( UPPER(p_action) <> 'DATABASE' )
       AND ( UPPER(p_action) <> 'CONNECTION' )) THEN

    SET v_step = 300;

    SET p_return_code = 'E';
    SET v_msgtext = 'Invalid action code. Valid actions are SCHEMA, DATABASE or CONNECTION.';
    SET p_return_msg = v_msgtext;
    CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, NULL, NULL, :p_task_id, :p_job_id);
    SET p_result = -2;

  ELSE

    SET v_step = 400;

    IF (( UPPER(p_action) = 'SCHEMA' ) OR ( UPPER(p_action) = 'DATABASE' )) THEN

      SET v_step = 500;

      SET v_action = 1;

    END IF;

    SET v_step = 600;

    IF ( UPPER(p_action) = 'CONNECTION' ) THEN

      SET v_step = 700;

      SET v_action = 2;

    END IF;

    --***********************************************************************
    -- Get the info for the load table
    --***********************************************************************

    SET v_step = 800;

    BEGIN

      DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET p_return_code = 'E';
        SET v_msgtext = 'Failed to get info for load table '||p_table||' '||v_sql_error;
        SET p_return_msg = v_msgtext;
        CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
            , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
        SET p_result = -2;
      END;

      SET v_step = 900;

      SELECT lt_obj_key
           , lt_connect_key
           , lt_source_schema
           , lt_source_table
           , lt_type
           , lt_transform_ind
           , dc_name
           , dc_database_id
           , dc_host_id
      INTO   :v_load_obj_key
           , :v_old_connect_key
           , :v_old_schema
           , :v_source_table
           , :v_old_load_type
           , :v_old_transform
           , :v_old_connect
           , :v_old_database
           , :v_old_host
      FROM [METABASE].ws_load_tab
      LEFT OUTER JOIN [METABASE].ws_dbc_connect
      ON lt_connect_key = dc_obj_key
      WHERE UPPER(lt_table_name) = UPPER(:p_table);

    END;

    IF ( v_load_obj_key = 0 ) THEN

      SET v_step = 1000;

      SET p_return_code = 'E';
      SET v_msgtext = 'Failed to find load table '||p_table;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, NULL, NULL, :p_task_id, :p_job_id);
      SET p_result = -2;

    ELSE

      --***********************************************************************
      -- If a connection change then get the new connect info
      --***********************************************************************

      SET v_step = 1100;

      IF ( v_action = 2 ) THEN

        BEGIN

          DECLARE EXIT HANDLER
          FOR SQLEXCEPTION
          BEGIN
            GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
            SET v_sql_code = SQLCODE;
            SET p_return_code = 'E';
            SET v_msgtext = 'Failed to get info for connection '||p_new_value||' '||v_sql_error;
            SET p_return_msg = v_msgtext;
            CALL [METABASE].WsWrkAudit('E', :p_job_name, :p_task_name, :p_sequence
                , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
            SET p_result = -2;
          END;

          SET v_step = 1200;

          SELECT dc_obj_key
               , dc_type
               , dc_database_id
               , dc_host_id
          INTO   :v_new_connect_key
               , :v_new_load_type
               , :v_new_database
               , :v_new_host
          FROM   [METABASE].ws_dbc_connect
          WHERE  UPPER(dc_name) = UPPER(:p_new_value);

          SET v_step = 1300;

          IF ( v_new_load_type = 'O' ) THEN

            SET v_step = 1400;

            SET v_new_transform = 'Y';

          ELSE

            SET v_step = 1500;

            SET v_new_transform = v_old_transform;

          END IF;

        END;

      ELSE

        SET v_step = 1600;

        SET v_new_connect_key = v_old_connect_key;
        SET v_new_load_type = v_old_load_type;
        SET v_new_database = v_old_database;
        SET v_new_host = v_old_host;
        SET v_new_transform = v_old_transform;

      END IF;

      --***********************************************************************
      -- If a schema change then get ready for it
      --***********************************************************************

      SET v_step = 1700;

      IF ( v_action = 1 ) THEN

        SET v_step = 1800;

        SET v_new_schema = p_new_value;
        SET v_old_value = v_old_schema;

      ELSE

        SET v_step = 1900;

        SET v_new_schema = v_old_schema;
        SET v_old_value = v_old_connect;

      END IF;

      --***********************************************************************
      -- Now fix up the from tables
      -- Code logic acquired from med application in LoaReconnect
      --***********************************************************************

      SET v_step = 2000;

      IF ( v_new_schema IS NOT NULL ) THEN

        SET v_step = 2100;

        SET v_from_tables = '';
        SET v_work = TRIM(v_source_table);
        SET v_tables = 0;
        SET v_cpos = INDEX(v_work,',');

        SET v_step = 2200;

        WHILE ( v_cpos > 0 )
        DO

          SET v_step = 2300;

          SET v_cpos = INDEX(v_work,',');

          SET v_step = 2400;

          IF ( v_cpos > 0 ) THEN

            SET v_step = 2500;

            SET v_tables = v_tables + 1;

            SET v_step = 2600;

            IF ( v_tables > 1 ) THEN

              SET v_step = 2700;

              SET v_from_tables = v_from_tables || ',';

            END IF;

            SET v_step = 2800;

            SET v_spos = INDEX(v_work,'.');

            SET v_step = 2900;

            IF (( v_spos >= v_cpos ) OR ( v_spos <= 0 )) THEN

              SET v_step = 3000;

              SET v_from_tables = v_from_tables || v_new_schema || '.';

            END IF;

            SET v_step = 3100;

            SET v_from_tables = v_from_tables || SUBSTR(v_work,1,v_cpos-1);

            SET v_step = 3200;
            -- RED-1242: Add source table alias
            IF ( INDEX(TRIM(SUBSTR(v_work,1,v_cpos-1)),' ') <= 0 ) THEN
              SET v_from_tables = v_from_tables || ' ' || SUBSTR(v_work,1,v_cpos-1);
            END IF;

            SET v_work = TRIM(SUBSTR(v_work,v_cpos+1));

          END IF;

        END WHILE;

        SET v_step = 3300;

        IF ( v_work IS NOT NULL ) THEN

          SET v_step = 3400;

          SET v_tables = v_tables + 1;

          SET v_step = 3500;

          IF ( v_tables > 1 ) THEN

            SET v_step = 3600;

            SET v_from_tables = v_from_tables || ',';

          END IF;

          SET v_step = 3700;

          SET v_spos = INDEX(v_work,'.');

          SET v_step = 3800;

          IF ( v_spos <= 0 ) THEN

            SET v_step = 3900;

            SET v_from_tables = v_from_tables || v_new_schema || '.';

          END IF;

          SET v_step = 4000;

          SET v_cpos = CHAR(v_work);

          SET v_step = 4100;

          SET v_from_tables = v_from_tables || v_work;
          -- RED-1242: Add source table alias
          IF ( INDEX(v_work,' ') <= 0 ) THEN
            SET v_from_tables = v_from_tables || ' ' || v_work;
          END IF;

        END IF;

      ELSE

        SET v_step = 4200;

        SET v_from_tables = v_source_table;

      END IF;

      --***********************************************************************
      -- Update the load table
      --***********************************************************************

      SET v_step = 4300;

      UPDATE [METABASE].ws_load_tab
      SET    lt_connect_key = :v_new_connect_key
           , lt_source_schema = :v_new_schema
           , lt_from_table = :v_from_tables
           , lt_transform_ind = :v_new_transform
           , lt_type = :v_new_load_type
      WHERE  lt_obj_key = :v_load_obj_key;

      SET v_step = 4400;

      SET p_return_code = 'S';
      SET v_msgtext = p_action || ' changed from '||v_old_value||' to '||p_new_value||
        ' for load table '||p_table;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_job_name, :p_sequence
        , :v_msgtext, NULL, NULL, :p_task_id, :p_job_id);
      SET p_result = 1;

    END IF;

  END IF;

END;
_PROCEDWSL_ Ws_Connect_Replace 
CREATE PROCEDURE [METABASE].Ws_Connect_Replace (
  IN  p_sequence     INTEGER
, IN  p_job_name     VARCHAR(64)
, IN  p_task_name    VARCHAR(64)
, IN  p_job_id       INTEGER
, IN  p_task_id      INTEGER
, IN  p_action       VARCHAR(64)
, IN  p_source       VARCHAR(64)
, IN  p_target       VARCHAR(64)
, OUT p_return_code  VARCHAR(1)
, OUT p_return_msg   VARCHAR(1024)
, OUT p_result       INTEGER)

Ws_Connect_Replace:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Connect_Replace
  -- Description         : Copies the contents of one connection to another
  -- Author              : Wayne Richmond
  -- Date                : 07/01/2006
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  07/01/2006   Version 5.0.0.2  First version (Oracle)
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   26/05/2014   Version 6.8.0.1  Changed to reflect new WS_DB_Connect column sizes
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- AD   24/04/2018   Version 8.2.1.0  Fix not updating Database Type in target connection
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_dc_obj_key               INTEGER;
  DECLARE v_dc_type                  VARCHAR(1);
  DECLARE v_dc_method                VARCHAR(64);
  DECLARE v_dc_host_id               VARCHAR(64);
  DECLARE v_dc_dblink_id             VARCHAR(1024);
  DECLARE v_dc_database_id           VARCHAR(1024);
  DECLARE v_dc_odbc_source           VARCHAR(64);
  DECLARE v_dc_extract_userid        VARCHAR(1024);
  DECLARE v_dc_extract_pwd           VARCHAR(1024);
  DECLARE v_dc_admin_userid          VARCHAR(1024);
  DECLARE v_dc_admin_pwd             VARCHAR(1024);
  DECLARE v_dc_work_dir              VARCHAR(256);
  DECLARE v_dc_database_home         VARCHAR(256);
  DECLARE v_dc_pre_login_act         VARCHAR(64);
  DECLARE v_dc_login_prompt          VARCHAR(64);
  DECLARE v_dc_password_prompt       VARCHAR(64);
  DECLARE v_dc_post_login_act        VARCHAR(64);
  DECLARE v_dc_command_prompt        VARCHAR(64);
  DECLARE v_dc_telnet_attributes     VARCHAR(4000);
  DECLARE v_dc_attributes            VARCHAR(4000);
  DECLARE v_dc_connect_string        VARCHAR(4000);
  DECLARE v_dc_server                VARCHAR(4000);
  DECLARE v_dc_doc_1                 VARCHAR(4000);
  DECLARE v_dc_doc_2                 VARCHAR(4000);
  DECLARE v_dc_doc_3                 VARCHAR(4000);
  DECLARE v_dc_doc_4                 VARCHAR(4000);
  DECLARE v_dc_doc_5                 VARCHAR(4000);
  DECLARE v_dc_doc_6                 VARCHAR(4000);
  DECLARE v_dc_doc_7                 VARCHAR(4000);
  DECLARE v_dc_doc_8                 VARCHAR(4000);
  DECLARE v_dc_doc_9                 VARCHAR(4000);
  DECLARE v_dc_doc_10                VARCHAR(4000);
  DECLARE v_dc_doc_11                VARCHAR(4000);
  DECLARE v_dc_doc_12                VARCHAR(4000);
  DECLARE v_dc_doc_13                VARCHAR(4000);
  DECLARE v_dc_doc_14                VARCHAR(4000);
  DECLARE v_dc_doc_15                VARCHAR(4000);
  DECLARE v_dc_doc_16                VARCHAR(4000);
  DECLARE v_dc_wizard_set_key        INTEGER;
  DECLARE v_dc_db_type_ind           INTEGER;
  DECLARE v_dc_authentication        VARCHAR(4000);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Connect_Replace. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --***********************************************************************
  -- Ensure a valid action entered
  --***********************************************************************
  SET v_step = 100;

  IF ( UPPER(p_action) = 'REPLACE' ) THEN

    SET v_step = 200;

  ELSE

    SET v_step = 300;

    SET p_return_code = 'E';

    SET v_step = 400;

    SET v_msgtext = 'Invalid action code in Ws_Connect_Replace. Valid actions are Replace.';
    CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
      , :v_msgtext, '', '', :p_task_id, :p_job_id);

    SET p_return_msg = v_msgtext;

    LEAVE Ws_Connect_Replace;

  END IF;

  --***********************************************************************
  -- Get the info for the source connection
  --***********************************************************************
  SET v_step = 500;

  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = SUBSTR('Failed to get info for source connection ' || p_source || ' ' ||
            '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
        CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
        SET p_return_msg = v_msgtext;
        SET p_return_code = 'E';
        SET p_result = -2;
      END;

    SET v_step = 600;

    SELECT dc_obj_key
         , dc_type
         , dc_method
         , dc_host_id
         , dc_dblink_id
         , dc_database_id
         , dc_odbc_source
         , dc_extract_userid
         , dc_extract_pwd
         , dc_admin_userid
         , dc_admin_pwd
         , dc_work_dir
         , dc_database_home
         , dc_pre_login_act
         , dc_login_prompt
         , dc_password_prompt
         , dc_post_login_act
         , dc_command_prompt
         , dc_telnet_attributes
         , dc_attributes
         , dc_connect_string
         , dc_server
         , dc_doc_1
         , dc_doc_2
         , dc_doc_3
         , dc_doc_4
         , dc_doc_5
         , dc_doc_6
         , dc_doc_7
         , dc_doc_8
         , dc_doc_9
         , dc_doc_10
         , dc_doc_11
         , dc_doc_12
         , dc_doc_13
         , dc_doc_14
         , dc_doc_15
         , dc_doc_16
         , dc_wizard_set_key
         , dc_db_type_ind
         , dc_authentication
    INTO   :v_dc_obj_key
         , :v_dc_type
         , :v_dc_method
         , :v_dc_host_id
         , :v_dc_dblink_id
         , :v_dc_database_id
         , :v_dc_odbc_source
         , :v_dc_extract_userid
         , :v_dc_extract_pwd
         , :v_dc_admin_userid
         , :v_dc_admin_pwd
         , :v_dc_work_dir
         , :v_dc_database_home
         , :v_dc_pre_login_act
         , :v_dc_login_prompt
         , :v_dc_password_prompt
         , :v_dc_post_login_act
         , :v_dc_command_prompt
         , :v_dc_telnet_attributes
         , :v_dc_attributes
         , :v_dc_connect_string
         , :v_dc_server
         , :v_dc_doc_1
         , :v_dc_doc_2
         , :v_dc_doc_3
         , :v_dc_doc_4
         , :v_dc_doc_5
         , :v_dc_doc_6
         , :v_dc_doc_7
         , :v_dc_doc_8
         , :v_dc_doc_9
         , :v_dc_doc_10
         , :v_dc_doc_11
         , :v_dc_doc_12
         , :v_dc_doc_13
         , :v_dc_doc_14
         , :v_dc_doc_15
         , :v_dc_doc_16
         , :v_dc_wizard_set_key
         , :v_dc_db_type_ind
         , :v_dc_authentication
    FROM   [METABASE].ws_dbc_connect
    WHERE  UPPER(dc_name) = UPPER(:p_source)
    ;

  END;

  SET v_step = 700;

  IF ( v_dc_obj_key <= 0 ) THEN

    SET v_msgtext = 'Failed to find source connection ' || p_source;
    CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
      , :v_msgtext, '', '', :p_task_id, :p_job_id);
    SET p_return_msg = v_msgtext;
    SET p_return_code = 'E';
    SET p_result = -2;

    LEAVE Ws_Connect_Replace;

  END IF;

  --***********************************************************************
  -- Update the target connection
  --***********************************************************************
  SET v_step = 800;

  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = SUBSTR('Failed to update connection ' || p_target || ' ' ||
            '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
        CALL [METABASE].WsWrkAudit('W', :p_job_name, :p_task_name, :p_sequence
          , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
        SET p_return_msg = v_msgtext;
        SET p_return_code = 'E';
        SET p_result = -2;
      END;

    SET v_step = 900;

    UPDATE [METABASE].ws_dbc_connect
    SET    dc_type = :v_dc_type
         , dc_method = :v_dc_method
         , dc_host_id = :v_dc_host_id
         , dc_dblink_id = :v_dc_dblink_id
         , dc_database_id = :v_dc_database_id
         , dc_odbc_source = :v_dc_odbc_source
         , dc_extract_userid = :v_dc_extract_userid
         , dc_extract_pwd = :v_dc_extract_pwd
         , dc_admin_userid = :v_dc_admin_userid
         , dc_admin_pwd = :v_dc_admin_pwd
         , dc_work_dir = :v_dc_work_dir
         , dc_database_home = :v_dc_database_home
         , dc_pre_login_act = :v_dc_pre_login_act
         , dc_login_prompt = :v_dc_login_prompt
         , dc_password_prompt = :v_dc_password_prompt
         , dc_post_login_act = :v_dc_post_login_act
         , dc_command_prompt = :v_dc_command_prompt
         , dc_telnet_attributes = :v_dc_telnet_attributes
         , dc_attributes = :v_dc_attributes
         , dc_connect_string = :v_dc_connect_string
         , dc_server = :v_dc_server
         , dc_doc_1 = :v_dc_doc_1
         , dc_doc_2 = :v_dc_doc_2
         , dc_doc_3 = :v_dc_doc_3
         , dc_doc_4 = :v_dc_doc_4
         , dc_doc_5 = :v_dc_doc_5
         , dc_doc_6 = :v_dc_doc_6
         , dc_doc_7 = :v_dc_doc_7
         , dc_doc_8 = :v_dc_doc_8
         , dc_doc_9 = :v_dc_doc_9
         , dc_doc_10 = :v_dc_doc_10
         , dc_doc_11 = :v_dc_doc_11
         , dc_doc_12 = :v_dc_doc_12
         , dc_doc_13 = :v_dc_doc_13
         , dc_doc_14 = :v_dc_doc_14
         , dc_doc_15 = :v_dc_doc_15
         , dc_doc_16 = :v_dc_doc_16
         , dc_wizard_set_key = :v_dc_wizard_set_key
         , dc_db_type_ind = :v_dc_db_type_ind
         , dc_authentication = :v_dc_authentication
    WHERE  UPPER(dc_name) = UPPER(:p_target);

  END;

  SET v_step = 1000;

  SET p_return_code = 'S';
  SET v_msgtext = 'Connection information for ' || p_target || ' replaced from ' || p_source;
  CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence
    , :v_msgtext, '', '', :p_task_id, :p_job_id);
  SET p_return_msg  = v_msgtext;
  SET p_result = 1;

END;
_PROCEDWSL_ Ws_Job_Clear_Logs_By_Date 
CREATE PROCEDURE [METABASE].Ws_Job_Clear_Logs_By_Date (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_job_to_clean     varchar(64)
, IN  p_day_count        integer
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		:	Teradata
  -- Script Name 	:	Ws_Job_Clear_Logs_By_Date
  -- Description 	:	Removes a set number of days logs
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- NRB 24/07/2007                   Teradata Port
  -- AP  03/10/2012   Version 6.6.3.0 RED-2885 Corrected sorting to be on complete date rather than sequence
  -- RS  18/01/2016   Version 6.8.5.2 Changed error handler
  -- HM  13/02/2019   Version 8.4.1.0 RED-7407 Increase message size from 256 to 1024 characters.
  --


  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext         varchar(1024); -- Text in audit_trail
  DECLARE v_step            integer;       -- return code
  DECLARE v_result          integer;       -- return code
  DECLARE v_count           integer;
  DECLARE v_job_sequence    integer;
  DECLARE v_job_key         integer;
  DECLARE v_job_status      varchar(1);
  DECLARE v_job_count       integer;
  DECLARE v_del_count       integer;
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_LogFetch        integer;

  DECLARE v_del_job_key     integer;
  DECLARE v_del_sequence    integer;
  DECLARE v_delete_date     timestamp(6);

  --=====================================================
  -- Cursor for all ready jobs
  --=====================================================
  DECLARE c_Log CURSOR FOR
    SELECT   wjl_job_key
           , wjl_sequence
    FROM     [METABASE].ws_wrk_job_log
    WHERE    wjl_name LIKE :p_job_to_clean
    AND      wjl_completed < :v_delete_date
    ORDER BY wjl_completed desc;
    --RED-2885 ORDER BY wjl_sequence desc;

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Clear_Logs_By_Date. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'W';
      SET p_result = -3;
    END;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_job_count = 0;
  SET v_del_count = 0;

  SET v_step = 200;

  IF (p_day_count< 0) THEN

    SET p_return_msg = 'Job '|| p_job_to_clean ||' negative value passed in day keep count. No action.';
    SET p_return_code = 'W';
    SET p_result = -1;

  ELSE

    --***********************************************************************
    -- Loop through all the logs in descending order skip over the first
    -- n that are to be kept
    --***********************************************************************
    SET v_step = 300;

    -- using CURRENT_DATE as opposed to CURRENT_TIMESTAMP in order to
    -- deal  with values > 99
    IF (p_day_count = 0) THEN
      SET v_delete_date = CURRENT_TIMESTAMP;
    ELSE
      SET v_delete_date = CAST((CURRENT_DATE - p_day_count) as TIMESTAMP(6));
    END IF;

    OPEN c_Log;

    SET v_step = 400;

    FETCH NEXT FROM c_Log
    INTO v_del_job_key
       , v_del_sequence;

    SET v_LogFetch = SQLCODE;

    SET v_step = 500;

    WHILE ( v_LogFetch = 0 )
    DO

      SET v_step = 600;

      -- Have a log to delete so move the tasks, job, audit and error info

      SET v_step = 700;

      -- Copy the audit info to archive
      INSERT INTO [METABASE].wx_wrk_audit_archive
      ( wa_time_stamp
      , wa_sequence
      , wa_job
      , wa_task
      , wa_status
      , wa_message
      , wa_db_msg_code
      , wa_db_msg_desc
      , wa_task_key
      , wa_job_key
      , wa_row_number )
      SELECT wa_time_stamp
           , wa_sequence
           , wa_job
           , wa_task
           , wa_status
           , wa_message
           , wa_db_msg_code
           , wa_db_msg_desc
           , wa_task_key
           , wa_job_key
           , wa_row_number
      FROM   [METABASE].ws_wrk_audit_log
      WHERE  wa_job_key = :v_del_job_key
      AND    wa_sequence = :v_del_sequence
      ;

      SET v_del_count = v_del_count + 1;

      SET v_step = 800;

      -- Delete the audit info
      DELETE FROM [METABASE].ws_wrk_audit_log
      WHERE  wa_job_key = :v_del_job_key
      AND    wa_sequence = :v_del_sequence
      ;

      SET v_step = 900;

      -- Copy the detail info to archive
      INSERT INTO [METABASE].wx_wrk_error_archive
      ( wd_time_stamp
      , wd_sequence
      , wd_job
      , wd_task
      , wd_status
      , wd_message
      , wd_db_msg_code
      , wd_db_msg_desc
      , wd_task_key
      , wd_job_key
      , wd_row_number
      , wd_severity
      , wd_action )
      SELECT wd_time_stamp
           , wd_sequence
           , wd_job
           , wd_task
           , wd_status
           , wd_message
           , wd_db_msg_code
           , wd_db_msg_desc
           , wd_task_key
           , wd_job_key
           , wd_row_number
           , wd_severity
           , wd_action
      FROM   [METABASE].ws_wrk_error_log
      WHERE  wd_job_key = :v_del_job_key
      AND    wd_sequence = :v_del_sequence
      ;

      SET v_del_count = v_del_count + 1;

      SET v_step = 1000;

      -- Delete the detail info
      DELETE FROM [METABASE].ws_wrk_error_log
      WHERE  wd_job_key = :v_del_job_key
      AND    wd_sequence = :v_del_sequence
      ;

      SET v_step = 1100;

      -- Delete the task log
      DELETE FROM [METABASE].ws_wrk_task_log
      WHERE  wtl_job_key = :v_del_job_key
      AND    wtl_sequence = :v_del_sequence
      ;

      SET v_step = 1200;

      -- Delete the job log
      DELETE FROM [METABASE].ws_wrk_job_log
      WHERE  wjl_job_key = :v_del_job_key
      AND    wjl_sequence = :v_del_sequence
      ;

      SET v_LogFetch = 0;

      SET v_step = 1300;

      FETCH NEXT FROM c_Log
      INTO v_del_job_key
         , v_del_sequence;

      SET v_LogFetch = SQLCODE;

    END WHILE;

    SET v_step = 1400;

    CLOSE c_Log;

    --***********************************************************************
    -- Archive Detail and audit info for records with no parent in job log
    --***********************************************************************
    SET v_step = 1500;

    -- Copy the audit info to archive
    INSERT INTO [METABASE].wx_wrk_audit_archive
    ( wa_time_stamp
    , wa_sequence
    , wa_job
    , wa_task
    , wa_status
    , wa_message
    , wa_db_msg_code
    , wa_db_msg_desc
    , wa_task_key
    , wa_job_key
    , wa_row_number )
    SELECT wa_time_stamp
         , ws_wrk_audit_log.wa_sequence
         , wa_job
         , wa_task
         , wa_status
         , wa_message
         , wa_db_msg_code
         , wa_db_msg_desc
         , wa_task_key
         , ws_wrk_audit_log.wa_job_key
         , wa_row_number
    FROM   [METABASE].ws_wrk_audit_log ws_wrk_audit_log
       , ( SELECT wa_job_key
                , wa_sequence
           FROM   [METABASE].ws_wrk_audit_log
           MINUS
           SELECT wjl_job_key
                , wjl_sequence
           FROM   [METABASE].ws_wrk_job_log
         ) AS del_list
    WHERE  ws_wrk_audit_log.wa_job_key = del_list.wa_job_key
    AND    ws_wrk_audit_log.wa_sequence = del_list.wa_sequence
    AND    wa_time_stamp < :v_delete_date
    ;

    SET v_step = 1600;

    -- Delete the audit info
    DELETE FROM [METABASE].ws_wrk_audit_log
    WHERE (wa_job_key, wa_sequence) IN
      ( SELECT wa_job_key
             , wa_sequence
        FROM   [METABASE].ws_wrk_audit_log
        MINUS
        SELECT wjl_job_key
             , wjl_sequence
        FROM   [METABASE].ws_wrk_job_log
      )
    AND    wa_time_stamp < :v_delete_date
    ;

    SET v_step = 1700;

    -- Copy the detail info to archive
    INSERT INTO [METABASE].wx_wrk_error_archive
    ( wd_time_stamp
    , wd_sequence
    , wd_job
    , wd_task
    , wd_status
    , wd_message
    , wd_db_msg_code
    , wd_db_msg_desc
    , wd_task_key
    , wd_job_key
    , wd_row_number
    , wd_severity
    , wd_action )
    SELECT wd_time_stamp
         , ws_wrk_error_log.wd_sequence
         , wd_job
         , wd_task
         , wd_status
         , wd_message
         , wd_db_msg_code
         , wd_db_msg_desc
         , wd_task_key
         , ws_wrk_error_log.wd_job_key
         , wd_row_number
         , wd_severity
         , wd_action
    FROM   [METABASE].ws_wrk_error_log ws_wrk_error_log
       , ( SELECT wd_job_key
                , wd_sequence
           FROM   [METABASE].ws_wrk_error_log
           MINUS
           SELECT wjl_job_key
                , wjl_sequence
           FROM   [METABASE].ws_wrk_job_log
         ) AS del_list
    WHERE  ws_wrk_error_log.wd_job_key = del_list.wd_job_key
    AND    ws_wrk_error_log.wd_sequence = del_list.wd_sequence
    AND    wd_time_stamp < :v_delete_date
    ;

    SET v_step = 1800;

    DELETE FROM [METABASE].ws_wrk_error_log
    WHERE (wd_job_key, wd_sequence) IN
      ( SELECT wd_job_key
             , wd_sequence
        FROM   [METABASE].ws_wrk_error_log
        MINUS
        SELECT wjl_job_key
             , wjl_sequence
        FROM   [METABASE].ws_wrk_job_log
      )
    AND    wd_time_stamp < :v_delete_date
    ;

    SET p_return_code = 'S';
    SET p_return_msg = 'Job ' || p_job_to_clean || ' had ' || CAST(v_del_count AS VARCHAR(10)) || ' logs removed. ';
    SET p_result = 1;

  END IF;

END;
_PROCEDWSL_ Ws_Job_CreateWait 
CREATE PROCEDURE [METABASE].Ws_Job_CreateWait (
  IN  p_sequence         INTEGER
, IN  p_job_name         VARCHAR(64)
, IN  p_task_name        VARCHAR(64)
, IN  p_job_id           INTEGER
, IN  p_task_id          INTEGER
, IN  p_template_job     VARCHAR(64)
, IN  p_new_job          VARCHAR(64)
, IN  p_description      VARCHAR(256)
, IN  p_state            VARCHAR(10)
, IN  p_release_time     TIMESTAMP
, IN  p_threads          INTEGER
, IN  p_scheduler        VARCHAR(8)
, IN  p_logs             INTEGER
, IN  p_okay             VARCHAR(256)
, IN  p_fail             VARCHAR(256)
, IN  p_att1             VARCHAR(4000)
, IN  p_att2             VARCHAR(4000)
, IN  p_att3             VARCHAR(4000)
, IN  p_att4             VARCHAR(4000)
, IN  p_att5             VARCHAR(4000)
, IN  p_att6             VARCHAR(4000)
, IN  p_att7             VARCHAR(4000)
, IN  p_att8             VARCHAR(4000)
, OUT p_return_code      VARCHAR(1)
, OUT p_return_msg       VARCHAR(1024)
, OUT p_result           INTEGER)

Ws_Job_CreateWait:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name           : Teradata
  -- Script Name         : Ws_Job_CreateWait
  -- Description         : Releases a held or waiting job
  -- Author              : Wayne Richmond
  -- Date                : 01/11/2006
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR  01/11/2006   Version 5.5.0.6
  -- JML  09/04/2008   Version 6.0.0.0  Teradata port
  -- RS   14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS   18/01/2016   Version 6.8.5.2  Changed error handler
  -- KH    1/11/2018   Version 8.3.1.0  RED-9838 wtc_action_ind added to task copy row.
  -- HM   13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Common variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_sql_code                 INTEGER;
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;
  DECLARE v_count                    INTEGER;
  DECLARE v_result                   VARCHAR(2000);      -- General result variable
  DECLARE v_sql                      VARCHAR(8000);      -- Text for sql statements

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_job_sequence             INTEGER;
  DECLARE v_job_key                  INTEGER;
  DECLARE v_job_status               VARCHAR(1);
  DECLARE v_old_key                  INTEGER;
  DECLARE v_old_sequence             INTEGER;
  DECLARE v_old_status               VARCHAR(1);
  DECLARE v_new_key                  INTEGER;
  DECLARE v_new_sequence             INTEGER;
  DECLARE v_wjc_status               VARCHAR(1);
  DECLARE v_wjc_type                 VARCHAR(1);

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_CreateWait. '||
          '. Version '|| v_ws_pro_version ||
          '. Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      CALL [METABASE].WsWrkAudit('F', :p_job_name, :p_task_name, :p_sequence
        , :v_msgtext, :v_sql_code, :v_sql_error, :p_task_id, :p_job_id);
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_sql_code                 = 0;
  SET v_step                     = 0;
  SET v_count                    = 0;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET p_return_msg = 'Unhandled Exception in Ws_Job_CreateWait.';
  SET p_return_code = 'F';
  SET p_result = -3;

  --***********************************************************************
  -- First see if the job name specified is in a held or waiting state
  -- If not in a held or waiting state report and exit
  --***********************************************************************
  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_old_key = 0;

      END;

    SET v_step = 200;

    SELECT wjc_job_key
         , wjc_sequence
         , wjc_status
    INTO   :v_old_key
         , :v_old_sequence
         , :v_old_status
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_template_job))
    ;

  END;

  SET v_step = 300;

  --***********************************************************************
  -- If not scheduled exit with that information
  --***********************************************************************

  IF ( COALESCE(v_old_key,0) = 0 ) THEN

    SET p_return_msg = 'Job ' || p_template_job || ' is not in a holding or waiting state. Cannot create new job';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE Ws_Job_CreateWait;

  END IF;

  SET v_step = 400;

  --***********************************************************************
  -- Make sure we have no job that matches our new job name
  --***********************************************************************

  BEGIN

    DECLARE CONTINUE HANDLER
      FOR SQLEXCEPTION
      BEGIN

        SET v_count = 1;

      END;

      SET v_step = 500;

      SELECT COUNT(*)
      INTO   :v_count
      FROM   [METABASE].ws_wrk_job_ctrl
      WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(:p_new_job))
      ;

  END;

  SET v_step = 600;

  IF ( v_count > 0 ) THEN

    SET p_return_msg = 'Job ' || p_new_job || ' already exists. Cannot create a new job of the same name';
    SET p_return_code = 'P';
    SET p_result = -1;

    LEAVE Ws_Job_CreateWait;

  END IF;

  SET v_step = 700;

  --***********************************************************************
  -- Get the right state for the new job and the sequence
  --***********************************************************************

  IF ( TRIM(UPPER(p_state)) = 'ONCE' ) THEN

    SET v_wjc_status = 'W';
    SET v_wjc_type = 'O';

  ELSEIF ( TRIM(UPPER(p_state)) = 'ONCE+HOLD' ) THEN

    SET v_wjc_status = 'W';
    SET v_wjc_type = 'S';

  ELSE

    SET v_wjc_status = 'H';
    SET v_wjc_type = 'H';

  END IF;

  SET v_step = 800;

  --***********************************************************************
  -- Get the job sequence for the new job
  --***********************************************************************

  INSERT INTO [METABASE].ws_wrk_sequence
  ( ws_sequence
  , ws_date
  , ws_session)
  VALUES
  ( NULL
  , CURRENT_TIMESTAMP
  , SESSION)
  ;

  SET v_step = 900;

  SELECT MAX(ws_sequence)
  INTO   :v_new_sequence
  FROM   [METABASE].ws_wrk_sequence
  WHERE  ws_session = SESSION
  ;

  SET v_step = 1000;

  --***********************************************************************
  -- Add the new job in a held state, so that we can add the tasks/dependencies
  --***********************************************************************

  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = SUBSTR('Failed to create Job ' || p_new_job ||
            '. Step ' || CAST(v_step AS VARCHAR(64)) ||
            '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
        SET p_return_msg = v_msgtext;
        SET p_return_code = 'E';
        SET p_result = -2;
      END;

    SET v_step = 1100;

    BT;

    INSERT INTO [METABASE].ws_wrk_job_ctrl
    ( wjc_job_key
    , wjc_name
    , wjc_description
    , wjc_sequence
    , wjc_group_key
    , wjc_project_key
    , wjc_status
    , wjc_last_status
    , wjc_type
    , wjc_submitted
    , wjc_first_schedule
    , wjc_start_hour
    , wjc_start_minute
    , wjc_start_day
    , wjc_user_key
    , wjc_start_after
    , wjc_started
    , wjc_completed
    , wjc_max_elapsed
    , wjc_task_elapsed
    , wjc_avg_elapsed
    , wjc_avg_count
    , wjc_publish_okay
    , wjc_publish_fail
    , wjc_task_fatal
    , wjc_task_error
    , wjc_task_warning
    , wjc_task_info
    , wjc_task_okay
    , wjc_chkp_count
    , wjc_max_threads
    , wjc_priority
    , wjc_publish_flag
    , wjc_scheduler
    , wjc_cust_sa_hh
    , wjc_cust_sa_mm
    , wjc_cust_sb_hh
    , wjc_cust_sb_mm
    , wjc_cust_min
    , wjc_cust_days
    )
    SELECT :v_new_sequence
         , :p_new_job
         , COALESCE(:p_description,wjc_description)
         , :v_new_sequence
         , wjc_group_key
         , wjc_project_key
         , 'H'
         , wjc_last_status
         , :v_wjc_type
         , wjc_submitted
         , wjc_first_schedule
         , wjc_start_hour
         , wjc_start_minute
         , wjc_start_day
         , wjc_user_key
         , :p_release_time
         , wjc_started
         , wjc_completed
         , wjc_max_elapsed
         , wjc_task_elapsed
         , wjc_avg_elapsed
         , COALESCE(:p_logs,wjc_avg_count)
         , COALESCE(:p_okay,wjc_publish_okay)
         , COALESCE(:p_fail,wjc_publish_fail)
         , wjc_task_fatal
         , wjc_task_error
         , wjc_task_warning
         , wjc_task_info
         , wjc_task_okay
         , wjc_chkp_count
         , COALESCE(:p_threads,wjc_max_threads)
         , wjc_priority
         , wjc_publish_flag
         , COALESCE(:p_scheduler,wjc_scheduler)
         , wjc_cust_sa_hh
         , wjc_cust_sa_mm
         , wjc_cust_sb_hh
         , wjc_cust_sb_mm
         , wjc_cust_min
         , wjc_cust_days
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  wjc_job_key = :v_old_key
    AND    wjc_status IN ('H','W')
    ;

    SET v_step = 1200;

    --***********************************************************************
    -- Add all the tasks
    --***********************************************************************
    INSERT INTO [METABASE].ws_wrk_task_ctrl
    ( wtc_task_key
    , wtc_job_key
    , wtc_obj_key
    , wtc_name
    , wtc_type
    , wtc_sequence
    , wtc_obj_type
    , wtc_action_type
    , wtc_order
    , wtc_order_a
    , wtc_order_b
    , wtc_order_c
    , wtc_run_status
    , wtc_audit_status
    , wtc_started
    , wtc_completed
    , wtc_avg_elapsed
    , wtc_avg_count
    , wtc_task_fatal
    , wtc_task_error
    , wtc_task_warning
    , wtc_task_info
    , wtc_task_okay
    , wtc_chkp_number
    , wtc_abort_level
    , wtc_action_ind
    )
    SELECT NULL
         , :v_new_sequence
         , wtc_obj_key
         , wtc_name
         , wtc_type
         , :v_new_sequence
         , wtc_obj_type
         , wtc_action_type
         , wtc_order
         , wtc_order_a
         , wtc_order_b
         , wtc_order_c
         , wtc_run_status
         , wtc_audit_status
         , wtc_started
         , wtc_completed
         , wtc_avg_elapsed
         , wtc_avg_count
         , wtc_task_fatal
         , wtc_task_error
         , wtc_task_warning
         , wtc_task_info
         , wtc_task_okay
         , wtc_chkp_number
         , wtc_abort_level
         , wtc_action_ind
    FROM   [METABASE].ws_wrk_task_ctrl
    WHERE  wtc_job_key = :v_old_key
    ;

    SET v_step = 1300;

    --***********************************************************************
    -- Add all the dependencies
    --***********************************************************************

    INSERT INTO [METABASE].ws_wrk_dependency
    ( wdp_job_key
    , wdp_parent_task_key
    , wdp_child_task_key
    )
    SELECT :v_new_sequence
         , b_new.wtc_task_key
         , c_new.wtc_task_key
    FROM   [METABASE].ws_wrk_dependency a
    JOIN   [METABASE].ws_wrk_task_ctrl b_old
    ON     a.wdp_parent_task_key = b_old.wtc_task_key
    JOIN   [METABASE].ws_wrk_task_ctrl c_old
    ON     a.wdp_child_task_key = c_old.wtc_task_key
    JOIN   [METABASE].ws_wrk_task_ctrl b_new
    ON     b_old.wtc_order = b_new.wtc_order
    JOIN   [METABASE].ws_wrk_task_ctrl c_new
    ON     c_old.wtc_order = c_new.wtc_order
    WHERE  a.wdp_job_key = :v_old_key
    AND    b_new.wtc_job_key = :v_new_sequence
    AND    c_new.wtc_job_key = :v_new_sequence
    ;

    SET v_step = 1400;

    --***********************************************************************
    -- Set the job to the request state
    --***********************************************************************

    UPDATE [METABASE].ws_wrk_job_ctrl
    SET    wjc_status = :v_wjc_status
    WHERE  wjc_job_key = :v_new_sequence
    AND    wjc_sequence = :v_new_sequence
    ;

    ET;

    SET p_return_code = 'S';
    SET p_return_msg = 'Job ' || p_new_job || ' created.';
    SET p_result = 1;

    LEAVE Ws_Job_CreateWait;

  END;

  SET v_step = 1500;

END;
_PROCEDWSL_ Ws_Version_Clear 
CREATE PROCEDURE [METABASE].Ws_Version_Clear (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_day_count        integer
, IN  p_keep_count       integer
, IN  p_options          varchar(256)
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name          :    Teradata
  -- Script Name        :    Ws_Version_Clear
  -- Description        :    Delete old versioned records
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- V5.6.0.9  NRB 27/06/2007 Original Version
  -- V5.6.1.1  AP  30/08/2007 Delete based on obj name not key, as indexes etc get new key
  --                          when regenerate
  -- V6.1.0.1  JML 30/03/2010 Changes to write to wx...archive tables before deleting for:
  --                          - ws_obj_object
  --                          - ws_pro_header_v
  --                          - ws_pro_line_v
  --                          - ws_scr_header_v
  --                          - ws_scr_line_v
  -- V6.7.0.1  RS  14/02/2013 Changed Default Declaration to Variable Assignment
  -- V6.8.2.1  BC  04/03/2015 Changed the select statement that determines the cursor for
  --                          metadata tables to delete:
  --                          - to use ColumnsV instead of Columns
  --                          - to eliminate the minus operator by joining to TablesV and
  --                            using filtering logic on the table kind
  -- V6.8.5.2 RS  18/01/2016  Changed error handler
  -- V8.4.1.0 HM  13/02/2019  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext              varchar(1024); -- Text in audit_trail
  DECLARE v_step                 integer;       -- return code
  DECLARE v_result               integer;       -- return code
  DECLARE v_count                integer;
  DECLARE v_job_sequence         integer;
  DECLARE v_job_key              integer;
  DECLARE v_job_status           varchar(1);
  DECLARE v_job_count            integer;
  DECLARE v_version_delete_count integer;
  DECLARE v_version_insert_count integer;
  DECLARE v_delete_count         integer;
  DECLARE v_insert_count         integer;
  DECLARE v_sql_code             integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error            varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_LogFetch             integer;
  DECLARE v_TabFetch             integer;

  DECLARE v_version_no           integer;
  DECLARE v_obj_key              integer;
  DECLARE v_obj_name             varchar(64);
  DECLARE v_creation_date        timestamp(6);
  DECLARE v_retain_till_date     timestamp(6);
  DECLARE v_process_flag         integer;
  DECLARE v_delete_date          timestamp(6);
  DECLARE v_prev_obj_name        varchar(64);
  DECLARE v_table_name           varchar(30);
  DECLARE v_column_name          varchar(30);
  DECLARE v_delete_sql           varchar(500);
  DECLARE v_insert_sql           varchar(500);

  --=====================================================
  -- Cursor for all ready jobs
  --=====================================================
  DECLARE c_Versions CURSOR FOR
  SELECT   ov_version_no
         , ov_obj_key
         , ov_obj_name
         , ov_creation_date
         , ov_retain_till_date
  FROM     [METABASE].ws_obj_versions
  ORDER BY ov_obj_name
         , ov_creation_date desc;

  --=====================================================
  -- Cursor for metadata tables to delete
  --=====================================================
  DECLARE c_Tables CURSOR FOR
  SELECT col.TableName
       , col.ColumnName
  FROM   dbc.TablesV tab
  JOIN   [METABASE].ws_meta meta
  ON     tab.DatabaseName = meta.meta_database
  JOIN   dbc.ColumnsV col
  ON     col.TableName = tab.TableName
  AND    col.DataBaseName = tab.DataBaseName
  WHERE  CAST(col.TableName as VARCHAR(30)) like 'ws_%_v'
  AND    CAST(col.ColumnName as VARCHAR(30)) like '%_version_no'
  AND    tab.TableKind  = 'V';

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Version_Clear.'||
          ' Version '|| v_ws_pro_version ||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;

      SET p_return_code = 'W';
      SET p_result = -3;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_job_count = 0;
  SET v_version_delete_count = 0;
  SET v_version_insert_count = 0;
  SET v_delete_count = 0;
  SET v_insert_count = 0;
  SET v_process_flag = 0;
  SET v_prev_obj_name = '_';

  --===============================================================
  -- check to see if need to delete based on datetime
  --===============================================================
  IF (p_day_count >= 0) THEN

    -- using CURRENT_DATE as opposed to CURRENT_TIMESTAMP in order to
    -- deal  with values > 99
    IF (p_day_count = 0) THEN

      SET v_delete_date = CURRENT_TIMESTAMP;

    ELSE

      SET v_delete_date = cast((CURRENT_DATE - p_day_count) as timestamp(6));

    END IF;

    SET v_msgtext = 'Delete Date: '||CAST(v_delete_date AS VARCHAR(20));
    CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence,
                               :v_msgtext, '', '', :p_task_id, :p_job_id);

  ELSE

    SET v_delete_date = CURRENT_TIMESTAMP;

  END IF;

  SET v_step = 200;

  --===============================================================
  -- check to see if need to keep minimum number of versioned records
  --===============================================================
  IF (p_keep_count > 0) THEN

    SET v_msgtext = 'Versions to Keep: '||CAST(p_keep_count AS VARCHAR(10));
    CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence,
                               :v_msgtext, '', '', :p_task_id, :p_job_id);

  END IF;

  SET v_step = 300;

  --===============================================================
  -- Loop through all version records and identify which ones to delete
  --===============================================================
  BEGIN TRANSACTION;

    OPEN c_Versions;

    SET v_step = 400;

    FETCH NEXT FROM c_Versions
    INTO v_version_no
       , v_obj_key
       , v_obj_name
       , v_creation_date
       , v_retain_till_date;

    SET v_LogFetch = SQLCODE;

    SET v_step = 500;

    WHILE ( v_LogFetch = 0 ) DO

      --============================================================
      -- check object key has changed and reset counter
      --============================================================
      IF (v_prev_obj_name <> v_obj_name) THEN

        SET v_prev_obj_name = v_obj_name;
        SET v_count = 0;
        SET v_process_flag = 0;

      END IF;

      -- increment counter for object key
      SET v_count = v_count + 1;

      SET v_step = 600;

      --============================================================
      -- Reset flag if deleting based on retain date, as need to
      -- check each individual record
      --============================================================
      IF (p_day_count < 0) THEN

        SET v_process_flag = 0;

      END IF;

      --============================================================
      -- check to see if versioned record can be deleted
      --============================================================
      IF (v_process_flag = 0) THEN

        -- check to see if min version to keep has been passed
        IF (v_count > p_keep_count) THEN

          -- check to see if deleting records old enough
          IF (p_day_count >= 0) THEN

            IF (v_delete_date >= v_creation_date) THEN

              SET v_process_flag = 1;

            END IF;

          ELSE

            IF (v_delete_date >= v_retain_till_date) THEN

              SET v_process_flag = 1;

            END IF;

          END IF;

        END IF;  -- end check for min versions to keep

      END IF;

      SET v_step = 700;

      --============================================================
      -- if flag set, delete verioned record
      --============================================================
      IF (v_process_flag = 1) THEN

        --==========================================================
        -- Archive rows in ws_obj_versions
        --==========================================================
        INSERT INTO [METABASE].wx_obj_versions_archive
        SELECT *
        FROM   [METABASE].ws_obj_versions
        WHERE  ov_version_no = :v_version_no;

        SET v_version_insert_count = v_version_insert_count + 1;

        SET v_step = 800;

        --==========================================================
        -- Delete rows from ws_obj_versions
        --==========================================================
        DELETE FROM [METABASE].ws_obj_versions
        WHERE ov_version_no = :v_version_no;

        SET v_version_delete_count = v_version_delete_count + 1;

        SET v_step = 900;

      END IF; -- end delete

      SET v_LogFetch = 0;

      SET v_step = 1000;

      FETCH NEXT FROM c_Versions
      INTO v_version_no
         , v_obj_key
         , v_obj_name
         , v_creation_date
         , v_retain_till_date;

      SET v_LogFetch = SQLCODE;

    END WHILE;

    SET v_step = 1100;

    CLOSE c_Versions;

  END TRANSACTION;

  SET v_step = 1200;

  --========================================================
  -- If more than one version record delete, delete data
  --========================================================
  IF (v_version_delete_count > 0) THEN

    SET v_TabFetch = 0;

    SET v_step = 1300;

    OPEN c_Tables;

    FETCH NEXT FROM c_Tables
    INTO v_table_name
        ,v_column_name;

    SET v_TabFetch = SQLCODE;

    SET v_step = 1400;

    --================================================================
    -- Loop on version detail tables
    --================================================================
    WHILE ( v_TabFetch = 0 ) DO

      SET v_step = 1500;

      SET v_insert_count = 0;

      --================================================================
      -- If the detail table is procedure/script headers/lines
      -- then archive the rows before deleting
      --================================================================
      IF (UPPER(v_table_name) IN ('WS_PRO_HEADER_V','WS_PRO_LINE_V','WS_SCR_HEADER_V','WS_SCR_LINE_V')) THEN

        -- generate insert SQL
        SET v_insert_sql = 'INSERT INTO [METABASE].wx' || SUBSTR(v_table_name,3,28) || '_archive '
                         ||'SELECT * '
                         ||'FROM   [METABASE].'|| v_table_name ||' a '
                         ||'WHERE NOT EXISTS (SELECT 1 '
                         ||'                  FROM   [METABASE].ws_obj_versions b '
                         ||'                  WHERE  a.'|| v_column_name ||' = b.ov_version_no)';

        --execute insert stmt
        BEGIN TRANSACTION;

          SET v_step = 1600;

          CALL DBC.SYSEXECSQL ( :v_insert_sql );

          SET v_insert_count = ACTIVITY_COUNT;

          SET v_step = 1700;

          IF ( v_insert_count > 0 ) THEN

            SET v_msgtext = CAST(v_insert_count AS VARCHAR(20))
                             ||' records archived to '
                             || 'wx' || SUBSTR(v_table_name,3,28) || '_archive';
            CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence,
                                   :v_msgtext, '', '', :p_task_id, :p_job_id);

          END IF;

        END TRANSACTION;

      END IF;

      SET v_step = 1800;

      SET v_delete_count = 0;

      SET v_delete_sql = 'DELETE FROM [METABASE].' || v_table_name || ' a '
                       ||'WHERE NOT EXISTS (SELECT 1 FROM [METABASE].ws_obj_versions b '
                       ||'WHERE a.' || v_column_name || ' = b.ov_version_no);';

      --execute delete stmt
      BEGIN TRANSACTION;

        SET v_step = 1900;

        CALL DBC.SYSEXECSQL ( :v_delete_sql );

        SET v_delete_count = ACTIVITY_COUNT;

        SET v_step = 2000;

        IF ( v_delete_count > 0 ) THEN

          SET v_msgtext = CAST(v_delete_count AS VARCHAR(20))||
                         ' records deleted from ' ||
                         v_table_name ;
          CALL [METABASE].WsWrkAudit('I', :p_job_name, :p_task_name, :p_sequence,
                                 :v_msgtext, '', '', :p_task_id, :p_job_id);

        END IF;

      END TRANSACTION;

      SET v_TabFetch = 0;

      SET v_step = 2100;

      FETCH NEXT FROM c_Tables
      INTO v_table_name
          ,v_column_name;

      SET v_TabFetch = SQLCODE;

    END WHILE;

    SET v_step = 2200;

    CLOSE c_Tables;

  END IF;

  SET v_step = 2300;

  SET p_return_code = 'S';
  SET p_return_msg = 'Version Records deleted: ' || CAST(v_version_delete_count AS VARCHAR(10));
  SET p_result = 1;

END;
_PROCEDWSL_ Ws_Job_Clear_Archive 
CREATE PROCEDURE [METABASE].Ws_Job_Clear_Archive (
  IN  p_sequence         integer
, IN  p_job_name         varchar(64)
, IN  p_task_name        varchar(64)
, IN  p_job_id           integer
, IN  p_task_id          integer
, IN  p_day_count        integer
, IN  p_job              varchar(64)
, IN  p_options          varchar(256)
, OUT p_return_code      varchar(1)
, OUT p_return_msg       varchar(1024)
, OUT p_result           integer)

BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name      :    Teradata
  -- Script Name    :    Ws_Job_Clear_Archive
  -- Description 	:	 Delete old versioned records
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- NB 19/07/2007                   Original Version
  -- NB 04/10/2007                   pre-calculate delete date prior to SQL
  -- RS 18/01/2016  Version 6.8.5.2  Changed error handler
  -- HM 13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext         varchar(1024); -- Text in audit_trail
  DECLARE v_step            integer;       -- return code
  DECLARE v_result          integer;       -- return code
  DECLARE v_count           integer;
  DECLARE v_job_sequence    integer;
  DECLARE v_job_key         integer;
  DECLARE v_job_status      varchar(1);
  DECLARE v_job_count       integer;
  DECLARE v_delete_count    integer;
  DECLARE v_sql_code        integer;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error       varchar(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_LogFetch        integer;
  DECLARE v_TabFetch        integer;

  DECLARE v_audit_del_count integer;       -- audit delete count
  DECLARE v_detail_del_count integer;      -- audit detail delete count
  DECLARE v_trunc_flag      integer;       -- flag indicating table truncation
  DECLARE v_job             varchar(64);   -- job to delete (includes wildcard)
  DECLARE v_delete_date     timestamp(6);  -- delete date


  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Clear_Archive. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_return_msg = v_msgtext;

      SET p_return_code = 'W';
      SET p_result = -3;
    END;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_audit_del_count = 0;
  SET v_detail_del_count = 0;
  SET v_trunc_flag = 0;

  -- if less than zero specified in logs to keep then return
  IF (p_day_count < 0) THEN

    SET p_return_code = 'W';
    SET p_return_msg = ' negative value passed in days to keep count. No action.';
    SET p_result = 1;

  ELSE

    SET v_job = COALESCE(p_job,'');

    --***********************************************************************
    -- Process options
    --***********************************************************************
    SET v_step = 200;

    IF ( p_options IS NOT NULL ) THEN
      IF ( UPPER(p_options) = 'TRUNCATE' ) THEN
        SET v_trunc_flag = 1;
      END IF;
    END IF;

    --***********************************************************************
    -- Delete relevant archive records
    --***********************************************************************
    SET v_step = 300;

    IF ( v_trunc_flag = 1 ) THEN

      --***********************************************************************
      -- truncate audit and detail archive info
      --***********************************************************************
      SET v_step = 400;

      DELETE FROM [METABASE].wx_wrk_audit_archive ALL
      ;

      SET v_step = 500;

      DELETE FROM [METABASE].wx_wrk_error_archive ALL
      ;

    ELSE

      SET v_step = 600;

      -- using CURRENT_DATE as opposed to CURRENT_TIMESTAMP in order to
      -- deal  with values > 99
      IF (p_day_count = 0) THEN
        SET v_delete_date = CURRENT_TIMESTAMP;
      ELSE
        SET v_delete_date = cast((CURRENT_DATE - p_day_count) as timestamp(6));
      END IF;

      --***********************************************************************
      -- construct and process DELETE statements
      --***********************************************************************
      IF (v_job <> '') THEN

        SET v_step = 700;

        --***********************************************************************
        -- delete includes job name (possibly with wildcard)
        --***********************************************************************
        BT;

          SET v_step = 800;

          DELETE FROM [METABASE].wx_wrk_audit_archive
          WHERE  wa_time_stamp < :v_delete_date
          AND    wa_job LIKE :p_job
          ;

          SET v_audit_del_count = ACTIVITY_COUNT;

          SET v_step = 900;

          DELETE FROM [METABASE].wx_wrk_error_archive
          WHERE  wd_time_stamp < :v_delete_date
          AND    wd_job LIKE :p_job
          ;

          SET v_detail_del_count = ACTIVITY_COUNT;

        ET;

      ELSE

        SET v_step = 1000;


        --***********************************************************************
        -- Delete based on just the day count
        --***********************************************************************
        BT;

          SET v_step = 1100;

          DELETE FROM [METABASE].wx_wrk_audit_archive
          WHERE  wa_time_stamp < :v_delete_date
          ;

          SET v_audit_del_count = ACTIVITY_COUNT;

          SET v_step = 1200;

          DELETE FROM [METABASE].wx_wrk_error_archive
          WHERE  wd_time_stamp < :v_delete_date
          ;

          SET v_detail_del_count = ACTIVITY_COUNT;

        ET;

      END IF;  -- length(v_job)

    END IF; -- end trunc_flag = 1

    SET v_step = 1300;

    SET p_return_code = 'S';

    IF (v_trunc_flag = 1) THEN
      SET p_return_msg = 'audit archive logs and detail archive logs tables truncated.';
    ELSE
      SET p_return_msg = CAST(v_audit_del_count AS VARCHAR(10))  || ' audit archive logs removed and '
                        || CAST(v_detail_del_count AS VARCHAR(10))  || ' detail archive logs removed. ';
    END IF;

    SET p_result = 1;

 END IF;

END;
_PROCEDWSL_ Ws_Job_Status 
CREATE PROCEDURE [METABASE].Ws_Job_Status
( IN  p_sequence            INTEGER
, IN  p_job_name            VARCHAR(64)
, IN  p_task_name           VARCHAR(64)
, IN  p_job_id              INTEGER
, IN  p_task_id             INTEGER
, IN  p_check_sequence      INTEGER
, IN  p_check_job           VARCHAR(64)
, IN  p_started_in_last_mi  INTEGER
, IN  p_started_after_dt    TIMESTAMP
, OUT p_return_code         VARCHAR(1)
, OUT p_return_msg          VARCHAR(1024)
, OUT p_result              INTEGER
, OUT p_job_status_simple   VARCHAR(1)
, OUT p_job_status_standard VARCHAR(1)
, OUT p_job_status_enhanced VARCHAR(2)
)
WSJOBSTATUS:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name		:	Teradata
  -- Script Name 	:	ws_job_status
  -- Description 	:	Returns the status of a job.
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- Notes / History
  --
  -- -----------------------------------------------------------------------------
  -- Important Note about Timestamps
  -- ---------------------------------
  -- ---------------------------------
  -- In V2R5.x, a NULL value in a timestamp variable results in the variable
  -- containing 0000-00-00 00:00:06.751193 and not a NULL.   This is an
  -- invalid timestamp as far as CAST and other functions are concerned and
  -- also tests TRUE to IS NULL.   Therefore, an IS NOT NULL tests against
  -- p_started_after_dt is the following:
  --       IF   (p_started_after_dt IS NOT NULL
  --       AND   p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP))
  -- and an IS NULL test against p_started_after_dt is the following:
  --       IF   (p_started_after_dt IS NULL
  --       OR    p_started_after_dt <= CAST('1900-01-01 00:00:00' AS TIMESTAMP))
  -- -----------------------------------------------------------------------------
  --
  -- V5.6.3.0 JML 16/11/2007   First Version
  -- v6.6.3.0 AP  03/10/2012   RED_2885 Order by completion date before sequence
  -- v6.8.4.4 BC  20/10/2015   RED-5392 Eliminate a potential race condition when getting
  --                           the details of a running job which could have completed in
  --                           the mean time, where its details will have been moved out of
  --                           ws_wrk_job_run into ws_wrk_job_log.
  --
  -- v6.8.5.2 RS  18/01/2016   RED-4607 Changed error handler
  -- v8.4.1.0 HM  13/02/2019   RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                VARCHAR(1024); -- Text in audit_trail
  DECLARE v_step                   INTEGER;       -- return code
  DECLARE v_sql_code               INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error              VARCHAR(1024); -- SQL Error Code for Audit Trail as varchar
  DECLARE v_job_not_found          CHAR(1);
  DECLARE v_job_sequence           INTEGER;
  DECLARE v_job_status_simple      VARCHAR(1);
  DECLARE v_job_status_standard    VARCHAR(1);
  DECLARE v_job_status_enhanced    VARCHAR(2);
  DECLARE v_job_state              VARCHAR(20);
  DECLARE v_job_status_msg         VARCHAR(256);
  DECLARE v_task_count             INTEGER;
  DECLARE v_mi                     INTEGER;
  DECLARE v_hh                     INTEGER;
  DECLARE v_dd                     INTEGER;
  DECLARE v_started_after_dt       TIMESTAMP;

  --=====================================================
  -- General Exception
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = SUBSTR('Unhandled Exception in Ws_Job_Status. '||
          ' Step ' || CAST(v_step AS VARCHAR(64)) ||
          '   SQL Error Code: ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error,1,1023);
      SET p_job_status_simple = '0';
      SET p_job_status_standard = '0';
      SET p_job_status_enhanced = '0';
      SET p_return_msg = v_msgtext;
      SET p_return_code = 'F';
      SET p_result = -3;
    END;

-- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  --=====================================================
  -- Main
  --=====================================================
  SET v_step = 100;

  SET v_job_not_found = 'N';
  SET p_return_code = 'S';
  SET p_result = 1;
  -- RED_2885 need these due to now using TOP 1 rather than MAX for the selects, which doesn't return a row if not found so select into wont result in 0
  SET v_job_state = 0;
  SET v_job_sequence = 0;

  SET v_step = 200;

  -- Check to ensure neither time based parameters have been specified if check sequence has been.
  -- Abort in this case.
  IF (( p_check_sequence IS NOT NULL ) AND (( p_started_in_last_mi IS NOT NULL) OR ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) ))) THEN

    SET v_step = 300;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Unable to proceed: neither p_started_in_last_mi or p_started_after_dt may not be specified if p_check_sequence is specified.';
    SET p_return_code = 'E';
    SET p_result = -2;

    LEAVE WSJOBSTATUS;

  -- Check to ensure zero or one time based parameters have been specified.
  -- Abort if both have been specified.
  ELSEIF (( p_started_in_last_mi IS NOT NULL) AND ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) )) THEN

    SET v_step = 400;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Unable to proceed: both p_started_in_last_mi and p_started_after_dt have been set. At most one of these may be set.';
    SET p_return_code = 'E';
    SET p_result = -2;

    LEAVE WSJOBSTATUS;

  ELSEIF ((( p_started_in_last_mi IS NOT NULL) OR ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) )) AND ( p_check_job IS NULL )) THEN

    SET v_step = 500;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Unable to proceed: if p_started_in_last_mi or p_started_after_dt have been set, then p_check_job must also be set.';
    SET p_return_code = 'E';
    SET p_result = -2;

    LEAVE WSJOBSTATUS;

  END IF;

  SET v_step = 600;

  -- If the job sequence has been specified, see if it is in the control, run
  -- or log tables.
  IF ( p_check_sequence IS NOT NULL ) THEN

    SET v_step = 700;

    SELECT COALESCE(MAX(job_state),'0')
    INTO   :v_job_state
    FROM ( SELECT sequence_data.*
                , ROW_NUMBER() OVER (ORDER BY job_state ASC) AS rank_job_state
           FROM ( SELECT '0' AS job_state
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_sequence = :p_check_sequence
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                  FROM   [METABASE].ws_wrk_job_run
                  WHERE  wjr_sequence = :p_check_sequence
                  UNION
                  SELECT '2' AS job_state
                  FROM   [METABASE].ws_wrk_job_log
                  WHERE  wjl_sequence = :p_check_sequence
                  UNION
                  SELECT '3' AS job_state
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_sequence = :p_check_sequence
                  AND    wjc_status <> 'B'
                ) AS sequence_data
         ) AS ranked_date
    WHERE rank_job_state = 1
    ;

    SET v_step = 800;

    IF ( v_job_state = 0 ) THEN

      SET v_step = 900;

      SET p_job_status_simple = '0';
      SET p_job_status_standard = '0';
      SET p_job_status_enhanced = '0';
      SET p_return_msg = 'Unable to locate specified job sequence.';
      SET p_return_code = 'E';
      SET p_result = -1;

      LEAVE WSJOBSTATUS;

    END IF;

    SET v_job_sequence = p_check_sequence;

  -- If either date and time parameter has been specified...
  ELSEIF (( p_started_in_last_mi IS NOT NULL ) OR ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) )) THEN

    -- If the started in the last X minutes parameter has been specified, then
    -- convert this into a day.
    -- Note: significant work done to get around Teradata date arithmetic limits.
    IF ( p_started_in_last_mi IS NOT NULL ) THEN

      -- Abort if minutes > 148599, to avoid Teradata arithmetic overflow errors.
      IF ( p_started_in_last_mi > 148599 ) THEN

        SET v_step = 1000;

        SET p_job_status_simple = '0';
        SET p_job_status_standard = '0';
        SET p_job_status_enhanced = '0';
        SET p_return_msg = 'Unable to proceed: please specify p_started_in_last_mi <= 148599.';
        SET p_return_code = 'E';
        SET p_result = -2;

        LEAVE WSJOBSTATUS;

      -- If value of minutes OK, break into days, hours and minutes as Teradata intervals
      -- for days, hours and minutes cannot exceed 99 each.
      ELSE

        SET v_step = 1100;

        SET v_mi = p_started_in_last_mi;
        SET v_hh = 0;
        SET v_dd = 0;

        IF ( v_mi > 99 ) THEN

          SET v_step = 1200;

          SET v_mi = v_mi MOD 99;
          SET v_hh = (v_mi-(v_mi MOD 99))/99;

          IF ( v_hh > 99 ) THEN

            SET v_step = 1300;

            SET v_hh = v_hh MOD 99;
            SET v_dd = (v_hh-(v_hh MOD 99))/99;

          END IF;

        END IF;

      END IF;

      SET v_step = 1400;

      -- Work out allowable start date and store in v_started_after_dt using the day, hour
      -- and minute interval values.
      SET v_started_after_dt = CURRENT_TIMESTAMP - CAST(v_mi AS INTERVAL MINUTE)
                                - CAST(v_hh AS INTERVAL HOUR) - CAST(v_dd AS INTERVAL DAY);

    -- Start after date parameter specified, so assign this to v_started_after_dt.
    ELSEIF ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) ) THEN

      SET v_started_after_dt = p_started_after_dt;

    END IF;

    SET v_step = 1500;

    -- Get the sequence of the job and see if it is in the control, run
    -- or log tables.
    -- Note order of precedence: has run, is running, has not yet run.
    -- *** Row number function is used as Teradata ignores order by statements in
    -- in-line views.
    SELECT TOP 1
           COALESCE(job_state,'0')
         , COALESCE(job_sequence,0)
    INTO   :v_job_state
         , :v_job_sequence
    FROM ( SELECT sequence_data.*
                , ROW_NUMBER() OVER (ORDER BY job_state ASC, job_completed DESC, job_sequence DESC) AS rank_job_state
           FROM ( SELECT '0' AS job_state
                       , wjc_sequence AS job_sequence
		       , wjc_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_name = :p_check_job
                  AND    wjc_started >= :v_started_after_dt
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                       , wjr_sequence AS job_sequence
		       , COALESCE(wjr_completed,wjr_started) AS job_completed
                  FROM   [METABASE].ws_wrk_job_run
                  WHERE  wjr_name = :p_check_job
                  AND    wjr_started >= :v_started_after_dt
                  UNION
                  SELECT '2' AS job_state
                       , wjl_sequence AS job_sequence
		       , wjl_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_log
                  WHERE  wjl_name = :p_check_job
                  AND    wjl_started >= :v_started_after_dt
                  UNION
                  SELECT '3' AS job_state
                       , wjc_sequence AS job_sequence
		       , wjc_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_name = :p_check_job
                  AND    wjc_started >= :v_started_after_dt
                  AND    wjc_status <> 'B'
                ) AS sequence_data
         ) AS ranked_date
    WHERE rank_job_state = 1
    ORDER BY rank_job_state ASC, job_completed DESC, job_sequence DESC
    ;

    -- If job sequence hasn't been found, set v_job_not_found to Y for later use.
    IF ( v_job_sequence = 0 ) THEN

      SET v_job_not_found = 'Y';

    END IF;

  END IF;

  -- If the sequence parameter or neither date parameters has been specified or
  -- both previous checks failed to find the job look for the max sequence of
  -- the specified job.
  -- Note order of precedence: has run, is running, has not yet run.
  -- *** Row number function is used as Teradata ignores order by statements in
  -- in-line views.
  IF ((( p_check_sequence IS NULL ) AND ( p_started_in_last_mi IS NULL ) AND ( p_started_after_dt IS NULL OR p_started_after_dt <= CAST('1900-01-01 00:00:00' AS TIMESTAMP))) OR ( v_job_not_found = 'Y' )) THEN

    SET v_step = 1600;

    SELECT TOP 1
           COALESCE(job_state,'0')
         , COALESCE(job_sequence,0)
    INTO   :v_job_state
         , :v_job_sequence
    FROM ( SELECT sequence_data.*
                , ROW_NUMBER() OVER (ORDER BY job_state ASC, job_completed DESC, job_sequence DESC) AS rank_job_state
           FROM ( SELECT '0' AS job_state
                       , wjc_sequence AS job_sequence
		       , wjc_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_name = :p_check_job
                  AND    wjc_status = 'B'
                  UNION
                  SELECT '1' AS job_state
                       , wjr_sequence AS job_sequence
		       , COALESCE(wjr_completed,wjr_started) AS job_completed
                  FROM   [METABASE].ws_wrk_job_run
                  WHERE  wjr_name = :p_check_job
                  UNION
                  SELECT '2' AS job_state
                       , wjl_sequence AS job_sequence
		       , wjl_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_log
                  WHERE  wjl_name = :p_check_job
                  UNION
                  SELECT '3' AS job_state
                       , wjc_sequence AS job_sequence
		       , wjc_completed AS job_completed
                  FROM   [METABASE].ws_wrk_job_ctrl
                  WHERE  wjc_name = :p_check_job
                  AND    wjc_status <> 'B'
                ) AS sequence_data
         ) AS ranked_date
    WHERE rank_job_state = 1
    ORDER BY rank_job_state, job_completed DESC, job_sequence DESC
    ;

  END IF;

  SET v_step = 1700;

  -- If the job could not be found, abort.
  IF ( v_job_sequence = 0 ) THEN

    SET v_step = 1800;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Unable to locate job.';
    SET p_return_code = 'E';
    SET p_result = -1;

    LEAVE WSJOBSTATUS;

  -- If the job exists but not starting in the last X minutes then abort.
  ELSEIF ( p_started_in_last_mi IS NOT NULL AND v_job_not_found = 'Y' ) THEN

    SET v_step = 1900;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Job Not Found having started in the last ' || TRIM(CAST(p_started_in_last_mi AS VARCHAR(20))) ||' minutes.';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE WSJOBSTATUS;

  -- If he job exists but not starting since the specified date and time then abort.
  ELSEIF ( p_started_after_dt IS NOT NULL AND p_started_after_dt > CAST('1900-01-01 00:00:00' AS TIMESTAMP) AND v_job_not_found = 'Y' ) THEN

    SET v_step = 2000;

    SET p_job_status_simple = '0';
    SET p_job_status_standard = '0';
    SET p_job_status_enhanced = '0';
    SET p_return_msg = 'Job Not Found having started after ' || CAST(p_started_after_dt AS VARCHAR(19)) ||'.';
    SET p_return_code = 'N';
    SET p_result = -1;

    LEAVE WSJOBSTATUS;

  END IF;

  SET v_step = 2100;

  -- If the job was found and is currently running or has failed and not been
  -- aborted, get it's details.
  IF ( v_job_state = '1' ) THEN

    SET v_step = 2700;

    SELECT COALESCE(MAX(
           CASE job_status
             WHEN 'H' THEN 'N'
             WHEN 'W' THEN 'N'
             WHEN 'B' THEN 'N'
             WHEN 'P' THEN 'N'
             WHEN 'R' THEN 'R'
             WHEN 'F' THEN 'F'
             WHEN 'C' THEN 'C'
             WHEN 'G' THEN 'F'
             WHEN 'E' THEN 'F'
             ELSE '0'
           END),'0') AS Job_Status_Simple
         , COALESCE(MAX(job_status),'0') AS Job_Status_Standard
         , COALESCE(MAX(
           CASE job_status
             WHEN 'H' THEN '1'
             WHEN 'W' THEN '2'
             WHEN 'B' THEN '3'
             WHEN 'P' THEN '4'
             WHEN 'R' THEN '5'
             WHEN 'F' THEN '8'
             WHEN 'C' THEN '9'
             WHEN 'G' THEN '11'
             WHEN 'E' THEN '12'
             ELSE '0'
           END),'0') AS Job_Status_Enhanced
         , COALESCE(MAX(CASE job_status
             WHEN 'H' THEN 'On Hold'
             WHEN 'R' THEN 'Running'
             WHEN 'P' THEN 'Pending'
             WHEN 'W' THEN 'Waiting'
             WHEN 'C' THEN 'Completed'
             WHEN 'B' THEN 'Blocked'
             WHEN 'F' THEN 'Failed'
             WHEN 'G' THEN 'Failed - Aborted'
             WHEN 'E' THEN 'Error Completion'
             ELSE 'Unknown'
           END),'Unknown') AS Job_Status_Message
    INTO   :v_job_status_simple
         , :v_job_status_standard
         , :v_job_status_enhanced
         , :v_job_status_msg
    FROM (
        SELECT wjr_status AS job_status
        FROM [METABASE].ws_wrk_job_run
        WHERE wjr_sequence = :v_job_sequence
          UNION
        SELECT wjl_status AS job_status
        FROM [METABASE].ws_wrk_job_log
        WHERE wjl_sequence = :v_job_sequence
    ) AS sequence_data
    ;

    SET v_step = 2800;

    -- If the job is still running, check to see if any completed tasks
    -- have any errors or warning.   Then enhance the return message and
    -- status.   If there are both warnings and errors then report as a
    -- running with errors.
    IF ( v_job_status_enhanced = '5' ) THEN

      SET v_step = 2900;

      SELECT COUNT(*)
      INTO   :v_task_count
      FROM   [METABASE].ws_wrk_task_run
      WHERE  wtr_sequence = :v_job_sequence
      AND    wtr_audit_status IN ('E','F')
      ;

      SET v_step = 3000;

      IF ( v_task_count > 0 ) THEN

        SET v_step = 3100;

        SET v_job_status_enhanced = '6';
        SET v_job_status_msg = 'Running with Errors';

      ELSE

        SET v_step = 3200;

        SELECT COUNT(*)
        INTO   :v_task_count
        FROM   [METABASE].ws_wrk_task_run
        WHERE  wtr_sequence = :v_job_sequence
        AND    wtr_audit_status = 'W'
        ;

        SET v_step = 3300;

        IF ( v_task_count > 0 ) THEN

          SET v_step = 3400;

          SET v_job_status_enhanced = '7';
          SET v_job_status_msg = 'Running with Warnings';

        END IF;

      END IF;

    END IF;

  -- If the job was found and has completed running, get it's details.
  ELSEIF ( v_job_state = '2' ) THEN

    SET v_step = 2200;

    SELECT COALESCE(MAX(
           CASE wjl_status
             WHEN 'H' THEN 'N'
             WHEN 'W' THEN 'N'
             WHEN 'B' THEN 'N'
             WHEN 'P' THEN 'N'
             WHEN 'R' THEN 'R'
             WHEN 'F' THEN 'F'
             WHEN 'C' THEN 'C'
             WHEN 'G' THEN 'F'
             WHEN 'E' THEN 'F'
             ELSE '0'
           END),'0') AS Job_Status_Simple
         , COALESCE(MAX(wjl_status),'0') AS Job_Status_Standard
         , COALESCE(MAX(
           CASE wjl_status
             WHEN 'H' THEN '1'
             WHEN 'W' THEN '2'
             WHEN 'B' THEN '3'
             WHEN 'P' THEN '4'
             WHEN 'R' THEN '5'
             WHEN 'F' THEN '8'
             WHEN 'C' THEN '9'
             WHEN 'G' THEN '11'
             WHEN 'E' THEN '12'
             ELSE '0'
           END),'0') AS Job_Status_Enhanced
         , COALESCE(MAX(CASE wjl_status
             WHEN 'H' THEN 'On Hold'
             WHEN 'R' THEN 'Running'
             WHEN 'P' THEN 'Pending'
             WHEN 'W' THEN 'Waiting'
             WHEN 'C' THEN 'Completed'
             WHEN 'B' THEN 'Blocked'
             WHEN 'F' THEN 'Failed'
             WHEN 'G' THEN 'Failed - Aborted'
             WHEN 'E' THEN 'Error Completion'
             ELSE 'Unknown'
           END),'Unknown') AS Job_Status_Message
    INTO   :v_job_status_simple
         , :v_job_status_standard
         , :v_job_status_enhanced
         , :v_job_status_msg
    FROM   [METABASE].ws_wrk_job_log
    WHERE  wjl_sequence = :v_job_sequence
    ;

    SET v_step = 2300;

    -- If the job completed successfully, check to see if there were
    -- any warnings.   Then enhance the return message and status.
    IF ( v_job_status_enhanced = '9' ) THEN

      SET v_step = 2400;

      SELECT COUNT(*)
      INTO   :v_task_count
      FROM   [METABASE].ws_wrk_task_log
      WHERE  wtl_sequence = :v_job_sequence
      AND    wtl_audit_status = 'W'
      ;

      SET v_step = 2500;

      IF ( v_task_count > 0 ) THEN

        SET v_step = 2600;

        SET v_job_status_enhanced = '10';
        SET v_job_status_msg = 'Completed with Warnings';

      END IF;

    END IF;

  -- If the job was found and has not yet run, get it's details.
  ELSEIF ( v_job_state IN ( '0', '3' )) THEN

    SET v_step = 3500;

    SELECT COALESCE(MAX(
           CASE wjc_status
             WHEN 'H' THEN 'N'
             WHEN 'W' THEN 'N'
             WHEN 'B' THEN 'N'
             WHEN 'P' THEN 'N'
             WHEN 'R' THEN 'R'
             WHEN 'F' THEN 'F'
             WHEN 'C' THEN 'C'
             WHEN 'G' THEN 'F'
             WHEN 'E' THEN 'F'
             ELSE '0'
           END),'0') AS Job_Status_Simple
         , COALESCE(MAX(wjc_status),'0') AS Job_Status_Standard
         , COALESCE(MAX(
           CASE wjc_status
             WHEN 'H' THEN '1'
             WHEN 'W' THEN '2'
             WHEN 'B' THEN '3'
             WHEN 'P' THEN '4'
             WHEN 'R' THEN '5'
             WHEN 'F' THEN '8'
             WHEN 'C' THEN '9'
             WHEN 'G' THEN '11'
             WHEN 'E' THEN '12'
             ELSE '0'
           END),'0') AS Job_Status_Enhanced
         , COALESCE(MAX(CASE wjc_status
             WHEN 'H' THEN 'On Hold'
             WHEN 'R' THEN 'Running'
             WHEN 'P' THEN 'Pending'
             WHEN 'W' THEN 'Waiting'
             WHEN 'C' THEN 'Completed'
             WHEN 'B' THEN 'Blocked'
             WHEN 'F' THEN 'Failed'
             WHEN 'G' THEN 'Failed - Aborted'
             WHEN 'E' THEN 'Error Completion'
             ELSE 'Unknown'
           END),'Unknown') AS Job_Status_Message
    INTO   :v_job_status_simple
         , :v_job_status_standard
         , :v_job_status_enhanced
         , :v_job_status_msg
    FROM   [METABASE].ws_wrk_job_ctrl
    WHERE  wjc_sequence = :v_job_sequence
    ;

  END IF;

  SET v_step = 3600;

  SET p_job_status_simple = v_job_status_simple;
  SET p_job_status_standard = v_job_status_standard;
  SET p_job_status_enhanced = v_job_status_enhanced;
  SET p_return_msg = 'Job Sequence ' || TRIM(CAST(v_job_sequence AS VARCHAR(20))) || ' ' || v_job_status_msg;

END;
_PROCEDWSL_ Ws_Act_Create 
CREATE PROCEDURE [METABASE].Ws_Act_Create
( IN  p_sequence        integer
, IN  p_obj_type        integer
, IN  p_action          integer
, IN  p_obj_key         integer
, IN  p_job_name        varchar(64)
, IN  p_task_name       varchar(64)
, IN  p_job_id          integer
, IN  p_task_id         integer
, OUT p_return_msg      varchar(1024)
, OUT p_status_code     integer
, OUT p_result          integer
)
WS_ACT_CREATE:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name             Teradata
  -- Script Name           ws_act_create
  -- Description           Create a Table, View or Join Index
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002  Version 1.0.0
  -- WMR 10/02/2005  Version 4.1.1.3  Add support for User Views
  -- WMR 26/03/2006  Version 5.6.0.0  Add support for Retrofit copies
  -- WMR 07/09/2007                   Converted to DB2
  -- AP  31/01/2008  Version 5.6.3.1  Convert parameters in views
  -- AP  09/04/2008  Version 6.0.0.0  Added support for ODS/Normal
  -- JML 01/09/2008  Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- JML 20/10/2010  Version 6.5.1.1  RED-1878 Include missing Primary Index.
  -- AP  21/12/2011  Version 6.5.5.2  RED-1514 Support NO PRIMARY KEY
  -- RS  14/02/2013  Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- HM  07/07/2014  Version 6.8.1.1  Added Override DDL
  -- RS  18/01/2016  Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016  Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- RS  03/10/2016  Version 6.8.6.2  Added support for multiple statements in DDL override
  -- HM  13/10/2016  Version 6.8.6.3  Added warning that on-the-fly template Create DDL isn't supported
  -- HM  13/02/2019  Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_create_ddl_type       CHAR(1);

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as varchar
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_create                   VARCHAR(8000);
  DECLARE v_row                      INTEGER;
  DECLARE v_table_created            INTEGER;
  DECLARE v_alter_ind                INTEGER;
  DECLARE v_database                 VARCHAR(64);
  DECLARE v_post_fix                 VARCHAR(4000);
  DECLARE v_pct_free                 INTEGER;
  DECLARE v_primary_index_active     VARCHAR(1);
  DECLARE v_primary_index_unique     VARCHAR(1);
  DECLARE v_multiset_ind             VARCHAR(1);
  DECLARE v_fallback_ind             VARCHAR(1);
  DECLARE v_data_block_size          VARCHAR(64);
  DECLARE v_table_name               VARCHAR(64);
  DECLARE v_keys                     VARCHAR(4000);
  DECLARE v_column                   VARCHAR(4000);
  DECLARE v_primary_index_name       VARCHAR(64);
  DECLARE v_col                      INTEGER;
  DECLARE v_where                    VARCHAR(4000);
  DECLARE v_group_by                 VARCHAR(4000);
  DECLARE v_order_by_required        VARCHAR(1);
  DECLARE v_info_return_code         VARCHAR(1);
  DECLARE v_info_return_msg          VARCHAR(1024);
  DECLARE v_info_result              INTEGER;
  DECLARE v_log_ddl_cntr             INTEGER;
  DECLARE v_dbobj_name               VARCHAR(64);
  DECLARE v_from_tab                 VARCHAR(4000);
  DECLARE v_cpos                     INTEGER;
  DECLARE v_tab_meta                 VARCHAR(32000);
  DECLARE v_meta_loop                INTEGER;
  DECLARE v_text1                    VARCHAR(4000);
  DECLARE v_text2                    VARCHAR(4000);
  DECLARE v_text3                    VARCHAR(4000);
  DECLARE v_text4                    VARCHAR(4000);
  DECLARE v_text5                    VARCHAR(4000);
  DECLARE v_temp1                    VARCHAR(20000);
  DECLARE v_temp2                    VARCHAR(20000);
  DECLARE v_ddl_override             VARCHAR(20000);
  DECLARE v_is_template_ddl_target   INTEGER DEFAULT 0;
  DECLARE v_start_location           INTEGER DEFAULT 1;
  DECLARE v_end_location             INTEGER;
  DECLARE v_statement                VARCHAR(32000);
  DECLARE v_delimiter                VARCHAR(4000);

  --=====================================================
  -- Cursor to find the primary index columns
  --=====================================================
  DECLARE c_prim_ind_col CURSOR FOR
  SELECT   ic_column
  FROM     [METABASE].ws_index_col
  WHERE    ic_obj_key = p_obj_key
  AND      ic_index_key = ( SELECT MAX(ih_index_key)
                            FROM   [METABASE].ws_index_header
                            WHERE  ih_obj_key = p_obj_key
                            AND    ih_index_type = 'P')
  ORDER BY ic_column_no
  ;

  --=====================================================
  -- Cursor to find the primary index name
  --=====================================================
  DECLARE c_prim_ind_name CURSOR FOR
  SELECT ih_index_name
       , ih_active
  FROM   [METABASE].ws_index_header
  WHERE  ih_obj_key = p_obj_key
  AND    ih_index_type = 'P'
  ;

  --=====================================================
  -- Cursor to find all load primary key columns
  --=====================================================
  DECLARE c_load_key CURSOR FOR
  SELECT lc_col_name
  FROM   [METABASE].ws_load_col
  WHERE  lc_obj_key = p_obj_key
  AND    COALESCE(lc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(lc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(lc_primary_index_ind),'N') <> ''
  ORDER BY lc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all fact primary key columns
  --=====================================================
  DECLARE c_fact_key CURSOR FOR
  SELECT fc_col_name
  FROM   [METABASE].ws_fact_col
  WHERE  fc_obj_key = p_obj_key
  AND    COALESCE(fc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(fc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(fc_primary_index_ind),'N') <> ''
  ORDER BY fc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all agg primary key columns
  --=====================================================
  DECLARE c_agg_key CURSOR FOR
  SELECT ac_col_name
  FROM   [METABASE].ws_agg_col
  WHERE  ac_obj_key = p_obj_key
  AND    COALESCE(ac_primary_index_ind,'N') <> 'N'
  AND    COALESCE(ac_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(ac_primary_index_ind),'N') <> ''
  ORDER BY ac_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all dim primary key columns
  --=====================================================
  DECLARE c_dim_key CURSOR FOR
  SELECT dc_col_name
  FROM   [METABASE].ws_dim_col
  WHERE  dc_obj_key = p_obj_key
  AND    COALESCE(dc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(dc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(dc_primary_index_ind),'N') <> ''
  ORDER BY dc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all stage primary key columns
  --=====================================================
  DECLARE c_stage_key CURSOR FOR
  SELECT sc_col_name
  FROM   [METABASE].ws_stage_col
  WHERE  sc_obj_key = p_obj_key
  AND    COALESCE(sc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(sc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(sc_primary_index_ind),'N') <> ''
  ORDER BY sc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all retro primary key columns
  --=====================================================
  DECLARE c_retro_key CURSOR FOR
  SELECT rc_col_name
  FROM   [METABASE].ws_retro_col
  WHERE  rc_obj_key = p_obj_key
  AND    COALESCE(rc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(rc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(rc_primary_index_ind),'N') <> ''
  ORDER BY rc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all ods primary key columns
  --=====================================================
  DECLARE c_ods_key CURSOR FOR
  SELECT oc_col_name
  FROM   [METABASE].ws_ods_col
  WHERE  oc_obj_key = p_obj_key
  AND    COALESCE(oc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(oc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(oc_primary_index_ind),'N') <> ''
  ORDER BY oc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all normal primary key columns
  --=====================================================
  DECLARE c_normal_key CURSOR FOR
  SELECT nc_col_name
  FROM   [METABASE].ws_normal_col
  WHERE  nc_obj_key = p_obj_key
  AND    COALESCE(nc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(nc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(nc_primary_index_ind),'N') <> ''
  ORDER BY nc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all join primary key columns
  --=====================================================
  DECLARE c_join_key CURSOR FOR
  SELECT jc_col_name
  FROM   [METABASE].ws_join_col
  WHERE  jc_obj_key = p_obj_key
  AND    COALESCE(jc_primary_index_ind,'N') <> 'N'
  AND    COALESCE(jc_primary_index_ind,'N') <> '0'
  AND    COALESCE(TRIM(jc_primary_index_ind),'N') <> ''
  ORDER BY jc_primary_index_ind
  ;

  --=====================================================
  -- Cursor to find all load columns
  --=====================================================
  DECLARE c_load_col CURSOR FOR
  SELECT lc_col_name || ' ' || lc_data_type ||
         (CASE WHEN lc_compress_flag = 'Y' AND COALESCE(TRIM(lc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(lc_compress_value),''))
              WHEN lc_compress_flag = 'Y' AND COALESCE(TRIM(lc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(lc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(lc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(lc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(lc_format),'') <> '' THEN ' FORMAT ''' || lc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(lc_display_name),'') <> '' THEN ' TITLE ''' || lc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(lc_default_value),'') <> '' THEN ' DEFAULT ' || lc_default_value ELSE '' END)
  FROM   [METABASE].ws_load_col
  WHERE  lc_obj_key = p_obj_key
  ORDER BY lc_order
  ;


  --=====================================================
  -- Cursor to find all fact columns
  --=====================================================
  DECLARE c_fact_col CURSOR FOR
  SELECT fc_col_name || ' ' || fc_data_type ||
         (CASE WHEN fc_compress_flag = 'Y' AND COALESCE(TRIM(fc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(fc_compress_value),''))
              WHEN fc_compress_flag = 'Y' AND COALESCE(TRIM(fc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(fc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(fc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(fc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(fc_format),'') <> '' THEN ' FORMAT ''' || fc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(fc_display_name),'') <> '' THEN ' TITLE ''' || fc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(fc_default_value),'') <> '' THEN ' DEFAULT ' || fc_default_value ELSE '' END)
  FROM   [METABASE].ws_fact_col
  WHERE  fc_obj_key = p_obj_key
  ORDER BY fc_order
  ;

  --=====================================================
  -- Cursor to find all agg columns
  --=====================================================
  DECLARE c_agg_col CURSOR FOR
  SELECT ac_col_name || ' ' || ac_data_type ||
         (CASE WHEN ac_compress_flag = 'Y' AND COALESCE(TRIM(ac_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(ac_compress_value),''))
              WHEN ac_compress_flag = 'Y' AND COALESCE(TRIM(ac_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(ac_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(ac_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(ac_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(ac_format),'') <> '' THEN ' FORMAT ''' || ac_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(ac_display_name),'') <> '' THEN ' TITLE ''' || ac_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(ac_default_value),'') <> '' THEN ' DEFAULT ' || ac_default_value ELSE '' END)
  FROM   [METABASE].ws_agg_col
  WHERE  ac_obj_key = p_obj_key
  ORDER BY ac_order
  ;

  --=====================================================
  -- Cursor to find all dim columns
  --=====================================================
  DECLARE c_dim_col CURSOR FOR
  SELECT dc_col_name || ' ' || dc_data_type ||
         (CASE WHEN dc_compress_flag = 'Y' AND COALESCE(TRIM(dc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(dc_compress_value),''))
              WHEN dc_compress_flag = 'Y' AND COALESCE(TRIM(dc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(dc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(dc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(dc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(dc_format),'') <> '' THEN ' FORMAT ''' || dc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(dc_display_name),'') <> '' THEN ' TITLE ''' || dc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(dc_default_value),'') <> '' THEN ' DEFAULT ' || dc_default_value ELSE '' END)
  FROM   [METABASE].ws_dim_col
  WHERE  dc_obj_key = p_obj_key
  ORDER BY dc_order
  ;

  --=====================================================
  -- Cursor to find all stage columns
  --=====================================================
  DECLARE c_stage_col CURSOR FOR
  SELECT sc_col_name || ' ' || sc_data_type ||
         (CASE WHEN sc_compress_flag = 'Y' AND COALESCE(TRIM(sc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(sc_compress_value),''))
              WHEN sc_compress_flag = 'Y' AND (COALESCE(TRIM(sc_compress_value),'')) = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(sc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(sc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(sc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(sc_format),'') <> '' THEN ' FORMAT ''' || sc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(sc_display_name),'') <> '' THEN ' TITLE ''' || sc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(sc_default_value),'') <> '' THEN ' DEFAULT ' || sc_default_value ELSE '' END)
  FROM   [METABASE].ws_stage_col
  WHERE  sc_obj_key = p_obj_key
  ORDER BY sc_order
  ;

  --=====================================================
  -- Cursor to find all retro columns
  --=====================================================
  DECLARE c_retro_col CURSOR FOR
  SELECT rc_col_name || ' ' || rc_data_type ||
         (CASE WHEN rc_compress_flag = 'Y' AND COALESCE(TRIM(rc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(rc_compress_value),''))
              WHEN rc_compress_flag = 'Y' AND COALESCE(TRIM(rc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(rc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(rc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(rc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(rc_format),'') <> '' THEN ' FORMAT ''' || rc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(rc_display_name),'') <> '' THEN ' TITLE ''' || rc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(rc_default_value),'') <> '' THEN ' DEFAULT ' || rc_default_value ELSE '' END)
  FROM   [METABASE].ws_retro_col
  WHERE  rc_obj_key = p_obj_key
  ORDER BY rc_order
  ;

  --=====================================================
  -- Cursor to find all ods columns
  --=====================================================
  DECLARE c_ods_col CURSOR FOR
  SELECT oc_col_name || ' ' || oc_data_type ||
         (CASE WHEN oc_compress_flag = 'Y' AND COALESCE(TRIM(oc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(oc_compress_value),''))
              WHEN oc_compress_flag = 'Y' AND COALESCE(TRIM(oc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(oc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(oc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(oc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(oc_format),'') <> '' THEN ' FORMAT ''' || oc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(oc_display_name),'') <> '' THEN ' TITLE ''' || oc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(oc_default_value),'') <> '' THEN ' DEFAULT ' || oc_default_value ELSE '' END)
  FROM   [METABASE].ws_ods_col
  WHERE  oc_obj_key = p_obj_key
  ORDER BY oc_order
  ;

  --=====================================================
  -- Cursor to find all normal columns
  --=====================================================
  DECLARE c_normal_col CURSOR FOR
  SELECT nc_col_name || ' ' || nc_data_type ||
         (CASE WHEN nc_compress_flag = 'Y' AND COALESCE(TRIM(nc_compress_value),'') <> ''
              THEN ' COMPRESS ' || (COALESCE(TRIM(nc_compress_value),''))
              WHEN nc_compress_flag = 'Y' AND COALESCE(TRIM(nc_compress_value),'') = ''
              THEN ' COMPRESS' ELSE '' END) ||
         (CASE WHEN UPPER(nc_nulls_flag) = 'N' THEN ' NOT NULL' ELSE '' END) ||
         (CASE WHEN UPPER(nc_case_flag) IN ('B','U') THEN ' UPPERCASE CASESPECIFIC'
              WHEN UPPER(nc_case_flag) IN ('C','N') THEN ' NOT CASESPECIFIC' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(nc_format),'') <> '' THEN ' FORMAT ''' || nc_format || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(nc_display_name),'') <> '' THEN ' TITLE ''' || nc_display_name || '''' ELSE '' END) ||
         (CASE WHEN COALESCE(TRIM(nc_default_value),'') <> '' THEN ' DEFAULT ' || nc_default_value ELSE '' END)
  FROM   [METABASE].ws_normal_col
  WHERE  nc_obj_key = p_obj_key
  ORDER BY nc_order
  ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Create Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('F', p_job_name, p_task_name, p_sequence
          , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_table_created            = 0;
  SET v_alter_ind                = 0;
  SET v_group_by                 = '';
  SET v_order_by_required        = 'N';
  SET v_log_ddl_cntr             = 0;
  SET v_from_tab                 = '';
  SET v_meta_loop                = 0;
  SET v_ws_create_ddl_type       = '3';

  --=====================================================
  -- MAIN
  --=====================================================
  SET v_step = 100;

  IF p_obj_type = v_ws_obj_view THEN

    SET v_dbobj_name = 'View';

  ELSEIF p_obj_type = v_ws_obj_join THEN

    SET v_dbobj_name = 'Join Index';

  ELSE

    SET v_dbobj_name = 'Table';

  END IF;

  --=====================================================
  -- Fall thru return variables.
  --=====================================================
  SET v_step = 200;

  SET p_return_msg = 'Unsupported object type ' || TRIM(CAST((COALESCE(p_obj_type,-1)) AS VARCHAR(18))) || ' in create';
  SET p_status_code = -2;
  SET p_result = -2;

  --**********************************
  -- C U B E
  --**********************************
  SET v_step = 300;

  IF p_obj_type = v_ws_obj_cube THEN

    -- run an Cube create by returning a result of 4
    SET p_result = 4;
    SET p_status_code = 4;

    LEAVE WS_ACT_CREATE;

  --**********************************
  -- C U B E   V I R T U A L
  --**********************************
  ELSEIF p_obj_type = v_ws_obj_cube_virtual THEN

    -- run an Cube create by returning a result of 4
    SET p_result = 4;
    SET p_status_code = 4;

    LEAVE WS_ACT_CREATE;

  ELSE

    --=====================================================
    --=====================================================
    -- Get table metadata for each table type
    --=====================================================
    --=====================================================
    SET v_step = 400;

    CALL [METABASE].Ws_Object_Info(p_sequence, p_job_name, p_task_name, p_job_id, p_task_id
                                 , p_obj_key, NULL
                                 , 'ALL'
                                 , v_info_return_code, v_info_return_msg
                                 , v_info_result, v_tab_meta  );

    SET v_step = 500;

    WHILE ( v_meta_loop < 9 ) DO

      SET v_meta_loop = v_meta_loop + 1;
      SET v_cpos = INDEX(v_tab_meta,X'08');

      IF v_meta_loop = 1 THEN

        SET v_database = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 2 THEN

        SET v_post_fix = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 3 THEN

        SET v_pct_free = CAST(SUBSTR(v_tab_meta,1,v_cpos-1) AS INTEGER);

      ELSEIF v_meta_loop = 4 THEN

        SET v_primary_index_unique = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 5 THEN

        SET v_multiset_ind = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 6 THEN

        SET v_fallback_ind = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 7 THEN

        SET v_data_block_size = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 8 THEN

        SET v_table_name = SUBSTR(v_tab_meta,1,v_cpos-1);

      ELSEIF v_meta_loop = 9 THEN

        SET v_where = SUBSTR(v_tab_meta,1,v_cpos-1);

      END IF;

      SET v_tab_meta = SUBSTR(v_tab_meta,v_cpos+1);

    END WHILE;

  END IF;

  --=====================================================
  --=====================================================
  -- Get the database for the table
  --=====================================================
  --=====================================================
  SET v_step = 600;

  -- If the database is null, lookup the current users default database
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SELECT CASE WHEN DefaultDataBase IS NULL
                THEN UserName
                ELSE DefaultDataBase
                END
    INTO   v_database
    FROM   DBC.Users
    WHERE  UserName = USER
    ;

  END IF;

  SET v_step = 700;

  -- If the database is still null, set it to the USER.
  IF NULLIF(TRIM(v_database),'') IS NULL THEN

    SET v_database = USER;

  END IF;

  SET v_database = TRIM(v_database);

  --=====================================================
  --=====================================================
  -- Get the primary index and its name.
  --=====================================================
  --=====================================================

  SET v_step = 800;

  IF p_obj_type <> v_ws_obj_view THEN

    -- First look for a defined primary index
    SET v_keys = '';
    SET v_no_more_data1 = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_prim_ind_col;

      FETCH FROM c_prim_ind_col INTO v_column;

      WHILE v_no_more_data1 = 0 DO

        IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

          SET v_keys = v_keys || ',';

        END IF;

        SET v_keys = v_keys || v_column;

        FETCH FROM c_prim_ind_col INTO v_column;

      END WHILE;

      CLOSE c_prim_ind_col;

    END;

    SET v_no_more_data1 = 0;

    -- Second, if no defined primary index object, look for
    -- columns marked as primary index columns
    IF NULLIF(TRIM(v_keys),'') IS NULL THEN

      BEGIN

        DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_no_more_data1 = 1;

        --**********************************
        -- L O A D
        --**********************************
        IF p_obj_type = v_ws_obj_load THEN

          OPEN c_load_key;

          FETCH FROM c_load_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_load_key INTO v_column;

          END WHILE;

          CLOSE c_load_key;

        --**********************************
        -- F A C T   A N D   K P I   F A C T
        --**********************************
        ELSEIF (( p_obj_type = v_ws_obj_fact ) OR ( p_obj_type = v_ws_obj_fact_kpi )) THEN

          OPEN c_fact_key;

          FETCH FROM c_fact_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

           SET v_keys = v_keys || v_column;

            FETCH FROM c_fact_key INTO v_column;

          END WHILE;

          CLOSE c_fact_key;

        --**********************************
        -- A G G R E G A T E
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_agg THEN

          OPEN c_agg_key;

          FETCH FROM c_agg_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_agg_key INTO v_column;

          END WHILE;

          CLOSE c_agg_key;

        --**********************************
        -- D I M E N S I O N
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_dim THEN

          OPEN c_dim_key;

          FETCH FROM c_dim_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_dim_key INTO v_column;

          END WHILE;

          CLOSE c_dim_key;

        --**********************************
        -- S T A G E
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_stage THEN

          OPEN c_stage_key;

          FETCH FROM c_stage_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_stage_key INTO v_column;

          END WHILE;

          CLOSE c_stage_key;

        --**********************************
        -- R E T R O   C O P Y   A N D
        -- R E T R O
        --**********************************
        ELSEIF (( p_obj_type = v_ws_obj_retro ) OR ( p_obj_type = v_ws_obj_retro_copy )) THEN

          OPEN c_retro_key;

          FETCH FROM c_retro_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_retro_key INTO v_column;

          END WHILE;

          CLOSE c_retro_key;

        --**********************************
        -- O D S
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_ods THEN

          OPEN c_ods_key;

          FETCH FROM c_ods_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_ods_key INTO v_column;

          END WHILE;

          CLOSE c_ods_key;

        --**********************************
        -- N O R M A L, H U B, etc
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_normal
            OR p_obj_type = v_ws_obj_hub
            OR p_obj_type = v_ws_obj_satellite
            OR p_obj_type = v_ws_obj_link
            OR p_obj_type = v_ws_obj_custom1
            OR p_obj_type = v_ws_obj_custom2
        THEN

          OPEN c_normal_key;

          FETCH FROM c_normal_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_normal_key INTO v_column;

          END WHILE;

          CLOSE c_normal_key;

        --**********************************
        -- J O I N
        --**********************************
        ELSEIF p_obj_type = v_ws_obj_join THEN

          OPEN c_join_key;

          FETCH FROM c_join_key INTO v_column;

          WHILE v_no_more_data1 = 0 DO

            IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

              SET v_keys = v_keys || ',';

            END IF;

            SET v_keys = v_keys || v_column;

            FETCH FROM c_join_key INTO v_column;

          END WHILE;

          CLOSE c_join_key;

        END IF;

      END;

    END IF;

    -- Get the primary index name
    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
      BEGIN
        SET v_primary_index_name = '';
        SET v_primary_index_active = '';
      END;

      OPEN c_prim_ind_name;

      FETCH FROM c_prim_ind_name INTO v_primary_index_name
                                     ,v_primary_index_active;

      CLOSE c_prim_ind_name;

    END;

  END IF;

  --=====================================================
  -- DDL Override
  --=====================================================

  SET v_step = 900;

  SELECT COALESCE(ta_text_1, '')
       , COALESCE(ta_text_2, '')
       , COALESCE(ta_text_3, '')
       , COALESCE(ta_text_4, '')
       , COALESCE(ta_text_5, '')
    INTO v_text1
       , v_text2
       , v_text3
       , v_text4
       , v_text5
  FROM [METABASE].ws_table_attributes
  WHERE ta_obj_key = p_obj_key
    AND ta_type = 'D'
  ;

  IF TRIM(v_text1) <> '' THEN

    SET v_step = 1000;

    SET v_table_name = TRIM(v_table_name);

    SET v_temp2 = v_text1 || v_text2 || v_text3 || v_text4 || v_text5;
    CALL [METABASE].Ws_String_Replace(v_temp2, '$SCHEMA$', v_database, v_temp1);
    CALL [METABASE].Ws_String_Replace(v_temp1, '$TABLE$', v_table_name, v_temp2);
    CALL [METABASE].Ws_String_Replace(v_temp2, '$DATABASE$', v_database, v_temp1);
    CALL [METABASE].Ws_String_Replace(v_temp1, '$OBJECT$', v_database || '.' || v_table_name, v_temp2);
    CALL [METABASE].Ws_String_Replace(v_temp2, '$INDEX$', v_table_name, v_temp1);
    CALL [METABASE].WsParameterReplace(v_temp1, 20000, v_ddl_override);

    SET v_step = 1100;

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET v_end_location = COALESCE(CHARACTER_LENGTH(v_ddl_override),0);

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT COALESCE(ta_text_3, '<EOS>') INTO v_delimiter FROM [METABASE].ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

     -- Loop through the override statement and execute each statement individually
    WHILE v_end_location > 0 DO

        SET v_sql_error = '';

        SELECT INSTR(v_ddl_override,v_delimiter, v_start_location) INTO v_end_location;

        SELECT CASE
              WHEN v_end_location > 0
              THEN SUBSTR(v_ddl_override,v_start_location,v_end_location -v_start_location)
              ELSE SUBSTR(v_ddl_override,v_start_location)
              END  INTO v_statement;

        IF TRIM(COALESCE(v_statement,'')) <> '' AND TRIM(v_statement) <> x'0A' THEN
            BEGIN
                DECLARE EXIT HANDLER FOR SQLEXCEPTION
                BEGIN
                  GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
                  SET v_sql_code = SQLCODE;


                  SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none'))
                               || ' Failed with SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error
                                ;
                  CALL [METABASE].WsWrkAudit( 'E', p_job_name, p_task_name, p_sequence
                                            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id
                                            );
                  SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none')) || ' Failed';
                  SET p_return_msg = v_msgtext;
                  SET p_status_code = -2;
                  SET p_result = -2;
                END;

                CALL DBC.SYSEXECSQL (v_statement);

                SET v_msgtext = v_dbobj_name || ' created using DDL Override ';

                IF NULLIF(v_database, '') IS NOT NULL THEN
                SET v_msgtext = v_msgtext || v_database || '.';
                END IF;

                SET v_msgtext = v_msgtext || v_table_name;
                SET v_table_created = 1;
                SET p_return_msg = v_msgtext;
                SET p_result = 1;
                SET p_status_code = 1;

            END;
        END IF;

        SELECT v_end_location + CHARACTER_LENGTH(v_delimiter) INTO v_start_location;
    END WHILE;

    LEAVE WS_ACT_CREATE;
  END IF;

  --=====================================================
  -- DDL Override Template Not Supported
  --=====================================================

  SET v_step = 1200;

  SET v_is_template_ddl_target = 0;
  SELECT 1
    INTO v_is_template_ddl_target
    FROM [METABASE].ws_table_attributes
   WHERE ta_obj_key = p_obj_key
     AND ta_type = 'L'
     AND ( v_ws_create_ddl_type = ta_ind_1
        OR v_ws_create_ddl_type = ta_ind_2
        OR v_ws_create_ddl_type = ta_ind_3
        OR v_ws_create_ddl_type = ta_ind_4
        OR v_ws_create_ddl_type = ta_ind_5
        OR v_ws_create_ddl_type = ta_ind_6
        OR v_ws_create_ddl_type = ta_ind_7
        OR v_ws_create_ddl_type = ta_ind_8
        OR v_ws_create_ddl_type = ta_ind_9
        OR v_ws_create_ddl_type = ta_ind_10
        OR v_ws_create_ddl_type = ta_ind_11
        OR v_ws_create_ddl_type = ta_ind_12
         )
  ;
  IF v_is_template_ddl_target = 1
  THEN
    SET v_step = 1300;

    SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none'))
                 || ' Failed - template based Create DDL Override is not supported by Teradata scheduler'
                  ;
    CALL [METABASE].WsWrkAudit( 'F', p_job_name, p_task_name, p_sequence
                              , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id
                              );
    SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none')) || ' Failed';
    SET p_return_msg = v_msgtext;
    SET p_status_code = -2;
    SET p_result = -2;

    LEAVE WS_ACT_CREATE;
  END IF;

  --=====================================================
  --=====================================================
  -- Build the SQL for the create
  --=====================================================
  --=====================================================

  SET v_step = 1400;

  -- If a view, call separate proc.
  IF p_obj_type = v_ws_obj_view THEN

    CALL [METABASE].Ws_Act_Create_View(p_sequence, p_obj_type, p_action, p_obj_key
                                     , p_job_name, p_task_name, p_job_id, p_task_id
                                     , v_create
                                     , v_info_return_msg, v_info_return_code, v_info_result);

  -- If a join index, call separate proc.
  ELSEIF p_obj_type = v_ws_obj_join THEN

    CALL [METABASE].Ws_Act_Create_Join(p_sequence, p_obj_type, p_action, p_obj_key
                                     , p_job_name, p_task_name, p_job_id, p_task_id
                                     , v_create
                                     , v_info_return_msg, v_info_return_code, v_info_result);

  -- All other table objects.
  ELSE

    -- Set unique/nonunique set/multiset in the create
    IF v_primary_index_unique = 'Y' THEN

      SET v_create = 'Create Set Table ';

    ELSEIF v_multiset_ind = 'Y' THEN

      SET v_create = 'Create Multiset Table ';

    ELSE

      SET v_create = 'Create Set Table ';

    END IF;

    -- Add in the database is specified
    IF NULLIF(TRIM(v_database),'') IS NOT NULL THEN

      SET v_create = v_create || v_database || '.';

    END IF;

    -- Add in the table name
    SET v_create = v_create || v_table_name;

    -- Add fallback if required
    IF v_fallback_ind = 'Y' THEN

      SET v_create = v_create || ' ' || X'0A' || ', Fallback ';

    ELSE

      SET v_create = v_create || ' ' || X'0A' || ', No Fallback ';

    END IF;

    -- Add in the free space if specified
    IF (( v_pct_free >= 0 ) AND ( v_pct_free <= 75 )) THEN

      SET v_create = v_create || ' ' || X'0A' || ', Freespace = ' || CAST(v_pct_free AS VARCHAR(18)) || ' Percent ';

    END IF;

    -- Add in the block size if specified
    IF NULLIF(TRIM(v_data_block_size),'') IS NOT NULL THEN

      IF v_data_block_size = 'MAXIMUM' THEN

        SET v_create = v_create || ' ' || X'0A' || ', Maximum Datablocksize ';

      ELSEIF v_data_block_size = 'MINIMUM' THEN

        SET v_create = v_create || ' ' || X'0A' || ', Minimum Datablocksize ';

      ELSE

        SET v_create = v_create || ' ' || X'0A' || ', Datablocksize=' || v_data_block_size || ' ';

      END IF;

    END IF;

    -- Add in the column names
    SET v_create = v_create || '(' || X'0A';
    SET v_no_more_data1 = 0;
    SET v_row = 0;
    SET v_col = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      --**********************************
      -- L O A D
      --**********************************
      IF p_obj_type = v_ws_obj_load THEN

        OPEN c_load_col;

        FETCH FROM c_load_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_load_col INTO v_column;

        END WHILE;

        CLOSE c_load_col;

      --**********************************
      -- F A C T   A N D   K P I   F A C T
      --**********************************
      ELSEIF (( p_obj_type = v_ws_obj_fact ) OR ( p_obj_type = v_ws_obj_fact_kpi )) THEN

        OPEN c_fact_col;

        FETCH FROM c_fact_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_fact_col INTO v_column;

        END WHILE;

        CLOSE c_fact_col;

      --**********************************
      -- A G G R E G A T E
      --**********************************
      ELSEIF p_obj_type = v_ws_obj_agg THEN

        OPEN c_agg_col;

        FETCH FROM c_agg_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_agg_col INTO v_column;

        END WHILE;

        CLOSE c_agg_col;

      --**********************************
      -- D I M E N S I O N
      --**********************************
      ELSEIF p_obj_type = v_ws_obj_dim THEN

        OPEN c_dim_col;

        FETCH FROM c_dim_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_dim_col INTO v_column;

        END WHILE;

        CLOSE c_dim_col;

      --**********************************
      -- S T A G E
      --**********************************
      ELSEIF p_obj_type = v_ws_obj_stage THEN

        OPEN c_stage_col;

        FETCH FROM c_stage_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_stage_col INTO v_column;

        END WHILE;

        CLOSE c_stage_col;

      --**********************************
      -- R E T R O   C O P Y   A N D
      -- R E T R O
      --**********************************
      ELSEIF (( p_obj_type = v_ws_obj_retro ) OR ( p_obj_type = v_ws_obj_retro_copy )) THEN

        OPEN c_retro_col;

        FETCH FROM c_retro_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_retro_col INTO v_column;

        END WHILE;

        CLOSE c_retro_col;

      --**********************************
      -- O D S
      --**********************************
      ELSEIF p_obj_type = v_ws_obj_ods THEN

        OPEN c_ods_col;

        FETCH FROM c_ods_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_ods_col INTO v_column;

        END WHILE;

        CLOSE c_ods_col;

      --**********************************
      -- N O R M A L, H U B, etc.
      --**********************************
      ELSEIF p_obj_type = v_ws_obj_normal
          OR p_obj_type = v_ws_obj_hub
          OR p_obj_type = v_ws_obj_satellite
          OR p_obj_type = v_ws_obj_link
          OR p_obj_type = v_ws_obj_custom1
          OR p_obj_type = v_ws_obj_custom2
      THEN

        OPEN c_normal_col;

        FETCH FROM c_normal_col INTO v_column;

        WHILE v_no_more_data1 = 0 DO

          SET v_row = v_row + 1;
          SET v_col = v_col + 1;

          IF v_row > 1 THEN

            SET v_create = v_create || ',';

          END IF;

          SET v_create = v_create || v_column;

          IF v_col > 3 THEN

            SET v_col = 0;
            SET v_create = v_create || X'0A';

          END IF;

          FETCH FROM c_normal_col INTO v_column;

        END WHILE;

        CLOSE c_normal_col;

      END IF;

    END;

    -- Build up the rest of the create string
    SET v_create = v_create || ')' || X'0A';

  END IF;

  -- =============================================================================
  -- RED-1878 Changed to not add for Join Indexes, as PI is now added in
  --          Ws_Act_Create_Join.
  -- =============================================================================
  --  IF p_obj_type <> v_ws_obj_view THEN
  IF p_obj_type <> v_ws_obj_view
  AND p_obj_type <> v_ws_obj_join THEN

    -- Add the primary index, if defined otherwise don't
    -- specify and Teradata will use the first column.
    IF v_primary_index_active = 'N' THEN
      SET v_create = v_create || 'NO PRIMARY INDEX ';
    ELSE
      IF NULLIF(TRIM(v_keys),'') IS NOT NULL THEN

        IF v_primary_index_unique = 'Y' THEN

          SET v_create = v_create || 'UNIQUE ';

        END IF;


        SET v_create = v_create || 'PRIMARY INDEX ';

        IF NULLIF(TRIM(v_primary_index_name),'') IS NOT NULL THEN

          SET v_create = v_create || v_primary_index_name;

        END IF;

        SET v_create = v_create || ' (';
        SET v_create = v_create || v_keys;
        SET v_create = v_create || ')' || X'0A' || ' ';

      ELSE

        SET v_create = v_create || ' ';
      END IF; -- Keys

    END IF; --Active INDEX

  END IF;

  -- Add any table options
  SET v_create = v_create || v_post_fix;

  --=====================================================
  --=====================================================
  -- Create the table
  --=====================================================
  --=====================================================
  BEGIN

    DECLARE EXIT HANDLER
      FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
        SET v_sql_code = SQLCODE;
        SET v_msgtext = v_dbobj_name || ' creation ' || (COALESCE(v_table_name,'none')) || ' Failed with ' ||
                        'SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
        CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
        SET v_msgtext = v_dbobj_name || ' creation ' || (COALESCE(v_table_name,'none')) || ' Failed';
        SET p_return_msg = v_msgtext;
        SET p_status_code = -2;
        SET p_result = -2;
      END;

    IF NULLIF(TRIM(v_create),'') IS NULL THEN

      SET v_msgtext = v_dbobj_name || ' creation ' || (COALESCE(v_table_name,'none')) || ' Failed - no SQL';
      SET p_return_msg = v_msgtext;
      SET p_result = -2;
      SET p_status_code = -2;

      LEAVE WS_ACT_CREATE;

    END IF;

    -- Replace special strings and parameters for views
    IF p_obj_type = v_ws_obj_view THEN
        SET v_temp2 = v_create;
        CALL [METABASE].Ws_String_Replace(v_temp2, '$SCHEMA$', v_database, v_temp1);
        CALL [METABASE].Ws_String_Replace(v_temp1, '$TABLE$', v_table_name, v_temp2);
        CALL [METABASE].Ws_String_Replace(v_temp2, '$DATABASE$', v_database, v_temp1);
        CALL [METABASE].Ws_String_Replace(v_temp1, '$OBJECT$', v_database || '.' || v_table_name, v_temp2);
        CALL [METABASE].WsParameterReplace(v_temp2, 20000, v_create);
    END IF;

    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET v_end_location = COALESCE(CHARACTER_LENGTH(v_create),0);

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT COALESCE(ta_text_3, '<EOS>') INTO v_delimiter FROM [METABASE].ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

     -- Loop through the override statement and execute each statement individually
    WHILE v_end_location > 0 DO

        SET v_sql_error = '';

        SELECT INSTR(v_create,v_delimiter, v_start_location) INTO v_end_location;

        SELECT CASE
              WHEN v_end_location > 0
              THEN SUBSTR(v_create,v_start_location,v_end_location -v_start_location)
              ELSE SUBSTR(v_create,v_start_location)
              END  INTO v_statement;

        IF TRIM(COALESCE(v_statement,'')) <> '' AND TRIM(v_statement) <> x'0A' THEN
            BEGIN
                DECLARE EXIT HANDLER FOR SQLEXCEPTION
                BEGIN
                  GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
                  SET v_sql_code = SQLCODE;


                  SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none'))
                               || ' Failed with SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error
                                ;
                  CALL [METABASE].WsWrkAudit( 'E', p_job_name, p_task_name, p_sequence
                                            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id
                                            );
                  SET v_msgtext = v_dbobj_name || ' creation using DDL Override ' || (COALESCE(v_table_name, 'none')) || ' Failed';
                  SET p_return_msg = v_msgtext;
                  SET p_status_code = -2;
                  SET p_result = -2;
                END;

                CALL DBC.SYSEXECSQL (v_statement);

                SET v_msgtext = v_dbobj_name || ' created using DDL Override ';

                IF NULLIF(v_database, '') IS NOT NULL THEN
                SET v_msgtext = v_msgtext || v_database || '.';
                END IF;

                SET v_msgtext = v_msgtext || v_table_name;
                SET v_table_created = 1;
                SET p_return_msg = v_msgtext;
                SET p_result = 1;
                SET p_status_code = 1;

            END;
        END IF;

        SELECT v_end_location + CHARACTER_LENGTH(v_delimiter) INTO v_start_location;
    END WHILE;

    SET v_msgtext = v_dbobj_name || ' created ';

    IF NULLIF(v_database,'') IS NOT NULL THEN

      SET v_msgtext = v_msgtext || v_database || '.';

    END IF;

    SET v_msgtext = v_msgtext || v_table_name;
    SET v_table_created = 1;
    SET p_return_msg = v_msgtext;
    SET p_result = 1;
    SET p_status_code = 1;

    LEAVE WS_ACT_CREATE;

  END;

END;
_PROCEDWSL_ Ws_Act_Export 
CREATE PROCEDURE [METABASE].Ws_Act_Export
( IN  p_sequence        INTEGER
, IN  p_obj_type        INTEGER
, IN  p_action          INTEGER
, IN  p_obj_key         INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, OUT p_return_msg      VARCHAR(1024)
, OUT p_status_code     INTEGER
, OUT p_result          INTEGER
)
WS_ACT_EXPORT:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    		Teradata
  -- Script Name 			ws_act_export
  -- Description 			Exports an export object
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- JML 17/04/2007   Version 5.6.0.0
  -- WMR 13/09/2007   Version 5.6.0.0  DB2 port
  -- AP  29/04/2008   Version 6.0.0.0  Standardized constants
  -- JML 01/09/2008   Version 6.0.2.0  Teradata Linux Scheduler Changes
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_stmt                     VARCHAR(4000);
  DECLARE v_status_code              INTEGER;
  DECLARE v_result                   INTEGER;

  --=====================================================
  -- Export Table Variables
  --=====================================================
  DECLARE v_et_pre_action            VARCHAR(1);
  DECLARE v_et_table_name            VARCHAR(64);
  DECLARE v_et_pre_sql               VARCHAR(4000);
  DECLARE v_et_type                  VARCHAR(1);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Export Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_max               = 27;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;

  --=====================================================
  -- MAIN
  --=====================================================
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 10;
  SET p_result = 1;

  --=====================================================
  -- First get the export table information
  --=====================================================
  SELECT et_pre_action
       , et_pre_sql
       , et_type
       , et_table_name
  INTO   v_et_pre_action
       , v_et_pre_sql
       , v_et_type
       , v_et_table_name
  FROM   [METABASE].ws_export_tab
  WHERE  et_obj_key = p_obj_key;

  SET v_step = 20;

  --=====================================================
  -- Handle any pre-export action
  --=====================================================
  IF v_et_pre_action = 'E' THEN

    SET v_stmt = TRIM(v_et_pre_sql);

    BEGIN
      DECLARE EXIT HANDLER
        FOR SQLEXCEPTION
        BEGIN
          GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
          SET v_sql_code = SQLCODE;
          SET v_msgtext = 'Ws_Act_Export ' || v_ws_pro_version ||
            'Unhandled exception in pre_export_sql for table ' || v_et_table_name;
          SET p_return_msg = v_msgtext;
          CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
          SET p_status_code = -2;
          SET p_result = -2;
        END;

      CALL DBC.SYSEXECSQL ( v_stmt );

      SET v_msgtext = SUBSTR('Executed pre export sql. ' || COALESCE(v_et_pre_sql,'NULL'),1,1023);
      CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence
        , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    END;

  END IF;

  --=====================================================
  -- See what type of export this is
  -- S = Script based export
  -- F = File based export
  -- E = External export
  --=====================================================
  --**********************************
  -- File export
  --**********************************
  IF v_et_type = 'F' THEN

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key
      , p_job_name, p_task_name, p_job_id, p_task_id
      , p_return_msg, v_status_code, v_result);

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF v_result = 1 THEN

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  END IF;

  --**********************************
  -- Script export
  --**********************************
  IF v_et_type = 'S' THEN

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key
      , p_job_name, p_task_name, p_job_id, p_task_id
      , p_return_msg, v_status_code, v_result);

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    IF v_result = 1 THEN

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  END IF;

  --**********************************
  -- External export
  --**********************************
  IF v_et_type = 'E' THEN

    SET p_return_msg = 'Externally exported';
    SET p_status_code = 1;
    SET p_result = 1;

  END IF;

  --**********************************
  -- Unsupported Export type
  --**********************************
  IF v_et_type NOT IN ('F','S','E') THEN

    SET v_msgtext = 'Ws_Act_Export '|| v_ws_pro_version || ' Unsupported Export Type ';
    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
      , v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET p_return_msg = 'Unsupport export type in Ws_Act_Export '|| v_ws_pro_version;
    SET p_status_code = -2;
    SET p_result = -2;

    LEAVE WS_ACT_EXPORT;

  END IF;

END;
_PROCEDWSL_ Ws_Act_Load 
CREATE PROCEDURE [METABASE].Ws_Act_Load
( IN  p_sequence        INTEGER
, IN  p_obj_type        INTEGER
, IN  p_action          INTEGER
, IN  p_obj_key         INTEGER
, IN  p_job_name        VARCHAR(64)
, IN  p_task_name       VARCHAR(64)
, IN  p_job_id          INTEGER
, IN  p_task_id         INTEGER
, OUT p_return_msg      VARCHAR(1024)
, OUT p_status_code     INTEGER
, OUT p_result          INTEGER
)
WS_ACT_LOAD:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name 	    		Teradata
  -- Script Name 			ws_act_load
  -- Description 			Loads a load table
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 22/01/2002   Version 1.0.0
  -- WMR 08/04/2002   Version 1.0.7    Added support for using lt_load_statement
  -- WMR 01/05/2002   Version 1.0.7.6  Fixed problem with pre-load sql.
  -- WMR 18/06/2002   Version 1.1.0    Added support for Non mandatory columns
  -- WMR 30/10/2002   Version 1.2.1.4  Converted to sql server
  -- WMR 01/04/2003   Version 1.2.1.7  added support for OPENQUERY for Oracle db linked loads
  -- WMR 16/05/2003   Version 1.2.1.8  added support for parameter replacement in where clause
  -- WMR 15/09/2003   Version 4.1.0.1  fixed issue with brackets applied to Oracle OpenQuery commands
  -- WMR 13/02/2004   Version 4.1.0.1  added support for XML based file loads
  -- WMR 25/07/2004   Version 4.1.0.8  Allow comments in transformations
  -- WMR 28/09/2004   Version 4.1.1.0  ODBC based statement overrides are handled in the scheduler
  -- WMR 10/02/2005   Version 4.1.1.3  Add support for a DISTINCT select and version in error
  -- WMR 19/04/2005   Version 4.1.2.2  Increased length of dc_dblink_id variable to 1024
  -- WMR 27/03/2005   Version 5.0.1.4  Prevented a [[ ]] situation if [] already around a table or column
  -- AP  29/01/2006   Version 5.5.0.8  Incorrectly processing if load col length > 4000
  -- JML 22/03/2007   Version 5.5.0.17 support for Native ODBC loads Added.
  -- WMR 22/05/2007   Version 5.6.0.6  Changed the status code returned by Odbc loads to 2 to prevent erroneous warning message.
  -- WMR 13/09/2007   Version 5.6.1.1  Converted to DB2
  -- AP  11/02/2008   Version 5.6.3.1  Call WsParameterReplace to allow parse of all fields for parameter substitution.
  --                                   Added substitution of $JOB_SEQUENCE$ with p_sequence
  -- AP  29/04/2008   Version 6.0.0.0  Standardized constants
  --     20/05/2008                    Now call ws_act_truncate to perform the truncate
  --     23/06/2008                    WsParameterReplace changed to a procedure rather than function
  -- JML 01/09/2008   Version 6.0.2.0  Teradata Conversion
  -- AP  03/12/2010   Version 6.5.3.1  Handle TPT Loads - return 15
  -- RSC 14/11/2012   Version 6.7.0.1  Added support for TPT script loads
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  04/08/2015   Version 6.8.4.2  Add target support
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- DLC 25/01/2016   Version 6.8.5.3  RED-3285 Changed statement from this
--                                         INSERT INTO LoadTable SELECT a, b, c FROM SourceTable
--                                     To this
--                                         INSERT INTO LoadTable (a, b, c) SELECT a, b, c FROM SourceTable
  -- BC  10/02/2016   Version 6.8.5.3  Added support for BDA Server operations
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- RS  03/11/2016   Version 6.8.6.3  Added support for multi Sql-statement processing in Pre-Load operation
  -- BC  22/03/2017   Version 6.8.8.0  Fixed Database link loads to correctly name non-source columns in the Insert query.
  -- FS  20/12/2017   Version 8.0.2.0  fixed missing 'INSERT INTO <Table> ' for DB load w/o destination cols specified
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_sql_code                 INTEGER;            -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024);      -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_step                     INTEGER;            -- step
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_msgtext                  VARCHAR(1024);      -- Text in audit_trail
  DECLARE v_row_count                INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_tabcol                   VARCHAR(512);
  DECLARE v_sql                      VARCHAR(4000);
  DECLARE v_stmt_pre_sql             VARCHAR(20000);
  DECLARE v_stmt_select              VARCHAR(20000);
  DECLARE v_stmt_insert              VARCHAR(512);
  DECLARE v_stmt_insert_cols         VARCHAR(20000);
  DECLARE v_stmt_out                 VARCHAR(20000);
  DECLARE v_cursor                   INTEGER;
  DECLARE v_col_found                INTEGER;
  DECLARE v_row                      INTEGER;
  DECLARE v_where_clause             VARCHAR(4000);
  DECLARE v_work                     VARCHAR(4000);
  DECLARE v_work2                    VARCHAR(4000);
  DECLARE v_t1pos                    INTEGER;
  DECLARE v_t2pos                    INTEGER;
  DECLARE v_distinct                 INTEGER;
  DECLARE v_new_value                VARCHAR(8000);
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status_code              INTEGER;
  DECLARE v_result                   INTEGER;

  DECLARE v_start_location           INTEGER DEFAULT 1;
  DECLARE v_end_location             INTEGER;
  DECLARE v_statement                VARCHAR(32000);
  DECLARE v_delimiter                VARCHAR(4000);

  --=====================================================
  -- Connection Variables
  --=====================================================
  DECLARE v_dc_host_id               VARCHAR(64);
  DECLARE v_dc_dblink_id             VARCHAR(1024);

  --=====================================================
  -- Load Table Variables
  --=====================================================
  DECLARE v_lt_pre_action            VARCHAR(1);
  DECLARE v_lt_table_name            VARCHAR(64);
  DECLARE v_lt_pre_sql               VARCHAR(4000);
  DECLARE v_lt_load_statement        VARCHAR(4000);
  DECLARE v_lt_type                  VARCHAR(1);
  DECLARE v_lt_connect_key           INTEGER;
  DECLARE v_lt_database              VARCHAR(64);
  DECLARE v_lt_transform_ind         VARCHAR(1);
  DECLARE v_lt_non_mandatory_ind     VARCHAR(1);
  DECLARE v_lt_source_schema         VARCHAR(64);
  DECLARE v_lt_source_columns        VARCHAR(4000);
  DECLARE v_lt_from_table            VARCHAR(4000);
  DECLARE v_lt_where_clause          VARCHAR(4000);
  DECLARE v_lt_missing_col_act       VARCHAR(1);
  DECLARE v_lt_load_options          VARCHAR(4000);

  --=====================================================
  -- Load Column Variables
  --=====================================================
  DECLARE v_lc_col_name              VARCHAR(64);
  DECLARE v_lc_src_column            VARCHAR(64);
  DECLARE v_lc_src_table             VARCHAR(64);
  DECLARE v_lc_transform_code        VARCHAR(4000);
  DECLARE v_lc_transform_type        VARCHAR(1);

  --=====================================================
  -- Cursor for all columns in the load table
  --=====================================================
  DECLARE c_Load CURSOR FOR
  SELECT   lc_col_name
         , lc_src_column
         , lc_src_table
         , lc_transform_code
         , lc_transform_type
  FROM     [METABASE].ws_load_col
  WHERE    lc_obj_key = p_obj_key
  ORDER BY lc_order;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_Act_Load Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET p_return_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence
        , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id);
      SET v_msgtext = 'Last SQL was ' || (COALESCE(v_stmt_select, 'NULL'));
      CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence
        , v_msgtext, '', '', p_task_id, p_job_id);
      SET p_status_code = -2;
      SET p_result = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_step = 100;

  SET v_row = 0;
  SET p_result = 1;

  --=====================================================
  -- First get the load table information
  --=====================================================
  SELECT lt_pre_action
       , lt_table_name
       , lt_pre_sql
       , lt_load_statement
       , lt_type
       , lt_connect_key
       , COALESCE(dt_database, lt_schema)
       , lt_transform_ind
       , lt_non_mandatory_ind
       , lt_source_schema
       , lt_source_columns
       , lt_from_table
       , lt_where_clause
       , lt_missing_col_act
       , lt_load_options
  INTO   v_lt_pre_action
       , v_lt_table_name
       , v_lt_pre_sql
       , v_lt_load_statement
       , v_lt_type
       , v_lt_connect_key
       , v_lt_database
       , v_lt_transform_ind
       , v_lt_non_mandatory_ind
       , v_lt_source_schema
       , v_lt_source_columns
       , v_lt_from_table
       , v_lt_where_clause
       , v_lt_missing_col_act
       , v_lt_load_options
  FROM   [METABASE].ws_load_tab
  LEFT JOIN [METABASE].ws_obj_object ws_obj_object
  ON lt_obj_key = oo_obj_key
  LEFT JOIN [METABASE].ws_dbc_target  ws_dbc_target
  ON dt_target_key = oo_target_key
  LEFT JOIN [METABASE].ws_dbc_connect ws_dbc_connect
  ON dc_obj_key = dt_connect_key
  WHERE  lt_obj_key = p_obj_key;

  SET v_step = 200;

  -- See if distinct specified
  SET v_distinct = INDEX(v_lt_load_options, 'DISTINCT;');

  SET v_step = 300;

  --=====================================================
  -- Handle any pre-load action
  --=====================================================
  IF v_lt_pre_action = 'T' OR v_lt_pre_action = 'B' THEN

    SET v_step = 400;

    --=====================================================
    -- Execute the truncate statement
    --=====================================================
    CALL [METABASE].Ws_Act_Truncate(p_sequence, p_obj_type, p_action,
                                    p_obj_key,
                                    p_job_name, p_task_name, p_job_id, p_task_id,
                                    v_msgtext, p_status_code,
                                    p_result);

    SET v_step = 500;

    CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                  v_msgtext, NULL, NULL, p_task_id, p_job_id);

  END IF;

  SET v_step = 600;
  IF v_lt_pre_action = 'E' OR v_lt_pre_action = 'B' THEN
    SET v_step = 700;
    SET v_stmt_pre_sql = TRIM(v_lt_pre_sql);
    SET v_step = 800;

    -- Replace parameters in the string
    CALL [METABASE].WsParameterReplace(v_stmt_pre_sql, 8000, v_new_value);
    SET v_stmt_pre_sql = v_new_value;
    SET v_step = 900;

    -- Resolve square brackets in the string
    CALL [METABASE].Ws_Database_Replace(p_sequence, p_job_name, p_task_name
                                      , p_job_id, p_task_id
                                      , v_stmt_pre_sql, v_new_value);

    SET v_stmt_pre_sql = v_new_value;
    SET v_step = 1000;
    SET v_work = CAST(p_sequence AS VARCHAR(18));

    -- Replace $JOB_SEQUENCE$ in the string
    CALL [METABASE].Ws_String_Replace(v_stmt_pre_sql, '$JOB_SEQUENCE$', v_work, v_new_value);
    CALL [METABASE].Ws_String_Replace(v_new_value, '$DATABASE$', v_lt_database, v_stmt_pre_sql);
    CALL [METABASE].Ws_String_Replace(v_stmt_pre_sql, '$OBJECT$', v_lt_database || '.' || v_lt_table_name, v_new_value);

    SET v_stmt_pre_sql = v_new_value;
    SET v_step = 1100;
    -- Execute the DDL statements individually based of the end-statement-indicator in the override statement
    -- Get the initial end location of the statement
    SET v_end_location = COALESCE(CHARACTER_LENGTH(v_stmt_pre_sql),0);

    -- Get the end-of-statement indicator, defaults to <EOS>
    SELECT CASE WHEN COALESCE(ta_text_3, '<EOS>')  <> ''
                THEN ta_text_3 ELSE '<EOS>'
           END INTO v_delimiter
    FROM [METABASE].ws_table_attributes WHERE ta_obj_key = 0 and ta_type = 'M';

     -- Loop through the override statement and execute each statement individually
    WHILE v_end_location > 0 DO

        SET v_sql_error = '';

        SELECT INSTR(v_stmt_pre_sql,v_delimiter, v_start_location) INTO v_end_location;

        SELECT CASE
              WHEN v_end_location > 0
              THEN SUBSTR(v_stmt_pre_sql,v_start_location,v_end_location -v_start_location)
              ELSE SUBSTR(v_stmt_pre_sql,v_start_location)
              END  INTO v_statement;

        IF TRIM(COALESCE(v_statement,'')) <> '' AND TRIM(v_statement) <> x'0A' THEN
            BEGIN
                DECLARE EXIT HANDLER FOR SQLEXCEPTION
                BEGIN
                  GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
                  SET v_sql_code = SQLCODE;


                  SET v_msgtext = 'Execution of pre load failed. ' || (COALESCE(v_statement, 'none'))
                               || ' Failed with SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error
                                ;
                  CALL [METABASE].WsWrkAudit( 'E', p_job_name, p_task_name, p_sequence
                                            , v_msgtext, v_sql_code, v_sql_error, p_task_id, p_job_id
                                            );
                  SET v_msgtext = 'Execution of pre load failed';
                  SET p_return_msg = v_msgtext;
                  SET p_status_code = -2;
                  SET p_result = -2;

                END;

                CALL DBC.SYSEXECSQL (v_statement);

                SET v_msgtext = SUBSTR('Executed pre load sql. ' || COALESCE(v_stmt_pre_sql, 'NULL'), 1, 1023);

                CALL [METABASE].WsWrkAudit('I', p_job_name, p_task_name, p_sequence,
                              v_msgtext, NULL, NULL, p_task_id, p_job_id);
            END;
        END IF;

        SELECT v_end_location + CHARACTER_LENGTH(v_delimiter) INTO v_start_location;
    END WHILE;
  END IF;

  SET v_step = 1400;

  --=====================================================
  -- L O A D     S T A T E M E N T
  --
  -- If a load statement then it overrides the load method
  -- and we will issue that statement to perform the load
  --=====================================================
  IF NULLIF(TRIM(v_lt_load_statement), '') IS NOT NULL AND v_lt_type = 'D' THEN
    --=====================================================
    -- Load using the load statement
    --=====================================================
    SET v_step = 1500;
    -- replace any parameters with their current values
    SET v_stmt_select = v_lt_load_statement;
    SET v_step = 1600;

    -- Replace parameters in the string
    CALL [METABASE].WsParameterReplace(v_stmt_select, 8000, v_new_value);
    SET v_stmt_select = v_new_value;
    SET v_step = 1700;

    -- Resolve square brackets in the string
    CALL [METABASE].Ws_Database_Replace(p_sequence, p_job_name, p_task_name
                                      , p_job_id, p_task_id
                                      , v_stmt_select, v_new_value);

    SET v_stmt_select = v_new_value;
    SET v_step = 1800;
    SET v_work = CAST(p_sequence AS VARCHAR(18));

    -- Replace $JOB_SEQUENCE$ in the string
    CALL [METABASE].Ws_String_Replace(v_stmt_select, '$JOB_SEQUENCE$', v_work, v_new_value);

    SET v_stmt_select = v_new_value;
    SET v_step = 1900;
    CALL DBC.SYSEXECSQL (v_stmt_select);
    SET v_row_count = ACTIVITY_COUNT;
    SET v_step = 2000;

    SET p_return_msg = TRIM(CAST((COALESCE(v_row_count, 0)) AS VARCHAR(18))) ||
      ' rows loaded (using load statement override) into ' || v_lt_table_name
      || ' ' || v_lt_type || ' ' || v_lt_load_statement;

    SET v_step = 2100;
    SET p_status_code = 1;
    SET p_result = 1;
    LEAVE WS_ACT_LOAD;
  END IF;

  SET v_step = 2200;

  --=====================================================
  -- See what type of load this is
  -- D = database Load
  -- O = Odbc based Load
  -- S = Script based load
  -- F = File based load
  -- X = XML File based load
  -- A = Apache Sqoop load
  -- E = External load
  --=====================================================
  IF v_lt_type = 'D' THEN

    --=====================================================
    -- Get the connection information
    --=====================================================
    SET v_step = 2300;

    SELECT dc_host_id
         , dc_dblink_id
    INTO   v_dc_host_id
         , v_dc_dblink_id
    FROM   [METABASE].ws_dbc_connect
    WHERE  dc_obj_key = v_lt_connect_key;

    --=====================================================
    -- Build the load statement
    --=====================================================
    SET v_step = 2400;
    SET v_stmt_insert = 'INSERT INTO ';
    SET v_stmt_insert_cols = '';

    SET v_step = 2500;
    IF v_lt_database <> '' THEN
      SET v_step = 2600;
      SET v_stmt_insert = v_stmt_insert || v_lt_database || '.';
    END IF;

    SET v_step = 2700;
    IF v_distinct > 0 THEN
      SET v_step = 2800;
      SET v_stmt_insert = v_stmt_insert ||  v_lt_table_name;
      SET v_stmt_select = ' SELECT DISTINCT ';
    ELSE
      SET v_step = 2900;
      SET v_stmt_insert = v_stmt_insert ||  v_lt_table_name;
      SET v_stmt_select = ' SELECT ';
    END IF;
    SET v_step = 3000;

    --=====================================================
    -- Transformation or Ordinary Load
    --=====================================================
    IF COALESCE(v_lt_transform_ind, 'N') = 'Y' THEN
      SET v_step = 3100;
      SET v_no_more_data1 = 0;
      BEGIN

        DECLARE CONTINUE HANDLER FOR NOT FOUND
          SET v_no_more_data1 = 1;

        OPEN c_Load;

        FETCH FROM c_Load INTO
          v_lc_col_name
        , v_lc_src_column
        , v_lc_src_table
        , v_lc_transform_code
        , v_lc_transform_type;

        WHILE v_no_more_data1 = 0 DO

          SET v_step = 3200;
          SET v_row = v_row + 1;
          IF v_row > 1 THEN
            SET v_stmt_select = v_stmt_select || ', ';
            SET v_stmt_insert_cols = v_stmt_insert_cols || ', ';
          END IF;

          -- If we have non mandatory columns specified then check to ensure
          -- each column exists in the source
          SET v_col_found = 1;

          -- End of column check
          SET v_handled = 0;
          SET v_step = 3300;
          IF COALESCE(v_lc_transform_type, 'Z') = 'D' AND NULLIF(TRIM(v_lc_transform_code), '') IS NOT NULL THEN

            -- Get rid of any comments in the transform
            SET v_work = v_lc_transform_code;
            SET v_t1pos = INDEX(v_work, X'45'||X'45');

            SET v_step = 3400;
            WHILE v_t1pos > 0 DO

              SET v_step = 3500;
              SET v_work2 = SUBSTR(v_work, v_t1pos, 4000);
              SET v_t2pos = INDEX(v_work2, X'10');

              SET v_step = 3600;
              IF v_t2pos > 0 THEN
                SET v_step = 3700;
                SET v_work2 = SUBSTR(v_work, 1, v_t1pos-1);
                SET v_step = 3800;
                IF v_work2 IS NULL THEN
                  SET v_step = 3900;
                  SET v_work = SUBSTR(v_work, v_t2pos+v_t1pos, 4000);
                ELSE
                  SET v_step = 4000;
                  SET v_work = v_work2 || SUBSTR(v_work, v_t2pos+v_t1pos, 4000);
                END IF;
              ELSE
                SET v_step = 4100;
                SET v_work = SUBSTR(v_work, 1, v_t1pos-1);
              END IF;

              SET v_step = 4200;
              SET v_t1pos = INDEX(v_work, X'45'||X'45');

            END WHILE; -- end of remove comments from transform

            SET v_step = 4300;
            SET v_lc_transform_code = TRIM(v_work);

            SET v_step = 4400;
            SET v_handled = 1;
            SET v_step = 4500;

            IF v_col_found = 1 THEN
              SET v_step = 4600;
              SET v_stmt_select = v_stmt_select || v_lc_transform_code;
              SET v_stmt_insert_cols = v_stmt_insert_cols || v_lc_col_name;
            ELSE
              SET v_step = 4700;
              SET v_sql = v_lc_transform_code;
              SET v_tabcol = v_lc_src_table || '.' || v_lc_src_column;

              SET v_step = 4800;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_tabcol = UPPER(v_tabcol);

              SET v_step = 4900;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_tabcol = LOWER(v_tabcol);

              SET v_step = 5000;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_tabcol = v_lc_src_column;

              SET v_step = 5100;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_tabcol = UPPER(v_tabcol);

              SET v_step = 5200;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_tabcol = LOWER(v_tabcol);

              SET v_step = 5300;
              CALL [METABASE].Ws_String_Replace(v_sql, v_tabcol, 'NULL', v_new_value);
              SET v_sql = v_new_value;
              SET v_stmt_select = v_stmt_select || v_sql;

              SET v_stmt_insert_cols = v_stmt_insert_cols || v_lc_col_name;
            END IF;
          END IF;

          SET v_step = 5400;

          IF v_handled = 0 THEN
            IF NULLIF(TRIM(v_lc_src_column), '') IS NOT NULL THEN
              IF v_col_found = 1 THEN
                IF NULLIF(TRIM(v_lc_src_table), '') IS NOT NULL THEN
                  SET v_step = 5500;
                  SET v_stmt_select = v_stmt_select ||  v_lc_src_table || '.';
                  -- don't add v_lc_src_table to the insert columns
                END IF;
                SET v_step = 5600;
                SET v_stmt_select = v_stmt_select || v_lc_src_column;
                SET v_stmt_insert_cols = v_stmt_insert_cols || v_lc_col_name;
              ELSE
                SET v_step = 5700;
                SET v_stmt_select = v_stmt_select || 'NULL';
                SET v_stmt_insert_cols = v_stmt_insert_cols || v_lc_col_name;
              END IF;
            ELSE
              SET v_step = 5800;
              SET v_stmt_select = v_stmt_select || 'NULL';
              SET v_stmt_insert_cols = v_stmt_insert_cols || v_lc_col_name;
            END IF;
          END IF;
          SET v_step = 5900;

          FETCH FROM c_Load INTO
            v_lc_col_name
          , v_lc_src_column
          , v_lc_src_table
          , v_lc_transform_code
          , v_lc_transform_type;

        END WHILE; -- End of cursor loop

        SET v_step = 6000;
        CLOSE c_Load;
      END;

    --- End of transform indicator
    ELSE
      SET v_step = 6100;
      SET v_stmt_select = v_stmt_select || v_lt_source_columns;
      SET v_lc_col_name = '';
    END IF;

    SET v_step = 6200;

    -- Add From
    SET v_stmt_select = v_stmt_select || ' FROM ';
    SET v_stmt_select = v_stmt_select || v_lt_from_table;

    SET v_step = 6300;

    -- Add Where
    IF NULLIF(TRIM(v_lt_where_clause), '') IS NOT NULL THEN

      SET v_step = 6400;

      SET v_where_clause = v_lt_where_clause;
      SET v_stmt_select = v_stmt_select || ' ' || v_where_clause;

    END IF;

    --=====================================================
    -- Replace any $JOB_SEQUENCE$
    --=====================================================
    SET v_step = 6500;
    SET v_work = CAST(p_sequence AS VARCHAR(18));
    SET v_step = 6550;
    CALL [METABASE].Ws_String_Replace(v_stmt_select, '$JOB_SEQUENCE$', v_work, v_new_value);
    SET v_stmt_select = v_new_value;

    SET v_step = 6600;
    SET v_work = CAST(p_sequence AS VARCHAR(18));
    SET v_step = 6650;
    CALL [METABASE].Ws_String_Replace(v_stmt_insert_cols, '$JOB_SEQUENCE$', v_work, v_new_value);
    SET v_stmt_insert_cols = v_new_value;

    --=====================================================
    -- Replace any parameters
    --=====================================================
    SET v_step = 6700;
    CALL [METABASE].WsParameterReplace(v_stmt_select, 8000, v_stmt_out);
    SET v_step = 6750;
    IF NULLIF(TRIM(v_stmt_out), '') IS NULL THEN
      SET v_step = 6800;
      SET v_stmt_out = v_stmt_select;
    END IF;
    SET v_step = 6850;
    SET v_stmt_select = v_stmt_out;

    SET v_step = 6900;
    CALL [METABASE].WsParameterReplace(v_stmt_insert_cols, 8000, v_stmt_out);
    SET v_step = 6950;
    IF NULLIF(TRIM(v_stmt_out), '') IS NULL THEN
      SET v_step = 7000;
      SET v_stmt_out = v_stmt_insert_cols;
    END IF;
    SET v_step = 7050;
    SET v_stmt_insert_cols = v_stmt_out;

    --=====================================================
    -- Perform the Load
    --=====================================================
    SET v_step = 7100;
    IF v_stmt_insert_cols <> '' THEN
        SET v_stmt_select = v_stmt_insert || ' (' || v_stmt_insert_cols || ') ' || v_stmt_select;
    ELSE
        SET v_stmt_select = v_stmt_insert || ' ' || v_stmt_select;
    END IF;
    CALL DBC.SYSEXECSQL(v_stmt_select);
    SET v_row_count = ACTIVITY_COUNT;
    SET v_step = 7200;
    SET p_return_msg = TRIM(CAST((COALESCE(v_row_count, 0)) AS VARCHAR(18))) || ' rows loaded into ' || v_lt_table_name;

    SET v_step = 7300;
    SET p_status_code = 1;
    SET p_result = 1;
END IF;

  SET v_step = 7400;

  --**********************************
  -- File Load
  --**********************************
  IF v_lt_type = 'F' THEN

    SET v_step = 7500;

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key,
        p_job_name, p_task_name, p_job_id, p_task_id,
        v_return_msg, v_status_code, v_result);

    SET v_step = 7600;

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    SET p_return_msg = v_return_msg;

    SET v_step = 7700;

    IF v_result = 1 THEN

      SET v_step = 7800;

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET v_step = 7900;

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  END IF;

  SET v_step = 8000;

  --**********************************
  -- XML File Load
  --**********************************
  IF v_lt_type = 'X' THEN

    SET v_step = 8100;

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key,
        p_job_name, p_task_name, p_job_id, p_task_id,
        v_return_msg, v_status_code, v_result);

    SET v_step = 8200;

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    SET p_return_msg = v_return_msg;

    SET v_step = 8300;

    IF v_result = 1 THEN

      SET v_step = 8400;

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET v_step = 8500;

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  END IF;

  SET v_step = 8600;

  --**********************************
  -- Script Load
  --**********************************
  IF v_lt_type = 'S' THEN

    SET v_step = 8700;

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key,
        p_job_name, p_task_name, p_job_id, p_task_id,
        v_return_msg, v_status_code, v_result);

    SET v_step = 8800;

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    SET p_return_msg = v_return_msg;

    SET v_step = 8900;

    IF v_result = 1 THEN

      SET v_step = 9000;

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET v_step = 9100;

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  END IF;

  SET v_step = 9200;

  --**********************************
  -- ODBC Load
  --**********************************
  IF v_lt_type = 'O' THEN

    SET v_step = 9300;

    -- run an ODBC load by returning a result of 3
    SET p_result = 3;
    SET p_status_code = 2;

  END IF;

  SET v_step = 9400;

  --**********************************
  -- Native ODBC Load
  --**********************************
  IF v_lt_type = 'N' THEN

    SET v_step = 9500;

    -- run a Native ODBC load by returning a result of 12
    SET p_result = 12;
    SET p_status_code = 2;

  END IF;

  SET v_step = 9600;

  --**********************************
  -- TPT ODBC Load
  --**********************************
  -- RED_2764 Enabled script based TPT ODBC Load
  IF v_lt_type = 'T' THEN

    SET v_step = 9650;

    CALL [METABASE].Ws_Act_Host_Script(p_sequence, p_obj_type, p_action, p_obj_key,
        p_job_name, p_task_name, p_job_id, p_task_id,
        v_return_msg, v_status_code, v_result);

    SET v_step = 9660;

    -- If script prepared okay then indicate to our caller that we want to
    -- run a script by returning a result of 2
    SET p_return_msg = v_return_msg;

    SET v_step = 9670;

    IF v_result = 1 THEN

      SET v_step = 9671;

      SET p_result = 2;
      SET p_status_code = 2;

    ELSE

      SET v_step = 9672;

      SET p_result = v_result;
      SET p_status_code = v_status_code;

    END IF;

  SET v_step = 9675;


    -- run a TPT load by returning a result of 15
    --SET p_result = 15;
    --SET p_status_code = 2;

  END IF;

  SET v_step = 9700;

  --**********************************
  -- Apache Sqoop Load
  --**********************************
  IF v_lt_type = 'A' THEN

    SET v_step = 9710;

    SET p_return_msg = 'Apache Sqoop load';
    SET p_result = 91;
    SET p_status_code = 2;

  END IF;

  SET v_step = 9750;

  --**********************************
  -- External Load
  --**********************************
  IF v_lt_type = 'E' THEN

    SET v_step = 9760;

    SET p_return_msg = 'Externally loaded';
    SET p_status_code = 1;
    SET p_result = 1;

  END IF;

  SET v_step = 9800;

  --**********************************
  -- Unsupported Load type
  --**********************************
  --RED_2764 Added TPT loads
  IF v_lt_type NOT IN ('D','F','S','O','E','X','N','T','A') THEN

    SET v_step = 9900;

    SET v_msgtext = 'Unsupported Load Type ';

    SET v_step = 10000;

    CALL [METABASE].WsWrkAudit('E', p_job_name, p_task_name, p_sequence,
                      v_msgtext, NULL, NULL, p_task_id, p_job_id);

    SET v_step = 10100;

    SET p_return_msg = 'Unsupport load type in ws_act_load '||
        v_ws_pro_version;
    SET p_status_code = -2;
    SET p_result = -2;

  END IF;

END;
_PROCEDWSL_ Ws_Job_Exec_Action 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_Action
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_obj_type         INTEGER
, IN  pi_action_type      INTEGER
, IN  pi_obj_key          INTEGER
, IN  pi_sid              INTEGER
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
, OUT po_handled          INTEGER
, OUT ps_job_key_list     VARCHAR(256) -- ( list of jobs to pass task down to. Comma separated )
, OUT ps_task_key_list    VARCHAR(256) -- ( list of tasks to pass task down to. Comma separated )
, OUT po_proc_stmt        VARCHAR(8000)
)
WS_JOB_EXEC_ACTION:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_action
  -- Description  Action a task for all actions except
  --               - load action
  --               - update action
  --               - initial load action
  --               - process action
  --               - custom action
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- AP  05/11/2009   Version 6.1.0.0  Implement OLAP objects
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_result                   INTEGER;
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status_code              INTEGER;
  DECLARE v_result_2                 INTEGER;
  DECLARE v_return_msg_2             VARCHAR(1024);
  DECLARE v_status_code_2            INTEGER;
  DECLARE v_result_3                 INTEGER;
  DECLARE v_return_msg_3             VARCHAR(1024);
  DECLARE v_status_code_3            INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_action_type              INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_task_key                 INTEGER;
  DECLARE v_default_stats            VARCHAR(4000);
  DECLARE v_idle_thread_wait         INTEGER;
  DECLARE v_idle_thread_wait_hh      INTEGER;
  DECLARE v_idle_thread_wait_mm      INTEGER;
  DECLARE v_idle_thread_wait_ss      INTEGER;
  DECLARE v_idle_thread_wait_string  VARCHAR(255);
  DECLARE v_proc_stmt                VARCHAR(4000);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in WS_JOB_EXEC_ACTION Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_task_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, pi_task_key, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_idle_thread_wait         = 30;
  SET v_idle_thread_wait_hh      = 0;
  SET v_idle_thread_wait_mm      = 0;
  SET v_idle_thread_wait_ss      = 0;
  SET v_idle_thread_wait_string  = '000030';

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_action_type = pi_action_type;
  SET v_obj_type = pi_obj_type;

  SET v_step = 181;

  --=====================================================
  -- Work out the type of action and run the appropriate
  -- function.
  --=====================================================
  SET v_status_code = -3;
  SET v_return_msg = 'Unhandled exception in action';
  SET v_handled = 0;

  --=====================================================
  -- E X E C U T E
  --=====================================================
  IF v_action_type = v_ws_act_execute THEN

    SET v_handled = 1;

    --=====================================================
    -- E X E C U T E      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_olap_cube
    OR v_obj_type = v_ws_obj_olap_dim
    OR v_obj_type = v_ws_obj_olap_role
    OR v_obj_type = v_ws_obj_cube
    OR v_obj_type = v_ws_obj_cube_virtual
    THEN

      -- If this execute is for a cube
      -- return value of 8
      -- pass back to the scheduler and let it do the create
      SET po_result_code = 8;
      SET po_result_msg = 'cube execute';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTION;

    END IF;

    --=====================================================
    -- E X E C U T E    P R O C E D U R E
    --=====================================================
    IF v_obj_type = v_ws_obj_procedure THEN

      CALL [METABASE].Ws_Act_Execute(pi_sequence, v_obj_type, v_action_type, pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                   , v_return_msg, v_status_code, v_result, v_proc_stmt);

      IF v_result >= -1 THEN

        SET po_result_code = 98;
        SET po_result_msg = v_return_msg;
        SET po_action_key = 0;
        SET po_action_msg = 'no action';
        SET po_handled = v_handled;
        SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET po_proc_stmt = v_proc_stmt;

        -- Delete the thread as returning to the OS to run the procedure
        CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

        LEAVE WS_JOB_EXEC_ACTION;

      END IF;

    END IF;

    --=====================================================
    -- E X E C U T E    S C R I P T
    --=====================================================
    IF v_obj_type = v_ws_obj_script THEN

      CALL [METABASE].Ws_Act_Host_Script(pi_sequence,v_obj_type,v_action_type,pi_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                       , v_return_msg, v_status_code
                                       , v_result);

      -- If script build worked then skip out to process it
      -- If it failed then the standard handling will deal with it.
      IF v_result >= -1 THEN

        SET po_result_code = 2;
        SET po_result_msg = 'execute script';
        SET po_action_key = 0;
        SET po_action_msg = 'no action';
        SET po_handled = v_handled;
        SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET po_proc_stmt = 'no statement';

        LEAVE WS_JOB_EXEC_ACTION;

      END IF;

    END IF;

    --=====================================================
    -- E X E C U T E    U N S U P P O R T E D
    --=====================================================
    IF v_handled = 0 THEN

      SET v_MsgText = 'Ws_Job_Exec_Action' || v_ws_pro_version || ' Job ' || pi_task_name || ' sequence ' ||
                        TRIM(CAST((COALESCE(pi_sequence,-1)) AS VARCHAR(18))) ||
                       ' could not perform action. Unsupported action ' ||
                       TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18)))
                       || ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

      CALL [METABASE].WsWrkAudit('E',pi_job_name, pi_task_name, pi_sequence,
                                       v_MsgText,NULL,NULL,pi_task_key,pi_job_key);

      SET v_status_code  = -2;
      SET v_return_msg = 'Unsupported action ' || TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18)))
                         || ' for object ' || TRIM(CAST(v_obj_type AS VARCHAR(18)));

      SET v_result = 1;

    END IF;

  END IF;

  --=====================================================
  -- T R U N C A T E
  --=====================================================
  IF v_action_type = v_ws_act_truncate THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Truncate(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

  END IF;

  --=====================================================
  -- C R E A T E
  --=====================================================
  IF v_action_type = v_ws_act_create THEN

    SET v_handled = 1;

    --=====================================================
    -- C R E A T E      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_olap_cube
    OR v_obj_type = v_ws_obj_olap_dim
    OR v_obj_type = v_ws_obj_olap_role
    OR v_obj_type = v_ws_obj_cube
    OR v_obj_type = v_ws_obj_cube_virtual
    THEN

      -- If this create is for a cube
      -- return value of 4
      -- pass back to the scheduler and let it do the create
      SET po_result_code = 4;
      SET po_result_msg = 'cube create';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTION;

    ELSE
    --=====================================================
    -- C R E A T E      A L L     O T H E R S
    --=====================================================

      CALL [METABASE].Ws_Act_Create(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

    END IF;

  END IF;

  --=====================================================
  -- D R O P
  --=====================================================
  IF v_action_type = v_ws_act_drop THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Drop(pi_sequence,v_obj_type,v_action_type
                              , pi_obj_key
                              , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                              , v_return_msg , v_status_code
                              , v_result);

  END IF;

  --=====================================================
  -- D R O P    A L L
  --=====================================================
  IF v_action_type = v_ws_act_drop_all THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Drop_All(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg , v_status_code
                                  , v_result);

  END IF;

  --=====================================================
  -- B U I L D
  --=====================================================
  IF v_action_type = v_ws_act_build THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Build(pi_sequence,v_obj_type,v_action_type
                               , pi_obj_key
                               , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                               , v_return_msg, v_status_code
                               , v_result);

  END IF;

  --=====================================================
  -- B U I L D    A L L
  --=====================================================
  IF v_action_type = v_ws_act_build_all THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Build_All(pi_sequence,v_obj_type,v_action_type
                                   , pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                                   , v_return_msg, v_status_code
                                   , v_result);

  END IF;

  --=====================================================
  -- P R E   D R O P
  --=====================================================
  IF v_action_type = v_ws_act_pre_drop THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Pre_Drop(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

  END IF;

  --=====================================================
  -- A N A L Y Z E
  --=====================================================
  IF v_action_type = v_ws_act_analyze THEN

    --=====================================================
    -- A N A L Y Z E      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_olap_cube
    OR v_obj_type = v_ws_obj_olap_dim
    OR v_obj_type = v_ws_obj_olap_role
    OR v_obj_type = v_ws_obj_cube
    OR v_obj_type = v_ws_obj_cube_virtual
    THEN

      -- If this analyze is for a cube
      -- return value of 8
      -- pass back to the scheduler and let it do the processing
      SET po_result_code = 8;
      SET po_result_msg = 'cube analyze';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTION;

    ELSE

      SET v_handled = 1;

      CALL [METABASE].Ws_Act_Analyze(pi_sequence,v_obj_type,v_action_type, 100,pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                   , v_return_msg, v_status_code
                                   , v_result);

    END IF;

  END IF;

  --=====================================================
  -- Q U I C K    A N A L Y Z E
  --=====================================================
  IF v_action_type = v_ws_act_quick_analyze THEN

    --=====================================================
    -- Q U I C K    A N A L Y Z E      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_olap_cube
    OR v_obj_type = v_ws_obj_olap_dim
    OR v_obj_type = v_ws_obj_olap_role
    OR v_obj_type = v_ws_obj_cube
    OR v_obj_type = v_ws_obj_cube_virtual
    THEN

      -- If this quick analyze is for a cube
      -- return value of 5
      -- pass back to the scheduler and let it do the processing
      SET po_result_code = 9;
      SET po_result_msg = 'cube quick analyze';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTION;

    ELSE

      SET v_handled = 1;

      CALL [METABASE].Ws_Act_Analyze(pi_sequence,v_obj_type,v_action_type, 3,pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                   , v_return_msg, v_status_code
                                   , v_result);

    END IF;

  END IF;

  --=====================================================
  -- S T A T I S T I C S
  --=====================================================
  IF v_action_type = v_ws_act_statistics THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Dbms_Stats(pi_sequence,v_obj_type,v_action_type, 100,pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result);

  END IF;

  --=====================================================
  -- Q U I C K   S T A T S
  --=====================================================
  IF v_action_type = v_ws_act_quick_statistics THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Dbms_Stats(pi_sequence,v_obj_type,v_action_type, 3,pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result);

  END IF;

  --=====================================================
  -- C U B E    D I M     P R O C E S S
  --=====================================================
  IF v_action_type = v_ws_act_cube_dim THEN

    SET v_handled = 1;

    -- If this process is for a cube
    -- return value of 6
    -- pass back to the scheduler and let it do the processing
    SET po_result_code = 6;
    SET po_result_msg = 'cube dim process';
    SET po_action_key = 0;
    SET po_action_msg = 'no action';
    SET po_handled = v_handled;
    SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
    SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
    SET po_proc_stmt = 'no statement';

    --=====================================================
    -- Remove this thread as being active
    --=====================================================
    SET v_step = 331;

    CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

    LEAVE WS_JOB_EXEC_ACTION;

  END IF;

  --=====================================================
  -- C U B E    D A T A B A S E     D I M     P R O C E S S
  --=====================================================
  IF v_action_type = v_ws_act_db_dim THEN

    SET v_handled = 1;

    -- If this process is for a cube database dim processing
    -- return value of 7
    -- pass back to the scheduler and let it do the processing
    SET po_result_code = 7;
    SET po_result_msg = 'cube database dim process';
    SET po_action_key = 0;
    SET po_action_msg = 'no action';
    SET po_handled = v_handled;
    SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
    SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
    SET po_proc_stmt = 'no statement';

    --=====================================================
    -- Remove this thread as being active
    --=====================================================
    SET v_step = 331;

    CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

    LEAVE WS_JOB_EXEC_ACTION;

  END IF;

  --=====================================================
  -- U N S U P P O R T E D
  --=====================================================
  IF v_handled = 0 THEN

    SET v_MsgText = 'Ws_Job_Exec_Action' || v_ws_pro_version || ' Job ' || pi_task_name || ' sequence ' ||
                     TRIM(CAST((COALESCE(pi_sequence,-1)) AS VARCHAR(18))) ||
                     ' could not perform action. Unsupported action ' ||
                     TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18)))
                     || ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    CALL [METABASE].WsWrkAudit('E',pi_job_name, pi_task_name, pi_sequence,
                                     v_MsgText,NULL,NULL,pi_task_key,pi_job_key);
    SET v_status_code  = -2;

    SET v_return_msg = 'Unsupported action ' ||
                       TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18))) ||
                       ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    SET v_result = 1;

  END IF;

  SET v_step = 190;

  SET po_result_code = v_status_code;
  SET po_result_msg = v_return_msg;
  SET po_action_key = 0;
  SET po_action_msg = 'no action';
  SET po_handled = v_handled;
  SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
  SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
  SET po_proc_stmt = 'no statement';

END;
_PROCEDWSL_ Ws_Job_Exec_ActionLUI 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_ActionLUI
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_obj_type         INTEGER
, IN  pi_action_type      INTEGER
, IN  pi_obj_key          INTEGER
, IN  pi_sid              INTEGER
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
, OUT po_handled          INTEGER
, OUT ps_job_key_list     VARCHAR(256) -- ( list of jobs to pass task down to. Comma separated )
, OUT ps_task_key_list    VARCHAR(256) -- ( list of tasks to pass task down to. Comma separated )
, OUT po_proc_stmt        VARCHAR(8000)
)
WS_JOB_EXEC_ACTIONLUI:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_actionLUI
  -- Description  Action a task for a
  --               - load action
  --               - update action
  --               - initial load action
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- AP  03/12/2010   Version 6.5.3.1  handle TPT type load - result code of 15
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- BC  10/02/2016   Version 6.8.5.3  Added support for BDA Server operations
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  14/11/2016   Version 6.8.6.3  Added support for BTEQ scripts
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_result                   INTEGER;
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status_code              INTEGER;
  DECLARE v_result_2                 INTEGER;
  DECLARE v_return_msg_2             VARCHAR(1024);
  DECLARE v_status_code_2            INTEGER;
  DECLARE v_result_3                 INTEGER;
  DECLARE v_return_msg_3             VARCHAR(1024);
  DECLARE v_status_code_3            INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_action_type              INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_task_key                 INTEGER;
  DECLARE v_default_stats            VARCHAR(4000);
  DECLARE v_idle_thread_wait         INTEGER;
  DECLARE v_idle_thread_wait_hh      INTEGER;
  DECLARE v_idle_thread_wait_mm      INTEGER;
  DECLARE v_idle_thread_wait_ss      INTEGER;
  DECLARE v_idle_thread_wait_string  VARCHAR(255);
  DECLARE v_proc_stmt                VARCHAR(4000);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in WS_JOB_EXEC_ACTIONLUI Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_task_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, pi_task_key, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_idle_thread_wait         = 30;
  SET v_idle_thread_wait_hh      = 0;
  SET v_idle_thread_wait_mm      = 0;
  SET v_idle_thread_wait_ss      = 0;
  SET v_idle_thread_wait_string  = '000030';

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_action_type = pi_action_type;
  SET v_obj_type = pi_obj_type;

  SET v_step = 181;

  --=====================================================
  -- Work out the type of action and run the appropriate
  -- function.
  --=====================================================
  SET v_status_code = -3;
  SET v_return_msg = 'Unhandled exception in action';
  SET v_handled = 0;

  --=====================================================
  -- L O A D
  --=====================================================
  IF v_action_type = v_ws_act_load THEN

    SET v_handled = 1;

    --=====================================================
    -- R E T R O     L O A D
    --=====================================================
    IF v_obj_type = v_ws_obj_retro_copy THEN

      -- If this a Retrofit ODBC based load then
      -- Skip out to process it
      SET po_result_code = 13;
      SET po_result_msg = 'retro table';
      SET po_action_key = pi_obj_key;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 334;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTIONLUI;

    --=====================================================
    -- L O A D     O B J E C T      L O A D
    --=====================================================
    ELSE

      CALL [METABASE].Ws_Act_Load(pi_sequence,v_obj_type,v_action_type
                                , pi_obj_key
                                , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                , v_return_msg, v_status_code
                                , v_result);

      IF v_result >= -1 THEN

        IF v_status_code = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_status_code <> 2 AND v_status_code <> 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        -- If this load requires a host script then we will have a
        -- return value of 2
        -- If script build worked then skip out to process it
        -- If it failed then the standard handling will deal with it.
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 2 THEN

          SET po_result_code = 2;
          SET po_result_msg = 'load table';
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 330;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

        -- If this load requires an ODBC based load then we will have a
        -- return value of 3
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 3 THEN

          SET po_result_code = 3;
          SET po_result_msg = 'load table';
          SET po_action_key = pi_obj_key;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 333;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

        -- If this load requires a Native ODBC based load then we will have a
        --   return value of 12
        -- If this load requires a TPT based load then we will have a
        --   return value of 15
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run

        IF ( v_result = 12
          OR v_result = 15 ) THEN

          SET po_result_code = v_result;
          SET po_result_msg = 'load table';
          SET po_action_key = pi_obj_key;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 334;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

        -- If this load requires an Apache Sqoop load then we will have a
        --   return value of 91
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 91 THEN

          SET po_result_code = v_result;
          SET po_result_msg = v_return_msg;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 335;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

        CALL [METABASE].Ws_Act_Post_Load(pi_sequence,v_obj_type,v_action_type
                                       , pi_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                       , v_return_msg_2, v_status_code_2
                                       , v_result_2, v_proc_stmt);

        IF v_status_code_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_status_code_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        -- If a post load procedure could be found
        -- The result will be 2 if no post load was found
        IF v_result_2 = 1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_return_msg_2;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

        -- If our post load procedure failed and the load worked then
        -- record the post load failure
        IF v_status_code_2 < v_status_code THEN

          SET v_status_code = v_status_code_2;

        END IF;

      END IF;-- End of successful load

    END IF;-- End of load object load

  END IF;-- End of LOAD

  --=====================================================
  -- U P D A T E
  --=====================================================
  IF v_action_type = v_ws_act_update THEN

    --=====================================================
    -- U P D A T E      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_cube THEN

      -- If this update is for a cube
      -- return value of 9
      -- pass back to the scheduler and let it do the create
      SET po_result_code = 9;
      SET po_result_msg = 'cube update';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTIONLUI;

    ELSE

      SET v_handled = 1;

      CALL [METABASE].Ws_Act_Update(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result, v_proc_stmt);

      -- If this update requires a host script then we will have a
      -- return value of 2
      -- If script build worked then skip out to process it
      -- If it failed then the standard handling will deal with it.
      -- When we Rejoin the job any post load procedure will be run
      IF v_result = 2 THEN

        SET po_result_code = 100;
        SET po_result_msg = 'bteq update';
        SET po_action_key = 0;
        SET po_action_msg = 'no action';
        SET po_handled = v_handled;
        SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET po_proc_stmt = 'no statement';

        -- Delete the thread as returning to the OS to run the procedure
        CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

        LEAVE WS_JOB_EXEC_ACTIONLUI;

      ELSEIF v_result >= -1 THEN

        SET po_result_code = 98;
        SET po_result_msg = v_return_msg;
        SET po_action_key = 0;
        SET po_action_msg = 'no action';
        SET po_handled = v_handled;
        SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET po_proc_stmt = v_proc_stmt;

        -- Delete the thread as returning to the OS to run the procedure
        CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

        LEAVE WS_JOB_EXEC_ACTIONLUI;

      END IF;

    END IF;

  END IF;

  --=====================================================
  -- I N I T I A L     L O A D
  --=====================================================
  IF v_action_type = v_ws_act_initial THEN

    SET v_handled = 1;

    --=====================================================
    -- R E T R O     I N I T I A L     L O A D
    --=====================================================
    IF v_obj_type = v_ws_obj_retro_copy THEN

      -- First create the table
      CALL [METABASE].Ws_Act_Create(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

      -- If this a Retrofit ODBC based load then
      -- Skip out to process it
      SET po_result_code = 13;
      SET po_result_msg = 'retro table';
      SET po_action_key = pi_obj_key;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 334;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTIONLUI;

    ELSE

      --==========================================================
      -- O T H E R     O B J E C T     I N I T I A L     B U I L D
      --==========================================================
      CALL [METABASE].Ws_Act_Drop_All(pi_sequence,v_obj_type,v_action_type
                                    , pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result);

      IF v_result >= -1 THEN

        IF v_status_code = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        CALL [METABASE].Ws_Act_Initial_Build(pi_sequence,v_obj_type,v_action_type
                                           , pi_obj_key
                                           , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                           , v_return_msg, v_status_code
                                           , v_result, v_proc_stmt);

        IF v_result >= -1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_return_msg;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONLUI;

        END IF;

      END IF;

      IF v_result >= -1 THEN

        CALL [METABASE].Ws_Act_Build_All(pi_sequence,v_obj_type,v_action_type
                                       , pi_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key, NULL
                                       , v_return_msg_2, v_status_code_2
                                       , v_result_2);

      END IF;

      IF v_status_code_2 = 1 THEN

        CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                             v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

      END IF;

      IF v_status_code_2 < 1 THEN

        CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                             v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

      END IF;

      -- If our index build failed and the initial load worked then
      -- record the index failure
      IF v_status_code_2 < v_status_code THEN

        SET v_status_code = v_status_code_2;

      END IF;

    END IF;-- End of other object initial load

  END IF;-- End of initial load

  --=====================================================
  -- U N S U P P O R T E D
  --=====================================================
  IF v_handled = 0 THEN

    SET v_MsgText = 'Ws_Job_Exec_ActionLUI' || v_ws_pro_version || ' Job ' || pi_task_name || ' sequence ' ||
                     TRIM(CAST((COALESCE(pi_sequence,-1)) AS VARCHAR(18))) ||
                     ' could not perform action. Unsupported action ' ||
                     TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18)))
                     || ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    CALL [METABASE].WsWrkAudit('E',pi_job_name, pi_task_name, pi_sequence,
                                     v_MsgText,NULL,NULL,pi_task_key,pi_job_key);
    SET v_status_code  = -2;

    SET v_return_msg = 'Unsupported action ' ||
                       TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18))) ||
                       ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    SET v_result = 1;

  END IF;

  SET v_step = 190;

  SET po_result_code = v_status_code;
  SET po_result_msg = v_return_msg;
  SET po_action_key = 0;
  SET po_action_msg = 'no action';
  SET po_handled = v_handled;
  SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
  SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
  SET po_proc_stmt = 'no statement';

END;
_PROCEDWSL_ Ws_Job_Exec_ActionPC 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_ActionPC
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_obj_type         INTEGER
, IN  pi_action_type      INTEGER
, IN  pi_obj_key          INTEGER
, IN  pi_sid              INTEGER
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
, OUT po_handled          INTEGER
, OUT ps_job_key_list     VARCHAR(256) -- ( list of jobs to pass task down to. Comma separated )
, OUT ps_task_key_list    VARCHAR(256) -- ( list of tasks to pass task down to. Comma separated )
, OUT po_proc_stmt        VARCHAR(8000)
)
WS_JOB_EXEC_ACTIONPC:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_actionPC
  -- Description  Action a task for a
  --               - process action
  --               - custom action
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- AP  05/11/2009   Version 6.1.0.0  Implement OLAP objects
  -- RS  14/02/2013   Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  18/01/2016   Version 6.8.5.2  Changed error handler
  -- BC  10/02/2016   Version 6.8.5.3  Added support for BDA Server operations
  -- RS  10/06/2016   Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019   Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_result                   INTEGER;
  DECLARE v_return_msg               VARCHAR(1024);
  DECLARE v_status_code              INTEGER;
  DECLARE v_result_2                 INTEGER;
  DECLARE v_return_msg_2             VARCHAR(1024);
  DECLARE v_status_code_2            INTEGER;
  DECLARE v_result_3                 INTEGER;
  DECLARE v_return_msg_3             VARCHAR(1024);
  DECLARE v_status_code_3            INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_handled                  INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_action_type              INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_task_key                 INTEGER;
  DECLARE v_default_stats            VARCHAR(4000);
  DECLARE v_idle_thread_wait         INTEGER;
  DECLARE v_idle_thread_wait_hh      INTEGER;
  DECLARE v_idle_thread_wait_mm      INTEGER;
  DECLARE v_idle_thread_wait_ss      INTEGER;
  DECLARE v_idle_thread_wait_string  VARCHAR(255);
  DECLARE v_proc_stmt                VARCHAR(4000);

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in WS_JOB_EXEC_ACTIONPC Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_task_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, pi_task_key, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;
  SET v_idle_thread_wait         = 30;
  SET v_idle_thread_wait_hh      = 0;
  SET v_idle_thread_wait_mm      = 0;
  SET v_idle_thread_wait_ss      = 0;
  SET v_idle_thread_wait_string  = '000030';

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET v_action_type = pi_action_type;
  SET v_obj_type = pi_obj_type;

  SET v_step = 181;

  --=====================================================
  -- Work out the type of action and run the appropriate
  -- function.
  --=====================================================
  SET v_status_code = -3;
  SET v_return_msg = 'Unhandled exception in action';
  SET v_handled = 0;

  --=====================================================
  -- P R O C E S S
  --=====================================================
  IF v_action_type = v_ws_act_process THEN

    SET v_handled = 1;

    --=====================================================
    -- P R O C E S S      C U B E
    --=====================================================
    IF v_obj_type = v_ws_obj_olap_cube
    OR v_obj_type = v_ws_obj_olap_dim
    OR v_obj_type = v_ws_obj_olap_role
    OR v_obj_type = v_ws_obj_cube
    OR v_obj_type = v_ws_obj_cube_virtual
    THEN

      -- If this process is for a cube
      -- return value of 5
      -- pass back to the scheduler and let it do the processing
      SET po_result_code = 5;
      SET po_result_msg = 'cube process';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
      --=====================================================
      SET v_step = 331;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTIONPC;

    END IF;

    --=====================================================
    -- P R O C E S S      L O A D
    --=====================================================
    IF v_obj_type = v_ws_obj_load THEN

      CALL [METABASE].Ws_Act_Pre_Drop(pi_sequence,v_obj_type,v_action_type
                                    , pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result);

      IF v_result >= -1 THEN

        IF v_status_code = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        CALL [METABASE].Ws_Act_Load(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

        -- If this load requires a host script then we will have a
        -- return value of 2
        -- If script build worked then skip out to process it
        -- If it failed then the standard handling will deal with it.
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 2 THEN

          SET po_result_code = 2;
          SET po_result_msg = 'process table';
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 330;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;

        -- If this load requires an ODBC load then we will have a
        -- return value of 3
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 3 THEN

          SET po_result_code = 3;
          SET po_result_msg = 'process table';
          SET po_action_key = pi_obj_key;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 336;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;-- end of result = 3

        -- If this load requires a Native ODBC load then we will have a
        -- return value of 12
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 12 THEN

          SET po_result_code = 12;
          SET po_result_msg = 'process table';
          SET po_action_key = pi_obj_key;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 337;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;-- end of result = 12

        -- If this load requires an Apache Sqoop load then we will have a
        --   return value of 91
        -- Skip out to process it
        -- When we Rejoin the job any post load procedure will be run
        IF v_result = 91 THEN

          SET po_result_code = v_result;
          SET po_result_msg = v_return_msg;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = 'no statement';

          --=====================================================
          -- Remove this thread as being active
          --=====================================================
          SET v_step = 338;

          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;-- end of result = 91

      END IF;-- End of load okay

      -- Now resume with running the post_load

      IF v_result >= -1 THEN

        CALL [METABASE].Ws_Act_Post_Load(pi_sequence,v_obj_type,v_action_type
                                       , pi_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                       , v_return_msg_2, v_status_code_2
                                       , v_result_2, v_proc_stmt);

        -- If a post load procedure could be found
        -- The result will be 2 if no post load was found
        IF v_result_2 = 1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_return_msg_2;
          SET po_handled = v_handled;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;

      ELSE

        SET v_status_code_2 = 1;

      END IF;

      IF v_result_2 >= -1 THEN

        IF v_status_code_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        CALL [METABASE].Ws_Act_Build(pi_sequence,v_obj_type,v_action_type
                                   , pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key,NULL
                                   , v_return_msg_3, v_status_code_3
                                   , v_result_3);

        IF v_status_code_3 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                v_return_msg_3,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_status_code_3 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                v_return_msg_3,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

      ELSE

        SET v_status_code_3 = 1;

      END IF;

      -- If our index build failed and the load worked then
      -- record the index failure
      IF v_status_code_2 < v_status_code THEN

        SET v_status_code = v_status_code_2;

      END IF;

      IF v_status_code_3 < v_status_code THEN

        SET v_status_code = v_status_code_3;

      END IF;

    END IF;-- End of Process a load

    --=====================================================
    -- P R O C E S S      E X P O R T
    --=====================================================
    IF v_obj_type = v_ws_obj_export THEN

      CALL [METABASE].Ws_Act_Export(pi_sequence,v_obj_type,v_action_type
                                  , pi_obj_key
                                  , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                  , v_return_msg, v_status_code
                                  , v_result);

      -- If this export requires a host script then we will have a
      -- return value of 2
      -- If script build worked then skip out to process it
      -- If it failed then the standard handling will deal with it.
      -- When we Rejoin the job any post load procedure will be run
      IF v_result = 2 THEN

        SET po_result_code = 11;
        SET po_result_msg = 'process table';
        SET po_action_key = 0;
        SET po_action_msg = 'no action';
        SET po_handled = v_handled;
        SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET po_proc_stmt = 'no statement';

        --=====================================================
        -- Remove this thread as being active
        --=====================================================
        SET v_step = 330;

        CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

        LEAVE WS_JOB_EXEC_ACTIONPC;

      END IF;

      IF v_result >= -1 THEN

        CALL [METABASE].Ws_Act_Post_Export(pi_sequence,v_obj_type,v_action_type
                                         , pi_obj_key
                                         , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                         , v_return_msg_2, v_status_code_2
                                         , v_result_2, v_proc_stmt);

        IF v_result_2 >= -1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_return_msg_2;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;

      ELSE

        SET v_status_code_2 = 1;

      END IF;

      IF v_result_2 >= -1 THEN

        IF v_status_code_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

      ELSE

        SET v_status_code_3 = 1;

      END IF;

      IF v_status_code_2 < v_status_code THEN

        SET v_status_code = v_status_code_2;

      END IF;

      IF v_status_code_3 < v_status_code THEN

        SET v_status_code = v_status_code_3;

      END IF;

    END IF;-- End of Process a export

    IF  v_obj_type <> v_ws_obj_olap_cube
    AND v_obj_type <> v_ws_obj_olap_dim
    AND v_obj_type <> v_ws_obj_olap_role
    AND v_obj_type <> v_ws_obj_cube
    AND v_obj_type <> v_ws_obj_cube_virtual
    AND v_obj_type <> v_ws_obj_load
    AND v_obj_type <> v_ws_obj_export
    THEN

    --=====================================================
    -- P R O C E S S      O T H E R     O B J E C T
    --=====================================================

      CALL [METABASE].Ws_Act_Pre_Drop(pi_sequence,v_obj_type,v_action_type
                                    , pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result);

      IF v_result >= -1 THEN

        IF v_status_code = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        ELSE

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        SET v_result = -3;

        SET v_return_msg = 'Unexpected error in call to update procedure';

        CALL [METABASE].Ws_Act_Update(pi_sequence,v_obj_type,v_action_type
                                    , pi_obj_key
                                    , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                    , v_return_msg, v_status_code
                                    , v_result, v_proc_stmt);

        IF v_result >= -1 THEN

          SET po_result_code = 98;
          SET po_result_msg = v_return_msg;
          SET po_action_key = 0;
          SET po_action_msg = 'no action';
          SET po_handled = v_handled;
          SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
          SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
          SET po_proc_stmt = v_proc_stmt;

          -- Delete the thread as returning to the OS to run the procedure
          CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

          LEAVE WS_JOB_EXEC_ACTIONPC;

        END IF;

      END IF;

      IF v_result >= -1 THEN

        CALL [METABASE].Ws_Act_Build(pi_sequence,v_obj_type,v_action_type
                                   , pi_obj_key
                                   , pi_job_name, pi_task_name, pi_job_key, pi_task_key, NULL
                                   , v_return_msg_2, v_status_code_2
                                   , v_result_2);

        IF v_status_code_2 = 1 THEN

          CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

        IF v_status_code_2 < 1 THEN

          CALL [METABASE].WsWrkAudit('W',pi_job_name, pi_task_name, pi_sequence,
                                 v_return_msg_2,NULL,NULL,pi_task_key,pi_job_key);

        END IF;

      ELSE

        SET v_status_code_2 = 1;

      END IF;

      -- If our index build failed and the update worked then
      -- record the index failure
      IF v_status_code_2 < v_status_code THEN

        SET v_status_code = v_status_code_2;

      END IF;

    END IF; -- End of other object process

  END IF; -- End of Process

  --=====================================================
  -- C U S T O M
  --=====================================================
  IF v_action_type = v_ws_act_custom THEN

    SET v_handled = 1;

    CALL [METABASE].Ws_Act_Initial_Build(pi_sequence,v_obj_type,v_action_type
                                       , pi_obj_key
                                       , pi_job_name, pi_task_name, pi_job_key, pi_task_key
                                       , v_return_msg, v_status_code
                                       , v_result, v_proc_stmt);

    IF v_result >= -1 THEN


      SET po_result_code = 98;
      SET po_result_msg = v_return_msg;
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET po_handled = v_handled;
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_proc_stmt = v_proc_stmt;

      -- Delete the thread as returning to the OS to run the procedure
      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, pi_sid, v_status_code);

      LEAVE WS_JOB_EXEC_ACTIONPC;

    END IF;

  END IF;-- End of custom

  --=====================================================
  -- U N S U P P O R T E D
  --=====================================================
  IF v_handled = 0 THEN

    SET v_MsgText = 'Ws_Job_Exec_ActionPC' || v_ws_pro_version || ' Job ' || pi_task_name || ' sequence ' ||
                     TRIM(CAST((COALESCE(pi_sequence,-1)) AS VARCHAR(18))) ||
                     ' could not perform action. Unsupported action ' ||
                     TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18)))
                     || ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    CALL [METABASE].WsWrkAudit('E',pi_job_name, pi_task_name, pi_sequence,
                                     v_MsgText,NULL,NULL,pi_task_key,pi_job_key);
    SET v_status_code  = -2;

    SET v_return_msg = 'Unsupported action ' ||
                       TRIM(CAST((COALESCE(v_action_type,-1)) AS VARCHAR(18))) ||
                       ' for object ' || TRIM(CAST((COALESCE(v_obj_type,-1)) AS VARCHAR(18)));

    SET v_result = 1;

  END IF;

  SET v_step = 190;

  SET po_result_code = v_status_code;
  SET po_result_msg = v_return_msg;
  SET po_action_key = 0;
  SET po_action_msg = 'no action';
  SET po_handled = v_handled;
  SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
  SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
  SET po_proc_stmt = 'no statement';

END;
_PROCEDWSL_ Ws_Job_Exec_Process 
REPLACE PROCEDURE [METABASE].Ws_Job_Exec_Process
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_action           VARCHAR(12)
, IN  pi_task_status      INTEGER
, IN  pi_task_msg         VARCHAR(256)
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(256)
, OUT po_task_name        VARCHAR(64)
, OUT po_task_key         INTEGER
, OUT po_proc_stmt        VARCHAR(8000)
, OUT ps_job_key_list     VARCHAR(256) -- ( list of jobs to pass task down to. Comma separated )
, OUT ps_task_key_list    VARCHAR(256) -- ( list of tasks to pass task down to. Comma separated )
)
WS_JOB_EXEC_PROCESS:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_process
  -- Description  Processes a task
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- AP  01/02/2010     Version 6.1.0.0  Provisional Handle task action indicator
  -- RS  14/02/2013     Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  08/04/2014     Version 6.7.4.1  Fixed issue with multi-threading
  -- RS  18/01/2016     Version 6.8.5.2  Changed error handler
  -- BC  10/02/2016     Version 6.8.5.3  Added support for BDA Server operations
  -- TA  25/02/2016     Version 6.8.5.3  Added support for BDA Server authentication
  -- HM  08/03/2016     Version 6.8.5.3  Comment fixes
  -- RS  21/03/2016     Version 6.8.5.3  Added support for ODBC load into Hive tables
  -- TA  11/03/2016     Version 6.8.5.4  RED-5890 Added support for Database Link Loads into Hive targets
  -- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- AP  22/06/2016     Version 6.8.6.2  RED-3282 Support 'disabled' tasks
  -- BC  28/09/2016     Version 6.8.6.2  RED-7268 Prevent Hive script loads and exports going to BDA.
  -- RS  14/12/2016     Version 6.8.6.3  RED-7626 Added check if object key is a child job before looking at BDA connection
  -- FS  05/12/2017     Version 8.0.2.0  RED-9068 resolved deadlock issues
  -- HM  03/10/2017     Version 8.1.1.0  Added support for Source Mapping
  -- HM  06/08/2018     Version 8.2.1.0  RED-9715 When thread is picked to run a job check that thread id in the job record
  --                                     matches thread's own id.
  -- AD  13/08/2018     Version 8.3.1.0  RED-9704 Fix high IO usage on scheduler query on Teradata
  -- BC  19/12/2018     Version 8.3.1.0  RED-10133 Fix to not treat a child job as an external object
  -- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  -- HM  01/03/2019     Version 8.3.1.1  RED-10221 Ensure primary index is used when accessing/updating ws_wrk_task_run to
  --                                     prevent deadlock.
  --
  -- ****************************************************
  -- DON'T FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;
  DECLARE v_ws_obj_source_mapping    INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  DECLARE v_wants_to_run             INTEGER;
  DECLARE v_ws_act_disabled_once     CHAR(1);
  DECLARE v_ws_act_disabled          CHAR(1);

  --=====================================================
  -- Parameters to the called procedures
  --=====================================================
  DECLARE v_return_msg               VARCHAR(1024);

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_no_more_data1            INTEGER;
  DECLARE v_no_more_data2            INTEGER;
  DECLARE v_dep_cursor               INTEGER;       -- status for the dependency cursor
  DECLARE v_task_cursor              INTEGER;       -- status for the task cursor
  DECLARE v_rec_count                INTEGER;
  DECLARE v_task_count               INTEGER;
  DECLARE v_child_key                INTEGER;
  DECLARE v_run_status               VARCHAR(1);
  DECLARE v_audit_status             VARCHAR(1);
  DECLARE v_abort_level              INTEGER;
  DECLARE v_halted                   INTEGER;
  DECLARE v_okay                     INTEGER;
  DECLARE v_checked                  INTEGER;
  DECLARE v_running_count            INTEGER;
  DECLARE v_failed_count             INTEGER;
  DECLARE v_halted_count             INTEGER;
  DECLARE v_job_status               VARCHAR(1);
  DECLARE v_OkayMsg                  VARCHAR(255); -- Okay result command
  DECLARE v_FailMsg                  VARCHAR(255); -- Failure result command
  DECLARE v_idle_thread              INTEGER;
  DECLARE v_process                  INTEGER;
  DECLARE v_action_type              INTEGER;
  DECLARE v_obj_type                 INTEGER;
  DECLARE v_obj_key                  INTEGER;
  DECLARE v_depend_loop              INTEGER;
  DECLARE v_taskrun_open             INTEGER;
  DECLARE v_sid                      INTEGER;
  DECLARE v_new_value                VARCHAR(8000);
  DECLARE v_status_code              INTEGER;
  DECLARE v_activity_count           INTEGER;
  DECLARE v_any_hive_targets         INTEGER;
  DECLARE v_bda_connect_key          INTEGER;
  DECLARE v_is_hive_target           INTEGER;
  DECLARE v_task_data                VARCHAR(4000);
  DECLARE v_secret_id                INTEGER;
  DECLARE v_secret_text              VARCHAR(4000);

  --=====================================================
  -- Output variables from calling Ws_Job_Exec_Process
  --=====================================================
  DECLARE vs_status_code             INTEGER;
  DECLARE vs_return_msg              VARCHAR(1024);
  DECLARE vs_action_key              INTEGER;
  DECLARE vs_action_msg              VARCHAR(256);
  DECLARE vs_handled                 INTEGER;
  DECLARE vs_job_key_list            VARCHAR(256);
  DECLARE vs_task_key_list           VARCHAR(256);
  DECLARE vs_proc_stmt               VARCHAR(8000);

  --=====================================================
  -- Variables for Task Run cursor
  --=====================================================
  DECLARE v_wtr_task_key             INTEGER;
  DECLARE v_wtr_job_key              INTEGER;
  DECLARE v_wtr_obj_key              INTEGER;
  DECLARE v_wtr_name                 VARCHAR(64);
  DECLARE v_wtr_sequence             INTEGER;
  DECLARE v_wtr_restart              INTEGER;
  DECLARE v_wtr_run_status           VARCHAR(1);
  DECLARE v_wtr_audit_status         VARCHAR(1);
  DECLARE v_wtr_started              timestamp;
  DECLARE v_wtr_completed            timestamp;
  DECLARE v_wtr_elapsed_hh           INTEGER;
  DECLARE v_wtr_elapsed_mi           INTEGER;
  DECLARE v_wtr_info_count           INTEGER;
  DECLARE v_wtr_warning_count        INTEGER;
  DECLARE v_wtr_detail_count         INTEGER;
  DECLARE v_wtr_return_msg           VARCHAR(1024);
  DECLARE v_wtr_type                 VARCHAR(1);
  DECLARE v_wtr_obj_type             INTEGER;
  DECLARE v_wtr_action_type          INTEGER;
  DECLARE v_wtr_chkp_number          INTEGER;
  DECLARE v_wtr_abort_level          INTEGER;
  DECLARE v_wtr_thread               INTEGER;
  DECLARE v_wtr_inserted             INTEGER;
  DECLARE v_wtr_updated              INTEGER;
  DECLARE v_wtr_replaced             INTEGER;
  DECLARE v_wtr_deleted              INTEGER;
  DECLARE v_wtr_discarded            INTEGER;
  DECLARE v_wtr_rejected             INTEGER;
  DECLARE v_wtr_errored              INTEGER;
  DECLARE v_wtr_order                INTEGER;
  DECLARE v_wtr_action_ind           VARCHAR(1);
  DECLARE v_delete                   VARCHAR(500); -- JWH 11 Sept 17

  --=====================================================
  -- Variables for Dependency cursor
  --=====================================================
  DECLARE v_wdp_job_key              INTEGER;
  DECLARE v_wdp_parent_task_key      INTEGER;
  DECLARE v_wdp_child_task_key       INTEGER;

  --=====================================================
  -- Cursor for all the task run records waiting to be run
  --=====================================================
  DECLARE c_TaskRun CURSOR FOR
  SELECT   *
  FROM     [METABASE].ws_wrk_task_run
  WHERE    wtr_job_key = pi_job_key
  AND      wtr_sequence = pi_sequence
  ORDER BY wtr_order
  FOR READ ONLY
  ;

  --=====================================================
  -- Cursor for all the parent dependencies of a particular task
  --=====================================================
  DECLARE c_Dependency CURSOR FOR
  SELECT *
  FROM   [METABASE].ws_wrk_dependency
  WHERE  wdp_job_key = pi_job_key
  AND    wdp_child_task_key = v_child_key
  FOR READ ONLY
  ;

  --=====================================================
  -- Cursor for updating the task record
  --=====================================================
  DECLARE c_TaskUpdate CURSOR FOR
  SELECT wtr_run_status
  FROM   [METABASE].ws_wrk_task_run
  WHERE  wtr_task_key = v_wtr_task_key
  AND    wtr_job_key = pi_job_key
  AND    wtr_sequence = pi_sequence
  AND    wtr_run_status = 'W'
  ;

  --=====================================================
  -- Cursor for updating the job record
  --=====================================================
  DECLARE c_JobUpdate CURSOR FOR
  SELECT wjr_status
  FROM   [METABASE].ws_wrk_job_run
  WHERE  wjr_job_key = pi_job_key
  AND    wjr_sequence = pi_sequence
  AND    v_run_status = 'R'
  ;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in WS_JOB_EXEC_PROCESS Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_job_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, 0, pi_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;

  SET v_ws_obj_job               = 50;
  SET v_ws_obj_source_mapping    = 69;

  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;
  SET v_ws_act_disabled_once     = 'A';
  SET v_ws_act_disabled          = 'B';
  SET v_no_more_data1            = 0;
  SET v_no_more_data2            = 0;

  --=====================================================
  -- MAIN
  --=====================================================

  --**********************************************************************
  -- Okay to start processing tasks. Three possible types of tasks
  -- will be handled. These Being (P)procedures, (F)functions and
  -- (C) checkpoints.
  -- Open the cursor we will use to run the tasks
  --**********************************************************************
  --=====================================================
  SET v_task_count = 1;
  SET v_step = 100;
  SET v_depend_loop = 0;
  SET po_task_key = 0;
  SET po_task_name = 'no task name';
  SET po_proc_stmt = 'no statement';

  -- While More tasks loop
  WHILE v_task_count > 0 DO

    SET v_step = 200;
    SET v_task_count = 0;
    SET v_running_count = 0;
    SET v_halted_count = 0;
    SET v_failed_count = 0;
    SET v_idle_thread = 0;

    -- Loop through All the Task records.
    -- Clearing any halted or failed status
    SET v_no_more_data1 = 0;

    BEGIN

      DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_no_more_data1 = 1;

      OPEN c_TaskRun;

      SET v_taskrun_open = 0;

      FETCH FROM c_TaskRun INTO
        v_wtr_task_key
      , v_wtr_job_key
      , v_wtr_obj_key
      , v_wtr_name
      , v_wtr_sequence
      , v_wtr_restart
      , v_wtr_run_status
      , v_wtr_audit_status
      , v_wtr_started
      , v_wtr_completed
      , v_wtr_elapsed_hh
      , v_wtr_elapsed_mi
      , v_wtr_info_count
      , v_wtr_warning_count
      , v_wtr_detail_count
      , v_wtr_return_msg
      , v_wtr_type
      , v_wtr_obj_type
      , v_wtr_action_type
      , v_wtr_chkp_number
      , v_wtr_abort_level
      , v_wtr_thread
      , v_wtr_inserted
      , v_wtr_updated
      , v_wtr_replaced
      , v_wtr_deleted
      , v_wtr_discarded
      , v_wtr_rejected
      , v_wtr_errored
      , v_wtr_order
      , v_wtr_action_ind;

      TASK_LOOP:
      WHILE v_no_more_data1 = 0 DO

        --=====================================================
        -- Check the status of each task
        -- If it is waiting then we will check dependencies etc.
        -- and see if it needs to be executed.
        --=====================================================
        SET v_step = 300;
        SET v_process = 0;

        IF v_wtr_run_status = 'W' THEN

          SET v_step = 400;
          SET v_task_count = 1;

          --=====================================================
          -- Check the dependencies for the task
          --=====================================================
          SELECT COUNT(*)
          INTO   v_rec_count
          FROM   [METABASE].ws_wrk_dependency
          WHERE  wdp_job_key = pi_job_key
          AND    wdp_child_task_key = v_wtr_task_key;

          -- If parent dependencies then check each to see if it has completed.
          SET v_child_key = v_wtr_task_key;
          SET v_halted = 0;
          SET v_okay = 0;
          SET v_checked = 0;
          SET v_step = 500;

          SET v_no_more_data2 = 0;

          BEGIN

            DECLARE CONTINUE HANDLER FOR NOT FOUND
              BEGIN
                SET v_no_more_data2 = 1;
                SET v_no_more_data1 = 0;
              END;

            OPEN c_Dependency;

            FETCH FROM c_Dependency INTO
              v_wdp_job_key
            , v_wdp_parent_task_key
            , v_wdp_child_task_key;

            WHILE v_no_more_data2 = 0 DO

              -- Get the parent task record from the task_run table
              SELECT wtr_run_status
                   , wtr_audit_status
                   , wtr_abort_level
              INTO   v_run_status
                   , v_audit_status
                   , v_abort_level
              FROM   [METABASE].ws_wrk_task_run
              WHERE  wtr_job_key = pi_job_key
              AND    wtr_task_key = v_wdp_parent_task_key;

              SET v_step = 600;

              -- Get the status for the parent task.
              -- If the parent is waiting or running then skip the rest of the tests as we can't go
              -- If the parent has been halted then set the flag to halt this task also.
              -- If the parent has failed or completed check the audit status
              -- The abort level will tell us if we should count this as a halt or an okay
              IF v_run_status = 'W' THEN

                SET v_dep_cursor = 1;
              ELSEIF v_run_status = 'R' THEN

                SET v_dep_cursor = 1;

              ELSEIF v_run_status = 'H' THEN

                SET v_halted = 1;
             SET v_dep_cursor = 1;

              ELSEIF v_run_status = 'F' THEN

                IF v_abort_level = 5 THEN

                  SET v_checked = v_checked + 1;

                ELSE

                  SET v_halted = 1;
                  SET v_dep_cursor = 1;

                END IF;

              ELSEIF v_run_status = 'U' THEN

                IF v_abort_level = 5 THEN

                  SET v_checked = v_checked + 1;

                ELSE

                  SET v_halted = 1;
                  SET v_dep_cursor = 1;

                END IF;

              ELSEIF v_run_status = 'C' THEN

                IF v_abort_level <= 3 THEN

                  IF v_audit_status = 'W' THEN

                    SET v_halted = 1;
                    SET v_dep_cursor = 1;

                  ELSE

                    SET v_checked = v_checked + 1;

                  END IF;

                ELSE

                  SET v_checked = v_checked + 1;

                END IF;

              ELSE

                SET v_dep_cursor = 1;

              END IF;

              FETCH FROM c_Dependency INTO
                v_wdp_job_key
              , v_wdp_parent_task_key
              , v_wdp_child_task_key;

            END WHILE;-- end of dependency cursor loop

            CLOSE c_Dependency;

          END;

          -- See if we passed our dependency check
          -- We either passed, need to halt the task or need to skip this task
          -- 5.6.1.1 also reset the depend_loop now to minimise erroneous errors
          --         that result if tasks have contention etc
          IF v_checked = v_rec_count THEN

            SET v_okay = 1;
            SET v_depend_loop = 0;

          END IF;

          SET v_step = 700;

          --=====================================================
          -- See if the task is okay to run and a procedure if so run it
          --=====================================================
          SET v_wants_to_run = 1;
          IF   v_okay = 1
          AND  (   (v_wtr_obj_type > 0 AND v_wtr_obj_type <= v_ws_obj_max)
                OR (v_wtr_obj_type = v_ws_obj_source_mapping)
                OR (v_wtr_obj_type = v_ws_obj_job)
               )
          THEN

            SET v_step = 800;

            --=====================================================
            -- Update the run record to indicate we are running.
            -- Need to lock the record first to prevent another thread from
            -- grabbing it, or in case another thread has already got it,
            -- or updated it
            --=====================================================
            SET v_run_status = 'Z';

            SELECT wtr_run_status
                 , CASE WHEN COALESCE(wtr_action_ind,'') IN ('A','B') THEN 0 ELSE 1 END wants_to_run
            INTO   v_run_status
                 , v_wants_to_run
            FROM   [METABASE].ws_wrk_task_run
            WHERE  wtr_task_key = v_wtr_task_key
            AND    wtr_job_key = pi_job_key
            AND    wtr_sequence = pi_sequence;

            SET v_step = 900;

            -- If the task is still in a wait state
            -- then set it to running
            IF v_run_status = 'W' THEN

              SET v_no_more_data2 = 0;

              BEGIN

                DECLARE CONTINUE HANDLER FOR SQLSTATE '40001'
                  BEGIN
                    SET v_step = 1000;
                    SET v_no_more_data1 = 1;
                    SET v_no_more_data2 = 1;
                    SET v_okay = 0;
                    SET v_running_count = v_running_count + 1;
                  END;

                BEGIN
                  DECLARE CONTINUE HANDLER FOR NOT FOUND
                    BEGIN
                      SET v_step = 1100;
                      SET v_no_more_data1 = 1;
                      SET v_no_more_data2 = 1;
                      SET v_okay = 0;
                      SET v_running_count = v_running_count + 1;
                    END;

                  SET v_step = 1200;

                  OPEN c_TaskUpdate;

                  SET v_step = 1300;

                  FETCH FROM c_TaskUpdate INTO v_run_status;

                  WHILE v_no_more_data2 = 0 DO

                    SET v_step = 1400;

                    IF v_wants_to_run = 0 THEN
                      UPDATE [METABASE].ws_wrk_task_run
                      SET    wtr_run_status = 'C'
                           , wtr_thread = pi_thread
                           , wtr_started = CURRENT_TIMESTAMP
                           , wtr_audit_status = 'S'
                           , wtr_return_msg   = 'Task Disabled, Skipped.'
                           , wtr_elapsed_hh   = 0
                           , wtr_elapsed_mi   = 0
                           , wtr_completed    = CURRENT_TIMESTAMP
                      WHERE  wtr_task_key = v_wtr_task_key
                      AND    wtr_job_key = pi_job_key
                      AND    wtr_sequence = pi_sequence
                      AND    wtr_run_status = 'W'
                      ;
                      SET v_activity_count = 0; -- deliberate to treat as nothing to run on this task
                      SET v_okay = 0;
                    ELSE
                      UPDATE [METABASE].ws_wrk_task_run
                      SET    wtr_run_status = 'R'
                           , wtr_thread = pi_thread
                           , wtr_started = CURRENT_TIMESTAMP
                      WHERE  wtr_task_key = v_wtr_task_key
                      AND    wtr_job_key = pi_job_key
                      AND    wtr_sequence = pi_sequence
                      AND    wtr_run_status = 'W'
                      ;
                      SET v_activity_count = ACTIVITY_COUNT;
                    END IF;

                    SET v_no_more_data2 = 1;

                  END WHILE;

                  SET v_step = 1500;

                  CLOSE c_TaskUpdate;

                  --Close the cursor only if we could successfully update
                  IF v_activity_count = 1 THEN

                    CLOSE c_TaskRun;
                    SET v_taskrun_open = 1;

                    SET v_step = 1600;
                    SET v_process = 1;
                    SET v_action_type = v_wtr_action_type;
                    SET v_obj_type = v_wtr_obj_type;
                    SET v_obj_key = v_wtr_obj_key;
                    SET v_task_cursor = 1;

                  END IF;

                END;

              END;

              SET v_step = 1700;

              --Leave loop only if the update of the thread was successful, otherwise another thread caught it just before
              IF v_activity_count = 1 THEN
                SELECT count(*)
                INTO   v_rec_count
                FROM   [METABASE].ws_wrk_task_run
                WHERE  wtr_task_key = v_wtr_task_key
                AND    wtr_job_key = pi_job_key
                AND    wtr_sequence = pi_sequence
                AND    wtr_thread = pi_thread
                AND    wtr_run_status = 'R'
                ;
              ELSE
                SET v_rec_count = 0;
              END IF;

              IF v_rec_count = 1 THEN

                 LEAVE TASK_LOOP;

              ELSE

                 -- someone else got the record just before
                 SET v_okay = 0;
                 SET v_running_count = v_running_count + 1;

              END IF;

            -- someone else got the record  (NOT = W)
            ELSE

              SET v_okay = 0;
              SET v_running_count = v_running_count + 1;

            END IF;

            -- someone else got the record and is running it
            IF v_run_status = 'R' THEN

              SET v_task_count = 0;
              SET v_running_count = v_running_count + 1;

            END IF;

            SET v_step = 1800;

            -- If we still have a go, then run it
            -- Break out of this loop and run the task by setting the v_process flag
            IF v_okay = 1 THEN

              SET v_process = 1;
              SET v_action_type = v_wtr_action_type;
              SET v_obj_type = v_wtr_obj_type;
              SET v_obj_key = v_wtr_obj_key;
              SET v_task_cursor = 1;

              LEAVE TASK_LOOP;

            END IF;

          END IF; -- end of okay to run and a normal task check

          SET v_step = 1900;

          --=====================================================
          -- See if the task needs a status update.
          --=====================================================
          IF v_okay = 1 OR v_halted = 1 THEN

            --=====================================================
            -- Update the run record to indicate our final status
            -- If we have a halt then generate a message
            --=====================================================
            SET v_step = 2000;

            IF v_halted = 1 THEN

              SET v_return_msg = 'Halted by dependency failure or halt';
              SET v_run_status = 'H';
              SET v_audit_status = NULL;

            END IF;

            UPDATE [METABASE].ws_wrk_task_run
            SET    wtr_run_status = v_run_status
                 , wtr_audit_status = v_audit_status
                 , wtr_return_msg = v_return_msg
                 , wtr_elapsed_hh = EXTRACT(HOUR FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
                 , wtr_elapsed_mi = EXTRACT(MINUTE FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
                 , wtr_completed = CURRENT_TIMESTAMP
            WHERE  wtr_task_key = v_wtr_task_key
            AND    wtr_job_key = pi_job_key
            AND    wtr_sequence = pi_sequence;

          END IF; -- End of task status update

        END IF;-- End if task status Waiting

        IF v_wtr_run_status = 'R' THEN

          SET v_running_count = v_running_count + 1;

        ELSEIF v_wtr_run_status = 'H' THEN

          SET v_halted_count = v_halted_count + 1;

        ELSEIF v_wtr_run_status = 'F' THEN

          SET v_failed_count = v_failed_count + 1;

        ELSEIF v_wtr_run_status = 'U' THEN

          SET v_failed_count = v_failed_count + 1;
       END IF;

        SET v_step = 2100;

        FETCH FROM c_TaskRun INTO
          v_wtr_task_key
        , v_wtr_job_key
        , v_wtr_obj_key
        , v_wtr_name
        , v_wtr_sequence
        , v_wtr_restart
        , v_wtr_run_status
        , v_wtr_audit_status
        , v_wtr_started
        , v_wtr_completed
        , v_wtr_elapsed_hh
        , v_wtr_elapsed_mi
        , v_wtr_info_count
        , v_wtr_warning_count
        , v_wtr_detail_count
        , v_wtr_return_msg
        , v_wtr_type
        , v_wtr_obj_type
        , v_wtr_action_type
        , v_wtr_chkp_number
        , v_wtr_abort_level
        , v_wtr_thread
        , v_wtr_inserted
        , v_wtr_updated
        , v_wtr_replaced
        , v_wtr_deleted
        , v_wtr_discarded
        , v_wtr_rejected
        , v_wtr_errored
        , v_wtr_order
        , v_wtr_action_ind;

      END WHILE; -- end of cursor loop

      SET v_step = 2200;

      IF v_taskrun_open = 0 THEN

        CLOSE c_TaskRun;

      END IF;

    END;

    -- A task that we are ready to run will break out of the Task loop
    -- with the v_Process flag set, so proceed to process it.
    IF ( v_process = 1 ) THEN

      -- Get the BDA connection key for a BDA operation.
      SET v_bda_connect_key = 0;
      SET v_is_hive_target = 0;

      -- Determine if there is any Hive target
      SET v_any_hive_targets = 0;
      SELECT DISTINCT 1 INTO v_any_hive_targets FROM [METABASE].ws_dbc_connect
      JOIN [METABASE].ws_dbc_target ON dt_connect_key = dc_obj_key
      WHERE dc_db_type_ind = 8;

      -- Attention: v_obj_key can also hold a job key! We need to explicitly exclude job keys as they can accidentally point to a Hive or Hadoop object
      IF v_any_hive_targets = 1 AND v_obj_type <> v_ws_obj_job THEN
          SELECT bda.connect_key, bda.is_hive_target
          INTO v_bda_connect_key, v_is_hive_target
          FROM (
            -- All Load tables using Apache Sqoop from Hive or Hadoop
            SELECT src_con.dc_obj_key connect_key, CASE WHEN tgt_con.dc_db_type_ind = 8 THEN 1 ELSE 0 END is_hive_target    -- 8 = WS_DB_HIVE
            FROM [METABASE].ws_load_tab
            JOIN [METABASE].ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
            JOIN [METABASE].ws_obj_object ON lt_obj_key = oo_obj_key
            LEFT JOIN [METABASE].ws_dbc_target ON oo_target_key = dt_target_key
            LEFT JOIN [METABASE].ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE lt_obj_key = v_obj_key
            AND (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))    -- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
                UNION ALL
            -- All other non-Script-based Load tables with Hive targets
            SELECT  CASE WHEN lt_type IN ('A','F','D') THEN tgt_con.dc_obj_key ELSE 0 END connect_key, 1 is_hive_target
            FROM [METABASE].ws_load_tab
            JOIN [METABASE].ws_dbc_connect src_con ON lt_connect_key = src_con.dc_obj_key
            JOIN [METABASE].ws_obj_object ON lt_obj_key = oo_obj_key
            JOIN [METABASE].ws_dbc_target ON oo_target_key = dt_target_key
            JOIN [METABASE].ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE lt_obj_key = v_obj_key
            AND NOT (lt_type = 'A' AND (src_con.dc_db_type_ind = 8 OR src_con.dc_type = 'H'))    -- 'A' = Apache Sqoop Load, 8 = WS_DB_HIVE, 'H' = Hadoop
            AND tgt_con.dc_db_type_ind = 8        -- 8 = WS_DB_HIVE
                UNION ALL
            -- All other non-Load tables with Hive targets, except Script-based exports
            SELECT tgt_con.dc_obj_key connect_key, 1 is_hive_target
            FROM [METABASE].ws_obj_object
            JOIN [METABASE].ws_dbc_target ON oo_target_key = dt_target_key
            JOIN [METABASE].ws_dbc_connect tgt_con ON dt_connect_key = tgt_con.dc_obj_key
            WHERE oo_obj_key = v_obj_key
            AND oo_type_key <> v_ws_obj_load
            AND NOT (oo_type_key = v_ws_obj_export AND (SELECT et_type from [METABASE].ws_export_tab WHERE et_obj_key = oo_obj_key) = 'S')
            AND tgt_con.dc_db_type_ind = 8        -- 8 = WS_DB_HIVE
          ) bda;
      END IF;

      IF v_is_hive_target = 1 THEN

        -- Remove this thread as being active
        CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, v_sid, v_status_code);

        IF v_bda_connect_key > 0 THEN
          SET vs_status_code = 90;
          SET vs_return_msg = 'BDA Server task with Hive target';
        ELSE
          SET vs_status_code = 18;
          SET vs_return_msg = 'Other Load with Hive target';
        END IF;

        SET vs_action_key = 0;
        SET vs_action_msg = 'no action';
        SET vs_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
        SET vs_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
        SET vs_proc_stmt = 'no statement';

      ELSEIF v_action_type = v_ws_act_process
      OR v_action_type = v_ws_act_custom THEN

        CALL [METABASE].Ws_Job_Exec_ActionPC(pi_job_name, v_wtr_name, pi_thread
                                           , pi_sequence, pi_job_key, v_wtr_task_key
                                           , v_obj_type, v_action_type, v_obj_key, v_sid
                                           , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg
                                           , vs_handled, vs_job_key_list, vs_task_key_list
                                           , vs_proc_stmt);

      ELSEIF v_action_type = v_ws_act_load
      OR v_action_type = v_ws_act_update
      OR v_action_type = v_ws_act_initial THEN

        CALL [METABASE].Ws_Job_Exec_ActionLUI(pi_job_name, v_wtr_name, pi_thread
                                            , pi_sequence, pi_job_key, v_wtr_task_key
                                            , v_obj_type, v_action_type, v_obj_key, v_sid
                                            , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg
                                            , vs_handled, vs_job_key_list, vs_task_key_list
                                            , vs_proc_stmt);

      ELSE

        CALL [METABASE].Ws_Job_Exec_Action(pi_job_name, v_wtr_name, pi_thread
                                         , pi_sequence, pi_job_key, v_wtr_task_key
                                         , v_obj_type, v_action_type, v_obj_key, v_sid
                                         , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg
                                         , vs_handled, vs_job_key_list, vs_task_key_list
                                         , vs_proc_stmt);

      END IF;

      IF vs_status_code >= 2 THEN

        IF vs_status_code = 91 THEN

          SET vs_return_msg = vs_return_msg || ' with non-Hive target';

        END IF;

        IF vs_status_code = 90 OR vs_status_code = 91 THEN

          -- Put BDA connection settings into task data.
          -- There should be at most one record, otherwise a fatal problem.
          SELECT count(*)
          INTO v_rec_count
          FROM [METABASE].ws_table_attributes
          WHERE ta_obj_key = v_bda_connect_key AND ta_type = 'B';

          IF v_rec_count = 1 THEN
            SELECT ta_text_1
            INTO v_task_data
            FROM [METABASE].ws_table_attributes
            WHERE ta_obj_key = v_bda_connect_key AND ta_type = 'B';
          ELSE
            SET v_task_data = '';
            IF v_rec_count > 1 THEN
              SET v_MsgText = 'Multiple BDA connection parameters found for job: ' || pi_job_name || '.';
              CALL [METABASE].WsWrkAudit('E',pi_job_name,v_wtr_name,pi_sequence,
                v_MsgText,NULL,NULL,v_wtr_task_key,pi_job_key);
            END IF;
          END IF;

          -- Put the object key and action type into task data.
          SET v_task_data = v_task_data
            || 'SCH_BDA_ObjKey[WSH]' || TRIM(CAST(v_wtr_obj_key AS VARCHAR(18))) || '[WSH]'
            || 'SCH_BDA_Action[WSH]' || TRIM(CAST(v_wtr_action_type AS VARCHAR(18))) || '[WSH]';

          -- Put the shared secret timestamp and base64 bytes into task data.
          SET v_secret_id = 0;
          SET v_secret_text = '';
          SELECT ta_val_1 AS secret_id, ta_text_1 AS secret_text
            INTO v_secret_id, v_secret_text
            FROM [METABASE].ws_table_attributes
           WHERE ta_type = 'Z'
             AND ta_obj_key = 0;

          IF ACTIVITY_COUNT <> 1 THEN
            SET v_MsgText = 'No shared secret for BDA connection found for job: ' || pi_job_name || '.';
            CALL [METABASE].WsWrkAudit('E',pi_job_name,v_wtr_name,pi_sequence,
              v_MsgText,NULL,NULL,v_wtr_task_key,pi_job_key);
          END IF;

          SET v_task_data = v_task_data
            || 'SCH_BDA_SecretId[WSH]' || TRIM(CAST(v_secret_id AS VARCHAR(18))) || '[WSH]'
            || 'SCH_BDA_Secret[WSH]' || TRIM(v_secret_text) || '[WSH]';

          SET vs_proc_stmt = v_task_data;

        END IF;

        SET po_result_code = vs_status_code;
        SET po_result_msg = vs_return_msg;
        SET po_action_key = vs_action_key;
        SET po_action_msg = vs_action_msg;
        SET ps_job_key_list = vs_job_key_list;
        SET ps_task_key_list = vs_task_key_list;
        SET po_task_name = v_wtr_name;
        SET po_task_key = v_wtr_task_key;
        SET po_proc_stmt = vs_proc_stmt;

        LEAVE WS_JOB_EXEC_PROCESS;

      END IF;

      --=====================================================
      -- Log the results in the audit trail
      --=====================================================
      SET vs_handled = 0;

      IF vs_status_code = 1 THEN

        SET vs_handled = 1;
        SET v_audit_status = 'S';
        SET v_run_status = 'C';

      ELSEIF vs_status_code = -1 THEN

        SET vs_handled = 1;
        SET v_audit_status = 'W';
        SET v_run_status = 'C';

      ELSEIF vs_status_code = -2 THEN

        SET vs_handled = 1;
        SET v_audit_status = 'E';
        SET v_run_status = 'F';

      ELSEIF vs_status_code = -3 THEN

        SET vs_handled = 1;
        SET v_audit_status = 'F';
        SET v_run_status = 'F';

      END IF;

      IF vs_handled = 0 THEN

        SET v_audit_status = 'U';
        SET v_run_status = 'U';
        SET vs_status_code = -3;

      END IF;

      CALL [METABASE].WsWrkAudit(v_audit_status, pi_job_name, v_wtr_name, pi_sequence,
               vs_return_msg, NULL, NULL, v_wtr_task_key, pi_job_key);

      SET po_result_code = vs_status_code;
      SET po_result_msg = vs_return_msg;
      SET po_action_key = vs_action_key;
      SET po_action_msg = vs_action_msg;
      SET ps_job_key_list = vs_job_key_list;
      SET ps_task_key_list = vs_task_key_list;

      --=====================================================
      -- See if the task needs a status update.
      --=====================================================
      IF v_okay = 1 OR v_halted = 1 THEN

        --=====================================================
        -- Update the run record to indicate our final status
        -- If we have a halt then generate a message
        --=====================================================
        SET v_step = 230;

        IF v_halted = 1 THEN

          SET v_return_msg = 'Halted by dependency failure or halt';
          SET v_run_status = 'H';
          SET v_audit_status = NULL;

        END IF;

        UPDATE [METABASE].ws_wrk_task_run
        SET    wtr_run_status = v_run_status
             , wtr_audit_status = v_audit_status
             , wtr_return_msg = vs_return_msg
             , wtr_elapsed_hh = EXTRACT(HOUR FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
             , wtr_elapsed_mi = EXTRACT(MINUTE FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wtr_started AS TIMESTAMP) DAY(4) to SECOND))
             , wtr_completed = CURRENT_TIMESTAMP
        WHERE  wtr_task_key = v_wtr_task_key
        AND    wtr_job_key = pi_job_key
        AND    wtr_sequence = pi_sequence;

      END IF; -- End of task record update

    -- End of v_process_flag set to 1
    ELSE -- not processing, so must be an idle thread

      SET v_idle_thread = 1;
      --
      -- Check that we have running tasks.
      -- If we have waiting tasks and no running tasks then we must have a dependency loop
      -- So tell them about it and abort.
      IF  v_task_count = 1 AND v_running_count = 0 THEN

        IF v_depend_loop = 1 THEN

          SET v_task_count = 0; -- force a break out of the loop

        ELSE

          SET v_depend_loop = 1;

        END IF;

      END IF;

    END IF; -- End of Processing of a task

    -- If the thread is idle then sleep for 30 seconds.
    -- Note Sleep is controlled by returning to the caller and it will reenter
    IF v_idle_thread = 1 AND v_running_count > 0 THEN

      SET po_result_code = 99;
      SET po_result_msg = 'SLEEP';
      SET po_action_key = 0;
      SET po_action_msg = 'no action';
      SET ps_job_key_list = TRIM(CAST(pi_job_key AS VARCHAR(18)));
      SET ps_task_key_list = TRIM(CAST(pi_task_key AS VARCHAR(18)));
      SET po_task_name = 'NO+JOB';
      SET po_task_key = 0;
      SET po_proc_stmt = 'no statement';

      --=====================================================
      -- Remove this thread as being active
       --=====================================================
      SET v_step = 2400;

      CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, v_sid, v_status_code);

      LEAVE WS_JOB_EXEC_PROCESS;

    END IF;

  END WHILE; -- End of While More tasks Loop

  SET v_step = 2500;

  --=====================================================
  --      A L L      T A S K S      D O N E
  --=====================================================
  --=====================================================
  -- Here if no more waiting tasks. If no more running tasks
  -- then we must be the last thread, so update the job_run
  -- record to a completed state
  -- WMR Need to update the ctrl record and move the run records to the log tables. WMR
  --=====================================================
  SET v_step = 2600;
  SET po_action_key = 0;
  SET po_action_msg = '';
  SET po_result_code = 1;

  IF v_running_count = 0 THEN

    SET v_okay = 0;

    IF v_halted_count = 0 AND v_failed_count = 0 AND v_depend_loop = 0 THEN

      SET v_job_status = 'C';
      SET v_audit_status = 'S';
      SET v_MsgText = 'Job ' || pi_job_name || ' sequence ' ||
                      TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' Completed. ';

      SELECT wjr_publish_okay
      INTO   v_OkayMsg
      FROM   [METABASE].ws_wrk_job_run
      WHERE  wjr_job_key = pi_job_key
      AND    wjr_sequence = pi_sequence;

      SET v_FailMsg = '';

    ELSE

      IF v_depend_loop = 1 AND v_failed_count = 0 THEN

        SET po_result_code = -2;
        SET v_job_status = 'F';
        SET v_audit_status = 'F';
        SET v_MsgText = 'Ws_Job_Exec_Process'|| v_ws_pro_version || ' Job ' || pi_job_name  || ' sequence ' ||
                         TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' CANNOT COMPLETE. Possible task dependency loop. ';

        SELECT wjr_publish_fail
        INTO   v_FailMsg
        FROM   [METABASE].ws_wrk_job_run
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_sequence = pi_sequence;

        SET v_OkayMsg = '';

      ELSE

        SET po_result_code = -2;
        SET v_job_status = 'F';
        SET v_audit_status = 'F';
        SET v_MsgText = 'Job ' || pi_job_name  || ' sequence ' ||
                        TRIM(CAST(pi_sequence AS VARCHAR(18))) || ' FAILED. ';

        SELECT wjr_publish_fail
        INTO   v_FailMsg
        FROM   [METABASE].ws_wrk_job_run
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_sequence = pi_sequence;

        SET v_OkayMsg = '';

      END IF;

    END IF;

    --=====================================================
    -- All tasks done
    -- Set the job status on the run record for the job and finish time.
    -- Need to lock the record first to prevent another thread from
    -- grabbing it, or in case another thread has already got it,
    -- or updated it
    --=====================================================
    SELECT wjr_status
    INTO   v_run_status
    FROM   [METABASE].ws_wrk_job_run
    WHERE  wjr_job_key = pi_job_key
    AND    wjr_sequence = pi_sequence;

    -- if the job is still running
    -- then we will finish it
    IF v_run_status = 'R' THEN

      SET v_no_more_data2 = 0;
      SET v_okay = 1;

      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLSTATE '40001'
          BEGIN
            SET v_okay = 0;
            SET v_no_more_data2 = 1;
          END;

        BEGIN
          DECLARE CONTINUE HANDLER FOR NOT FOUND
            BEGIN
              SET v_okay = 0;
              SET v_no_more_data2 = 1;
            END;

          OPEN c_JobUpdate;

          FETCH FROM c_JobUpdate INTO v_run_status;

          WHILE v_no_more_data2 = 0 DO

            UPDATE [METABASE].ws_wrk_job_run
            SET    wjr_status = v_job_status
                 , wjr_elapsed_hh = EXTRACT(HOUR FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wjr_started AS TIMESTAMP) DAY(4) to SECOND))
                 , wjr_elapsed_mi = EXTRACT(MINUTE FROM (CAST(CURRENT_TIMESTAMP AS TIMESTAMP)-CAST(wjr_started AS TIMESTAMP) DAY(4) to SECOND))
                 , wjr_completed = CURRENT_TIMESTAMP
            WHERE  wjr_job_key = pi_job_key
            AND    wjr_sequence = pi_sequence;

            SET v_no_more_data2 = 1;

          END WHILE;

          CLOSE c_JobUpdate;

        END;

      END;

    ELSE

      -- someone else got the record
      SET v_okay = 0;

    END IF;

    -- we are the updater so do the rest
    IF v_okay = 1 THEN

      IF NULLIF(TRIM(v_OkayMsg),'') IS NOT NULL THEN

        SET po_action_key = 1;
        SET v_msgtext = v_OkayMsg;

      END IF;

      IF NULLIF(TRIM(v_FailMsg),'') IS NOT NULL THEN

        SET po_action_key = 2;
        SET v_msgtext = v_FailMsg;

      END IF;

      -- Substitute any job variables.
      IF NULLIF(TRIM(v_msgtext),'') IS NOT NULL THEN

        CALL [METABASE].Ws_String_Replace(v_msgtext,'$JOB_KEY$',TRIM(CAST((COALESCE(pi_job_key,0)) AS VARCHAR(18))),v_new_value);

        SET v_msgtext = v_new_value;

        CALL [METABASE].Ws_String_Replace(v_msgtext,'$JOB_SEQ$',TRIM(CAST((COALESCE(pi_sequence,0)) AS VARCHAR(18))),v_new_value);

        SET v_msgtext = v_new_value;

        CALL [METABASE].Ws_String_Replace(v_msgtext,'$JOB_THREAD$',TRIM(CAST((COALESCE(pi_thread,-1)) AS VARCHAR(18))),v_new_value);

        SET v_msgtext = v_new_value;

        CALL [METABASE].Ws_String_Replace(v_msgtext,'$JOB_NAME$',pi_job_name,v_new_value);

        SET v_msgtext = v_new_value;

      END IF;

      --
      -- replace any DSS parameters with their current values
      --
      CALL [METABASE].WsParameterReplace(v_msgtext, 8000, v_new_value);

      SET v_msgtext = v_new_value;

      SET po_action_msg = v_msgtext;

      CALL [METABASE].WsWrkAudit(v_audit_status,pi_job_name, pi_job_name, pi_sequence,
                                              v_MsgText,NULL,NULL,0,pi_job_key);

      -- Set the job status on the control record for the job and finish time.
      -- WMR need to set the status to HOLD or Waiting depending on if another run.
      SET v_step = 2700;

      UPDATE [METABASE].ws_wrk_job_ctrl
      SET    wjc_last_status = v_job_status
           , wjc_completed = CURRENT_TIMESTAMP
      WHERE  wjc_job_key = pi_job_key;

      SET v_step = 2800;

      IF v_job_status = 'C' THEN

        -- Move the job run record to the log record
        SET v_step = 2900;

        INSERT INTO [METABASE].ws_wrk_job_log
        SELECT *
        fROM   [METABASE].ws_wrk_job_run
        WHERE  wjr_job_key = pi_job_key
        AND    wjr_sequence = pi_sequence;

        DELETE from [METABASE].ws_wrk_job_run
        WHERE wjr_job_key = pi_job_key
        AND wjr_sequence = pi_sequence;

        -- Move the task run records to the log record
        SET v_step = 3000;

        INSERT INTO [METABASE].ws_wrk_task_log
        SELECT *
        FROM   [METABASE].ws_wrk_task_run
        WHERE  wtr_job_key = pi_job_key
        AND    wtr_sequence = pi_sequence;

        SET v_step = 3100;

         SET v_delete = -- JWH  11 Sept 17
        'DELETE FROM [METABASE].ws_wrk_task_run
        WHERE wtr_job_key = ' || pi_job_key
        || ' AND wtr_sequence = ' || pi_sequence || ';'
        ;

        CALL DBC.SysExecSQL (:v_delete);       --  JWH 11 Sept 2017

      END IF; -- End of Job status = 'C'

      -- If this job has a blocked iteration waiting then release it
      SET v_step = 3200;

      UPDATE [METABASE].ws_wrk_job_ctrl
      SET    wjc_status = 'W'
      WHERE  wjc_job_key = pi_job_key
      AND    wjc_status = 'B';

    END IF;-- End of we are the updater

  END IF;-- end of running_count = 0

  --=====================================================
  -- Remove this thread as being active
  --=====================================================
  SET v_step = 3300;

  CALL [METABASE].Ws_Job_Exec_Thread('DELETE', pi_job_key, pi_sequence, pi_thread, v_sid, v_status_code);

  SET po_result_code = 1;

END;
_PROCEDWSL_ Ws_Job_Exec_411 
CREATE PROCEDURE [METABASE].Ws_Job_Exec_411
( IN  pi_job_name         VARCHAR(64)
, IN  pi_task_name        VARCHAR(64)
, IN  pi_action           VARCHAR(12)
, IN  pi_thread           INTEGER
, IN  pi_sequence         INTEGER
, IN  pi_job_key          INTEGER
, IN  pi_task_key         INTEGER
, IN  pi_task_status      INTEGER      -- used during rejoin to pass back a tasks status
, IN  pi_task_msg         VARCHAR(256)
, IN  pm_rejoin_job_keys  VARCHAR(256) -- List of job keys to rejoin on.
, IN  pm_rejoin_task_keys VARCHAR(256) -- List of task keys to rejoin on.
, OUT po_result_code      INTEGER
, OUT po_result_msg       VARCHAR(1024)
, OUT po_job_key          INTEGER
, OUT po_task_name        VARCHAR(64)
, OUT po_task_key         INTEGER
, OUT po_action_key       INTEGER
, OUT po_action_msg       VARCHAR(4000)
, OUT ps_job_key_list     VARCHAR(256) -- ( list of jobs to pass task down to. Comma separated )
, OUT ps_task_key_list    VARCHAR(256) -- ( list of tasks to pass task down to. Comma separated )
, OUT po_proc_stmt        VARCHAR(8000)
)
WS_JOB_EXEC_411:
BEGIN

  -- <<< IMPORTANT NOTICE: Please do not modify this software as doing so could cause support issues and result in additional support fees being charged.

  -- =============================================================================
  -- DBMS Name    Teradata
  -- Script Name  ws_job_exec_411
  -- Description  Executes a Wherescape Job
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019
  -- =============================================================================
  -- WMR 24/08/2001     Reworked the task loop to prevent the holding open of the
  --                    TaskRun cursor, causing a Rollback too old problem
  -- WMR 24/08/2001     If a job has a previously failed Sequence then let the job go.
  --                    If it has a running Sequence then put it into Hold
  -- WMR 09/11/2001     If a restart then check job is pending. Change to ws_job_wait.
  -- WMR 22/01/2002     Version 1.0.0
  -- WMR 08/03/2002     Handle change of SID when breakout to perform host script
  -- WMR 05/04/2002     Changed analyze from 1% to 3%. Handle new wj_scheduler column
  -- WMR 06/04/2002     Handle ODBC based loads.
  -- WMR 09/04/2002     Handle customer jobs in working out next scheduled time
  --                    Handle blocked jobs. Release them when a job has finished or failed
  -- WMR 23/05/2002     Additional info message and check if unable to rejoin a job
  -- WMR 25/05/2002     All job_name comparisons use upper and rtrim
  -- WMR 01/10/2002     Threads sleep for 30 seconds if no action and tasks still running
  -- WMR 18/10/2002     Invalid return status now assumed to be a failure.
  -- WMR 25/10/2002     SQL Server version
  -- WMR 01/08/2003     Ensure only one thread writes the job complete stuff and executes
  --                    and job complete or failed command
  -- WMR 14/08/2003     Updates for version 4.1
  -- WMR 30/09/2003     Missing commit before return
  -- WMR 02/10/2003     Added cube creation and processing
  -- WMR 10/10/2003     Restart failed due to invalid cursor read on ws_wrk_task_run
  -- WMR 16/10/2003     Call to Ws_Job_Clear_Logs to remove old logs
  -- WMR 31/10/2003     Added cube and database dim processing
  -- WMR 03/11/2003     Added sp_getapplock to handle locking. Place named transactions
  --                    on every transaction
  -- WMR 19/11/2003     Handle an invalid return status ('U'). Fail the job
  -- WMR 09/03/2004     Handle virtual cube create and process
  -- WMR 10/05/2004     Added support for custom procedures
  -- WMR 03/07/2004     Fixed custom scheduling. Was using datepart(dd) instead of (dw)
  -- WMR 23/09/2004     Changed custom scheduling to us the day name instead of number
  -- WMR 18/02/2005     Added ability to call another job from a running job
  -- WMR 01/03/2005     Introduced Ws_Act_Truncate
  -- WMR 17/03/2005     Put the task order into the wtr_thread field so that we can sort
  --                    waiting tasks. It will be overwritten with the thread when the
  --                    task starts.
  -- WMR 18/03/2005     Scheduler incorrectly reporting failure due to dependency loop
  -- WMR 27/05/2005     Scheduler incorrectly reporting failure due to dependency loop
  --                    when two thread both try to get the last task.
  -- WMR 04/04/2006     Changed custom job re-scheduling to prevent time creep.
  -- WMR 04/04/2006     Pre drop and build of indexes during a process are now flagged as Information
  -- WMR 03/05/2006     custom job re-scheduling was skipping a day in some cases.
  -- WMR 13/06/2006     Scheduler incorrectly reporting failure due to dependency loop
  -- AP  07/07/2006     Changed locking to handle a 1 return instead of just 0
  -- AP  16/08/2006     Version 5.5.0.5
  --                    Implemented a lock timeout on the lock call to address locking issues
  --                    Removed transaction level lock timeout settings
  --                    Added ordering default to cursor c_TaskRun.. eventually want to have this
  --                      changed to use the sort order from the tasks but this reqs meta change
  --                    Added version number to messages
  --                    Added DSS parameter substitution for job fail/success message
  -- WMR 11/02/2006     Scheduler incorrectly reporting failure due to dependency loop when child jobs
  --                    where present at some sites due to join to ws_obj_object
  -- JML 22/03/2007     Version 5.5.0.17 support for Native ODBC loads Added.
  -- WMR 26/03/2007     Version 5.6.0.0 support for Retrofit ODBC loads Added.
  -- JML 17/04/2007     Version 5.6.0.0 support for Export Objects Added.
  -- WMR 23/04/2007     Changed Action Process code to fix bug and remove ELSE statement.
  -- WMR 08/05/2007     Changed custom job re-schedule to use v_start_after date instead of GETDATE()
  --                    in case we go past midnight.
  -- AP  26/07/2007     Version 5.6.1.1 Reset depend loop count as soon as find a task so as to minimise risk
  --                     of erroneous dependency loop error message
  -- =============================================================================
  -- WMR 06/09/2007     IBM DB2 Conversion
  -- AP  20/11/2007     Version 5.6.2.1  When deleting from ws_wrk_scr_* use parent job_key
  -- AP  09/04/2008     Version 6.0.0.0  Added support for ODS/Normal
  --                                     New wtr_order column included
  --                                     Fix so post_loads work for non file loads
  --                                     New action process_withstats
  --                                     New override for wait for idle tasks
  --                                     New action of SLEEP to perform a sleep from our scheduler as no sleep in DB2
  -- =============================================================================
  -- JML 01/09/2008     Version 6.0.2.0  Teradata Conversion
  -- JML 29/06/2009     Version 6.0.4.1  Implement new '-99' return code for blocked job so handle nicer
  -- RS  14/02/2013     Version 6.7.0.1  Changed Default Declaration to Variable Assignment
  -- RS  01/10/2014     Version 6.8.1.2  RED-3792 Fixed missing job variable substitution for blocked jobs
  -- RS  18/01/2016     Version 6.8.5.2  Changed error handler
  -- BC  10/02/2016     Version 6.8.5.3  Added support for BDA Server operations
  -- RS  10/06/2016     Version 6.8.6.1  Added support for Hub/Satellite/Link and Custom1/Custom2
  -- HM  13/02/2019     Version 8.4.1.0  RED-7407 Increase message size from 256 to 1024 characters.
  -- HM  22/02/2019     Version 8.4.1.0  RED-7407 Increase max length of success/failure command.
  --
  -- ****************************************************
  -- DONT FORGET TO UPDATE THE VERSION NUMBER BELOW !!!!
  -- ****************************************************
  --

  --=====================================================
  -- Constants Declared
  --=====================================================
  DECLARE v_ws_pro_version           VARCHAR(15);
  DECLARE v_ws_obj_procedure         INTEGER;
  DECLARE v_ws_obj_fact_kpi          INTEGER;
  DECLARE v_ws_obj_script            INTEGER;
  DECLARE v_ws_obj_template          INTEGER;
  DECLARE v_ws_obj_fact              INTEGER;
  DECLARE v_ws_obj_dim               INTEGER;
  DECLARE v_ws_obj_stage             INTEGER;
  DECLARE v_ws_obj_load              INTEGER;
  DECLARE v_ws_obj_agg               INTEGER;
  DECLARE v_ws_obj_index             INTEGER;
  DECLARE v_ws_obj_connect           INTEGER;
  DECLARE v_ws_obj_dim_view          INTEGER;
  DECLARE v_ws_obj_export            INTEGER;
  DECLARE v_ws_obj_cube              INTEGER;
  DECLARE v_ws_obj_cube_virtual      INTEGER;
  DECLARE v_ws_obj_report            INTEGER;
  DECLARE v_ws_obj_view              INTEGER;
  DECLARE v_ws_obj_join              INTEGER;
  DECLARE v_ws_obj_retro             INTEGER;
  DECLARE v_ws_obj_retro_copy        INTEGER;
  DECLARE v_ws_obj_olap_cube         INTEGER;
  DECLARE v_ws_obj_olap_dim          INTEGER;
  DECLARE v_ws_obj_olap_role         INTEGER;
  DECLARE v_ws_obj_ods               INTEGER;
  DECLARE v_ws_obj_normal            INTEGER;
  DECLARE v_ws_obj_hub               INTEGER;
  DECLARE v_ws_obj_satellite         INTEGER;
  DECLARE v_ws_obj_link              INTEGER;
  DECLARE v_ws_obj_custom1           INTEGER;
  DECLARE v_ws_obj_custom2           INTEGER;
  DECLARE v_ws_obj_max               INTEGER;

  DECLARE v_ws_obj_job               INTEGER;

  DECLARE v_ws_act_drop              INTEGER;
  DECLARE v_ws_act_create            INTEGER;
  DECLARE v_ws_act_drop_all          INTEGER;
  DECLARE v_ws_act_pre_drop          INTEGER;
  DECLARE v_ws_act_load              INTEGER;
  DECLARE v_ws_act_update            INTEGER;
  DECLARE v_ws_act_execute           INTEGER;
  DECLARE v_ws_act_process           INTEGER;
  DECLARE v_ws_act_build             INTEGER;
  DECLARE v_ws_act_build_all         INTEGER;
  DECLARE v_ws_act_analyze           INTEGER;
  DECLARE v_ws_act_quick_analyze     INTEGER;
  DECLARE v_ws_act_statistics        INTEGER;
  DECLARE v_ws_act_quick_statistics  INTEGER;
  DECLARE v_ws_act_initial           INTEGER;
  DECLARE v_ws_act_cube_dim          INTEGER;
  DECLARE v_ws_act_db_dim            INTEGER;
  DECLARE v_ws_act_custom            INTEGER;
  DECLARE v_ws_act_truncate          INTEGER;
  DECLARE v_ws_act_compile           INTEGER;
  DECLARE v_ws_act_process_withstats INTEGER;

  --=====================================================
  -- Variables
  --=====================================================
  DECLARE v_msgtext                  VARCHAR(1024); -- Text for audit_trail
  DECLARE v_step                     INTEGER;       -- return code
  DECLARE v_sql_code                 INTEGER;       -- SQL Error Code for Audit Trail
  DECLARE v_sql_error                VARCHAR(1024); -- SQL Error Code for Audit Trail as VARCHAR
  DECLARE v_job_key                  INTEGER;
  -- RED_3792
  DECLARE v_new_value                VARCHAR(256);


  --=====================================================
  -- Output variables
  --=====================================================
  DECLARE vs_task_name               VARCHAR(64);
  DECLARE vs_task_key                INTEGER;
  DECLARE vs_proc_stmt               VARCHAR(8000);
  DECLARE vs_status_code             INTEGER;
  DECLARE vs_return_msg              VARCHAR(1024);
  DECLARE vs_action_key              INTEGER;
  DECLARE vs_action_msg              VARCHAR(4000);
  DECLARE vs_job_key_list            VARCHAR(256);
  DECLARE vs_task_key_list           VARCHAR(256);

  --=====================================================
  -- Variables for jobs from jobs
  --=====================================================
  DECLARE v_restart_flag             INTEGER;

  --=====================================================
  -- Default Exception Handler
  --=====================================================
  DECLARE EXIT HANDLER
    FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS EXCEPTION 1 v_sql_error = MESSAGE_TEXT;
      SET v_sql_code = SQLCODE;
      SET v_msgtext = 'Unhandled exception in Ws_job_Exec_411 Version '||
        v_ws_pro_version || '. Step ' || CAST(v_step AS VARCHAR(64)) ||
        '   SQL Error Code ' || CAST(v_sql_code AS VARCHAR(10)) || ' - ' || v_sql_error;
      SET po_result_msg = v_msgtext;
      CALL [METABASE].WsWrkAudit('E', pi_job_name, pi_task_name, pi_sequence
        , v_msgtext, v_sql_code, v_sql_error, pi_task_key, v_job_key);
      SET po_result_code = -2;
    END;

  --=====================================================
  -- Set Values for Constants
  --=====================================================
  SET v_ws_pro_version           = '8.4.1.0';
  SET v_ws_obj_procedure         = 1;
  SET v_ws_obj_fact_kpi          = 2;
  SET v_ws_obj_script            = 3;
  SET v_ws_obj_template          = 4;
  SET v_ws_obj_fact              = 5;
  SET v_ws_obj_dim               = 6;
  SET v_ws_obj_stage             = 7;
  SET v_ws_obj_load              = 8;
  SET v_ws_obj_agg               = 9;
  SET v_ws_obj_index             = 10;
  SET v_ws_obj_connect           = 11;
  SET v_ws_obj_dim_view          = 12;
  SET v_ws_obj_export            = 13;
  SET v_ws_obj_cube              = 15;
  SET v_ws_obj_cube_virtual      = 16;
  SET v_ws_obj_report            = 17;
  SET v_ws_obj_view              = 18;
  SET v_ws_obj_join              = 20;
  SET v_ws_obj_retro             = 21;
  SET v_ws_obj_retro_copy        = 22;
  SET v_ws_obj_olap_cube         = 23;
  SET v_ws_obj_olap_dim          = 24;
  SET v_ws_obj_olap_role         = 25;
  SET v_ws_obj_ods               = 26;
  SET v_ws_obj_normal            = 27;
  SET v_ws_obj_hub               = 28;
  SET v_ws_obj_satellite         = 29;
  SET v_ws_obj_link              = 30;
  SET v_ws_obj_custom1           = 31;
  SET v_ws_obj_custom2           = 32;
  SET v_ws_obj_max               = 32;
  SET v_ws_obj_job               = 50;
  SET v_ws_act_drop              = 1;
  SET v_ws_act_create            = 2;
  SET v_ws_act_drop_all          = 3;
  SET v_ws_act_pre_drop          = 4;
  SET v_ws_act_load              = 5;
  SET v_ws_act_update            = 6;
  SET v_ws_act_execute           = 7;
  SET v_ws_act_process           = 8;
  SET v_ws_act_build             = 9;
  SET v_ws_act_build_all         = 10;
  SET v_ws_act_analyze           = 11;
  SET v_ws_act_quick_analyze     = 12;
  SET v_ws_act_statistics        = 13;
  SET v_ws_act_quick_statistics  = 14;
  SET v_ws_act_initial           = 15;
  SET v_ws_act_cube_dim          = 16;
  SET v_ws_act_db_dim            = 17;
  SET v_ws_act_custom            = 18;
  SET v_ws_act_truncate          = 19;
  SET v_ws_act_compile           = 20;
  SET v_ws_act_process_withstats = 21;

  --=====================================================
  -- MAIN
  --=====================================================
  -- WhereScape Limited, inc. All rights reserved. (C) Copyright 1996-2019

  SET po_result_code = 0;
  SET po_result_msg = 'no result';

  SET v_restart_flag = 0;

  --=====================================================
  -- Check to see if job exists and get its key
  --=====================================================
  SELECT wjc_job_key
  INTO   v_job_key
  FROM   [METABASE].ws_wrk_job_ctrl
  WHERE  TRIM(UPPER(wjc_name)) = TRIM(UPPER(pi_job_name));

  IF v_job_key IS NULL THEN

    SELECT wjr_job_key
    INTO   v_job_key
    FROM   [METABASE].ws_wrk_job_run
    WHERE  TRIM(UPPER(wjr_name)) = TRIM(UPPER(pi_job_name));

    IF v_job_key IS NULL THEN

      SET v_MsgText = 'Ws_Job_Exec_411 '|| v_ws_pro_version || ' Job '|| pi_job_name || ' passed invalid job name in New Job. ';

      CALL [METABASE].WsWrkAudit( 'F',pi_job_name, pi_job_name, pi_sequence,
                                     v_MsgText,NULL,NULL,0,0);

      SET po_result_code = -2;

      LEAVE WS_JOB_EXEC_411;

    END IF;

  END IF;

  SET po_job_key = v_job_key;

  --=====================================================
  --=====================================================
  --=====================================================
  --                  N E W       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  IF UPPER(pi_action) = 'NEW' THEN

    CALL [METABASE].Ws_Job_Exec_New(pi_job_name, pi_task_name, pi_thread
                                  , pi_sequence, v_job_key, pi_task_key
                                  , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg);

    SET po_result_code = vs_status_code;
    SET po_result_msg = vs_return_msg;
    SET po_job_key = v_job_key;
    SET po_task_name = pi_task_name;
    SET po_task_key = pi_task_key;
    SET po_action_key = vs_action_key;
    SET po_action_msg = vs_action_msg;
    SET ps_job_key_list = CAST(pi_job_key AS VARCHAR(18));
    SET ps_task_key_list = CAST(pi_task_key AS VARCHAR(18));
    SET po_proc_stmt = 'no statement';

    IF (( vs_status_code = -2 ) OR ( vs_status_code = -99 )) THEN

       -- RED_3792
       -- Substitute any job variables for the error message of a fatal problem or a blocked job and set the output variables for this case
       IF NULLIF(TRIM(vs_action_msg),'') IS NOT NULL THEN
         CALL [METABASE].Ws_String_Replace(vs_action_msg,'$JOB_KEY$',TRIM(CAST((COALESCE(pi_job_key,0)) AS VARCHAR(18))),v_new_value);
         SET vs_action_msg = v_new_value;

         CALL [METABASE].Ws_String_Replace(vs_action_msg,'$JOB_SEQ$',TRIM(CAST((COALESCE(pi_sequence,0)) AS VARCHAR(18))),v_new_value);
         SET vs_action_msg = v_new_value;

         CALL [METABASE].Ws_String_Replace(vs_action_msg,'$JOB_THREAD$',TRIM(CAST((COALESCE(pi_thread,-1)) AS VARCHAR(18))),v_new_value);
         SET vs_action_msg = v_new_value;

         CALL [METABASE].Ws_String_Replace(vs_action_msg,'$JOB_NAME$',pi_job_name,v_new_value);
         SET vs_action_msg = v_new_value;
      END IF;

      SET po_action_msg = vs_action_msg;

      LEAVE WS_JOB_EXEC_411;

    END IF;

  -- End of NEW Job

  --=====================================================
  --=====================================================
  --=====================================================
  --                  R E S T A R T       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  ELSEIF UPPER(pi_action) = 'RESTART' THEN

    SET v_restart_flag = 1;

    CALL [METABASE].Ws_Job_Exec_Restart(pi_job_name, pi_task_name, pi_thread
                                      , pi_sequence, v_job_key, pi_task_key
                                      , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg);

    SET po_result_code = vs_status_code;
    SET po_result_msg = vs_return_msg;
    SET po_job_key = v_job_key;
    SET po_task_name = pi_task_name;
    SET po_task_key = pi_task_key;
    SET po_action_key = vs_action_key;
    SET po_action_msg = vs_action_msg;
    SET ps_job_key_list = CAST(pi_job_key AS VARCHAR(18));
    SET ps_task_key_list = CAST(pi_task_key AS VARCHAR(18));
    SET po_proc_stmt = 'no statement';

    IF ( vs_status_code = -2 ) THEN

      LEAVE WS_JOB_EXEC_411;

    END IF;

  -- end of RESTART job

  --=====================================================
  --=====================================================
  --=====================================================
  --                  R E J O I N       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  ELSEIF (SUBSTR(UPPER(pi_action),1,6) = 'REJOIN' ) OR ( UPPER(pi_action) = 'PROCJOIN' )THEN

    CALL [METABASE].Ws_Job_Exec_Rejoin(pi_job_name, pi_task_name, pi_action, pi_thread
                                     , pi_sequence, v_job_key, pi_task_key
                                     , pi_task_status, pi_task_msg
                                     , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg
                                     , vs_proc_stmt);

    SET po_result_code = vs_status_code;
    SET po_result_msg = vs_return_msg;
    SET po_job_key = v_job_key;
    SET po_task_name = pi_task_name;
    SET po_task_key = pi_task_key;
    SET po_action_key = vs_action_key;
    SET po_action_msg = vs_action_msg;
    SET ps_job_key_list = CAST(pi_job_key AS VARCHAR(18));
    SET ps_task_key_list = CAST(pi_task_key AS VARCHAR(18));
    SET po_proc_stmt = vs_proc_stmt;

    IF ( vs_status_code = -2 OR vs_status_code = 98 ) THEN

      LEAVE WS_JOB_EXEC_411;

    END IF;

  -- End of REJOIN Job

  --=====================================================
  --=====================================================
  --=====================================================
  --                 C A N C E L       J O B
  --=====================================================
  --=====================================================
  --=====================================================
  -- If we are a Cancel job then check we are in a halted or aborted
  -- state.
  -- Archive the _run table to the log table
  --=====================================================
  ELSEIF UPPER(pi_action) = 'CANCEL' THEN

    --=====================================================
    -- If we are thread 0 then do some checks and archive
    --=====================================================
    IF pi_thread = 0 THEN

      CALL [METABASE].Ws_Job_Exec_Cancel(pi_job_name, pi_task_name, pi_thread
                                       , pi_sequence, v_job_key, pi_task_key
                                       , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg);

      SET po_result_code = vs_status_code;
      SET po_result_msg = vs_return_msg;
      SET po_job_key = v_job_key;
      SET po_task_name = pi_task_name;
      SET po_task_key = pi_task_key;
      SET po_action_key = vs_action_key;
      SET po_action_msg = vs_action_msg;
      SET ps_job_key_list = CAST(pi_job_key AS VARCHAR(18));
      SET ps_task_key_list = CAST(pi_task_key AS VARCHAR(18));
      SET po_proc_stmt = 'no statement';

      IF ( vs_status_code = -2 ) THEN

        LEAVE WS_JOB_EXEC_411;

      END IF;

    END IF;

  -- End of cancel job

  --=====================================================
  --=====================================================
  --=====================================================
  --                 S  L  E  E  P
  --=====================================================
  --=====================================================
  --=====================================================
  -- If we are a Sleep job then we just carry on
  --=====================================================
  ELSEIF UPPER(pi_action) = 'SLEEP' THEN

    SET v_MsgText = 'Ws_Job_Exec_411'|| v_ws_pro_version || ' Job ' || pi_job_name || ' Slept.';

    CALL [METABASE].WsWrkAudit('I',pi_job_name, pi_job_name, pi_sequence,
                          v_MsgText,NULL,NULL,0,v_job_key);

  -- End of SLEEP

  -- Not a New, Restart, Rejoin, Cancel or Sleep so we have a problem
  ELSE

    SET v_MsgText = 'Ws_Job_Exec_411'|| v_ws_pro_version || ' Job ' || pi_job_name || ' passed invalid option ' ||
                      pi_action || '. No Action !!!';

    CALL [METABASE].WsWrkAudit('F',pi_job_name, pi_job_name, pi_sequence,
                          v_MsgText,NULL,NULL,0,v_job_key);

  END IF;

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================


  --=====================================================
  --=====================================================
  --=====================================================
  --                  E X E C U T E      T A S K S
  --=====================================================
  --=====================================================
  --=====================================================

  CALL [METABASE].Ws_Job_Exec_Process(pi_job_name, pi_task_name, pi_thread
                                    , pi_sequence, v_job_key, pi_task_key
                                    , pi_action, pi_task_status, pi_task_msg
                                    , vs_status_code, vs_return_msg, vs_action_key, vs_action_msg
                                    , vs_task_name, vs_task_key, vs_proc_stmt
                                    , vs_job_key_list, vs_task_key_list);

  SET po_result_code = vs_status_code;
  SET po_result_msg = vs_return_msg;
  SET po_job_key = v_job_key;
  SET po_task_name = vs_task_name;
  SET po_task_key = vs_task_key;
  SET po_action_key = vs_action_key;
  SET po_action_msg = vs_action_msg;
  SET ps_job_key_list = vs_job_key_list;
  SET ps_task_key_list = vs_task_key_list;
  SET po_proc_stmt = vs_proc_stmt;

  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================
  --=====================================================

END;
